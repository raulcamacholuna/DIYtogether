--- START OF FILE: .\CMakeLists.txt ---
# Fecha: 17/08/2025 - 04:03 
# Fichero: ./CMakeLists.txt
# Último cambio: Reestructurados y mejorados los comentarios para mayor claridad.
# Descripción: Fichero raíz de configuración de CMake para el proyecto. Define la versión mínima de CMake,
#              el nombre del proyecto, y rutas adicionales para componentes de terceros. El error 'Permission denied'
#              del sistema de compilación (Ninja) no se origina en este fichero, sino en un problema externo
#              como un antivirus o permisos del sistema de ficheros. Se mejora este fichero como acción proactiva.

# Versión mínima de CMake requerida por ESP-IDF.
cmake_minimum_required(VERSION 3.16)

# Añade el directorio 'components_dependencies' a la ruta de búsqueda de componentes.
# Esto permite que el sistema de compilación encuentre librerías de terceros (ej. esp_lvgl_port)
# que no forman parte de los componentes estándar ni del propio proyecto.
set(EXTRA_COMPONENT_DIRS components_dependencies)

# Define una macro de preprocesador global para todo el proyecto.
# En este caso, se usa para informar a los componentes que se está utilizando LVGL v9.
add_compile_definitions(LVGL_VERSION_MAJOR=9)

# Incluye el script principal de ESP-IDF que gestiona toda la lógica de compilación de proyectos.
# Esta línea es fundamental y debe ir después de las configuraciones iniciales.
include($ENV{IDF_PATH}/tools/cmake/project.cmake)

# Declara el nombre del proyecto.
project(DIYTOGETHER)

--- END OF FILE: .\CMakeLists.txt ---

--- START OF FILE: .\partitions.csv ---
# Name,   Type, SubType, Offset,  Size, Flags
nvs,      data, nvs,     0x9000,  0x6000,
phy_init, data, phy,     0xf000,  0x1000,
factory,  app,  factory, 0x10000, 6M,
--- END OF FILE: .\partitions.csv ---

--- START OF FILE: .\platformio.ini ---
# Fecha: 15/08/2025 - 03:54 
# Fichero: Z:\DIYTOGETHER\DIYtogether\platformio.ini
# Último cambio: Eliminada la dependencia 'lvgl' de lib_deps para resolver conflictos de redefinición de macros.
# Descripción: Este fichero configura el entorno de PlatformIO. Se ha eliminado la dependencia de `lvgl` de la sección `lib_deps` porque el proyecto ya gestiona LVGL como un componente local de ESP-IDF. Esto evita que PlatformIO descargue una segunda copia de la librería y resuelve los warnings de macros redefinidas (`CONFIG_LV_...`) durante la compilación.

# PlatformIO Project Configuration File
#
# NOTA DE MIGRACIÓN:
# Este fichero está configurado para usar la estructura de directorios de ESP-IDF.
# El código fuente principal está en la carpeta 'main', y los componentes adicionales
# en la carpeta 'components'.

[platformio]
default_envs = esp32-c6-devkitc-1
src_dir = main

[env:esp32-c6-devkitc-1]
# -- Configuración General --
platform = espressif32
board = esp32-c6-devkitc-1
framework = espidf

# -- Opciones de Compilación y Subida (extraídas de sdkconfig y CMakeLists.txt) --
board_build.flash_mode = dio
board_build.flash_freq = 80m
board_build.partitions = partitions.csv

# Esta línea es CRUCIAL. Le dice a PlatformIO que use tu 'sdkconfig' existente,
# manteniendo todas tus configuraciones detalladas (tamaño de stack, etc.).
board_build.sdkconfig_path = sdkconfig

# -- Opciones del Monitor Serie --
monitor_speed = 115200

# -- Dependencias de Librerías y Componentes --
# PlatformIO encuentra automáticamente los componentes locales en la carpeta 'components'.
lib_deps =
    # [CORRECCIÓN] Se elimina esta línea. Tu proyecto ya incluye LVGL como un componente de ESP-IDF,
    # y esta dependencia externa causa conflictos de configuración.

# -- Banderas de Compilación --
# Definiciones personalizadas extraídas de tu CMakeLists.txt raíz.
build_flags = -D LVGL_VERSION_MAJOR=9

--- END OF FILE: .\platformio.ini ---

--- START OF FILE: .\README.md ---
/* Fecha: 17/08/2025 - 03:39  */
/* Fichero: .\README.md */
/* Último cambio: Actualizada la nota de compilación para reflejar la arquitectura de UI refactorizada y corregido el escapado de caracteres para PowerShell. */
/* Descripción: Documentación principal del proyecto. La nota sobre la estructura del componente 'ui' ahora detalla la nueva organización modular en subdirectorios (assets, core, screens, etc.) para reflejar la reciente refactorización. Se han escapado los caracteres de acento grave (backticks) para evitar errores de parser en PowerShell. */

# DIYTogether - Tu Mascota Virtual DIY

![Ilustración de DIYTogether en acción]([Link a git3.png])

**DIYTogether** no es solo un gadget. Es una aventura de aprendizaje, una puerta a la creatividad y una excusa para construir algo increíble con las personas que te importan.

## La Historia detrás de DIYTogether

Constantemente sueño despierto.

Fantaseo con ser *`ese tío guay`* para mis sobrinos, el que les enseña a crear, a entender la tecnología, a jugar con la electrónica y la domótica. Quería construir algo que nos uniera, un juego que les apasionara y despertara su curiosidad por dentro. Una excusa perfecta para aprender divirtiéndose y pasar tiempo de calidad juntos.

De esa idea nace **DIYTogether**.

Un proyecto que empezó con mis mejores amigos y que ahora abro al mundo, invitando a todo aquel que quiera unirse a crear una tecnología con alma.

---

## ¿Qué es DIYTogether?

DIYTogether es un proyecto de mascota virtual open-source basada en hardware ESP32. Es un **`Tamagotchi para Hackers`** diseñado desde cero para ser:

*   🎨 **Personalizable**: Crea y carga tus propios "Skins" (gráficos, animaciones y sonidos) sin necesidad de reprogramar nada. ¡Haz tu DIYTogether verdaderamente tuyo!
*   🧠 **Educativo**: Aprende electrónica, programación (C++/ESP-IDF) y conectividad IoT de una forma práctica y progresiva. Cada paso es una lección, y los errores son parte del viaje.
*   🌍 **Interactivo**: Utiliza sensores como el acelerómetro y la conectividad Bluetooth para interactuar con tu criatura de formas nuevas y creativas.
*   ❤️ **Abierto y Comunitario**: Todo el proyecto (firmware, hardware, diseños 3D) es libre. Queremos que lo copies, lo modifiques, lo mejores y lo compartas.

![Variedad de colores y criaturas DIYTogether]([Link a git2.png])

---

## Características Principales

*   **Hardware**: Basado en la placa Waveshare ESP32-C6-Touch-LCD-1.9 o hardware similar.
*   **Firmware**: Escrito en C/C++ con el framework ESP-IDF.
*   **Sistema de Evolución Modular**: Las criaturas evolucionan según tus cuidados, el entorno e interacciones.
*   **Licencias**:
    *   **Código**: GPLv3 - ¡Libre para siempre!
    *   **Diseños de la carcasa**: CC BY-NC - ¡Compártela, pero no para uso comercial sin permiso!

![Prototipo de DIYTogether con interfaz holográfica]([Link a git1.png])

---

### Estado Actual del Proyecto
> *Nota: Esta sección se actualizará con los avances.*

*   ✅ Prototipo funcional con interacciones básicas (alimentar, entrenar, limpiar).
*   ✅ Sistema de skins dinámicas implementado.
*   🚧 Trabajando en la conectividad Bluetooth con la App de soporte (FIYNDEX).
*   💡 Planeando una campaña de Kickstarter para ofrecer kits DIY asequibles.

---

## ¿Cómo puedes empezar?

### 1. Requisitos
*   **Hardware**: Waveshare ESP32-C6-Touch-LCD-1.9.
*   **Software**: [Visual Studio Code](https://code.visualstudio.com/) con la extensión [PlatformIO IDE](https://platformio.org/platformio-ide).

### 2. Compilación y Subida del Firmware
Este proyecto está configurado para ser compilado y subido fácilmente con PlatformIO.

*(Nota: La arquitectura del componente `ui` ha sido completamente refactorizada para seguir principios de diseño modular y de responsabilidad única. La lógica ahora está organizada en subdirectorios bien definidos:*
*   ***`assets/`***: *Contiene todos los recursos estáticos (imágenes, fuentes).*
*   ***`core/`***: *Orquesta la UI, gestiona el estado y la telemetría.*
*   ***`screens/`***: *Define y controla las diferentes pantallas de la aplicación.*
*   ***`actions/`***: *Encapsula la lógica de cada acción del usuario (comer, reiniciar, etc.).*
*   ***`buttons/`***: *Módulos individuales para cada botón, encapsulando su creación y eventos.*
*A pesar de esta estructura interna avanzada, el proceso de compilación con PlatformIO sigue siendo el mismo y es el método recomendado.)*

1.  **Clona el repositorio**:
    `ash
    git clone [URL de tu repositorio]
    cd DIYtogether
    `
2.  **Abre el proyecto en VS Code**:
    *   Abre VS Code.
    *   Ve a File > Open Folder... y selecciona la carpeta DIYtogether que acabas de clonar.
    *   PlatformIO debería detectar automáticamente el fichero platformio.ini y configurar el entorno.

3.  **Compila y Sube**:
    *   Conecta tu placa ESP32-C6 al ordenador por USB.
    *   En la barra de estado de PlatformIO (generalmente en la parte inferior de VS Code), busca y haz clic en el icono de la flecha (->) que corresponde a **Upload**.
    *   PlatformIO compilará el código, generará los binarios y los subirá automáticamente a tu placa.

4.  **Monitor Serie**:
    *   Para ver los logs de depuración, haz clic en el icono del enchufe (🔌) que corresponde a **Monitor** en la barra de estado de PlatformIO.

*(Aquí puedes poner un GIF animado de tu prototipo funcionando. ¡Esto es súper efectivo!)*
![alt text](ruta/a/tu/gif/animado.gif)

---

## ¡Únete a la Comunidad!

Este proyecto vive gracias a gente como tú. Si te gusta la idea, ¡involúcrate!

*   ⭐ **Dale una estrella a este repositorio**: ¡Nos ayuda a ganar visibilidad!
*   💬 **Únete a nuestro canal de Discord/Telegram**: El mejor lugar para charlar, pedir ayuda y compartir tus creaciones.
*   💡 **Aporta ideas o reporta bugs**: Abre un `Issue` aquí en GitHub.
*   🚀 **Contribuye con código o diseños**: ¡Los Pull Requests son bienvenidos! Revisa nuestra [guía de contribución].

Gracias por tu apoyo y por creer en un proyecto hecho con cariño y curiosidad.

--- END OF FILE: .\README.md ---

--- START OF FILE: .\sdkconfig ---
#
# Automatically generated file. DO NOT EDIT.
# Espressif IoT Development Framework (ESP-IDF) 5.5.0 Project Configuration
#
CONFIG_SOC_ADC_SUPPORTED=y
CONFIG_SOC_DEDICATED_GPIO_SUPPORTED=y
CONFIG_SOC_UART_SUPPORTED=y
CONFIG_SOC_UHCI_SUPPORTED=y
CONFIG_SOC_GDMA_SUPPORTED=y
CONFIG_SOC_AHB_GDMA_SUPPORTED=y
CONFIG_SOC_GPTIMER_SUPPORTED=y
CONFIG_SOC_PCNT_SUPPORTED=y
CONFIG_SOC_MCPWM_SUPPORTED=y
CONFIG_SOC_TWAI_SUPPORTED=y
CONFIG_SOC_ETM_SUPPORTED=y
CONFIG_SOC_PARLIO_SUPPORTED=y
CONFIG_SOC_BT_SUPPORTED=y
CONFIG_SOC_IEEE802154_SUPPORTED=y
CONFIG_SOC_ASYNC_MEMCPY_SUPPORTED=y
CONFIG_SOC_USB_SERIAL_JTAG_SUPPORTED=y
CONFIG_SOC_TEMP_SENSOR_SUPPORTED=y
CONFIG_SOC_PHY_SUPPORTED=y
CONFIG_SOC_WIFI_SUPPORTED=y
CONFIG_SOC_SUPPORTS_SECURE_DL_MODE=y
CONFIG_SOC_ULP_SUPPORTED=y
CONFIG_SOC_LP_CORE_SUPPORTED=y
CONFIG_SOC_EFUSE_KEY_PURPOSE_FIELD=y
CONFIG_SOC_EFUSE_SUPPORTED=y
CONFIG_SOC_RTC_FAST_MEM_SUPPORTED=y
CONFIG_SOC_RTC_MEM_SUPPORTED=y
CONFIG_SOC_I2S_SUPPORTED=y
CONFIG_SOC_RMT_SUPPORTED=y
CONFIG_SOC_SDM_SUPPORTED=y
CONFIG_SOC_GPSPI_SUPPORTED=y
CONFIG_SOC_LEDC_SUPPORTED=y
CONFIG_SOC_I2C_SUPPORTED=y
CONFIG_SOC_SYSTIMER_SUPPORTED=y
CONFIG_SOC_SUPPORT_COEXISTENCE=y
CONFIG_SOC_AES_SUPPORTED=y
CONFIG_SOC_MPI_SUPPORTED=y
CONFIG_SOC_SHA_SUPPORTED=y
CONFIG_SOC_HMAC_SUPPORTED=y
CONFIG_SOC_DIG_SIGN_SUPPORTED=y
CONFIG_SOC_ECC_SUPPORTED=y
CONFIG_SOC_FLASH_ENC_SUPPORTED=y
CONFIG_SOC_SECURE_BOOT_SUPPORTED=y
CONFIG_SOC_SDIO_SLAVE_SUPPORTED=y
CONFIG_SOC_BOD_SUPPORTED=y
CONFIG_SOC_APM_SUPPORTED=y
CONFIG_SOC_PMU_SUPPORTED=y
CONFIG_SOC_PAU_SUPPORTED=y
CONFIG_SOC_LP_TIMER_SUPPORTED=y
CONFIG_SOC_LP_AON_SUPPORTED=y
CONFIG_SOC_LP_PERIPHERALS_SUPPORTED=y
CONFIG_SOC_LP_I2C_SUPPORTED=y
CONFIG_SOC_ULP_LP_UART_SUPPORTED=y
CONFIG_SOC_CLK_TREE_SUPPORTED=y
CONFIG_SOC_ASSIST_DEBUG_SUPPORTED=y
CONFIG_SOC_WDT_SUPPORTED=y
CONFIG_SOC_SPI_FLASH_SUPPORTED=y
CONFIG_SOC_RNG_SUPPORTED=y
CONFIG_SOC_LIGHT_SLEEP_SUPPORTED=y
CONFIG_SOC_DEEP_SLEEP_SUPPORTED=y
CONFIG_SOC_MODEM_CLOCK_SUPPORTED=y
CONFIG_SOC_PM_SUPPORTED=y
CONFIG_SOC_XTAL_SUPPORT_40M=y
CONFIG_SOC_XTAL_CLOCK_PATH_DEPENDS_ON_TOP_DOMAIN=y
CONFIG_SOC_AES_SUPPORT_DMA=y
CONFIG_SOC_AES_GDMA=y
CONFIG_SOC_AES_SUPPORT_AES_128=y
CONFIG_SOC_AES_SUPPORT_AES_256=y
CONFIG_SOC_ADC_DIG_CTRL_SUPPORTED=y
CONFIG_SOC_ADC_DIG_IIR_FILTER_SUPPORTED=y
CONFIG_SOC_ADC_MONITOR_SUPPORTED=y
CONFIG_SOC_ADC_DMA_SUPPORTED=y
CONFIG_SOC_ADC_PERIPH_NUM=1
CONFIG_SOC_ADC_MAX_CHANNEL_NUM=7
CONFIG_SOC_ADC_ATTEN_NUM=4
CONFIG_SOC_ADC_DIGI_CONTROLLER_NUM=1
CONFIG_SOC_ADC_PATT_LEN_MAX=8
CONFIG_SOC_ADC_DIGI_MAX_BITWIDTH=12
CONFIG_SOC_ADC_DIGI_MIN_BITWIDTH=12
CONFIG_SOC_ADC_DIGI_IIR_FILTER_NUM=2
CONFIG_SOC_ADC_DIGI_MONITOR_NUM=2
CONFIG_SOC_ADC_DIGI_RESULT_BYTES=4
CONFIG_SOC_ADC_DIGI_DATA_BYTES_PER_CONV=4
CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_HIGH=83333
CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_LOW=611
CONFIG_SOC_ADC_RTC_MIN_BITWIDTH=12
CONFIG_SOC_ADC_RTC_MAX_BITWIDTH=12
CONFIG_SOC_ADC_CALIBRATION_V1_SUPPORTED=y
CONFIG_SOC_ADC_SELF_HW_CALI_SUPPORTED=y
CONFIG_SOC_ADC_CALIB_CHAN_COMPENS_SUPPORTED=y
CONFIG_SOC_ADC_TEMPERATURE_SHARE_INTR=y
CONFIG_SOC_ADC_SHARED_POWER=y
CONFIG_SOC_BROWNOUT_RESET_SUPPORTED=y
CONFIG_SOC_SHARED_IDCACHE_SUPPORTED=y
CONFIG_SOC_CACHE_FREEZE_SUPPORTED=y
CONFIG_SOC_CPU_CORES_NUM=1
CONFIG_SOC_CPU_INTR_NUM=32
CONFIG_SOC_CPU_HAS_FLEXIBLE_INTC=y
CONFIG_SOC_INT_PLIC_SUPPORTED=y
CONFIG_SOC_CPU_HAS_CSR_PC=y
CONFIG_SOC_CPU_BREAKPOINTS_NUM=4
CONFIG_SOC_CPU_WATCHPOINTS_NUM=4
CONFIG_SOC_CPU_WATCHPOINT_MAX_REGION_SIZE=0x80000000
CONFIG_SOC_CPU_HAS_PMA=y
CONFIG_SOC_CPU_IDRAM_SPLIT_USING_PMP=y
CONFIG_SOC_CPU_PMP_REGION_GRANULARITY=4
CONFIG_SOC_DS_SIGNATURE_MAX_BIT_LEN=3072
CONFIG_SOC_DS_KEY_PARAM_MD_IV_LENGTH=16
CONFIG_SOC_DS_KEY_CHECK_MAX_WAIT_US=1100
CONFIG_SOC_AHB_GDMA_VERSION=1
CONFIG_SOC_GDMA_NUM_GROUPS_MAX=1
CONFIG_SOC_GDMA_PAIRS_PER_GROUP_MAX=3
CONFIG_SOC_GDMA_SUPPORT_ETM=y
CONFIG_SOC_GDMA_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_ETM_GROUPS=1
CONFIG_SOC_ETM_CHANNELS_PER_GROUP=50
CONFIG_SOC_ETM_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_GPIO_PORT=1
CONFIG_SOC_GPIO_PIN_COUNT=31
CONFIG_SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER=y
CONFIG_SOC_GPIO_FLEX_GLITCH_FILTER_NUM=8
CONFIG_SOC_GPIO_SUPPORT_ETM=y
CONFIG_SOC_GPIO_SUPPORT_RTC_INDEPENDENT=y
CONFIG_SOC_GPIO_SUPPORT_DEEPSLEEP_WAKEUP=y
CONFIG_SOC_LP_IO_CLOCK_IS_INDEPENDENT=y
CONFIG_SOC_GPIO_IN_RANGE_MAX=30
CONFIG_SOC_GPIO_OUT_RANGE_MAX=30
CONFIG_SOC_GPIO_DEEP_SLEEP_WAKE_VALID_GPIO_MASK=0
CONFIG_SOC_GPIO_DEEP_SLEEP_WAKE_SUPPORTED_PIN_CNT=8
CONFIG_SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK=0x000000007FFFFF00
CONFIG_SOC_GPIO_SUPPORT_FORCE_HOLD=y
CONFIG_SOC_GPIO_SUPPORT_HOLD_IO_IN_DSLP=y
CONFIG_SOC_GPIO_SUPPORT_HOLD_SINGLE_IO_IN_DSLP=y
CONFIG_SOC_GPIO_CLOCKOUT_BY_GPIO_MATRIX=y
CONFIG_SOC_CLOCKOUT_HAS_SOURCE_GATE=y
CONFIG_SOC_GPIO_CLOCKOUT_CHANNEL_NUM=3
CONFIG_SOC_RTCIO_PIN_COUNT=8
CONFIG_SOC_RTCIO_INPUT_OUTPUT_SUPPORTED=y
CONFIG_SOC_RTCIO_HOLD_SUPPORTED=y
CONFIG_SOC_RTCIO_WAKE_SUPPORTED=y
CONFIG_SOC_RTCIO_EDGE_WAKE_SUPPORTED=y
CONFIG_SOC_DEDIC_GPIO_OUT_CHANNELS_NUM=8
CONFIG_SOC_DEDIC_GPIO_IN_CHANNELS_NUM=8
CONFIG_SOC_DEDIC_PERIPH_ALWAYS_ENABLE=y
CONFIG_SOC_I2C_NUM=2
CONFIG_SOC_HP_I2C_NUM=1
CONFIG_SOC_I2C_FIFO_LEN=32
CONFIG_SOC_I2C_CMD_REG_NUM=8
CONFIG_SOC_I2C_SUPPORT_SLAVE=y
CONFIG_SOC_I2C_SUPPORT_HW_FSM_RST=y
CONFIG_SOC_I2C_SUPPORT_HW_CLR_BUS=y
CONFIG_SOC_I2C_SUPPORT_XTAL=y
CONFIG_SOC_I2C_SUPPORT_RTC=y
CONFIG_SOC_I2C_SUPPORT_10BIT_ADDR=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_BROADCAST=y
CONFIG_SOC_I2C_SLAVE_CAN_GET_STRETCH_CAUSE=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_I2CRAM_ACCESS=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_SLAVE_UNMATCH=y
CONFIG_SOC_I2C_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_LP_I2C_NUM=1
CONFIG_SOC_LP_I2C_FIFO_LEN=16
CONFIG_SOC_I2S_NUM=1
CONFIG_SOC_I2S_HW_VERSION_2=y
CONFIG_SOC_I2S_SUPPORTS_ETM=y
CONFIG_SOC_I2S_SUPPORTS_XTAL=y
CONFIG_SOC_I2S_SUPPORTS_PLL_F160M=y
CONFIG_SOC_I2S_SUPPORTS_PCM=y
CONFIG_SOC_I2S_SUPPORTS_PDM=y
CONFIG_SOC_I2S_SUPPORTS_PDM_TX=y
CONFIG_SOC_I2S_SUPPORTS_PCM2PDM=y
CONFIG_SOC_I2S_SUPPORTS_PDM_RX=y
CONFIG_SOC_I2S_PDM_MAX_TX_LINES=2
CONFIG_SOC_I2S_PDM_MAX_RX_LINES=1
CONFIG_SOC_I2S_SUPPORTS_TDM=y
CONFIG_SOC_I2S_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_LEDC_SUPPORT_PLL_DIV_CLOCK=y
CONFIG_SOC_LEDC_SUPPORT_XTAL_CLOCK=y
CONFIG_SOC_LEDC_TIMER_NUM=4
CONFIG_SOC_LEDC_CHANNEL_NUM=6
CONFIG_SOC_LEDC_TIMER_BIT_WIDTH=20
CONFIG_SOC_LEDC_SUPPORT_FADE_STOP=y
CONFIG_SOC_LEDC_GAMMA_CURVE_FADE_SUPPORTED=y
CONFIG_SOC_LEDC_GAMMA_CURVE_FADE_RANGE_MAX=16
CONFIG_SOC_LEDC_FADE_PARAMS_BIT_WIDTH=10
CONFIG_SOC_LEDC_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MMU_PAGE_SIZE_CONFIGURABLE=y
CONFIG_SOC_MMU_PAGE_SIZE_8KB_SUPPORTED=y
CONFIG_SOC_MMU_PERIPH_NUM=1
CONFIG_SOC_MMU_LINEAR_ADDRESS_REGION_NUM=1
CONFIG_SOC_MMU_DI_VADDR_SHARED=y
CONFIG_SOC_MPU_MIN_REGION_SIZE=0x20000000
CONFIG_SOC_MPU_REGIONS_MAX_NUM=8
CONFIG_SOC_PCNT_GROUPS=1
CONFIG_SOC_PCNT_UNITS_PER_GROUP=4
CONFIG_SOC_PCNT_CHANNELS_PER_UNIT=2
CONFIG_SOC_PCNT_THRES_POINT_PER_UNIT=2
CONFIG_SOC_PCNT_SUPPORT_RUNTIME_THRES_UPDATE=y
CONFIG_SOC_PCNT_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_RMT_GROUPS=1
CONFIG_SOC_RMT_TX_CANDIDATES_PER_GROUP=2
CONFIG_SOC_RMT_RX_CANDIDATES_PER_GROUP=2
CONFIG_SOC_RMT_CHANNELS_PER_GROUP=4
CONFIG_SOC_RMT_MEM_WORDS_PER_CHANNEL=48
CONFIG_SOC_RMT_SUPPORT_RX_PINGPONG=y
CONFIG_SOC_RMT_SUPPORT_RX_DEMODULATION=y
CONFIG_SOC_RMT_SUPPORT_TX_ASYNC_STOP=y
CONFIG_SOC_RMT_SUPPORT_TX_LOOP_COUNT=y
CONFIG_SOC_RMT_SUPPORT_TX_LOOP_AUTO_STOP=y
CONFIG_SOC_RMT_SUPPORT_TX_SYNCHRO=y
CONFIG_SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY=y
CONFIG_SOC_RMT_SUPPORT_XTAL=y
CONFIG_SOC_RMT_SUPPORT_RC_FAST=y
CONFIG_SOC_RMT_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MCPWM_GROUPS=1
CONFIG_SOC_MCPWM_TIMERS_PER_GROUP=3
CONFIG_SOC_MCPWM_OPERATORS_PER_GROUP=3
CONFIG_SOC_MCPWM_COMPARATORS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_GENERATORS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_TRIGGERS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_GPIO_FAULTS_PER_GROUP=3
CONFIG_SOC_MCPWM_CAPTURE_TIMERS_PER_GROUP=y
CONFIG_SOC_MCPWM_CAPTURE_CHANNELS_PER_TIMER=3
CONFIG_SOC_MCPWM_GPIO_SYNCHROS_PER_GROUP=3
CONFIG_SOC_MCPWM_SWSYNC_CAN_PROPAGATE=y
CONFIG_SOC_MCPWM_SUPPORT_ETM=y
CONFIG_SOC_MCPWM_CAPTURE_CLK_FROM_GROUP=y
CONFIG_SOC_MCPWM_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_PARLIO_GROUPS=1
CONFIG_SOC_PARLIO_TX_UNITS_PER_GROUP=1
CONFIG_SOC_PARLIO_RX_UNITS_PER_GROUP=1
CONFIG_SOC_PARLIO_TX_UNIT_MAX_DATA_WIDTH=16
CONFIG_SOC_PARLIO_RX_UNIT_MAX_DATA_WIDTH=16
CONFIG_SOC_PARLIO_TX_RX_SHARE_INTERRUPT=y
CONFIG_SOC_PARLIO_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MPI_MEM_BLOCKS_NUM=4
CONFIG_SOC_MPI_OPERATIONS_NUM=3
CONFIG_SOC_RSA_MAX_BIT_LEN=3072
CONFIG_SOC_SHA_DMA_MAX_BUFFER_SIZE=3968
CONFIG_SOC_SHA_SUPPORT_DMA=y
CONFIG_SOC_SHA_SUPPORT_RESUME=y
CONFIG_SOC_SHA_GDMA=y
CONFIG_SOC_SHA_SUPPORT_SHA1=y
CONFIG_SOC_SHA_SUPPORT_SHA224=y
CONFIG_SOC_SHA_SUPPORT_SHA256=y
CONFIG_SOC_SDM_GROUPS=1
CONFIG_SOC_SDM_CHANNELS_PER_GROUP=4
CONFIG_SOC_SDM_CLK_SUPPORT_PLL_F80M=y
CONFIG_SOC_SDM_CLK_SUPPORT_XTAL=y
CONFIG_SOC_SPI_PERIPH_NUM=2
CONFIG_SOC_SPI_MAX_CS_NUM=6
CONFIG_SOC_SPI_MAXIMUM_BUFFER_SIZE=64
CONFIG_SOC_SPI_SUPPORT_DDRCLK=y
CONFIG_SOC_SPI_SLAVE_SUPPORT_SEG_TRANS=y
CONFIG_SOC_SPI_SUPPORT_CD_SIG=y
CONFIG_SOC_SPI_SUPPORT_CONTINUOUS_TRANS=y
CONFIG_SOC_SPI_SUPPORT_SLAVE_HD_VER2=y
CONFIG_SOC_SPI_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_SPI_SUPPORT_CLK_XTAL=y
CONFIG_SOC_SPI_SUPPORT_CLK_PLL_F80M=y
CONFIG_SOC_SPI_SUPPORT_CLK_RC_FAST=y
CONFIG_SOC_SPI_SCT_SUPPORTED=y
CONFIG_SOC_SPI_SCT_REG_NUM=14
CONFIG_SOC_SPI_SCT_BUFFER_NUM_MAX=y
CONFIG_SOC_SPI_SCT_CONF_BITLEN_MAX=0x3FFFA
CONFIG_SOC_MEMSPI_IS_INDEPENDENT=y
CONFIG_SOC_SPI_MAX_PRE_DIVIDER=16
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE=y
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND=y
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_RESUME=y
CONFIG_SOC_SPI_MEM_SUPPORT_IDLE_INTR=y
CONFIG_SOC_SPI_MEM_SUPPORT_SW_SUSPEND=y
CONFIG_SOC_SPI_MEM_SUPPORT_CHECK_SUS=y
CONFIG_SOC_SPI_MEM_SUPPORT_WRAP=y
CONFIG_SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED=y
CONFIG_SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED=y
CONFIG_SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED=y
CONFIG_SOC_SYSTIMER_COUNTER_NUM=2
CONFIG_SOC_SYSTIMER_ALARM_NUM=3
CONFIG_SOC_SYSTIMER_BIT_WIDTH_LO=32
CONFIG_SOC_SYSTIMER_BIT_WIDTH_HI=20
CONFIG_SOC_SYSTIMER_FIXED_DIVIDER=y
CONFIG_SOC_SYSTIMER_SUPPORT_RC_FAST=y
CONFIG_SOC_SYSTIMER_INT_LEVEL=y
CONFIG_SOC_SYSTIMER_ALARM_MISS_COMPENSATE=y
CONFIG_SOC_SYSTIMER_SUPPORT_ETM=y
CONFIG_SOC_LP_TIMER_BIT_WIDTH_LO=32
CONFIG_SOC_LP_TIMER_BIT_WIDTH_HI=16
CONFIG_SOC_TIMER_GROUPS=2
CONFIG_SOC_TIMER_GROUP_TIMERS_PER_GROUP=1
CONFIG_SOC_TIMER_GROUP_COUNTER_BIT_WIDTH=54
CONFIG_SOC_TIMER_GROUP_SUPPORT_XTAL=y
CONFIG_SOC_TIMER_GROUP_SUPPORT_RC_FAST=y
CONFIG_SOC_TIMER_GROUP_TOTAL_TIMERS=2
CONFIG_SOC_TIMER_SUPPORT_ETM=y
CONFIG_SOC_TIMER_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MWDT_SUPPORT_XTAL=y
CONFIG_SOC_MWDT_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_TWAI_CONTROLLER_NUM=2
CONFIG_SOC_TWAI_MASK_FILTER_NUM=1
CONFIG_SOC_TWAI_CLK_SUPPORT_XTAL=y
CONFIG_SOC_TWAI_BRP_MIN=2
CONFIG_SOC_TWAI_BRP_MAX=32768
CONFIG_SOC_TWAI_SUPPORTS_RX_STATUS=y
CONFIG_SOC_TWAI_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_EFUSE_DIS_DOWNLOAD_ICACHE=y
CONFIG_SOC_EFUSE_DIS_PAD_JTAG=y
CONFIG_SOC_EFUSE_DIS_USB_JTAG=y
CONFIG_SOC_EFUSE_DIS_DIRECT_BOOT=y
CONFIG_SOC_EFUSE_SOFT_DIS_JTAG=y
CONFIG_SOC_EFUSE_DIS_ICACHE=y
CONFIG_SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK=y
CONFIG_SOC_SECURE_BOOT_V2_RSA=y
CONFIG_SOC_SECURE_BOOT_V2_ECC=y
CONFIG_SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS=3
CONFIG_SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS=y
CONFIG_SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY=y
CONFIG_SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX=64
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES=y
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_128=y
CONFIG_SOC_APM_CTRL_FILTER_SUPPORTED=y
CONFIG_SOC_APM_LP_APM0_SUPPORTED=y
CONFIG_SOC_CRYPTO_DPA_PROTECTION_SUPPORTED=y
CONFIG_SOC_UART_NUM=3
CONFIG_SOC_UART_HP_NUM=2
CONFIG_SOC_UART_LP_NUM=1
CONFIG_SOC_UART_FIFO_LEN=128
CONFIG_SOC_LP_UART_FIFO_LEN=16
CONFIG_SOC_UART_BITRATE_MAX=5000000
CONFIG_SOC_UART_SUPPORT_PLL_F80M_CLK=y
CONFIG_SOC_UART_SUPPORT_RTC_CLK=y
CONFIG_SOC_UART_SUPPORT_XTAL_CLK=y
CONFIG_SOC_UART_SUPPORT_WAKEUP_INT=y
CONFIG_SOC_UART_HAS_LP_UART=y
CONFIG_SOC_UART_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_UART_SUPPORT_FSM_TX_WAIT_SEND=y
CONFIG_SOC_UART_WAKEUP_CHARS_SEQ_MAX_LEN=5
CONFIG_SOC_UART_WAKEUP_SUPPORT_ACTIVE_THRESH_MODE=y
CONFIG_SOC_UART_WAKEUP_SUPPORT_FIFO_THRESH_MODE=y
CONFIG_SOC_UART_WAKEUP_SUPPORT_START_BIT_MODE=y
CONFIG_SOC_UART_WAKEUP_SUPPORT_CHAR_SEQ_MODE=y
CONFIG_SOC_UHCI_NUM=1
CONFIG_SOC_COEX_HW_PTI=y
CONFIG_SOC_EXTERNAL_COEX_ADVANCE=y
CONFIG_SOC_PHY_DIG_REGS_MEM_SIZE=21
CONFIG_SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH=12
CONFIG_SOC_RTC_MEM_SUPPORT_SPEED_MODE_SWITCH=y
CONFIG_SOC_PM_SUPPORT_WIFI_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_BEACON_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_BT_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP_MODE_PER_PIN=y
CONFIG_SOC_PM_SUPPORT_CPU_PD=y
CONFIG_SOC_PM_SUPPORT_MODEM_PD=y
CONFIG_SOC_PM_SUPPORT_XTAL32K_PD=y
CONFIG_SOC_PM_SUPPORT_RC32K_PD=y
CONFIG_SOC_PM_SUPPORT_RC_FAST_PD=y
CONFIG_SOC_PM_SUPPORT_VDDSDIO_PD=y
CONFIG_SOC_PM_SUPPORT_TOP_PD=y
CONFIG_SOC_PM_SUPPORT_HP_AON_PD=y
CONFIG_SOC_PM_SUPPORT_MAC_BB_PD=y
CONFIG_SOC_PM_SUPPORT_RTC_PERIPH_PD=y
CONFIG_SOC_PM_SUPPORT_PMU_MODEM_STATE=y
CONFIG_SOC_PM_SUPPORT_PMU_CLK_ICG=y
CONFIG_SOC_PM_SUPPORT_DEEPSLEEP_CHECK_STUB_ONLY=y
CONFIG_SOC_PM_CPU_RETENTION_BY_SW=y
CONFIG_SOC_PM_MODEM_RETENTION_BY_REGDMA=y
CONFIG_SOC_PM_RETENTION_HAS_CLOCK_BUG=y
CONFIG_SOC_EXT_MEM_CACHE_TAG_IN_CPU_DOMAIN=y
CONFIG_SOC_PM_PAU_LINK_NUM=4
CONFIG_SOC_PM_PAU_REGDMA_LINK_MULTI_ADDR=y
CONFIG_SOC_PM_PAU_REGDMA_LINK_WIFIMAC=y
CONFIG_SOC_PM_PAU_REGDMA_UPDATE_CACHE_BEFORE_WAIT_COMPARE=y
CONFIG_SOC_PM_PMU_MIN_SLP_SLOW_CLK_CYCLE_FIXED=y
CONFIG_SOC_PM_RETENTION_MODULE_NUM=32
CONFIG_SOC_CLK_RC_FAST_SUPPORT_CALIBRATION=y
CONFIG_SOC_MODEM_CLOCK_IS_INDEPENDENT=y
CONFIG_SOC_CLK_XTAL32K_SUPPORTED=y
CONFIG_SOC_CLK_OSC_SLOW_SUPPORTED=y
CONFIG_SOC_CLK_RC32K_SUPPORTED=y
CONFIG_SOC_CLK_LP_FAST_SUPPORT_XTAL_D2=y
CONFIG_SOC_RCC_IS_INDEPENDENT=y
CONFIG_SOC_CLK_ANA_I2C_MST_HAS_ROOT_GATE=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_XTAL=y
CONFIG_SOC_TEMPERATURE_SENSOR_INTR_SUPPORT=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_ETM=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_TEMPERATURE_SENSOR_UNDER_PD_TOP_DOMAIN=y
CONFIG_SOC_RNG_CLOCK_IS_INDEPENDENT=y
CONFIG_SOC_WIFI_HW_TSF=y
CONFIG_SOC_WIFI_FTM_SUPPORT=y
CONFIG_SOC_WIFI_GCMP_SUPPORT=y
CONFIG_SOC_WIFI_WAPI_SUPPORT=y
CONFIG_SOC_WIFI_CSI_SUPPORT=y
CONFIG_SOC_WIFI_MESH_SUPPORT=y
CONFIG_SOC_WIFI_HE_SUPPORT=y
CONFIG_SOC_WIFI_MAC_VERSION_NUM=2
CONFIG_SOC_BLE_SUPPORTED=y
CONFIG_SOC_BLE_MESH_SUPPORTED=y
CONFIG_SOC_ESP_NIMBLE_CONTROLLER=y
CONFIG_SOC_BLE_50_SUPPORTED=y
CONFIG_SOC_BLE_DEVICE_PRIVACY_SUPPORTED=y
CONFIG_SOC_BLE_POWER_CONTROL_SUPPORTED=y
CONFIG_SOC_BLE_PERIODIC_ADV_ENH_SUPPORTED=y
CONFIG_SOC_BLUFI_SUPPORTED=y
CONFIG_SOC_BLE_MULTI_CONN_OPTIMIZATION=y
CONFIG_SOC_BLE_USE_WIFI_PWR_CLK_WORKAROUND=y
CONFIG_SOC_PHY_COMBO_MODULE=y
CONFIG_SOC_CAPS_NO_RESET_BY_ANA_BOD=y
CONFIG_SOC_LP_CORE_SINGLE_INTERRUPT_VECTOR=y
CONFIG_SOC_LP_CORE_SUPPORT_ETM=y
CONFIG_SOC_DEBUG_HAVE_OCD_STUB_BINS=y
CONFIG_IDF_CMAKE=y
CONFIG_IDF_TOOLCHAIN="gcc"
CONFIG_IDF_TOOLCHAIN_GCC=y
CONFIG_IDF_TARGET_ARCH_RISCV=y
CONFIG_IDF_TARGET_ARCH="riscv"
CONFIG_IDF_TARGET="esp32c6"
CONFIG_IDF_INIT_VERSION="5.5.0"
CONFIG_IDF_TARGET_ESP32C6=y
CONFIG_IDF_FIRMWARE_CHIP_ID=0x000D

#
# Build type
#
CONFIG_APP_BUILD_TYPE_APP_2NDBOOT=y
# CONFIG_APP_BUILD_TYPE_RAM is not set
CONFIG_APP_BUILD_GENERATE_BINARIES=y
CONFIG_APP_BUILD_BOOTLOADER=y
CONFIG_APP_BUILD_USE_FLASH_SECTIONS=y
# CONFIG_APP_REPRODUCIBLE_BUILD is not set
# CONFIG_APP_NO_BLOBS is not set
# end of Build type

#
# Bootloader config
#

#
# Bootloader manager
#
CONFIG_BOOTLOADER_COMPILE_TIME_DATE=y
CONFIG_BOOTLOADER_PROJECT_VER=1
# end of Bootloader manager

#
# Application Rollback
#
# CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE is not set
# end of Application Rollback

#
# Bootloader Rollback
#
# end of Bootloader Rollback

CONFIG_BOOTLOADER_OFFSET_IN_FLASH=0x0
CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE=y
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_DEBUG is not set
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_PERF is not set

#
# Log
#
CONFIG_BOOTLOADER_LOG_VERSION_1=y
CONFIG_BOOTLOADER_LOG_VERSION=1
# CONFIG_BOOTLOADER_LOG_LEVEL_NONE is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_ERROR is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_WARN is not set
CONFIG_BOOTLOADER_LOG_LEVEL_INFO=y
# CONFIG_BOOTLOADER_LOG_LEVEL_DEBUG is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_VERBOSE is not set
CONFIG_BOOTLOADER_LOG_LEVEL=3

#
# Format
#
# CONFIG_BOOTLOADER_LOG_COLORS is not set
CONFIG_BOOTLOADER_LOG_TIMESTAMP_SOURCE_CPU_TICKS=y
# end of Format

#
# Settings
#
CONFIG_BOOTLOADER_LOG_MODE_TEXT_EN=y
CONFIG_BOOTLOADER_LOG_MODE_TEXT=y
# end of Settings
# end of Log

#
# Serial Flash Configurations
#
# CONFIG_BOOTLOADER_FLASH_DC_AWARE is not set
CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT=y
# end of Serial Flash Configurations

# CONFIG_BOOTLOADER_FACTORY_RESET is not set
# CONFIG_BOOTLOADER_APP_TEST is not set
CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE=y
CONFIG_BOOTLOADER_WDT_ENABLE=y
# CONFIG_BOOTLOADER_WDT_DISABLE_IN_USER_CODE is not set
CONFIG_BOOTLOADER_WDT_TIME_MS=9000
# CONFIG_BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP is not set
# CONFIG_BOOTLOADER_SKIP_VALIDATE_ON_POWER_ON is not set
# CONFIG_BOOTLOADER_SKIP_VALIDATE_ALWAYS is not set
CONFIG_BOOTLOADER_RESERVE_RTC_SIZE=0
# CONFIG_BOOTLOADER_CUSTOM_RESERVE_RTC is not set
# end of Bootloader config

#
# Security features
#
CONFIG_SECURE_BOOT_V2_RSA_SUPPORTED=y
CONFIG_SECURE_BOOT_V2_ECC_SUPPORTED=y
CONFIG_SECURE_BOOT_V2_PREFERRED=y
# CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT is not set
# CONFIG_SECURE_BOOT is not set
# CONFIG_SECURE_FLASH_ENC_ENABLED is not set
CONFIG_SECURE_ROM_DL_MODE_ENABLED=y
# end of Security features

#
# Application manager
#
CONFIG_APP_COMPILE_TIME_DATE=y
# CONFIG_APP_EXCLUDE_PROJECT_VER_VAR is not set
# CONFIG_APP_EXCLUDE_PROJECT_NAME_VAR is not set
# CONFIG_APP_PROJECT_VER_FROM_CONFIG is not set
CONFIG_APP_RETRIEVE_LEN_ELF_SHA=9
# end of Application manager

CONFIG_ESP_ROM_HAS_CRC_LE=y
CONFIG_ESP_ROM_HAS_CRC_BE=y
CONFIG_ESP_ROM_HAS_JPEG_DECODE=y
CONFIG_ESP_ROM_UART_CLK_IS_XTAL=y
CONFIG_ESP_ROM_USB_SERIAL_DEVICE_NUM=3
CONFIG_ESP_ROM_HAS_RETARGETABLE_LOCKING=y
CONFIG_ESP_ROM_GET_CLK_FREQ=y
CONFIG_ESP_ROM_HAS_RVFPLIB=y
CONFIG_ESP_ROM_HAS_HAL_WDT=y
CONFIG_ESP_ROM_HAS_HAL_SYSTIMER=y
CONFIG_ESP_ROM_HAS_HEAP_TLSF=y
CONFIG_ESP_ROM_TLSF_CHECK_PATCH=y
CONFIG_ESP_ROM_MULTI_HEAP_WALK_PATCH=y
CONFIG_ESP_ROM_HAS_LAYOUT_TABLE=y
CONFIG_ESP_ROM_HAS_SPI_FLASH=y
CONFIG_ESP_ROM_HAS_SPI_FLASH_MMAP=y
CONFIG_ESP_ROM_HAS_REGI2C_BUG=y
CONFIG_ESP_ROM_HAS_NEWLIB=y
CONFIG_ESP_ROM_HAS_NEWLIB_NORMAL_FORMAT=y
CONFIG_ESP_ROM_REV0_HAS_NO_ECDSA_INTERFACE=y
CONFIG_ESP_ROM_WDT_INIT_PATCH=y
CONFIG_ESP_ROM_NEEDS_SET_CACHE_MMU_SIZE=y
CONFIG_ESP_ROM_RAM_APP_NEEDS_MMU_INIT=y
CONFIG_ESP_ROM_HAS_SW_FLOAT=y
CONFIG_ESP_ROM_USB_OTG_NUM=-1
CONFIG_ESP_ROM_HAS_VERSION=y
CONFIG_ESP_ROM_SUPPORT_DEEP_SLEEP_WAKEUP_STUB=y
CONFIG_ESP_ROM_HAS_OUTPUT_PUTC_FUNC=y
CONFIG_ESP_ROM_NO_USB_SERIAL_OUTPUT_API=y
CONFIG_ESP_ROM_HAS_SUBOPTIMAL_NEWLIB_ON_MISALIGNED_MEMORY=y

#
# Boot ROM Behavior
#
CONFIG_BOOT_ROM_LOG_ALWAYS_ON=y
# CONFIG_BOOT_ROM_LOG_ALWAYS_OFF is not set
# CONFIG_BOOT_ROM_LOG_ON_GPIO_HIGH is not set
# CONFIG_BOOT_ROM_LOG_ON_GPIO_LOW is not set
# end of Boot ROM Behavior

#
# ESP-TEE (Trusted Execution Environment)
#
# CONFIG_SECURE_ENABLE_TEE is not set
CONFIG_SECURE_TEE_LOG_LEVEL=0
# end of ESP-TEE (Trusted Execution Environment)

#
# Serial flasher config
#
# CONFIG_ESPTOOLPY_NO_STUB is not set
# CONFIG_ESPTOOLPY_FLASHMODE_QIO is not set
# CONFIG_ESPTOOLPY_FLASHMODE_QOUT is not set
CONFIG_ESPTOOLPY_FLASHMODE_DIO=y
# CONFIG_ESPTOOLPY_FLASHMODE_DOUT is not set
CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_STR=y
CONFIG_ESPTOOLPY_FLASHMODE="dio"
CONFIG_ESPTOOLPY_FLASHFREQ_80M=y
# CONFIG_ESPTOOLPY_FLASHFREQ_40M is not set
# CONFIG_ESPTOOLPY_FLASHFREQ_20M is not set
CONFIG_ESPTOOLPY_FLASHFREQ="80m"
# CONFIG_ESPTOOLPY_FLASHSIZE_1MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_2MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_4MB is not set
CONFIG_ESPTOOLPY_FLASHSIZE_8MB=y
# CONFIG_ESPTOOLPY_FLASHSIZE_16MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_32MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_64MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_128MB is not set
CONFIG_ESPTOOLPY_FLASHSIZE="8MB"
# CONFIG_ESPTOOLPY_HEADER_FLASHSIZE_UPDATE is not set
CONFIG_ESPTOOLPY_BEFORE_RESET=y
# CONFIG_ESPTOOLPY_BEFORE_NORESET is not set
CONFIG_ESPTOOLPY_BEFORE="default_reset"
CONFIG_ESPTOOLPY_AFTER_RESET=y
# CONFIG_ESPTOOLPY_AFTER_NORESET is not set
CONFIG_ESPTOOLPY_AFTER="hard_reset"
CONFIG_ESPTOOLPY_MONITOR_BAUD=115200
# end of Serial flasher config

#
# Partition Table
#
# CONFIG_PARTITION_TABLE_SINGLE_APP is not set
# CONFIG_PARTITION_TABLE_SINGLE_APP_LARGE is not set
# CONFIG_PARTITION_TABLE_TWO_OTA is not set
# CONFIG_PARTITION_TABLE_TWO_OTA_LARGE is not set
CONFIG_PARTITION_TABLE_CUSTOM=y
CONFIG_PARTITION_TABLE_CUSTOM_FILENAME="partitions.csv"
CONFIG_PARTITION_TABLE_FILENAME="partitions.csv"
CONFIG_PARTITION_TABLE_OFFSET=0x8000
CONFIG_PARTITION_TABLE_MD5=y
# end of Partition Table

#
# Example Configuration
#
CONFIG_ESP_WIFI_SSID="myssid"
CONFIG_ESP_WIFI_PASSWORD="mypassword"
# end of Example Configuration

#
# DIYMON Board Support Package
#
# CONFIG_DIYMON_BOARD_ORIGINAL is not set
CONFIG_DIYMON_BOARD_WAVESHARE_C6=y
# end of DIYMON Board Support Package

#
# Compiler options
#
CONFIG_COMPILER_OPTIMIZATION_DEBUG=y
# CONFIG_COMPILER_OPTIMIZATION_SIZE is not set
# CONFIG_COMPILER_OPTIMIZATION_PERF is not set
# CONFIG_COMPILER_OPTIMIZATION_NONE is not set
CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE=y
# CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT is not set
# CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_DISABLE is not set
CONFIG_COMPILER_ASSERT_NDEBUG_EVALUATE=y
# CONFIG_COMPILER_FLOAT_LIB_FROM_GCCLIB is not set
CONFIG_COMPILER_FLOAT_LIB_FROM_RVFPLIB=y
CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL=2
# CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT is not set
CONFIG_COMPILER_HIDE_PATHS_MACROS=y
# CONFIG_COMPILER_CXX_EXCEPTIONS is not set
# CONFIG_COMPILER_CXX_RTTI is not set
CONFIG_COMPILER_STACK_CHECK_MODE_NONE=y
# CONFIG_COMPILER_STACK_CHECK_MODE_NORM is not set
# CONFIG_COMPILER_STACK_CHECK_MODE_STRONG is not set
# CONFIG_COMPILER_STACK_CHECK_MODE_ALL is not set
# CONFIG_COMPILER_NO_MERGE_CONSTANTS is not set
# CONFIG_COMPILER_WARN_WRITE_STRINGS is not set
# CONFIG_COMPILER_SAVE_RESTORE_LIBCALLS is not set
CONFIG_COMPILER_DISABLE_DEFAULT_ERRORS=y
# CONFIG_COMPILER_DISABLE_GCC12_WARNINGS is not set
# CONFIG_COMPILER_DISABLE_GCC13_WARNINGS is not set
# CONFIG_COMPILER_DISABLE_GCC14_WARNINGS is not set
# CONFIG_COMPILER_DUMP_RTL_FILES is not set
CONFIG_COMPILER_RT_LIB_GCCLIB=y
CONFIG_COMPILER_RT_LIB_NAME="gcc"
CONFIG_COMPILER_ORPHAN_SECTIONS_WARNING=y
# CONFIG_COMPILER_ORPHAN_SECTIONS_PLACE is not set
# CONFIG_COMPILER_STATIC_ANALYZER is not set
# end of Compiler options

#
# Component config
#

#
# Application Level Tracing
#
# CONFIG_APPTRACE_DEST_JTAG is not set
CONFIG_APPTRACE_DEST_NONE=y
# CONFIG_APPTRACE_DEST_UART1 is not set
# CONFIG_APPTRACE_DEST_UART2 is not set
CONFIG_APPTRACE_DEST_UART_NONE=y
CONFIG_APPTRACE_UART_TASK_PRIO=1
CONFIG_APPTRACE_LOCK_ENABLE=y
# end of Application Level Tracing

#
# Bluetooth
#
# CONFIG_BT_ENABLED is not set

#
# Common Options
#
# CONFIG_BT_BLE_LOG_SPI_OUT_ENABLED is not set
# end of Common Options
# end of Bluetooth

#
# Console Library
#
CONFIG_CONSOLE_SORTED_HELP=y
# end of Console Library

#
# Driver Configurations
#

#
# Legacy TWAI Driver Configurations
#
# CONFIG_TWAI_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy TWAI Driver Configurations

#
# Legacy ADC Driver Configuration
#
# CONFIG_ADC_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_ADC_SKIP_LEGACY_CONFLICT_CHECK is not set

#
# Legacy ADC Calibration Configuration
#
# CONFIG_ADC_CALI_SUPPRESS_DEPRECATE_WARN is not set
# end of Legacy ADC Calibration Configuration
# end of Legacy ADC Driver Configuration

#
# Legacy MCPWM Driver Configurations
#
# CONFIG_MCPWM_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_MCPWM_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy MCPWM Driver Configurations

#
# Legacy Timer Group Driver Configurations
#
# CONFIG_GPTIMER_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_GPTIMER_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy Timer Group Driver Configurations

#
# Legacy RMT Driver Configurations
#
# CONFIG_RMT_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_RMT_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy RMT Driver Configurations

#
# Legacy I2S Driver Configurations
#
# CONFIG_I2S_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_I2S_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy I2S Driver Configurations

#
# Legacy I2C Driver Configurations
#
# CONFIG_I2C_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy I2C Driver Configurations

#
# Legacy PCNT Driver Configurations
#
# CONFIG_PCNT_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_PCNT_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy PCNT Driver Configurations

#
# Legacy SDM Driver Configurations
#
# CONFIG_SDM_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_SDM_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy SDM Driver Configurations

#
# Legacy Temperature Sensor Driver Configurations
#
# CONFIG_TEMP_SENSOR_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_TEMP_SENSOR_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy Temperature Sensor Driver Configurations
# end of Driver Configurations

#
# eFuse Bit Manager
#
# CONFIG_EFUSE_CUSTOM_TABLE is not set
# CONFIG_EFUSE_VIRTUAL is not set
CONFIG_EFUSE_MAX_BLK_LEN=256
# end of eFuse Bit Manager

#
# ESP-TLS
#
CONFIG_ESP_TLS_USING_MBEDTLS=y
# CONFIG_ESP_TLS_USE_SECURE_ELEMENT is not set
CONFIG_ESP_TLS_USE_DS_PERIPHERAL=y
# CONFIG_ESP_TLS_CLIENT_SESSION_TICKETS is not set
# CONFIG_ESP_TLS_SERVER_SESSION_TICKETS is not set
# CONFIG_ESP_TLS_SERVER_CERT_SELECT_HOOK is not set
# CONFIG_ESP_TLS_SERVER_MIN_AUTH_MODE_OPTIONAL is not set
# CONFIG_ESP_TLS_PSK_VERIFICATION is not set
# CONFIG_ESP_TLS_INSECURE is not set
# end of ESP-TLS

#
# ADC and ADC Calibration
#
# CONFIG_ADC_ONESHOT_CTRL_FUNC_IN_IRAM is not set
# CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE is not set
# CONFIG_ADC_ENABLE_DEBUG_LOG is not set
# end of ADC and ADC Calibration

#
# Wireless Coexistence
#
CONFIG_ESP_COEX_ENABLED=y
CONFIG_ESP_COEX_SW_COEXIST_ENABLE=y
# CONFIG_ESP_COEX_EXTERNAL_COEXIST_ENABLE is not set
# CONFIG_ESP_COEX_POWER_MANAGEMENT is not set
# CONFIG_ESP_COEX_GPIO_DEBUG is not set
# end of Wireless Coexistence

#
# Common ESP-related
#
CONFIG_ESP_ERR_TO_NAME_LOOKUP=y
# end of Common ESP-related

#
# ESP-Driver:GPIO Configurations
#
# CONFIG_GPIO_CTRL_FUNC_IN_IRAM is not set
# end of ESP-Driver:GPIO Configurations

#
# ESP-Driver:GPTimer Configurations
#
CONFIG_GPTIMER_ISR_HANDLER_IN_IRAM=y
# CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM is not set
# CONFIG_GPTIMER_ISR_CACHE_SAFE is not set
CONFIG_GPTIMER_OBJ_CACHE_SAFE=y
# CONFIG_GPTIMER_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:GPTimer Configurations

#
# ESP-Driver:I2C Configurations
#
# CONFIG_I2C_ISR_IRAM_SAFE is not set
# CONFIG_I2C_ENABLE_DEBUG_LOG is not set
# CONFIG_I2C_ENABLE_SLAVE_DRIVER_VERSION_2 is not set
CONFIG_I2C_MASTER_ISR_HANDLER_IN_IRAM=y
# end of ESP-Driver:I2C Configurations

#
# ESP-Driver:I2S Configurations
#
# CONFIG_I2S_ISR_IRAM_SAFE is not set
# CONFIG_I2S_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:I2S Configurations

#
# ESP-Driver:LEDC Configurations
#
# CONFIG_LEDC_CTRL_FUNC_IN_IRAM is not set
# end of ESP-Driver:LEDC Configurations

#
# ESP-Driver:MCPWM Configurations
#
CONFIG_MCPWM_ISR_HANDLER_IN_IRAM=y
# CONFIG_MCPWM_ISR_CACHE_SAFE is not set
# CONFIG_MCPWM_CTRL_FUNC_IN_IRAM is not set
CONFIG_MCPWM_OBJ_CACHE_SAFE=y
# CONFIG_MCPWM_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:MCPWM Configurations

#
# ESP-Driver:Parallel IO Configurations
#
CONFIG_PARLIO_TX_ISR_HANDLER_IN_IRAM=y
CONFIG_PARLIO_RX_ISR_HANDLER_IN_IRAM=y
# CONFIG_PARLIO_TX_ISR_CACHE_SAFE is not set
# CONFIG_PARLIO_RX_ISR_CACHE_SAFE is not set
CONFIG_PARLIO_OBJ_CACHE_SAFE=y
# CONFIG_PARLIO_ENABLE_DEBUG_LOG is not set
# CONFIG_PARLIO_ISR_IRAM_SAFE is not set
# end of ESP-Driver:Parallel IO Configurations

#
# ESP-Driver:PCNT Configurations
#
# CONFIG_PCNT_CTRL_FUNC_IN_IRAM is not set
# CONFIG_PCNT_ISR_IRAM_SAFE is not set
# CONFIG_PCNT_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:PCNT Configurations

#
# ESP-Driver:RMT Configurations
#
CONFIG_RMT_ENCODER_FUNC_IN_IRAM=y
CONFIG_RMT_TX_ISR_HANDLER_IN_IRAM=y
CONFIG_RMT_RX_ISR_HANDLER_IN_IRAM=y
# CONFIG_RMT_RECV_FUNC_IN_IRAM is not set
# CONFIG_RMT_TX_ISR_CACHE_SAFE is not set
# CONFIG_RMT_RX_ISR_CACHE_SAFE is not set
CONFIG_RMT_OBJ_CACHE_SAFE=y
# CONFIG_RMT_ENABLE_DEBUG_LOG is not set
# CONFIG_RMT_ISR_IRAM_SAFE is not set
# end of ESP-Driver:RMT Configurations

#
# ESP-Driver:Sigma Delta Modulator Configurations
#
# CONFIG_SDM_CTRL_FUNC_IN_IRAM is not set
# CONFIG_SDM_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:Sigma Delta Modulator Configurations

#
# ESP-Driver:SPI Configurations
#
# CONFIG_SPI_MASTER_IN_IRAM is not set
CONFIG_SPI_MASTER_ISR_IN_IRAM=y
# CONFIG_SPI_SLAVE_IN_IRAM is not set
CONFIG_SPI_SLAVE_ISR_IN_IRAM=y
# end of ESP-Driver:SPI Configurations

#
# ESP-Driver:Temperature Sensor Configurations
#
# CONFIG_TEMP_SENSOR_ENABLE_DEBUG_LOG is not set
# CONFIG_TEMP_SENSOR_ISR_IRAM_SAFE is not set
# end of ESP-Driver:Temperature Sensor Configurations

#
# ESP-Driver:TWAI Configurations
#
# CONFIG_TWAI_ISR_IN_IRAM is not set
# CONFIG_TWAI_ISR_CACHE_SAFE is not set
# CONFIG_TWAI_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:TWAI Configurations

#
# ESP-Driver:UART Configurations
#
# CONFIG_UART_ISR_IN_IRAM is not set
# end of ESP-Driver:UART Configurations

#
# ESP-Driver:UHCI Configurations
#
# CONFIG_UHCI_ISR_HANDLER_IN_IRAM is not set
# CONFIG_UHCI_ISR_CACHE_SAFE is not set
# CONFIG_UHCI_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:UHCI Configurations

#
# ESP-Driver:USB Serial/JTAG Configuration
#
CONFIG_USJ_ENABLE_USB_SERIAL_JTAG=y
# end of ESP-Driver:USB Serial/JTAG Configuration

#
# Ethernet
#
CONFIG_ETH_ENABLED=y
CONFIG_ETH_USE_SPI_ETHERNET=y
# CONFIG_ETH_SPI_ETHERNET_DM9051 is not set
# CONFIG_ETH_SPI_ETHERNET_W5500 is not set
# CONFIG_ETH_SPI_ETHERNET_KSZ8851SNL is not set
# CONFIG_ETH_USE_OPENETH is not set
# CONFIG_ETH_TRANSMIT_MUTEX is not set
# end of Ethernet

#
# Event Loop Library
#
# CONFIG_ESP_EVENT_LOOP_PROFILING is not set
CONFIG_ESP_EVENT_POST_FROM_ISR=y
CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR=y
# end of Event Loop Library

#
# GDB Stub
#
CONFIG_ESP_GDBSTUB_ENABLED=y
# CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME is not set
CONFIG_ESP_GDBSTUB_SUPPORT_TASKS=y
CONFIG_ESP_GDBSTUB_MAX_TASKS=32
# end of GDB Stub

#
# ESP HID
#
CONFIG_ESPHID_TASK_SIZE_BT=2048
CONFIG_ESPHID_TASK_SIZE_BLE=4096
# end of ESP HID

#
# ESP HTTP client
#
CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS=y
# CONFIG_ESP_HTTP_CLIENT_ENABLE_BASIC_AUTH is not set
# CONFIG_ESP_HTTP_CLIENT_ENABLE_DIGEST_AUTH is not set
# CONFIG_ESP_HTTP_CLIENT_ENABLE_CUSTOM_TRANSPORT is not set
CONFIG_ESP_HTTP_CLIENT_EVENT_POST_TIMEOUT=2000
# end of ESP HTTP client

#
# HTTP Server
#
CONFIG_HTTPD_MAX_REQ_HDR_LEN=1024
CONFIG_HTTPD_MAX_URI_LEN=512
CONFIG_HTTPD_ERR_RESP_NO_DELAY=y
CONFIG_HTTPD_PURGE_BUF_LEN=32
# CONFIG_HTTPD_LOG_PURGE_DATA is not set
# CONFIG_HTTPD_WS_SUPPORT is not set
# CONFIG_HTTPD_QUEUE_WORK_BLOCKING is not set
CONFIG_HTTPD_SERVER_EVENT_POST_TIMEOUT=2000
# end of HTTP Server

#
# ESP HTTPS OTA
#
# CONFIG_ESP_HTTPS_OTA_DECRYPT_CB is not set
# CONFIG_ESP_HTTPS_OTA_ALLOW_HTTP is not set
CONFIG_ESP_HTTPS_OTA_EVENT_POST_TIMEOUT=2000
# end of ESP HTTPS OTA

#
# ESP HTTPS server
#
# CONFIG_ESP_HTTPS_SERVER_ENABLE is not set
CONFIG_ESP_HTTPS_SERVER_EVENT_POST_TIMEOUT=2000
# CONFIG_ESP_HTTPS_SERVER_CERT_SELECT_HOOK is not set
# end of ESP HTTPS server

#
# Hardware Settings
#

#
# Chip revision
#
CONFIG_ESP32C6_REV_MIN_0=y
# CONFIG_ESP32C6_REV_MIN_1 is not set
# CONFIG_ESP32C6_REV_MIN_2 is not set
CONFIG_ESP32C6_REV_MIN_FULL=0
CONFIG_ESP_REV_MIN_FULL=0

#
# Maximum Supported ESP32-C6 Revision (Rev v0.99)
#
CONFIG_ESP32C6_REV_MAX_FULL=99
CONFIG_ESP_REV_MAX_FULL=99
CONFIG_ESP_EFUSE_BLOCK_REV_MIN_FULL=0
CONFIG_ESP_EFUSE_BLOCK_REV_MAX_FULL=99

#
# Maximum Supported ESP32-C6 eFuse Block Revision (eFuse Block Rev v0.99)
#
# end of Chip revision

#
# MAC Config
#
CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_BT=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_ETH=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_IEEE802154=y
CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES_FOUR=y
CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES=4
# CONFIG_ESP32C6_UNIVERSAL_MAC_ADDRESSES_TWO is not set
CONFIG_ESP32C6_UNIVERSAL_MAC_ADDRESSES_FOUR=y
CONFIG_ESP32C6_UNIVERSAL_MAC_ADDRESSES=4
# CONFIG_ESP_MAC_USE_CUSTOM_MAC_AS_BASE_MAC is not set
# end of MAC Config

#
# Sleep Config
#
# CONFIG_ESP_SLEEP_POWER_DOWN_FLASH is not set
CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND=y
# CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU is not set
CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND=y
CONFIG_ESP_SLEEP_WAIT_FLASH_READY_EXTRA_DELAY=0
# CONFIG_ESP_SLEEP_CACHE_SAFE_ASSERTION is not set
# CONFIG_ESP_SLEEP_DEBUG is not set
CONFIG_ESP_SLEEP_GPIO_ENABLE_INTERNAL_RESISTORS=y
# end of Sleep Config

#
# RTC Clock Config
#
CONFIG_RTC_CLK_SRC_INT_RC=y
# CONFIG_RTC_CLK_SRC_EXT_CRYS is not set
# CONFIG_RTC_CLK_SRC_EXT_OSC is not set
# CONFIG_RTC_CLK_SRC_USE_DANGEROUS_RC32K_ALLOWED is not set
CONFIG_RTC_CLK_CAL_CYCLES=1024
# end of RTC Clock Config

#
# Peripheral Control
#
CONFIG_ESP_PERIPH_CTRL_FUNC_IN_IRAM=y
CONFIG_ESP_REGI2C_CTRL_FUNC_IN_IRAM=y
# end of Peripheral Control

#
# ETM Configuration
#
# CONFIG_ETM_ENABLE_DEBUG_LOG is not set
# end of ETM Configuration

#
# GDMA Configurations
#
CONFIG_GDMA_CTRL_FUNC_IN_IRAM=y
CONFIG_GDMA_ISR_HANDLER_IN_IRAM=y
CONFIG_GDMA_OBJ_DRAM_SAFE=y
# CONFIG_GDMA_ENABLE_DEBUG_LOG is not set
# CONFIG_GDMA_ISR_IRAM_SAFE is not set
# end of GDMA Configurations

#
# Main XTAL Config
#
CONFIG_XTAL_FREQ_40=y
CONFIG_XTAL_FREQ=40
# end of Main XTAL Config

#
# Power Supplier
#

#
# Brownout Detector
#
CONFIG_ESP_BROWNOUT_DET=y
CONFIG_ESP_BROWNOUT_DET_LVL_SEL_7=y
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_2 is not set
CONFIG_ESP_BROWNOUT_DET_LVL=7
CONFIG_ESP_BROWNOUT_USE_INTR=y
# end of Brownout Detector
# end of Power Supplier

CONFIG_ESP_SPI_BUS_LOCK_ISR_FUNCS_IN_IRAM=y
CONFIG_ESP_INTR_IN_IRAM=y
# end of Hardware Settings

#
# ESP-Driver:LCD Controller Configurations
#
# CONFIG_LCD_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:LCD Controller Configurations

#
# ESP-MM: Memory Management Configurations
#
# end of ESP-MM: Memory Management Configurations

#
# ESP NETIF Adapter
#
CONFIG_ESP_NETIF_IP_LOST_TIMER_INTERVAL=120
# CONFIG_ESP_NETIF_PROVIDE_CUSTOM_IMPLEMENTATION is not set
CONFIG_ESP_NETIF_TCPIP_LWIP=y
# CONFIG_ESP_NETIF_LOOPBACK is not set
CONFIG_ESP_NETIF_USES_TCPIP_WITH_BSD_API=y
CONFIG_ESP_NETIF_REPORT_DATA_TRAFFIC=y
# CONFIG_ESP_NETIF_RECEIVE_REPORT_ERRORS is not set
# CONFIG_ESP_NETIF_L2_TAP is not set
# CONFIG_ESP_NETIF_BRIDGE_EN is not set
# CONFIG_ESP_NETIF_SET_DNS_PER_DEFAULT_NETIF is not set
# end of ESP NETIF Adapter

#
# Partition API Configuration
#
# end of Partition API Configuration

#
# PHY
#
CONFIG_ESP_PHY_ENABLED=y
CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE=y
# CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION is not set
CONFIG_ESP_PHY_MAX_WIFI_TX_POWER=20
CONFIG_ESP_PHY_MAX_TX_POWER=20
# CONFIG_ESP_PHY_REDUCE_TX_POWER is not set
# CONFIG_ESP_PHY_ENABLE_CERT_TEST is not set
CONFIG_ESP_PHY_RF_CAL_PARTIAL=y
# CONFIG_ESP_PHY_RF_CAL_NONE is not set
# CONFIG_ESP_PHY_RF_CAL_FULL is not set
CONFIG_ESP_PHY_CALIBRATION_MODE=0
# CONFIG_ESP_PHY_PLL_TRACK_DEBUG is not set
# CONFIG_ESP_PHY_RECORD_USED_TIME is not set
CONFIG_ESP_PHY_IRAM_OPT=y
# end of PHY

#
# Power Management
#
CONFIG_PM_SLEEP_FUNC_IN_IRAM=y
# CONFIG_PM_ENABLE is not set
CONFIG_PM_SLP_IRAM_OPT=y
CONFIG_PM_SLP_DEFAULT_PARAMS_OPT=y
CONFIG_PM_POWER_DOWN_CPU_IN_LIGHT_SLEEP=y
# CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP is not set
# end of Power Management

#
# ESP PSRAM
#

#
# ESP Ringbuf
#
# CONFIG_RINGBUF_PLACE_FUNCTIONS_INTO_FLASH is not set
# end of ESP Ringbuf

#
# ESP-ROM
#
CONFIG_ESP_ROM_PRINT_IN_IRAM=y
# end of ESP-ROM

#
# ESP Security Specific
#

#
# Crypto DPA Protection
#
CONFIG_ESP_CRYPTO_DPA_PROTECTION_AT_STARTUP=y
CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL_LOW=y
# CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL_MEDIUM is not set
# CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL_HIGH is not set
CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL=1
# end of Crypto DPA Protection
# end of ESP Security Specific

#
# ESP System Settings
#
# CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_80 is not set
# CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_120 is not set
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_160=y
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ=160
# CONFIG_ESP_SYSTEM_PANIC_PRINT_HALT is not set
CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT=y
# CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT is not set
# CONFIG_ESP_SYSTEM_PANIC_GDBSTUB is not set
CONFIG_ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS=0
CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE=y
CONFIG_ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK=y
CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP=y
CONFIG_ESP_SYSTEM_NO_BACKTRACE=y
# CONFIG_ESP_SYSTEM_USE_EH_FRAME is not set
# CONFIG_ESP_SYSTEM_USE_FRAME_POINTER is not set

#
# Memory protection
#
CONFIG_ESP_SYSTEM_PMP_IDRAM_SPLIT=y
# CONFIG_ESP_SYSTEM_PMP_LP_CORE_RESERVE_MEM_EXECUTABLE is not set
# end of Memory protection

CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE=32
CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE=2304
CONFIG_ESP_MAIN_TASK_STACK_SIZE=16384
CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0=y
# CONFIG_ESP_MAIN_TASK_AFFINITY_NO_AFFINITY is not set
CONFIG_ESP_MAIN_TASK_AFFINITY=0x0
CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE=2048
CONFIG_ESP_CONSOLE_UART_DEFAULT=y
# CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG is not set
# CONFIG_ESP_CONSOLE_UART_CUSTOM is not set
# CONFIG_ESP_CONSOLE_NONE is not set
# CONFIG_ESP_CONSOLE_SECONDARY_NONE is not set
CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG=y
CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG_ENABLED=y
CONFIG_ESP_CONSOLE_UART=y
CONFIG_ESP_CONSOLE_UART_NUM=0
CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM=0
CONFIG_ESP_CONSOLE_UART_BAUDRATE=115200
CONFIG_ESP_INT_WDT=y
CONFIG_ESP_INT_WDT_TIMEOUT_MS=300
CONFIG_ESP_TASK_WDT_EN=y
CONFIG_ESP_TASK_WDT_INIT=y
# CONFIG_ESP_TASK_WDT_PANIC is not set
CONFIG_ESP_TASK_WDT_TIMEOUT_S=5
CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0=y
# CONFIG_ESP_PANIC_HANDLER_IRAM is not set
# CONFIG_ESP_DEBUG_STUBS_ENABLE is not set
# CONFIG_ESP_DEBUG_INCLUDE_OCD_STUB_BINS is not set
CONFIG_ESP_DEBUG_OCDAWARE=y
CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4=y
CONFIG_ESP_SYSTEM_HW_STACK_GUARD=y
CONFIG_ESP_SYSTEM_BBPLL_RECALIB=y
CONFIG_ESP_SYSTEM_HW_PC_RECORD=y
# end of ESP System Settings

#
# IPC (Inter-Processor Call)
#
CONFIG_ESP_IPC_TASK_STACK_SIZE=1024
# end of IPC (Inter-Processor Call)

#
# ESP Timer (High Resolution Timer)
#
CONFIG_ESP_TIMER_IN_IRAM=y
# CONFIG_ESP_TIMER_PROFILING is not set
CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER=y
CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER=y
CONFIG_ESP_TIMER_TASK_STACK_SIZE=3584
CONFIG_ESP_TIMER_INTERRUPT_LEVEL=1
# CONFIG_ESP_TIMER_SHOW_EXPERIMENTAL is not set
CONFIG_ESP_TIMER_TASK_AFFINITY=0x0
CONFIG_ESP_TIMER_TASK_AFFINITY_CPU0=y
CONFIG_ESP_TIMER_ISR_AFFINITY_CPU0=y
# CONFIG_ESP_TIMER_SUPPORTS_ISR_DISPATCH_METHOD is not set
CONFIG_ESP_TIMER_IMPL_SYSTIMER=y
# end of ESP Timer (High Resolution Timer)

#
# Wi-Fi
#
CONFIG_ESP_WIFI_ENABLED=y
CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM=10
CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM=32
# CONFIG_ESP_WIFI_STATIC_TX_BUFFER is not set
CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER=y
CONFIG_ESP_WIFI_TX_BUFFER_TYPE=1
CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM=32
CONFIG_ESP_WIFI_STATIC_RX_MGMT_BUFFER=y
# CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUFFER is not set
CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUF=0
CONFIG_ESP_WIFI_RX_MGMT_BUF_NUM_DEF=5
# CONFIG_ESP_WIFI_CSI_ENABLED is not set
CONFIG_ESP_WIFI_AMPDU_TX_ENABLED=y
CONFIG_ESP_WIFI_TX_BA_WIN=6
CONFIG_ESP_WIFI_AMPDU_RX_ENABLED=y
CONFIG_ESP_WIFI_RX_BA_WIN=6
CONFIG_ESP_WIFI_NVS_ENABLED=y
CONFIG_ESP_WIFI_SOFTAP_BEACON_MAX_LEN=752
CONFIG_ESP_WIFI_MGMT_SBUF_NUM=32
CONFIG_ESP_WIFI_IRAM_OPT=y
CONFIG_ESP_WIFI_EXTRA_IRAM_OPT=y
CONFIG_ESP_WIFI_RX_IRAM_OPT=y
CONFIG_ESP_WIFI_ENABLE_WPA3_SAE=y
CONFIG_ESP_WIFI_ENABLE_SAE_PK=y
CONFIG_ESP_WIFI_ENABLE_SAE_H2E=y
CONFIG_ESP_WIFI_SOFTAP_SAE_SUPPORT=y
CONFIG_ESP_WIFI_ENABLE_WPA3_OWE_STA=y
CONFIG_ESP_WIFI_SLP_IRAM_OPT=y
CONFIG_ESP_WIFI_SLP_DEFAULT_MIN_ACTIVE_TIME=50
CONFIG_ESP_WIFI_BSS_MAX_IDLE_SUPPORT=y
CONFIG_ESP_WIFI_SLP_DEFAULT_MAX_ACTIVE_TIME=10
CONFIG_ESP_WIFI_SLP_DEFAULT_WAIT_BROADCAST_DATA_TIME=15
# CONFIG_ESP_WIFI_FTM_ENABLE is not set
CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE=y
# CONFIG_ESP_WIFI_GCMP_SUPPORT is not set
CONFIG_ESP_WIFI_GMAC_SUPPORT=y
CONFIG_ESP_WIFI_SOFTAP_SUPPORT=y
# CONFIG_ESP_WIFI_SLP_BEACON_LOST_OPT is not set
CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM=7
CONFIG_ESP_WIFI_MBEDTLS_CRYPTO=y
CONFIG_ESP_WIFI_MBEDTLS_TLS_CLIENT=y
# CONFIG_ESP_WIFI_WAPI_PSK is not set
# CONFIG_ESP_WIFI_SUITE_B_192 is not set
# CONFIG_ESP_WIFI_11KV_SUPPORT is not set
# CONFIG_ESP_WIFI_MBO_SUPPORT is not set
# CONFIG_ESP_WIFI_DPP_SUPPORT is not set
# CONFIG_ESP_WIFI_11R_SUPPORT is not set
# CONFIG_ESP_WIFI_WPS_SOFTAP_REGISTRAR is not set
# CONFIG_ESP_WIFI_ENABLE_WIFI_TX_STATS is not set
# CONFIG_ESP_WIFI_ENABLE_WIFI_RX_STATS is not set
CONFIG_ESP_WIFI_TX_HETB_QUEUE_NUM=3

#
# WPS Configuration Options
#
# CONFIG_ESP_WIFI_WPS_STRICT is not set
# CONFIG_ESP_WIFI_WPS_PASSPHRASE is not set
# end of WPS Configuration Options

# CONFIG_ESP_WIFI_DEBUG_PRINT is not set
# CONFIG_ESP_WIFI_TESTING_OPTIONS is not set
CONFIG_ESP_WIFI_ENTERPRISE_SUPPORT=y
# CONFIG_ESP_WIFI_ENT_FREE_DYNAMIC_BUFFER is not set
# end of Wi-Fi

#
# Core dump
#
# CONFIG_ESP_COREDUMP_ENABLE_TO_FLASH is not set
# CONFIG_ESP_COREDUMP_ENABLE_TO_UART is not set
CONFIG_ESP_COREDUMP_ENABLE_TO_NONE=y
# end of Core dump

#
# FAT Filesystem support
#
CONFIG_FATFS_VOLUME_COUNT=2
# CONFIG_FATFS_LFN_NONE is not set
CONFIG_FATFS_LFN_HEAP=y
# CONFIG_FATFS_LFN_STACK is not set
# CONFIG_FATFS_SECTOR_512 is not set
CONFIG_FATFS_SECTOR_4096=y
# CONFIG_FATFS_CODEPAGE_DYNAMIC is not set
CONFIG_FATFS_CODEPAGE_437=y
# CONFIG_FATFS_CODEPAGE_720 is not set
# CONFIG_FATFS_CODEPAGE_737 is not set
# CONFIG_FATFS_CODEPAGE_771 is not set
# CONFIG_FATFS_CODEPAGE_775 is not set
# CONFIG_FATFS_CODEPAGE_850 is not set
# CONFIG_FATFS_CODEPAGE_852 is not set
# CONFIG_FATFS_CODEPAGE_855 is not set
# CONFIG_FATFS_CODEPAGE_857 is not set
# CONFIG_FATFS_CODEPAGE_860 is not set
# CONFIG_FATFS_CODEPAGE_861 is not set
# CONFIG_FATFS_CODEPAGE_862 is not set
# CONFIG_FATFS_CODEPAGE_863 is not set
# CONFIG_FATFS_CODEPAGE_864 is not set
# CONFIG_FATFS_CODEPAGE_865 is not set
# CONFIG_FATFS_CODEPAGE_866 is not set
# CONFIG_FATFS_CODEPAGE_869 is not set
# CONFIG_FATFS_CODEPAGE_932 is not set
# CONFIG_FATFS_CODEPAGE_936 is not set
# CONFIG_FATFS_CODEPAGE_949 is not set
# CONFIG_FATFS_CODEPAGE_950 is not set
CONFIG_FATFS_CODEPAGE=437
CONFIG_FATFS_MAX_LFN=255
CONFIG_FATFS_API_ENCODING_ANSI_OEM=y
# CONFIG_FATFS_API_ENCODING_UTF_8 is not set
CONFIG_FATFS_FS_LOCK=0
CONFIG_FATFS_TIMEOUT_MS=10000
CONFIG_FATFS_PER_FILE_CACHE=y
# CONFIG_FATFS_USE_FASTSEEK is not set
CONFIG_FATFS_USE_STRFUNC_NONE=y
# CONFIG_FATFS_USE_STRFUNC_WITHOUT_CRLF_CONV is not set
# CONFIG_FATFS_USE_STRFUNC_WITH_CRLF_CONV is not set
CONFIG_FATFS_VFS_FSTAT_BLKSIZE=0
# CONFIG_FATFS_IMMEDIATE_FSYNC is not set
# CONFIG_FATFS_USE_LABEL is not set
CONFIG_FATFS_LINK_LOCK=y
# CONFIG_FATFS_USE_DYN_BUFFERS is not set

#
# File system free space calculation behavior
#
CONFIG_FATFS_DONT_TRUST_FREE_CLUSTER_CNT=0
CONFIG_FATFS_DONT_TRUST_LAST_ALLOC=0
# end of File system free space calculation behavior
# end of FAT Filesystem support

#
# FreeRTOS
#

#
# Kernel
#
# CONFIG_FREERTOS_SMP is not set
CONFIG_FREERTOS_UNICORE=y
CONFIG_FREERTOS_HZ=100
CONFIG_FREERTOS_OPTIMIZED_SCHEDULER=y
# CONFIG_FREERTOS_CHECK_STACKOVERFLOW_NONE is not set
# CONFIG_FREERTOS_CHECK_STACKOVERFLOW_PTRVAL is not set
CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY=y
CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS=1
CONFIG_FREERTOS_IDLE_TASK_STACKSIZE=1536
# CONFIG_FREERTOS_USE_IDLE_HOOK is not set
# CONFIG_FREERTOS_USE_TICK_HOOK is not set
CONFIG_FREERTOS_MAX_TASK_NAME_LEN=16
# CONFIG_FREERTOS_ENABLE_BACKWARD_COMPATIBILITY is not set
CONFIG_FREERTOS_USE_TIMERS=y
CONFIG_FREERTOS_TIMER_SERVICE_TASK_NAME="Tmr Svc"
# CONFIG_FREERTOS_TIMER_TASK_AFFINITY_CPU0 is not set
CONFIG_FREERTOS_TIMER_TASK_NO_AFFINITY=y
CONFIG_FREERTOS_TIMER_SERVICE_TASK_CORE_AFFINITY=0x7FFFFFFF
CONFIG_FREERTOS_TIMER_TASK_PRIORITY=1
CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH=2048
CONFIG_FREERTOS_TIMER_QUEUE_LENGTH=10
CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE=0
CONFIG_FREERTOS_TASK_NOTIFICATION_ARRAY_ENTRIES=1
# CONFIG_FREERTOS_USE_TRACE_FACILITY is not set
# CONFIG_FREERTOS_USE_LIST_DATA_INTEGRITY_CHECK_BYTES is not set
# CONFIG_FREERTOS_GENERATE_RUN_TIME_STATS is not set
# CONFIG_FREERTOS_USE_APPLICATION_TASK_TAG is not set
# end of Kernel

#
# Port
#
CONFIG_FREERTOS_TASK_FUNCTION_WRAPPER=y
# CONFIG_FREERTOS_WATCHPOINT_END_OF_STACK is not set
CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS=y
# CONFIG_FREERTOS_TASK_PRE_DELETION_HOOK is not set
# CONFIG_FREERTOS_ENABLE_STATIC_TASK_CLEAN_UP is not set
CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER=y
CONFIG_FREERTOS_ISR_STACKSIZE=1536
CONFIG_FREERTOS_INTERRUPT_BACKTRACE=y
CONFIG_FREERTOS_TICK_SUPPORT_SYSTIMER=y
CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL1=y
# CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL3 is not set
CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER=y
# CONFIG_FREERTOS_PLACE_FUNCTIONS_INTO_FLASH is not set
# CONFIG_FREERTOS_CHECK_PORT_CRITICAL_COMPLIANCE is not set
# end of Port

#
# Extra
#
# end of Extra

CONFIG_FREERTOS_PORT=y
CONFIG_FREERTOS_NO_AFFINITY=0x7FFFFFFF
CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION=y
CONFIG_FREERTOS_DEBUG_OCDAWARE=y
CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT=y
CONFIG_FREERTOS_PLACE_SNAPSHOT_FUNS_INTO_FLASH=y
CONFIG_FREERTOS_NUMBER_OF_CORES=1
CONFIG_FREERTOS_IN_IRAM=y
# end of FreeRTOS

#
# Hardware Abstraction Layer (HAL) and Low Level (LL)
#
CONFIG_HAL_ASSERTION_EQUALS_SYSTEM=y
# CONFIG_HAL_ASSERTION_DISABLE is not set
# CONFIG_HAL_ASSERTION_SILENT is not set
# CONFIG_HAL_ASSERTION_ENABLE is not set
CONFIG_HAL_DEFAULT_ASSERTION_LEVEL=2
CONFIG_HAL_SYSTIMER_USE_ROM_IMPL=y
CONFIG_HAL_WDT_USE_ROM_IMPL=y
# end of Hardware Abstraction Layer (HAL) and Low Level (LL)

#
# Heap memory debugging
#
CONFIG_HEAP_POISONING_DISABLED=y
# CONFIG_HEAP_POISONING_LIGHT is not set
# CONFIG_HEAP_POISONING_COMPREHENSIVE is not set
CONFIG_HEAP_TRACING_OFF=y
# CONFIG_HEAP_TRACING_STANDALONE is not set
# CONFIG_HEAP_TRACING_TOHOST is not set
# CONFIG_HEAP_USE_HOOKS is not set
# CONFIG_HEAP_TASK_TRACKING is not set
# CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS is not set
CONFIG_HEAP_TLSF_USE_ROM_IMPL=y
# CONFIG_HEAP_PLACE_FUNCTION_INTO_FLASH is not set
# end of Heap memory debugging

#
# IEEE 802.15.4
#
CONFIG_IEEE802154_ENABLED=y
CONFIG_IEEE802154_RX_BUFFER_SIZE=20
# CONFIG_IEEE802154_CCA_CARRIER is not set
CONFIG_IEEE802154_CCA_ED=y
# CONFIG_IEEE802154_CCA_CARRIER_OR_ED is not set
# CONFIG_IEEE802154_CCA_CARRIER_AND_ED is not set
CONFIG_IEEE802154_CCA_MODE=1
CONFIG_IEEE802154_CCA_THRESHOLD=-60
CONFIG_IEEE802154_PENDING_TABLE_SIZE=20
# CONFIG_IEEE802154_MULTI_PAN_ENABLE is not set
CONFIG_IEEE802154_TIMING_OPTIMIZATION=y
# CONFIG_IEEE802154_DEBUG is not set
# CONFIG_IEEE802154_DEBUG_ASSERT_MONITOR is not set
# end of IEEE 802.15.4

#
# Log
#
CONFIG_LOG_VERSION_1=y
# CONFIG_LOG_VERSION_2 is not set
CONFIG_LOG_VERSION=1

#
# Log Level
#
# CONFIG_LOG_DEFAULT_LEVEL_NONE is not set
# CONFIG_LOG_DEFAULT_LEVEL_ERROR is not set
# CONFIG_LOG_DEFAULT_LEVEL_WARN is not set
CONFIG_LOG_DEFAULT_LEVEL_INFO=y
# CONFIG_LOG_DEFAULT_LEVEL_DEBUG is not set
# CONFIG_LOG_DEFAULT_LEVEL_VERBOSE is not set
CONFIG_LOG_DEFAULT_LEVEL=3
CONFIG_LOG_MAXIMUM_EQUALS_DEFAULT=y
# CONFIG_LOG_MAXIMUM_LEVEL_DEBUG is not set
# CONFIG_LOG_MAXIMUM_LEVEL_VERBOSE is not set
CONFIG_LOG_MAXIMUM_LEVEL=3

#
# Level Settings
#
# CONFIG_LOG_MASTER_LEVEL is not set
CONFIG_LOG_DYNAMIC_LEVEL_CONTROL=y
# CONFIG_LOG_TAG_LEVEL_IMPL_NONE is not set
# CONFIG_LOG_TAG_LEVEL_IMPL_LINKED_LIST is not set
CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_AND_LINKED_LIST=y
# CONFIG_LOG_TAG_LEVEL_CACHE_ARRAY is not set
CONFIG_LOG_TAG_LEVEL_CACHE_BINARY_MIN_HEAP=y
CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_SIZE=31
# end of Level Settings
# end of Log Level

#
# Format
#
# CONFIG_LOG_COLORS is not set
CONFIG_LOG_TIMESTAMP_SOURCE_RTOS=y
# CONFIG_LOG_TIMESTAMP_SOURCE_SYSTEM is not set
# end of Format

#
# Settings
#
CONFIG_LOG_MODE_TEXT_EN=y
CONFIG_LOG_MODE_TEXT=y
# end of Settings

CONFIG_LOG_IN_IRAM=y
# end of Log

#
# LWIP
#
CONFIG_LWIP_ENABLE=y
CONFIG_LWIP_LOCAL_HOSTNAME="espressif"
CONFIG_LWIP_TCPIP_TASK_PRIO=2
# CONFIG_LWIP_TCPIP_CORE_LOCKING is not set
# CONFIG_LWIP_CHECK_THREAD_SAFETY is not set
CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES=y
# CONFIG_LWIP_L2_TO_L3_COPY is not set
# CONFIG_LWIP_IRAM_OPTIMIZATION is not set
# CONFIG_LWIP_EXTRA_IRAM_OPTIMIZATION is not set
CONFIG_LWIP_TIMERS_ONDEMAND=y
CONFIG_LWIP_ND6=y
# CONFIG_LWIP_FORCE_ROUTER_FORWARDING is not set
CONFIG_LWIP_MAX_SOCKETS=10
# CONFIG_LWIP_USE_ONLY_LWIP_SELECT is not set
# CONFIG_LWIP_SO_LINGER is not set
CONFIG_LWIP_SO_REUSE=y
CONFIG_LWIP_SO_REUSE_RXTOALL=y
# CONFIG_LWIP_SO_RCVBUF is not set
# CONFIG_LWIP_NETBUF_RECVINFO is not set
CONFIG_LWIP_IP_DEFAULT_TTL=64
CONFIG_LWIP_IP4_FRAG=y
CONFIG_LWIP_IP6_FRAG=y
# CONFIG_LWIP_IP4_REASSEMBLY is not set
# CONFIG_LWIP_IP6_REASSEMBLY is not set
CONFIG_LWIP_IP_REASS_MAX_PBUFS=10
# CONFIG_LWIP_IP_FORWARD is not set
# CONFIG_LWIP_STATS is not set
CONFIG_LWIP_ESP_GRATUITOUS_ARP=y
CONFIG_LWIP_GARP_TMR_INTERVAL=60
CONFIG_LWIP_ESP_MLDV6_REPORT=y
CONFIG_LWIP_MLDV6_TMR_INTERVAL=40
CONFIG_LWIP_TCPIP_RECVMBOX_SIZE=32
CONFIG_LWIP_DHCP_DOES_ARP_CHECK=y
# CONFIG_LWIP_DHCP_DOES_ACD_CHECK is not set
# CONFIG_LWIP_DHCP_DOES_NOT_CHECK_OFFERED_IP is not set
# CONFIG_LWIP_DHCP_DISABLE_CLIENT_ID is not set
CONFIG_LWIP_DHCP_DISABLE_VENDOR_CLASS_ID=y
# CONFIG_LWIP_DHCP_RESTORE_LAST_IP is not set
CONFIG_LWIP_DHCP_OPTIONS_LEN=68
CONFIG_LWIP_NUM_NETIF_CLIENT_DATA=0
CONFIG_LWIP_DHCP_COARSE_TIMER_SECS=1

#
# DHCP server
#
CONFIG_LWIP_DHCPS=y
CONFIG_LWIP_DHCPS_LEASE_UNIT=60
CONFIG_LWIP_DHCPS_MAX_STATION_NUM=8
CONFIG_LWIP_DHCPS_STATIC_ENTRIES=y
CONFIG_LWIP_DHCPS_ADD_DNS=y
# end of DHCP server

# CONFIG_LWIP_AUTOIP is not set
CONFIG_LWIP_IPV4=y
CONFIG_LWIP_IPV6=y
# CONFIG_LWIP_IPV6_AUTOCONFIG is not set
CONFIG_LWIP_IPV6_NUM_ADDRESSES=3
# CONFIG_LWIP_IPV6_FORWARD is not set
# CONFIG_LWIP_NETIF_STATUS_CALLBACK is not set
CONFIG_LWIP_NETIF_LOOPBACK=y
CONFIG_LWIP_LOOPBACK_MAX_PBUFS=8

#
# TCP
#
CONFIG_LWIP_MAX_ACTIVE_TCP=16
CONFIG_LWIP_MAX_LISTENING_TCP=16
CONFIG_LWIP_TCP_HIGH_SPEED_RETRANSMISSION=y
CONFIG_LWIP_TCP_MAXRTX=12
CONFIG_LWIP_TCP_SYNMAXRTX=12
CONFIG_LWIP_TCP_MSS=1440
CONFIG_LWIP_TCP_TMR_INTERVAL=250
CONFIG_LWIP_TCP_MSL=60000
CONFIG_LWIP_TCP_FIN_WAIT_TIMEOUT=20000
CONFIG_LWIP_TCP_SND_BUF_DEFAULT=5760
CONFIG_LWIP_TCP_WND_DEFAULT=5760
CONFIG_LWIP_TCP_RECVMBOX_SIZE=6
CONFIG_LWIP_TCP_ACCEPTMBOX_SIZE=6
CONFIG_LWIP_TCP_QUEUE_OOSEQ=y
CONFIG_LWIP_TCP_OOSEQ_TIMEOUT=6
CONFIG_LWIP_TCP_OOSEQ_MAX_PBUFS=4
# CONFIG_LWIP_TCP_SACK_OUT is not set
CONFIG_LWIP_TCP_OVERSIZE_MSS=y
# CONFIG_LWIP_TCP_OVERSIZE_QUARTER_MSS is not set
# CONFIG_LWIP_TCP_OVERSIZE_DISABLE is not set
CONFIG_LWIP_TCP_RTO_TIME=1500
# end of TCP

#
# UDP
#
CONFIG_LWIP_MAX_UDP_PCBS=16
CONFIG_LWIP_UDP_RECVMBOX_SIZE=6
# end of UDP

#
# Checksums
#
# CONFIG_LWIP_CHECKSUM_CHECK_IP is not set
# CONFIG_LWIP_CHECKSUM_CHECK_UDP is not set
CONFIG_LWIP_CHECKSUM_CHECK_ICMP=y
# end of Checksums

CONFIG_LWIP_TCPIP_TASK_STACK_SIZE=3072
CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY=y
# CONFIG_LWIP_TCPIP_TASK_AFFINITY_CPU0 is not set
CONFIG_LWIP_TCPIP_TASK_AFFINITY=0x7FFFFFFF
CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE=3
CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS=5
CONFIG_LWIP_IPV6_ND6_NUM_PREFIXES=5
CONFIG_LWIP_IPV6_ND6_NUM_ROUTERS=3
CONFIG_LWIP_IPV6_ND6_NUM_DESTINATIONS=10
# CONFIG_LWIP_PPP_SUPPORT is not set
# CONFIG_LWIP_SLIP_SUPPORT is not set

#
# ICMP
#
CONFIG_LWIP_ICMP=y
# CONFIG_LWIP_MULTICAST_PING is not set
# CONFIG_LWIP_BROADCAST_PING is not set
# end of ICMP

#
# LWIP RAW API
#
CONFIG_LWIP_MAX_RAW_PCBS=16
# end of LWIP RAW API

#
# SNTP
#
CONFIG_LWIP_SNTP_MAX_SERVERS=1
# CONFIG_LWIP_DHCP_GET_NTP_SRV is not set
CONFIG_LWIP_SNTP_UPDATE_DELAY=3600000
CONFIG_LWIP_SNTP_STARTUP_DELAY=y
CONFIG_LWIP_SNTP_MAXIMUM_STARTUP_DELAY=5000
# end of SNTP

#
# DNS
#
CONFIG_LWIP_DNS_MAX_HOST_IP=1
CONFIG_LWIP_DNS_MAX_SERVERS=3
# CONFIG_LWIP_FALLBACK_DNS_SERVER_SUPPORT is not set
# CONFIG_LWIP_DNS_SETSERVER_WITH_NETIF is not set
# CONFIG_LWIP_USE_ESP_GETADDRINFO is not set
# end of DNS

CONFIG_LWIP_BRIDGEIF_MAX_PORTS=7
CONFIG_LWIP_ESP_LWIP_ASSERT=y

#
# Hooks
#
# CONFIG_LWIP_HOOK_TCP_ISN_NONE is not set
CONFIG_LWIP_HOOK_TCP_ISN_DEFAULT=y
# CONFIG_LWIP_HOOK_TCP_ISN_CUSTOM is not set
CONFIG_LWIP_HOOK_IP6_ROUTE_NONE=y
# CONFIG_LWIP_HOOK_IP6_ROUTE_DEFAULT is not set
# CONFIG_LWIP_HOOK_IP6_ROUTE_CUSTOM is not set
CONFIG_LWIP_HOOK_ND6_GET_GW_NONE=y
# CONFIG_LWIP_HOOK_ND6_GET_GW_DEFAULT is not set
# CONFIG_LWIP_HOOK_ND6_GET_GW_CUSTOM is not set
CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_NONE=y
# CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_DEFAULT is not set
# CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_CUSTOM is not set
CONFIG_LWIP_HOOK_DHCP_EXTRA_OPTION_NONE=y
# CONFIG_LWIP_HOOK_DHCP_EXTRA_OPTION_DEFAULT is not set
# CONFIG_LWIP_HOOK_DHCP_EXTRA_OPTION_CUSTOM is not set
CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_NONE=y
# CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_DEFAULT is not set
# CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_CUSTOM is not set
CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_NONE=y
# CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_CUSTOM is not set
# CONFIG_LWIP_HOOK_IP6_INPUT_NONE is not set
CONFIG_LWIP_HOOK_IP6_INPUT_DEFAULT=y
# CONFIG_LWIP_HOOK_IP6_INPUT_CUSTOM is not set
# end of Hooks

# CONFIG_LWIP_DEBUG is not set
# end of LWIP

#
# mbedTLS
#
CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC=y
# CONFIG_MBEDTLS_DEFAULT_MEM_ALLOC is not set
# CONFIG_MBEDTLS_CUSTOM_MEM_ALLOC is not set
CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN=y
CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN=16384
CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN=4096
# CONFIG_MBEDTLS_DYNAMIC_BUFFER is not set
# CONFIG_MBEDTLS_DEBUG is not set

#
# mbedTLS v3.x related
#
# CONFIG_MBEDTLS_SSL_PROTO_TLS1_3 is not set
# CONFIG_MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH is not set
# CONFIG_MBEDTLS_X509_TRUSTED_CERT_CALLBACK is not set
# CONFIG_MBEDTLS_SSL_CONTEXT_SERIALIZATION is not set
CONFIG_MBEDTLS_SSL_KEEP_PEER_CERTIFICATE=y
CONFIG_MBEDTLS_PKCS7_C=y
# end of mbedTLS v3.x related

#
# Certificate Bundle
#
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE=y
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL=y
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_CMN is not set
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_NONE is not set
# CONFIG_MBEDTLS_CUSTOM_CERTIFICATE_BUNDLE is not set
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEPRECATED_LIST is not set
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_MAX_CERTS=200
# end of Certificate Bundle

# CONFIG_MBEDTLS_ECP_RESTARTABLE is not set
CONFIG_MBEDTLS_CMAC_C=y
CONFIG_MBEDTLS_HARDWARE_AES=y
CONFIG_MBEDTLS_AES_USE_INTERRUPT=y
CONFIG_MBEDTLS_AES_INTERRUPT_LEVEL=0
CONFIG_MBEDTLS_GCM_SUPPORT_NON_AES_CIPHER=y
CONFIG_MBEDTLS_HARDWARE_MPI=y
CONFIG_MBEDTLS_LARGE_KEY_SOFTWARE_MPI=y
CONFIG_MBEDTLS_MPI_USE_INTERRUPT=y
CONFIG_MBEDTLS_MPI_INTERRUPT_LEVEL=0
CONFIG_MBEDTLS_HARDWARE_SHA=y
CONFIG_MBEDTLS_HARDWARE_ECC=y
CONFIG_MBEDTLS_ECC_OTHER_CURVES_SOFT_FALLBACK=y
CONFIG_MBEDTLS_ROM_MD5=y
# CONFIG_MBEDTLS_ATCA_HW_ECDSA_SIGN is not set
# CONFIG_MBEDTLS_ATCA_HW_ECDSA_VERIFY is not set
CONFIG_MBEDTLS_HAVE_TIME=y
# CONFIG_MBEDTLS_PLATFORM_TIME_ALT is not set
# CONFIG_MBEDTLS_HAVE_TIME_DATE is not set
CONFIG_MBEDTLS_ECDSA_DETERMINISTIC=y
CONFIG_MBEDTLS_SHA1_C=y
CONFIG_MBEDTLS_SHA512_C=y
# CONFIG_MBEDTLS_SHA3_C is not set
CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT=y
# CONFIG_MBEDTLS_TLS_SERVER_ONLY is not set
# CONFIG_MBEDTLS_TLS_CLIENT_ONLY is not set
# CONFIG_MBEDTLS_TLS_DISABLED is not set
CONFIG_MBEDTLS_TLS_SERVER=y
CONFIG_MBEDTLS_TLS_CLIENT=y
CONFIG_MBEDTLS_TLS_ENABLED=y

#
# TLS Key Exchange Methods
#
# CONFIG_MBEDTLS_PSK_MODES is not set
CONFIG_MBEDTLS_KEY_EXCHANGE_RSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA=y
# end of TLS Key Exchange Methods

CONFIG_MBEDTLS_SSL_RENEGOTIATION=y
CONFIG_MBEDTLS_SSL_PROTO_TLS1_2=y
# CONFIG_MBEDTLS_SSL_PROTO_GMTSSL1_1 is not set
# CONFIG_MBEDTLS_SSL_PROTO_DTLS is not set
CONFIG_MBEDTLS_SSL_ALPN=y
CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS=y
CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS=y

#
# Symmetric Ciphers
#
CONFIG_MBEDTLS_AES_C=y
# CONFIG_MBEDTLS_CAMELLIA_C is not set
# CONFIG_MBEDTLS_DES_C is not set
# CONFIG_MBEDTLS_BLOWFISH_C is not set
# CONFIG_MBEDTLS_XTEA_C is not set
CONFIG_MBEDTLS_CCM_C=y
CONFIG_MBEDTLS_GCM_C=y
# CONFIG_MBEDTLS_NIST_KW_C is not set
# end of Symmetric Ciphers

# CONFIG_MBEDTLS_RIPEMD160_C is not set

#
# Certificates
#
CONFIG_MBEDTLS_PEM_PARSE_C=y
CONFIG_MBEDTLS_PEM_WRITE_C=y
CONFIG_MBEDTLS_X509_CRL_PARSE_C=y
CONFIG_MBEDTLS_X509_CSR_PARSE_C=y
# end of Certificates

CONFIG_MBEDTLS_ECP_C=y
CONFIG_MBEDTLS_PK_PARSE_EC_EXTENDED=y
CONFIG_MBEDTLS_PK_PARSE_EC_COMPRESSED=y
# CONFIG_MBEDTLS_DHM_C is not set
CONFIG_MBEDTLS_ECDH_C=y
CONFIG_MBEDTLS_ECDSA_C=y
# CONFIG_MBEDTLS_ECJPAKE_C is not set
CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED=y
CONFIG_MBEDTLS_ECP_NIST_OPTIM=y
# CONFIG_MBEDTLS_ECP_FIXED_POINT_OPTIM is not set
# CONFIG_MBEDTLS_POLY1305_C is not set
# CONFIG_MBEDTLS_CHACHA20_C is not set
# CONFIG_MBEDTLS_HKDF_C is not set
# CONFIG_MBEDTLS_THREADING_C is not set
CONFIG_MBEDTLS_ERROR_STRINGS=y
CONFIG_MBEDTLS_FS_IO=y
# CONFIG_MBEDTLS_ALLOW_WEAK_CERTIFICATE_VERIFICATION is not set
# end of mbedTLS

#
# ESP-MQTT Configurations
#
CONFIG_MQTT_PROTOCOL_311=y
# CONFIG_MQTT_PROTOCOL_5 is not set
CONFIG_MQTT_TRANSPORT_SSL=y
CONFIG_MQTT_TRANSPORT_WEBSOCKET=y
CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE=y
# CONFIG_MQTT_MSG_ID_INCREMENTAL is not set
# CONFIG_MQTT_SKIP_PUBLISH_IF_DISCONNECTED is not set
# CONFIG_MQTT_REPORT_DELETED_MESSAGES is not set
# CONFIG_MQTT_USE_CUSTOM_CONFIG is not set
# CONFIG_MQTT_TASK_CORE_SELECTION_ENABLED is not set
# CONFIG_MQTT_CUSTOM_OUTBOX is not set
# end of ESP-MQTT Configurations

#
# LibC
#
CONFIG_LIBC_NEWLIB=y
CONFIG_LIBC_MISC_IN_IRAM=y
CONFIG_LIBC_LOCKS_PLACE_IN_IRAM=y
CONFIG_LIBC_STDOUT_LINE_ENDING_CRLF=y
# CONFIG_LIBC_STDOUT_LINE_ENDING_LF is not set
# CONFIG_LIBC_STDOUT_LINE_ENDING_CR is not set
# CONFIG_LIBC_STDIN_LINE_ENDING_CRLF is not set
# CONFIG_LIBC_STDIN_LINE_ENDING_LF is not set
CONFIG_LIBC_STDIN_LINE_ENDING_CR=y
# CONFIG_LIBC_NEWLIB_NANO_FORMAT is not set
CONFIG_LIBC_TIME_SYSCALL_USE_RTC_HRT=y
# CONFIG_LIBC_TIME_SYSCALL_USE_RTC is not set
# CONFIG_LIBC_TIME_SYSCALL_USE_HRT is not set
# CONFIG_LIBC_TIME_SYSCALL_USE_NONE is not set
# CONFIG_LIBC_OPTIMIZED_MISALIGNED_ACCESS is not set
# end of LibC

#
# NVS
#
# CONFIG_NVS_ENCRYPTION is not set
# CONFIG_NVS_ASSERT_ERROR_CHECK is not set
# CONFIG_NVS_LEGACY_DUP_KEYS_COMPATIBILITY is not set
# end of NVS

#
# OpenThread
#
# CONFIG_OPENTHREAD_ENABLED is not set

#
# OpenThread Spinel
#
# CONFIG_OPENTHREAD_SPINEL_ONLY is not set
# end of OpenThread Spinel
# end of OpenThread

#
# Protocomm
#
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_0=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_1=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_2=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_PATCH_VERSION=y
# end of Protocomm

#
# PThreads
#
CONFIG_PTHREAD_TASK_PRIO_DEFAULT=5
CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT=3072
CONFIG_PTHREAD_STACK_MIN=768
CONFIG_PTHREAD_TASK_CORE_DEFAULT=-1
CONFIG_PTHREAD_TASK_NAME_DEFAULT="pthread"
# end of PThreads

#
# MMU Config
#
CONFIG_MMU_PAGE_SIZE_64KB=y
CONFIG_MMU_PAGE_MODE="64KB"
CONFIG_MMU_PAGE_SIZE=0x10000
# end of MMU Config

#
# Main Flash configuration
#

#
# SPI Flash behavior when brownout
#
CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC=y
CONFIG_SPI_FLASH_BROWNOUT_RESET=y
# end of SPI Flash behavior when brownout

#
# Optional and Experimental Features (READ DOCS FIRST)
#

#
# Features here require specific hardware (READ DOCS FIRST!)
#
# CONFIG_SPI_FLASH_AUTO_SUSPEND is not set
CONFIG_SPI_FLASH_SUSPEND_TSUS_VAL_US=50
# CONFIG_SPI_FLASH_FORCE_ENABLE_XMC_C_SUSPEND is not set
# CONFIG_SPI_FLASH_FORCE_ENABLE_C6_H2_SUSPEND is not set
CONFIG_SPI_FLASH_PLACE_FUNCTIONS_IN_IRAM=y
# end of Optional and Experimental Features (READ DOCS FIRST)
# end of Main Flash configuration

#
# SPI Flash driver
#
# CONFIG_SPI_FLASH_VERIFY_WRITE is not set
# CONFIG_SPI_FLASH_ENABLE_COUNTERS is not set
CONFIG_SPI_FLASH_ROM_DRIVER_PATCH=y
# CONFIG_SPI_FLASH_ROM_IMPL is not set
CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS=y
# CONFIG_SPI_FLASH_DANGEROUS_WRITE_FAILS is not set
# CONFIG_SPI_FLASH_DANGEROUS_WRITE_ALLOWED is not set
# CONFIG_SPI_FLASH_BYPASS_BLOCK_ERASE is not set
CONFIG_SPI_FLASH_YIELD_DURING_ERASE=y
CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS=20
CONFIG_SPI_FLASH_ERASE_YIELD_TICKS=1
CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE=8192
# CONFIG_SPI_FLASH_SIZE_OVERRIDE is not set
# CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED is not set
# CONFIG_SPI_FLASH_OVERRIDE_CHIP_DRIVER_LIST is not set

#
# Auto-detect flash chips
#
CONFIG_SPI_FLASH_VENDOR_XMC_SUPPORTED=y
# CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_MXIC_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_GD_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_WINBOND_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_BOYA_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_TH_CHIP is not set
# end of Auto-detect flash chips

CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE=y
# end of SPI Flash driver

#
# SPIFFS Configuration
#
CONFIG_SPIFFS_MAX_PARTITIONS=3

#
# SPIFFS Cache Configuration
#
CONFIG_SPIFFS_CACHE=y
CONFIG_SPIFFS_CACHE_WR=y
# CONFIG_SPIFFS_CACHE_STATS is not set
# end of SPIFFS Cache Configuration

CONFIG_SPIFFS_PAGE_CHECK=y
CONFIG_SPIFFS_GC_MAX_RUNS=10
# CONFIG_SPIFFS_GC_STATS is not set
CONFIG_SPIFFS_PAGE_SIZE=256
CONFIG_SPIFFS_OBJ_NAME_LEN=32
# CONFIG_SPIFFS_FOLLOW_SYMLINKS is not set
CONFIG_SPIFFS_USE_MAGIC=y
CONFIG_SPIFFS_USE_MAGIC_LENGTH=y
CONFIG_SPIFFS_META_LENGTH=4
CONFIG_SPIFFS_USE_MTIME=y

#
# Debug Configuration
#
# CONFIG_SPIFFS_DBG is not set
# CONFIG_SPIFFS_API_DBG is not set
# CONFIG_SPIFFS_GC_DBG is not set
# CONFIG_SPIFFS_CACHE_DBG is not set
# CONFIG_SPIFFS_CHECK_DBG is not set
# CONFIG_SPIFFS_TEST_VISUALISATION is not set
# end of Debug Configuration
# end of SPIFFS Configuration

#
# TCP Transport
#

#
# Websocket
#
CONFIG_WS_TRANSPORT=y
CONFIG_WS_BUFFER_SIZE=1024
# CONFIG_WS_DYNAMIC_BUFFER is not set
# end of Websocket
# end of TCP Transport

#
# Ultra Low Power (ULP) Co-processor
#
# CONFIG_ULP_COPROC_ENABLED is not set

#
# ULP Debugging Options
#
# end of ULP Debugging Options
# end of Ultra Low Power (ULP) Co-processor

#
# Unity unit testing library
#
CONFIG_UNITY_ENABLE_FLOAT=y
CONFIG_UNITY_ENABLE_DOUBLE=y
# CONFIG_UNITY_ENABLE_64BIT is not set
# CONFIG_UNITY_ENABLE_COLOR is not set
CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER=y
# CONFIG_UNITY_ENABLE_FIXTURE is not set
# CONFIG_UNITY_ENABLE_BACKTRACE_ON_FAIL is not set
# CONFIG_UNITY_TEST_ORDER_BY_FILE_PATH_AND_LINE is not set
# end of Unity unit testing library

#
# Virtual file system
#
CONFIG_VFS_SUPPORT_IO=y
CONFIG_VFS_SUPPORT_DIR=y
CONFIG_VFS_SUPPORT_SELECT=y
CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT=y
# CONFIG_VFS_SELECT_IN_RAM is not set
CONFIG_VFS_SUPPORT_TERMIOS=y
CONFIG_VFS_MAX_COUNT=8

#
# Host File System I/O (Semihosting)
#
CONFIG_VFS_SEMIHOSTFS_MAX_MOUNT_POINTS=1
# end of Host File System I/O (Semihosting)

CONFIG_VFS_INITIALIZE_DEV_NULL=y
# end of Virtual file system

#
# Wear Levelling
#
# CONFIG_WL_SECTOR_SIZE_512 is not set
CONFIG_WL_SECTOR_SIZE_4096=y
CONFIG_WL_SECTOR_SIZE=4096
# end of Wear Levelling

#
# Wi-Fi Provisioning Manager
#
CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES=16
CONFIG_WIFI_PROV_AUTOSTOP_TIMEOUT=30
CONFIG_WIFI_PROV_STA_ALL_CHANNEL_SCAN=y
# CONFIG_WIFI_PROV_STA_FAST_SCAN is not set
# end of Wi-Fi Provisioning Manager

#
# ESP LCD TOUCH
#
CONFIG_ESP_LCD_TOUCH_MAX_POINTS=5
CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS=1
# end of ESP LCD TOUCH

#
# ESP LVGL PORT
#
# end of ESP LVGL PORT

#
# CMake Utilities
#
# CONFIG_CU_RELINKER_ENABLE is not set
# CONFIG_CU_DIAGNOSTICS_COLOR_NEVER is not set
CONFIG_CU_DIAGNOSTICS_COLOR_ALWAYS=y
# CONFIG_CU_DIAGNOSTICS_COLOR_AUTO is not set
# CONFIG_CU_GCC_LTO_ENABLE is not set
# CONFIG_CU_GCC_STRING_1BYTE_ALIGN is not set
# end of CMake Utilities

#
# LVGL configuration
#
CONFIG_LV_CONF_SKIP=y
# CONFIG_LV_CONF_MINIMAL is not set

#
# Color Settings
#
# CONFIG_LV_COLOR_DEPTH_32 is not set
# CONFIG_LV_COLOR_DEPTH_24 is not set
CONFIG_LV_COLOR_DEPTH_16=y
# CONFIG_LV_COLOR_DEPTH_8 is not set
# CONFIG_LV_COLOR_DEPTH_1 is not set
CONFIG_LV_COLOR_DEPTH=16
# end of Color Settings

#
# Memory Settings
#
CONFIG_LV_USE_BUILTIN_MALLOC=y
# CONFIG_LV_USE_CLIB_MALLOC is not set
# CONFIG_LV_USE_MICROPYTHON_MALLOC is not set
# CONFIG_LV_USE_RTTHREAD_MALLOC is not set
# CONFIG_LV_USE_CUSTOM_MALLOC is not set
CONFIG_LV_USE_BUILTIN_STRING=y
# CONFIG_LV_USE_CLIB_STRING is not set
# CONFIG_LV_USE_CUSTOM_STRING is not set
CONFIG_LV_USE_BUILTIN_SPRINTF=y
# CONFIG_LV_USE_CLIB_SPRINTF is not set
# CONFIG_LV_USE_CUSTOM_SPRINTF is not set
CONFIG_LV_MEM_SIZE_KILOBYTES=64
CONFIG_LV_MEM_POOL_EXPAND_SIZE_KILOBYTES=0
CONFIG_LV_MEM_ADR=0x0
# end of Memory Settings

#
# HAL Settings
#
CONFIG_LV_DEF_REFR_PERIOD=33
CONFIG_LV_DPI_DEF=130
# end of HAL Settings

#
# Operating System (OS)
#
CONFIG_LV_OS_NONE=y
# CONFIG_LV_OS_PTHREAD is not set
# CONFIG_LV_OS_FREERTOS is not set
# CONFIG_LV_OS_CMSIS_RTOS2 is not set
# CONFIG_LV_OS_RTTHREAD is not set
# CONFIG_LV_OS_WINDOWS is not set
# CONFIG_LV_OS_CUSTOM is not set
CONFIG_LV_USE_OS=0
# end of Operating System (OS)

#
# Rendering Configuration
#
CONFIG_LV_DRAW_BUF_STRIDE_ALIGN=1
CONFIG_LV_DRAW_BUF_ALIGN=4
CONFIG_LV_DRAW_LAYER_SIMPLE_BUF_SIZE=24576
CONFIG_LV_USE_DRAW_SW=y
CONFIG_LV_DRAW_SW_DRAW_UNIT_CNT=1
# CONFIG_LV_USE_DRAW_ARM2D_SYNC is not set
CONFIG_LV_USE_NATIVE_HELIUM_ASM=y
CONFIG_LV_DRAW_SW_COMPLEX=y
CONFIG_LV_DRAW_SW_SHADOW_CACHE_SIZE=0
CONFIG_LV_DRAW_SW_CIRCLE_CACHE_SIZE=4
CONFIG_LV_DRAW_SW_ASM_NONE=y
# CONFIG_LV_DRAW_SW_ASM_NEON is not set
# CONFIG_LV_DRAW_SW_ASM_HELIUM is not set
# CONFIG_LV_DRAW_SW_ASM_CUSTOM is not set
CONFIG_LV_USE_DRAW_SW_ASM=0
# CONFIG_LV_USE_DRAW_VGLITE is not set
# CONFIG_LV_USE_DRAW_PXP is not set
# CONFIG_LV_USE_DRAW_DAVE2D is not set
# CONFIG_LV_USE_DRAW_SDL is not set
# CONFIG_LV_USE_DRAW_VG_LITE is not set
# CONFIG_LV_USE_VECTOR_GRAPHIC is not set
# end of Rendering Configuration

#
# Feature Configuration
#

#
# Logging
#
# CONFIG_LV_USE_LOG is not set
# end of Logging

#
# Asserts
#
CONFIG_LV_USE_ASSERT_NULL=y
CONFIG_LV_USE_ASSERT_MALLOC=y
# CONFIG_LV_USE_ASSERT_STYLE is not set
# CONFIG_LV_USE_ASSERT_MEM_INTEGRITY is not set
# CONFIG_LV_USE_ASSERT_OBJ is not set
CONFIG_LV_ASSERT_HANDLER_INCLUDE="assert.h"
# end of Asserts

#
# Debug
#
# CONFIG_LV_USE_REFR_DEBUG is not set
# CONFIG_LV_USE_LAYER_DEBUG is not set
# CONFIG_LV_USE_PARALLEL_DRAW_DEBUG is not set
# end of Debug

#
# Others
#
# CONFIG_LV_ENABLE_GLOBAL_CUSTOM is not set
CONFIG_LV_CACHE_DEF_SIZE=0
CONFIG_LV_IMAGE_HEADER_CACHE_DEF_CNT=0
CONFIG_LV_GRADIENT_MAX_STOPS=2
CONFIG_LV_COLOR_MIX_ROUND_OFS=128
# CONFIG_LV_OBJ_STYLE_CACHE is not set
# CONFIG_LV_USE_OBJ_ID is not set
# CONFIG_LV_USE_OBJ_ID_BUILTIN is not set
# CONFIG_LV_USE_OBJ_PROPERTY is not set
# end of Others
# end of Feature Configuration

#
# Compiler Settings
#
# CONFIG_LV_BIG_ENDIAN_SYSTEM is not set
CONFIG_LV_ATTRIBUTE_MEM_ALIGN_SIZE=1
# CONFIG_LV_ATTRIBUTE_FAST_MEM_USE_IRAM is not set
# CONFIG_LV_USE_FLOAT is not set
# end of Compiler Settings

#
# Font Usage
#

#
# Enable built-in fonts
#
# CONFIG_LV_FONT_MONTSERRAT_8 is not set
# CONFIG_LV_FONT_MONTSERRAT_10 is not set
# CONFIG_LV_FONT_MONTSERRAT_12 is not set
CONFIG_LV_FONT_MONTSERRAT_14=y
# CONFIG_LV_FONT_MONTSERRAT_16 is not set
# CONFIG_LV_FONT_MONTSERRAT_18 is not set
# CONFIG_LV_FONT_MONTSERRAT_20 is not set
# CONFIG_LV_FONT_MONTSERRAT_22 is not set
# CONFIG_LV_FONT_MONTSERRAT_24 is not set
# CONFIG_LV_FONT_MONTSERRAT_26 is not set
# CONFIG_LV_FONT_MONTSERRAT_28 is not set
# CONFIG_LV_FONT_MONTSERRAT_30 is not set
# CONFIG_LV_FONT_MONTSERRAT_32 is not set
# CONFIG_LV_FONT_MONTSERRAT_34 is not set
# CONFIG_LV_FONT_MONTSERRAT_36 is not set
# CONFIG_LV_FONT_MONTSERRAT_38 is not set
# CONFIG_LV_FONT_MONTSERRAT_40 is not set
# CONFIG_LV_FONT_MONTSERRAT_42 is not set
# CONFIG_LV_FONT_MONTSERRAT_44 is not set
# CONFIG_LV_FONT_MONTSERRAT_46 is not set
# CONFIG_LV_FONT_MONTSERRAT_48 is not set
# CONFIG_LV_FONT_MONTSERRAT_28_COMPRESSED is not set
# CONFIG_LV_FONT_DEJAVU_16_PERSIAN_HEBREW is not set
# CONFIG_LV_FONT_SIMSUN_16_CJK is not set
# CONFIG_LV_FONT_UNSCII_8 is not set
# CONFIG_LV_FONT_UNSCII_16 is not set
# end of Enable built-in fonts

# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_8 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_12 is not set
CONFIG_LV_FONT_DEFAULT_MONTSERRAT_14=y
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_16 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_18 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_20 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_22 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_24 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_26 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_28 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_30 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_32 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_34 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_36 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_38 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_40 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_42 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_44 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_46 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_48 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_28_COMPRESSED is not set
# CONFIG_LV_FONT_DEFAULT_DEJAVU_16_PERSIAN_HEBREW is not set
# CONFIG_LV_FONT_DEFAULT_SIMSUN_16_CJK is not set
# CONFIG_LV_FONT_DEFAULT_UNSCII_8 is not set
# CONFIG_LV_FONT_DEFAULT_UNSCII_16 is not set
# CONFIG_LV_FONT_FMT_TXT_LARGE is not set
# CONFIG_LV_USE_FONT_COMPRESSED is not set
CONFIG_LV_USE_FONT_PLACEHOLDER=y
# end of Font Usage

#
# Text Settings
#
CONFIG_LV_TXT_ENC_UTF8=y
# CONFIG_LV_TXT_ENC_ASCII is not set
CONFIG_LV_TXT_BREAK_CHARS=" ,.;:-_)]}"
CONFIG_LV_TXT_LINE_BREAK_LONG_LEN=0
# CONFIG_LV_USE_BIDI is not set
# CONFIG_LV_USE_ARABIC_PERSIAN_CHARS is not set
# end of Text Settings

#
# Widget Usage
#
CONFIG_LV_WIDGETS_HAS_DEFAULT_VALUE=y
CONFIG_LV_USE_ANIMIMG=y
CONFIG_LV_USE_ARC=y
CONFIG_LV_USE_BAR=y
CONFIG_LV_USE_BUTTON=y
CONFIG_LV_USE_BUTTONMATRIX=y
CONFIG_LV_USE_CALENDAR=y
# CONFIG_LV_CALENDAR_WEEK_STARTS_MONDAY is not set
CONFIG_LV_USE_CALENDAR_HEADER_ARROW=y
CONFIG_LV_USE_CALENDAR_HEADER_DROPDOWN=y
CONFIG_LV_USE_CANVAS=y
CONFIG_LV_USE_CHART=y
CONFIG_LV_USE_CHECKBOX=y
CONFIG_LV_USE_DROPDOWN=y
CONFIG_LV_USE_IMAGE=y
CONFIG_LV_USE_IMAGEBUTTON=y
CONFIG_LV_USE_KEYBOARD=y
CONFIG_LV_USE_LABEL=y
CONFIG_LV_LABEL_TEXT_SELECTION=y
CONFIG_LV_LABEL_LONG_TXT_HINT=y
CONFIG_LV_LABEL_WAIT_CHAR_COUNT=3
CONFIG_LV_USE_LED=y
CONFIG_LV_USE_LINE=y
CONFIG_LV_USE_LIST=y
CONFIG_LV_USE_MENU=y
CONFIG_LV_USE_MSGBOX=y
# CONFIG_LV_USE_OBSERVER is not set
CONFIG_LV_USE_ROLLER=y
CONFIG_LV_USE_SCALE=y
CONFIG_LV_USE_SLIDER=y
CONFIG_LV_USE_SPAN=y
CONFIG_LV_SPAN_SNIPPET_STACK_SIZE=64
CONFIG_LV_USE_SPINBOX=y
CONFIG_LV_USE_SPINNER=y
CONFIG_LV_USE_SWITCH=y
CONFIG_LV_USE_TEXTAREA=y
CONFIG_LV_TEXTAREA_DEF_PWD_SHOW_TIME=1500
CONFIG_LV_USE_TABLE=y
CONFIG_LV_USE_TABVIEW=y
CONFIG_LV_USE_TILEVIEW=y
CONFIG_LV_USE_WIN=y
# end of Widget Usage

#
# Themes
#
CONFIG_LV_USE_THEME_DEFAULT=y
# CONFIG_LV_THEME_DEFAULT_DARK is not set
CONFIG_LV_THEME_DEFAULT_GROW=y
CONFIG_LV_THEME_DEFAULT_TRANSITION_TIME=80
CONFIG_LV_USE_THEME_SIMPLE=y
# CONFIG_LV_USE_THEME_MONO is not set
# end of Themes

#
# Layouts
#
CONFIG_LV_USE_FLEX=y
CONFIG_LV_USE_GRID=y
# end of Layouts

#
# 3rd Party Libraries
#
# CONFIG_LV_USE_FS_STDIO is not set
# CONFIG_LV_USE_FS_POSIX is not set
# CONFIG_LV_USE_FS_WIN32 is not set
# CONFIG_LV_USE_FS_FATFS is not set
# CONFIG_LV_USE_FS_MEMFS is not set
# CONFIG_LV_USE_FS_LITTLEFS is not set
# CONFIG_LV_USE_LODEPNG is not set
# CONFIG_LV_USE_LIBPNG is not set
# CONFIG_LV_USE_BMP is not set
# CONFIG_LV_USE_TJPGD is not set
# CONFIG_LV_USE_LIBJPEG_TURBO is not set
# CONFIG_LV_USE_GIF is not set
# CONFIG_LV_BIN_DECODER_RAM_LOAD is not set
# CONFIG_LV_USE_RLE is not set
# CONFIG_LV_USE_QRCODE is not set
# CONFIG_LV_USE_BARCODE is not set
# CONFIG_LV_USE_FREETYPE is not set
# CONFIG_LV_USE_TINY_TTF is not set
# CONFIG_LV_USE_RLOTTIE is not set
# CONFIG_LV_USE_THORVG is not set
# CONFIG_LV_USE_LZ4 is not set
# CONFIG_LV_USE_FFMPEG is not set
# end of 3rd Party Libraries

#
# Others
#
# CONFIG_LV_USE_SNAPSHOT is not set
# CONFIG_LV_USE_SYSMON is not set
# CONFIG_LV_USE_MONKEY is not set
# CONFIG_LV_USE_PROFILER is not set
# CONFIG_LV_USE_GRIDNAV is not set
# CONFIG_LV_USE_FRAGMENT is not set
# CONFIG_LV_USE_IMGFONT is not set
# CONFIG_LV_USE_IME_PINYIN is not set
# CONFIG_LV_USE_FILE_EXPLORER is not set
# end of Others

#
# Devices
#
# CONFIG_LV_USE_SDL is not set
# CONFIG_LV_USE_X11 is not set
# CONFIG_LV_USE_LINUX_FBDEV is not set
# CONFIG_LV_USE_NUTTX is not set
# CONFIG_LV_USE_LINUX_DRM is not set
# CONFIG_LV_USE_TFT_ESPI is not set
# CONFIG_LV_USE_EVDEV is not set
# CONFIG_LV_USE_LIBINPUT is not set
# CONFIG_LV_USE_ST7735 is not set
# CONFIG_LV_USE_ST7789 is not set
# CONFIG_LV_USE_ST7796 is not set
# CONFIG_LV_USE_ILI9341 is not set
# CONFIG_LV_USE_GENERIC_MIPI is not set
# CONFIG_LV_USE_WINDOWS is not set
# end of Devices

#
# Examples
#
CONFIG_LV_BUILD_EXAMPLES=y
# end of Examples

#
# Demos
#
# CONFIG_LV_USE_DEMO_WIDGETS is not set
# CONFIG_LV_USE_DEMO_KEYPAD_AND_ENCODER is not set
# CONFIG_LV_USE_DEMO_RENDER is not set
# CONFIG_LV_USE_DEMO_SCROLL is not set
# CONFIG_LV_USE_DEMO_STRESS is not set
# CONFIG_LV_USE_DEMO_MUSIC is not set
# CONFIG_LV_USE_DEMO_FLEX_LAYOUT is not set
# CONFIG_LV_USE_DEMO_MULTILANG is not set
# end of Demos
# end of LVGL configuration

#
# DIYMON Board Options
#
CONFIG_BSP_SD_CARD_ENABLED=y
# end of DIYMON Board Options

#
# IoT Button
#
CONFIG_BUTTON_PERIOD_TIME_MS=5
CONFIG_BUTTON_DEBOUNCE_TICKS=2
CONFIG_BUTTON_SHORT_PRESS_TIME_MS=180
CONFIG_BUTTON_LONG_PRESS_TIME_MS=1500
CONFIG_BUTTON_LONG_PRESS_HOLD_SERIAL_TIME_MS=20
CONFIG_ADC_BUTTON_MAX_CHANNEL=3
CONFIG_ADC_BUTTON_MAX_BUTTON_PER_CHANNEL=8
CONFIG_ADC_BUTTON_SAMPLE_TIMES=1
# end of IoT Button

#
# ESP LCD TOUCH - CST816S
#
# CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID is not set
# end of ESP LCD TOUCH - CST816S
# end of Component config

# CONFIG_IDF_EXPERIMENTAL_FEATURES is not set

# Deprecated options for backward compatibility
# CONFIG_APP_BUILD_TYPE_ELF_RAM is not set
# CONFIG_NO_BLOBS is not set
# CONFIG_APP_ROLLBACK_ENABLE is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_NONE is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_ERROR is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_WARN is not set
CONFIG_LOG_BOOTLOADER_LEVEL_INFO=y
# CONFIG_LOG_BOOTLOADER_LEVEL_DEBUG is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_VERBOSE is not set
CONFIG_LOG_BOOTLOADER_LEVEL=3
# CONFIG_FLASH_ENCRYPTION_ENABLED is not set
# CONFIG_FLASHMODE_QIO is not set
# CONFIG_FLASHMODE_QOUT is not set
CONFIG_FLASHMODE_DIO=y
# CONFIG_FLASHMODE_DOUT is not set
CONFIG_MONITOR_BAUD=115200
CONFIG_OPTIMIZATION_LEVEL_DEBUG=y
CONFIG_COMPILER_OPTIMIZATION_LEVEL_DEBUG=y
CONFIG_COMPILER_OPTIMIZATION_DEFAULT=y
# CONFIG_OPTIMIZATION_LEVEL_RELEASE is not set
# CONFIG_COMPILER_OPTIMIZATION_LEVEL_RELEASE is not set
CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED=y
# CONFIG_OPTIMIZATION_ASSERTIONS_SILENT is not set
# CONFIG_OPTIMIZATION_ASSERTIONS_DISABLED is not set
CONFIG_OPTIMIZATION_ASSERTION_LEVEL=2
# CONFIG_CXX_EXCEPTIONS is not set
CONFIG_STACK_CHECK_NONE=y
# CONFIG_STACK_CHECK_NORM is not set
# CONFIG_STACK_CHECK_STRONG is not set
# CONFIG_STACK_CHECK_ALL is not set
# CONFIG_WARN_WRITE_STRINGS is not set
# CONFIG_ESP32_APPTRACE_DEST_TRAX is not set
CONFIG_ESP32_APPTRACE_DEST_NONE=y
CONFIG_ESP32_APPTRACE_LOCK_ENABLE=y
CONFIG_SW_COEXIST_ENABLE=y
CONFIG_ESP32_WIFI_SW_COEXIST_ENABLE=y
CONFIG_ESP_WIFI_SW_COEXIST_ENABLE=y
# CONFIG_EXTERNAL_COEX_ENABLE is not set
# CONFIG_ESP_WIFI_EXTERNAL_COEXIST_ENABLE is not set
# CONFIG_GPTIMER_ISR_IRAM_SAFE is not set
# CONFIG_MCPWM_ISR_IRAM_SAFE is not set
# CONFIG_EVENT_LOOP_PROFILING is not set
CONFIG_POST_EVENTS_FROM_ISR=y
CONFIG_POST_EVENTS_FROM_IRAM_ISR=y
CONFIG_GDBSTUB_SUPPORT_TASKS=y
CONFIG_GDBSTUB_MAX_TASKS=32
# CONFIG_OTA_ALLOW_HTTP is not set
# CONFIG_ESP_SYSTEM_PD_FLASH is not set
CONFIG_PERIPH_CTRL_FUNC_IN_IRAM=y
CONFIG_BROWNOUT_DET=y
CONFIG_BROWNOUT_DET_LVL_SEL_7=y
# CONFIG_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_2 is not set
CONFIG_BROWNOUT_DET_LVL=7
CONFIG_ESP_SYSTEM_BROWNOUT_INTR=y
CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE=y
# CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION is not set
CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER=20
CONFIG_ESP32_PHY_MAX_TX_POWER=20
# CONFIG_REDUCE_PHY_TX_POWER is not set
# CONFIG_ESP32_REDUCE_PHY_TX_POWER is not set
CONFIG_ESP_SYSTEM_PM_POWER_DOWN_CPU=y
CONFIG_SYSTEM_EVENT_QUEUE_SIZE=32
CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE=2304
CONFIG_MAIN_TASK_STACK_SIZE=16384
CONFIG_CONSOLE_UART_DEFAULT=y
# CONFIG_CONSOLE_UART_CUSTOM is not set
# CONFIG_CONSOLE_UART_NONE is not set
# CONFIG_ESP_CONSOLE_UART_NONE is not set
CONFIG_CONSOLE_UART=y
CONFIG_CONSOLE_UART_NUM=0
CONFIG_CONSOLE_UART_BAUDRATE=115200
CONFIG_INT_WDT=y
CONFIG_INT_WDT_TIMEOUT_MS=300
CONFIG_TASK_WDT=y
CONFIG_ESP_TASK_WDT=y
# CONFIG_TASK_WDT_PANIC is not set
CONFIG_TASK_WDT_TIMEOUT_S=5
CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0=y
# CONFIG_ESP32_DEBUG_STUBS_ENABLE is not set
CONFIG_IPC_TASK_STACK_SIZE=1024
CONFIG_TIMER_TASK_STACK_SIZE=3584
CONFIG_ESP32_WIFI_ENABLED=y
CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM=10
CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM=32
# CONFIG_ESP32_WIFI_STATIC_TX_BUFFER is not set
CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER=y
CONFIG_ESP32_WIFI_TX_BUFFER_TYPE=1
CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM=32
# CONFIG_ESP32_WIFI_CSI_ENABLED is not set
CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED=y
CONFIG_ESP32_WIFI_TX_BA_WIN=6
CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED=y
CONFIG_ESP32_WIFI_RX_BA_WIN=6
CONFIG_ESP32_WIFI_NVS_ENABLED=y
CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN=752
CONFIG_ESP32_WIFI_MGMT_SBUF_NUM=32
CONFIG_ESP32_WIFI_IRAM_OPT=y
CONFIG_ESP32_WIFI_RX_IRAM_OPT=y
CONFIG_ESP32_WIFI_ENABLE_WPA3_SAE=y
CONFIG_ESP32_WIFI_ENABLE_WPA3_OWE_STA=y
CONFIG_WPA_MBEDTLS_CRYPTO=y
CONFIG_WPA_MBEDTLS_TLS_CLIENT=y
# CONFIG_WPA_WAPI_PSK is not set
# CONFIG_WPA_SUITE_B_192 is not set
# CONFIG_WPA_11KV_SUPPORT is not set
# CONFIG_WPA_MBO_SUPPORT is not set
# CONFIG_WPA_DPP_SUPPORT is not set
# CONFIG_WPA_11R_SUPPORT is not set
# CONFIG_WPA_WPS_SOFTAP_REGISTRAR is not set
# CONFIG_WPA_WPS_STRICT is not set
# CONFIG_WPA_DEBUG_PRINT is not set
# CONFIG_WPA_TESTING_OPTIONS is not set
# CONFIG_ESP32_ENABLE_COREDUMP_TO_FLASH is not set
# CONFIG_ESP32_ENABLE_COREDUMP_TO_UART is not set
CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE=y
CONFIG_TIMER_TASK_PRIORITY=1
CONFIG_TIMER_TASK_STACK_DEPTH=2048
CONFIG_TIMER_QUEUE_LENGTH=10
# CONFIG_ENABLE_STATIC_TASK_CLEAN_UP_HOOK is not set
# CONFIG_HAL_ASSERTION_SILIENT is not set
# CONFIG_L2_TO_L3_COPY is not set
CONFIG_ESP_GRATUITOUS_ARP=y
CONFIG_GARP_TMR_INTERVAL=60
CONFIG_TCPIP_RECVMBOX_SIZE=32
CONFIG_TCP_MAXRTX=12
CONFIG_TCP_SYNMAXRTX=12
CONFIG_TCP_MSS=1440
CONFIG_TCP_MSL=60000
CONFIG_TCP_SND_BUF_DEFAULT=5760
CONFIG_TCP_WND_DEFAULT=5760
CONFIG_TCP_RECVMBOX_SIZE=6
CONFIG_TCP_QUEUE_OOSEQ=y
CONFIG_TCP_OVERSIZE_MSS=y
# CONFIG_TCP_OVERSIZE_QUARTER_MSS is not set
# CONFIG_TCP_OVERSIZE_DISABLE is not set
CONFIG_UDP_RECVMBOX_SIZE=6
CONFIG_TCPIP_TASK_STACK_SIZE=3072
CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY=y
# CONFIG_TCPIP_TASK_AFFINITY_CPU0 is not set
CONFIG_TCPIP_TASK_AFFINITY=0x7FFFFFFF
# CONFIG_PPP_SUPPORT is not set
CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF=y
# CONFIG_NEWLIB_STDOUT_LINE_ENDING_LF is not set
# CONFIG_NEWLIB_STDOUT_LINE_ENDING_CR is not set
# CONFIG_NEWLIB_STDIN_LINE_ENDING_CRLF is not set
# CONFIG_NEWLIB_STDIN_LINE_ENDING_LF is not set
CONFIG_NEWLIB_STDIN_LINE_ENDING_CR=y
# CONFIG_NEWLIB_NANO_FORMAT is not set
CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT=y
# CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC is not set
# CONFIG_NEWLIB_TIME_SYSCALL_USE_HRT is not set
# CONFIG_NEWLIB_TIME_SYSCALL_USE_NONE is not set
CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT=5
CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT=3072
CONFIG_ESP32_PTHREAD_STACK_MIN=768
CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT=-1
CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT="pthread"
CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS=y
# CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_FAILS is not set
# CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ALLOWED is not set
CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT=y
CONFIG_SUPPORT_TERMIOS=y
CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS=1
# End of deprecated options

--- END OF FILE: .\sdkconfig ---

--- START OF FILE: .\components\bsp\include\bsp_api.h ---
/* Fecha: 18/08/2025 - 09:01  */
/* Fichero: components/bsp/include/bsp_api.h */
/* Último cambio: Añadida la declaración de bsp_wifi_deinit para la limpieza de recursos. */
/* Descripción: Interfaz pública del BSP. Se añade la función `bsp_wifi_deinit` para permitir una desinicialización completa y segura del stack WiFi. Esto es crucial para liberar memoria y recursos al salir de modos de operación que usan la red, como el modo de configuración, evitando así fugas y fallos de asignación al reiniciar servicios. */

#ifndef BSP_API_H
#define BSP_API_H

#include "esp_err.h"
#include "esp_lcd_panel_ops.h"
#include "esp_lcd_touch.h"
#include "driver/i2c_master.h"
#include "driver/gpio.h"
#include "esp_wifi.h"
#include <stdint.h> // Para uint16_t

// --- INICIALIZADORES DE HARDWARE ---
esp_err_t bsp_init(void);
esp_err_t bsp_init_service_mode(void);
esp_err_t bsp_init_minimal_headless(void);

// --- INICIALIZADORES DE PERIFÉRICOS INDIVIDUALES ---
esp_err_t bsp_i2c_init(void);
esp_err_t bsp_spi_init(void);
esp_err_t bsp_display_init(void);
esp_err_t bsp_touch_init(void);
esp_err_t bsp_sdcard_init(void);
esp_err_t bsp_imu_init(void);
esp_err_t bsp_battery_init(void);

// --- FUNCIONES DE WIFI ---
void bsp_wifi_init_stack(void);
void bsp_wifi_init_sta(const char *ssid, const char *pass);
void bsp_wifi_start_ap(void);
void bsp_wifi_init_sta_from_nvs(void);
void bsp_wifi_deinit(void); // <-- NUEVA FUNCIÓN
bool bsp_wifi_wait_for_ip(uint32_t timeout_ms);
void bsp_wifi_get_ip(char *ip);
void bsp_wifi_erase_credentials(void);

// --- FUNCIONES DE CONTROL ---
void bsp_display_set_brightness(int percentage);
void bsp_display_turn_on(void);
void bsp_display_turn_off(void);

// --- FUNCIONES DEL IMU (SENSOR DE MOVIMIENTO) ---
void bsp_imu_read(float acc[3], float gyro[3]);

// --- FUNCIONES DE BATERÍA ---
void bsp_battery_get_voltage(float *voltage, uint16_t *adc_value);

// --- GETTERS DE HANDLES Y CONFIGURACIÓN ---
i2c_master_bus_handle_t bsp_get_i2c_bus_handle(void);
esp_lcd_panel_io_handle_t bsp_get_panel_io_handle(void);
esp_lcd_panel_handle_t bsp_get_display_handle(void);
esp_lcd_touch_handle_t bsp_get_touch_handle(void);
int bsp_get_display_hres(void);
int bsp_get_display_vres(void);
size_t bsp_get_display_buffer_size(void);

#endif // BSP_API_H

--- END OF FILE: .\components\bsp\include\bsp_api.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\include\esp_lcd_touch_cst816s.h ---
/*
 * SPDX-FileCopyrightText: 2023-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @file
 * @brief ESP LCD touch: CST816S
 */

#pragma once

#include "esp_idf_version.h"
#include "esp_lcd_touch.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Create a new CST816S touch driver
 *
 * @note  The I2C communication should be initialized before use this function.
 *
 * @param io LCD panel IO handle, it should be created by `esp_lcd_new_panel_io_i2c()`
 * @param config Touch panel configuration
 * @param tp Touch panel handle
 * @return
 *      - ESP_OK: on success
 */
esp_err_t esp_lcd_touch_new_i2c_cst816s(const esp_lcd_panel_io_handle_t io, const esp_lcd_touch_config_t *config, esp_lcd_touch_handle_t *tp);

/**
 * @brief I2C address of the CST816S controller
 *
 */
#define ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS    (0x15)

/**
 * @brief Touch IO configuration structure
 *
 */
#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(5, 2, 0)
#define ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG()             \
    {                                                     \
        .dev_addr = ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS, \
        .on_color_trans_done = 0,                         \
        .user_ctx = 0,                                    \
        .control_phase_bytes = 1,                         \
        .dc_bit_offset = 0,                               \
        .lcd_cmd_bits = 8,                                \
        .lcd_param_bits = 0,                              \
        .flags =                                          \
        {                                                 \
            .dc_low_on_data = 0,                          \
            .disable_control_phase = 1,                   \
        }                                                 \
    }
#else
#define ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG()             \
    {                                                     \
        .dev_addr = ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS, \
        .on_color_trans_done = 0,                         \
        .user_ctx = 0,                                    \
        .control_phase_bytes = 1,                         \
        .dc_bit_offset = 0,                               \
        .lcd_cmd_bits = 8,                                \
        .lcd_param_bits = 0,                              \
        .flags =                                          \
        {                                                 \
            .dc_low_on_data = 0,                          \
            .disable_control_phase = 1,                   \
        },                                                \
        .scl_speed_hz = 100000                            \
    }
#endif

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\include\esp_lcd_touch_cst816s.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\main\CMakeLists.txt ---
idf_component_register(SRCS "test_esp_lcd_touch_cst816s.c")

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\main\CMakeLists.txt ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\main\test_esp_lcd_touch_cst816s.c ---
/*
 * SPDX-FileCopyrightText: 2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: CC0-1.0
 */

#include <inttypes.h>
#include "driver/i2c.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "unity.h"
#include "unity_test_runner.h"

#include "esp_lcd_touch_cst816s.h"

#define TEST_TOUCH_I2C_NUM       (0)
#define TEST_TOUCH_I2C_CLK_HZ    (400000)

#define TEST_LCD_H_RES              (240)
#define TEST_LCD_V_RES              (240)

/* LCD touch pins */
#define TEST_TOUCH_I2C_SCL       (GPIO_NUM_18)
#define TEST_TOUCH_I2C_SDA       (GPIO_NUM_8)
#define TEST_TOUCH_GPIO_INT      (GPIO_NUM_3)

TEST_CASE("test cst816s to initialize touch", "[cst816s][i2c]")
{
    /* Initilize I2C */
    const i2c_config_t i2c_conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = TEST_TOUCH_I2C_SDA,
        .sda_pullup_en = GPIO_PULLUP_DISABLE,
        .scl_io_num = TEST_TOUCH_I2C_SCL,
        .scl_pullup_en = GPIO_PULLUP_DISABLE,
        .master.clk_speed = TEST_TOUCH_I2C_CLK_HZ
    };
    TEST_ESP_OK(i2c_param_config(TEST_TOUCH_I2C_NUM, &i2c_conf));
    TEST_ESP_OK(i2c_driver_install(TEST_TOUCH_I2C_NUM, i2c_conf.mode, 0, 0, 0));

    /* Initialize touch HW */
    const esp_lcd_touch_config_t tp_cfg = {
        .x_max = TEST_LCD_H_RES,
        .y_max = TEST_LCD_V_RES,
        .rst_gpio_num = GPIO_NUM_NC, // Shared with LCD reset
        .int_gpio_num = TEST_TOUCH_GPIO_INT,
        .levels = {
            .reset = 0,
            .interrupt = 0,
        },
        .flags = {
            .swap_xy = 0,
            .mirror_x = 1,
            .mirror_y = 0,
        },
    };

    esp_lcd_touch_handle_t touch_handle;
    esp_lcd_panel_io_handle_t tp_io_handle = NULL;
    const esp_lcd_panel_io_i2c_config_t tp_io_config = ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG();
    TEST_ESP_OK(esp_lcd_new_panel_io_i2c((esp_lcd_i2c_bus_handle_t)TEST_TOUCH_I2C_NUM, &tp_io_config, &tp_io_handle));
    TEST_ESP_OK(esp_lcd_touch_new_i2c_cst816s(tp_io_handle, &tp_cfg, &touch_handle));
}

void app_main(void)
{
    printf("CST816S Test\r\n");
    unity_run_menu();
}

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\main\test_esp_lcd_touch_cst816s.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\CMakeLists.txt ---
# The following lines of boilerplate have to be in your project's CMakeLists
# in this exact order for cmake to work correctly
cmake_minimum_required(VERSION 3.5)
set(EXTRA_COMPONENT_DIRS "$ENV{IDF_PATH}/tools/unit-test-app/components")
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(test_esp_lcd_touch_cst816s)

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\CMakeLists.txt ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\CMakeLists.txt ---
idf_component_register(SRCS "esp_lcd_touch_cst816s.c" INCLUDE_DIRS "include" REQUIRES "esp_lcd")

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\CMakeLists.txt ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\esp_lcd_touch_cst816s.c ---
/*
 * SPDX-FileCopyrightText: 2015-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_system.h"
#include "esp_err.h"
#include "esp_log.h"
#include "esp_check.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_touch.h"

#define POINT_NUM_MAX       (1)

#define DATA_START_REG      (0x02)
#define CHIP_ID_REG         (0xA7)

static const char *TAG = "CST816S";

static esp_err_t read_data(esp_lcd_touch_handle_t tp);
static bool get_xy(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num);
static esp_err_t del(esp_lcd_touch_handle_t tp);

static esp_err_t i2c_read_bytes(esp_lcd_touch_handle_t tp, uint16_t reg, uint8_t *data, uint8_t len);

static esp_err_t reset(esp_lcd_touch_handle_t tp);
static esp_err_t read_id(esp_lcd_touch_handle_t tp);

esp_err_t esp_lcd_touch_new_i2c_cst816s(const esp_lcd_panel_io_handle_t io, const esp_lcd_touch_config_t *config, esp_lcd_touch_handle_t *tp)
{
    ESP_RETURN_ON_FALSE(io, ESP_ERR_INVALID_ARG, TAG, "Invalid io");
    ESP_RETURN_ON_FALSE(config, ESP_ERR_INVALID_ARG, TAG, "Invalid config");
    ESP_RETURN_ON_FALSE(tp, ESP_ERR_INVALID_ARG, TAG, "Invalid touch handle");

    /* Prepare main structure */
    esp_err_t ret = ESP_OK;
    esp_lcd_touch_handle_t cst816s = calloc(1, sizeof(esp_lcd_touch_t));
    ESP_GOTO_ON_FALSE(cst816s, ESP_ERR_NO_MEM, err, TAG, "Touch handle malloc failed");

    /* Communication interface */
    cst816s->io = io;
    /* Only supported callbacks are set */
    cst816s->read_data = read_data;
    cst816s->get_xy = get_xy;
    cst816s->del = del;
    /* Mutex */
    cst816s->data.lock.owner = portMUX_FREE_VAL;
    /* Save config */
    memcpy(&cst816s->config, config, sizeof(esp_lcd_touch_config_t));

    /* Prepare pin for touch interrupt */
    if (cst816s->config.int_gpio_num != GPIO_NUM_NC) {
        const gpio_config_t int_gpio_config = {
            .mode = GPIO_MODE_INPUT,
            .intr_type = (cst816s->config.levels.interrupt ? GPIO_INTR_POSEDGE : GPIO_INTR_NEGEDGE),
            .pin_bit_mask = BIT64(cst816s->config.int_gpio_num)
        };
        ESP_GOTO_ON_ERROR(gpio_config(&int_gpio_config), err, TAG, "GPIO intr config failed");

        /* Register interrupt callback */
        if (cst816s->config.interrupt_callback) {
            esp_lcd_touch_register_interrupt_callback(cst816s, cst816s->config.interrupt_callback);
        }
    }
    /* Prepare pin for touch controller reset */
    if (cst816s->config.rst_gpio_num != GPIO_NUM_NC) {
        const gpio_config_t rst_gpio_config = {
            .mode = GPIO_MODE_OUTPUT,
            .pin_bit_mask = BIT64(cst816s->config.rst_gpio_num)
        };
        ESP_GOTO_ON_ERROR(gpio_config(&rst_gpio_config), err, TAG, "GPIO reset config failed");
    }
    /* Reset controller */
    ESP_GOTO_ON_ERROR(reset(cst816s), err, TAG, "Reset failed");
    /* Read product id */
#ifdef CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID
    ESP_LOGI(TAG, "Read ID disabled");
#else
    ESP_GOTO_ON_ERROR(read_id(cst816s), err, TAG, "Read ID failed");
#endif
    *tp = cst816s;

    return ESP_OK;
err:
    if (cst816s) {
        del(cst816s);
    }
    ESP_LOGE(TAG, "Initialization failed!");
    return ret;
}

static esp_err_t read_data(esp_lcd_touch_handle_t tp)
{
    typedef struct {
        uint8_t num;
        uint8_t x_h : 4;
        uint8_t : 4;
        uint8_t x_l;
        uint8_t y_h : 4;
        uint8_t : 4;
        uint8_t y_l;
    } data_t;

    data_t point;
    ESP_RETURN_ON_ERROR(i2c_read_bytes(tp, DATA_START_REG, (uint8_t *)&point, sizeof(data_t)), TAG, "I2C read failed");

    portENTER_CRITICAL(&tp->data.lock);
    point.num = (point.num > POINT_NUM_MAX ? POINT_NUM_MAX : point.num);
    tp->data.points = point.num;
    /* Fill all coordinates */
    for (int i = 0; i < point.num; i++) {
        tp->data.coords[i].x = point.x_h << 8 | point.x_l;
        tp->data.coords[i].y = point.y_h << 8 | point.y_l;
    }
    portEXIT_CRITICAL(&tp->data.lock);

    return ESP_OK;
}

static bool get_xy(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num)
{
    portENTER_CRITICAL(&tp->data.lock);
    /* Count of points */
    *point_num = (tp->data.points > max_point_num ? max_point_num : tp->data.points);
    for (size_t i = 0; i < *point_num; i++) {
        x[i] = tp->data.coords[i].x;
        y[i] = tp->data.coords[i].y;

        if (strength) {
            strength[i] = tp->data.coords[i].strength;
        }
    }
    /* Invalidate */
    tp->data.points = 0;
    portEXIT_CRITICAL(&tp->data.lock);

    return (*point_num > 0);
}

static esp_err_t del(esp_lcd_touch_handle_t tp)
{
    /* Reset GPIO pin settings */
    if (tp->config.int_gpio_num != GPIO_NUM_NC) {
        gpio_reset_pin(tp->config.int_gpio_num);
        if (tp->config.interrupt_callback) {
            gpio_isr_handler_remove(tp->config.int_gpio_num);
        }
    }
    if (tp->config.rst_gpio_num != GPIO_NUM_NC) {
        gpio_reset_pin(tp->config.rst_gpio_num);
    }
    /* Release memory */
    free(tp);

    return ESP_OK;
}

static esp_err_t reset(esp_lcd_touch_handle_t tp)
{
    if (tp->config.rst_gpio_num != GPIO_NUM_NC) {
        ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, tp->config.levels.reset), TAG, "GPIO set level failed");
        vTaskDelay(pdMS_TO_TICKS(200));
        ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, !tp->config.levels.reset), TAG, "GPIO set level failed");
        vTaskDelay(pdMS_TO_TICKS(200));
    }

    return ESP_OK;
}

#ifndef CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID
static esp_err_t read_id(esp_lcd_touch_handle_t tp)
{
    uint8_t id;
    ESP_RETURN_ON_ERROR(i2c_read_bytes(tp, CHIP_ID_REG, &id, 1), TAG, "I2C read failed");
    ESP_LOGI(TAG, "IC id: %d", id);
    return ESP_OK;
}
#endif

static esp_err_t i2c_read_bytes(esp_lcd_touch_handle_t tp, uint16_t reg, uint8_t *data, uint8_t len)
{
    ESP_RETURN_ON_FALSE(data, ESP_ERR_INVALID_ARG, TAG, "Invalid data");

    return esp_lcd_panel_io_rx_param(tp->io, reg, data, len);
}

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\esp_lcd_touch_cst816s.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\Kconfig ---
menu "ESP LCD TOUCH - CST816S"

    config ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID
        bool "Disable reading ID during initialization"
        default n
        help
            For some CST816 series chips, reading ID may cause initialization failure.

endmenu

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\Kconfig ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\README.md ---
# ESP LCD Touch CST816S Controller

[![Component Registry](https://components.espressif.com/components/espressif/esp_lcd_touch_cst816s/badge.svg)](https://components.espressif.com/components/espressif/esp_lcd_touch_cst816s)

Implementation of the CST816S touch controller with esp_lcd_touch component.

| Touch controller | Communication interface |    Component name     |                             Link to datasheet                              |
| :--------------: | :---------------------: | :-------------------: | :------------------------------------------------------------------------: |
|     CST816S      |           I2C           | esp_lcd_touch_cst816s | [datasheet](https://www.buydisplay.com/download/ic/DS-CST816S_DS_V1.3.pdf) |

> [!NOTE]
> * There are two things about the driver are noteworthy (from [document](https://doc.riot-os.org/group__drivers__cst816s.html)):
>   * It only responds to I2C commands after an event, such as a touch detection. Do not expect it to respond on init. Instead after a touch event, it will assert the IRQ and respond to I2C reads for a short time.
>   * While it should be able to detect multiple finger events, this version of the chip always returns only a single finger event and a gesture. Reading the display data multiple times during a single event will return the last sampled finger position.
> * For some chips, reading ID may cause initialization failure. Disable reading ID by setting `CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID` to `y` in `menuconfig`.

## Add to project

Packages from this repository are uploaded to [Espressif's component service](https://components.espressif.com/).
You can add them to your project via `idf.py add-dependancy`, e.g.
```
    idf.py add-dependency esp_lcd_touch_cst816s==1.0.0
```

Alternatively, you can create `idf_component.yml`. More is in [Espressif's documentation](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/tools/idf-component-manager.html).

## Example use

Define a mutex for the touch and create it before initialize the touch:

```
static SemaphoreHandle_t touch_mux;

touch_mux = xSemaphoreCreateBinary();
```

Define a callback function used by ISR:

```
static void touch_callback(esp_lcd_touch_handle_t tp)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(touch_mux, &xHigherPriorityTaskWoken);

    if (xHigherPriorityTaskWoken) {
        portYIELD_FROM_ISR();
    }
}
```

Initialization of the touch component.

```
    esp_lcd_panel_io_i2c_config_t io_config = ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG();

    esp_lcd_touch_config_t tp_cfg = {
        .x_max = CONFIG_LCD_HRES,
        .y_max = CONFIG_LCD_VRES,
        .rst_gpio_num = CONFIG_LCD_TOUCH_RST,
        .int_gpio_num = CONFIG_LCD_TOUCH_INT,
        .levels = {
            .reset = 0,
            .interrupt = 0,
        },
        .flags = {
            .swap_xy = 0,
            .mirror_x = 0,
            .mirror_y = 0,
        },
        .interrupt_callback = touch_callback,
    };

    esp_lcd_touch_handle_t tp;
    esp_lcd_touch_new_i2c_cst816s(io_handle, &tp_cfg, &tp);
```

Read data from the touch controller and store it in RAM memory. It should be called regularly in poll.

```
    if (xSemaphoreTake(touch_mux, 0) == pdTRUE) {
        esp_lcd_touch_read_data(tp); // read only when ISR was triggled
    }
```

Get one X and Y coordinates with strength of touch.

```
    uint16_t touch_x[1];
    uint16_t touch_y[1];
    uint16_t touch_strength[1];
    uint8_t touch_cnt = 0;

    bool touchpad_pressed = esp_lcd_touch_get_coordinates(tp, touch_x, touch_y, touch_strength, &touch_cnt, 1);
```

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\README.md ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_battery.c ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_battery.c
 * Fecha: 13/08/2025 - 12:06 
 * Último cambio: Corregido el tipo de retorno de la función de inicialización.
 * Descripción: Se ha corregido la firma de la función sp_battery_init de oid a sp_err_t
 *              para que coincida con su declaración en la API pública. Esto resuelve un error
 *              crítico de compilación (ESP_ERROR_CHECK sobre una función void) que causaba
 *              un reinicio del dispositivo durante el arranque.
 */
#include "bsp_battery.h"

#include "esp_adc/adc_oneshot.h"
#include "esp_adc/adc_cali.h"
#include "esp_adc/adc_cali_scheme.h"


#include "esp_log.h"

static char *TAG = "bsp_battery";


static adc_oneshot_unit_handle_t adc1_handle;
static adc_cali_handle_t adc1_cali_chan0_handle = NULL;
static bool do_calibration1_chan0;


static bool example_adc_calibration_init(adc_unit_t unit, adc_channel_t channel, adc_atten_t atten, adc_cali_handle_t *out_handle)
{
    adc_cali_handle_t handle = NULL;
    esp_err_t ret = ESP_FAIL;
    bool calibrated = false;

#if ADC_CALI_SCHEME_CURVE_FITTING_SUPPORTED
    if (!calibrated)
    {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Curve Fitting");
        adc_cali_curve_fitting_config_t cali_config = {
            .unit_id = unit,
            .chan = channel,
            .atten = atten,
            .bitwidth = ADC_BITWIDTH_DEFAULT,
        };
        ret = adc_cali_create_scheme_curve_fitting(&cali_config, &handle);
        if (ret == ESP_OK)
        {
            calibrated = true;
        }
    }
#endif

#if ADC_CALI_SCHEME_LINE_FITTING_SUPPORTED
    if (!calibrated)
    {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Line Fitting");
        adc_cali_line_fitting_config_t cali_config = {
            .unit_id = unit,
            .atten = atten,
            .bitwidth = ADC_BITWIDTH_DEFAULT,
        };
        ret = adc_cali_create_scheme_line_fitting(&cali_config, &handle);
        if (ret == ESP_OK)
        {
            calibrated = true;
        }
    }
#endif

    *out_handle = handle;
    if (ret == ESP_OK)
    {
        ESP_LOGI(TAG, "Calibration Success");
    }
    else if (ret == ESP_ERR_NOT_SUPPORTED || !calibrated)
    {
        ESP_LOGW(TAG, "eFuse not burnt, skip software calibration");
    }
    else
    {
        ESP_LOGE(TAG, "Invalid arg or no memory");
    }

    return calibrated;
}


esp_err_t bsp_battery_init(void)
{

    adc_oneshot_unit_init_cfg_t init_config1 = {
        .unit_id = EXAMPLE_ADC_UNIT,
    };
    ESP_ERROR_CHECK(adc_oneshot_new_unit(&init_config1, &adc1_handle));
    //-------------ADC1 Config---------------//
    adc_oneshot_chan_cfg_t config = {
        .bitwidth = ADC_BITWIDTH_DEFAULT,
        .atten = EXAMPLE_ADC_ATTEN,
    };
    ESP_ERROR_CHECK(adc_oneshot_config_channel(adc1_handle, EXAMPLE_BATTERY_ADC_CHANNEL, &config));

    //-------------ADC1 Calibration Init---------------//

    do_calibration1_chan0 = example_adc_calibration_init(EXAMPLE_ADC_UNIT, EXAMPLE_BATTERY_ADC_CHANNEL, EXAMPLE_ADC_ATTEN, &adc1_cali_chan0_handle);
    return ESP_OK;
}


void bsp_battery_get_voltage(float *voltage, uint16_t *adc_value)
{
    int adc_raw;
    int voltage_int;
    
    ESP_ERROR_CHECK(adc_oneshot_read(adc1_handle, EXAMPLE_BATTERY_ADC_CHANNEL, &adc_raw));
    
    // ESP_LOGI(TAG, "ADC%d Channel[%d] Raw Data: %d", ADC_UNIT_1 + 1, EXAMPLE_BATTERY_ADC_CHANNEL, adc_raw);
    if (do_calibration1_chan0)
    {
        ESP_ERROR_CHECK(adc_cali_raw_to_voltage(adc1_cali_chan0_handle, adc_raw, &voltage_int));
        *voltage = (voltage_int / 1000.0f) * 3.0; 

        if (adc_value)
        {
            *adc_value = adc_raw;
        }   
    }
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_battery.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_battery.h ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_battery.h
 * Fecha: 13/08/2025 - 12:06 
 * Último cambio: Corregido el tipo de retorno de la función de inicialización.
 * Descripción: Cabecera privada para el driver de la batería. Se ha corregido la firma
 *              de sp_battery_init a sp_err_t para que sea consistente con la
 *              API pública y evitar un crash en tiempo de ejecución.
 */
#ifndef __BSP_BATTERY_H__
#define __BSP_BATTERY_H__
#include <stdio.h>
#include "esp_err.h"
#include <stdint.h>

#define EXAMPLE_ADC_UNIT ADC_UNIT_1
#define EXAMPLE_BATTERY_ADC_CHANNEL ADC_CHANNEL_0
#define EXAMPLE_ADC_ATTEN ADC_ATTEN_DB_12


#ifdef __cplusplus
extern "C" {
#endif

esp_err_t bsp_battery_init(void);
void bsp_battery_get_voltage(float *voltage, uint16_t *adc_value);

#ifdef __cplusplus
}
#endif


#endif

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_battery.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_display.c ---
/*
Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_display.c
Fecha: $timestamp
Último cambio: Modificada la lógica de `bsp_display_set_brightness` para no guardar el estado de atenuación (10%) en NVS.
Descripción: Driver del display. Se ha modificado la función de ajuste de brillo para que los cambios automáticos de atenuación (al 10%) no sobrescriban el brillo configurado por el usuario en la NVS ni el último nivel de brillo conocido. Esto asegura que al reactivar la pantalla, esta vuelva al estado deseado por el usuario y no al 10%.
*/
#include "bsp_api.h"
#include "esp_log.h"
#include "driver/spi_master.h"
#include "driver/ledc.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_ops.h"
#include "esp_lcd_panel_vendor.h"
#include "nvs_flash.h"
#include "nvs.h"

static const char *TAG = "bsp_display";

#define BSP_SPI_HOST            SPI2_HOST
#define PIN_NUM_LCD_SCLK        5
#define PIN_NUM_LCD_MOSI        4
#define PIN_NUM_LCD_CS          7
#define PIN_NUM_LCD_DC          6
#define PIN_NUM_LCD_RST         14
#define PIN_NUM_LCD_BL          15
#define PIN_NUM_SD_MISO         19
#define BSP_LCD_H_RES           170
#define BSP_LCD_V_RES           320

static esp_lcd_panel_handle_t g_panel_handle = NULL;
static esp_lcd_panel_io_handle_t g_io_handle = NULL;

// Variable estática para guardar el último nivel de brillo
static int s_last_brightness_percentage = 100;

esp_err_t bsp_display_init(void) {
    ESP_LOGI(TAG, "Initializing display...");

    ledc_timer_config_t bl_timer_conf = {
        .speed_mode = LEDC_LOW_SPEED_MODE, .duty_resolution = LEDC_TIMER_8_BIT,
        .timer_num = LEDC_TIMER_0, .freq_hz = 5000, .clk_cfg = LEDC_AUTO_CLK
    };
    ESP_ERROR_CHECK(ledc_timer_config(&bl_timer_conf));
    ledc_channel_config_t bl_channel_conf = {
        .gpio_num = PIN_NUM_LCD_BL, .speed_mode = LEDC_LOW_SPEED_MODE,
        .channel = LEDC_CHANNEL_0, .timer_sel = LEDC_TIMER_0, .duty = 0, .hpoint = 0
    };
    ESP_ERROR_CHECK(ledc_channel_config(&bl_channel_conf));

    // Carga el último nivel de brillo guardado en NVS.
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READONLY, &nvs_handle);
    int32_t saved_brightness = 100; // Valor por defecto si no se encuentra nada.
    if (err == ESP_OK) {
        err = nvs_get_i32(nvs_handle, "brightness", &saved_brightness);
        if (err != ESP_OK) {
            ESP_LOGW(TAG, "No se encontró brillo en NVS, usando valor por defecto (100).");
            saved_brightness = 100;
        } else {
            ESP_LOGI(TAG, "Brillo cargado desde NVS: %d%%", (int)saved_brightness);
        }
        nvs_close(nvs_handle);
    } else {
        ESP_LOGE(TAG, "Error al abrir NVS para leer brillo: %s", esp_err_to_name(err));
    }
    bsp_display_set_brightness((int)saved_brightness);

    esp_lcd_panel_io_spi_config_t io_config = {
        .cs_gpio_num = PIN_NUM_LCD_CS, .dc_gpio_num = PIN_NUM_LCD_DC,
        .spi_mode = 0, .pclk_hz = 40 * 1000 * 1000, .trans_queue_depth = 10,
        .lcd_cmd_bits = 8, .lcd_param_bits = 8
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi((esp_lcd_spi_bus_handle_t)BSP_SPI_HOST, &io_config, &g_io_handle));

    esp_lcd_panel_dev_config_t panel_config = {
        .reset_gpio_num = PIN_NUM_LCD_RST, .bits_per_pixel = 16,
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_st7789(g_io_handle, &panel_config, &g_panel_handle));
    
    esp_lcd_panel_reset(g_panel_handle);
    esp_lcd_panel_init(g_panel_handle);
    
    esp_lcd_panel_swap_xy(g_panel_handle, true);
    esp_lcd_panel_mirror(g_panel_handle, false, true);
    esp_lcd_panel_set_gap(g_panel_handle, 35, 0); 
    esp_lcd_panel_invert_color(g_panel_handle, true);

    esp_lcd_panel_disp_on_off(g_panel_handle, true);
    
    ESP_LOGI(TAG, "Display initialized and rotated by driver to 170x320.");
    return ESP_OK;
}

void bsp_display_set_brightness(int percentage) {
    if (percentage > 100) percentage = 100;
    if (percentage < 0) percentage = 0;

    // Calcula y establece el ciclo de trabajo del PWM para el backlight.
    uint32_t duty = 255 - ((255 * percentage) / 100);
    ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);

    // El valor 10% es el nivel de atenuación automática por inactividad.
    // No se debe guardar en NVS ni como último brillo conocido del usuario.
    if (percentage == 10) {
        ESP_LOGD(TAG, "Atenuando pantalla temporalmente a 10%%. No se guarda el estado.");
        return;
    }

    // Guarda el último nivel de brillo (si es > 0) para la función de re-encendido.
    if (percentage > 0) {
        s_last_brightness_percentage = percentage;
    }

    // Guarda el nuevo nivel de brillo en la memoria no volátil (NVS).
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err == ESP_OK) {
        err = nvs_set_i32(nvs_handle, "brightness", (int32_t)percentage);
        if (err == ESP_OK) {
            nvs_commit(nvs_handle);
            ESP_LOGD(TAG, "Brillo de usuario (%d%%) guardado en NVS.", percentage);
        } else {
            ESP_LOGE(TAG, "Error al guardar brillo en NVS: %s", esp_err_to_name(err));
        }
        nvs_close(nvs_handle);
    } else {
        ESP_LOGE(TAG, "Error al abrir NVS para guardar brillo: %s", esp_err_to_name(err));
    }
}

void bsp_display_turn_on(void) {
    ESP_LOGI(TAG, "Turning display ON and restoring brightness to %d%%", s_last_brightness_percentage);
    // 1. Restaurar el brillo (sin guardar estado, ya que se restaura uno existente)
    uint32_t duty = 255 - ((255 * s_last_brightness_percentage) / 100);
    ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);
    // 2. Encender el panel
    esp_lcd_panel_disp_on_off(g_panel_handle, true);
}

void bsp_display_turn_off(void) {
    ESP_LOGI(TAG, "Turning display and backlight OFF");
    // 1. Apagar el panel
    esp_lcd_panel_disp_on_off(g_panel_handle, false);
    // 2. Apagar el backlight directamente para no llamar a set_brightness
    uint32_t duty = 255; // Duty 255 es 0% de brillo en mi configuración invertida
    ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);
}

esp_lcd_panel_handle_t bsp_get_display_handle(void) { return g_panel_handle; }
esp_lcd_panel_io_handle_t bsp_get_panel_io_handle(void) { return g_io_handle; }
int bsp_get_display_hres(void) { return BSP_LCD_H_RES; }
int bsp_get_display_vres(void) { return BSP_LCD_V_RES; }
size_t bsp_get_display_buffer_size(void) { return BSP_LCD_H_RES * 20; }

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_display.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_display.h ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_display.h
 * Fecha: 12/08/2025 - 11:46
 * Último cambio: Añadidas las declaraciones para encendido/apagado del display.
 * Descripción: Cabecera privada para el driver del display. Se añaden las declaraciones de las funciones que controlan el estado de encendido del panel.
 */
#ifndef BSP_DISPLAY_H
#define BSP_DISPLAY_H

#include "esp_err.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_ops.h"

#ifdef __cplusplus
extern "C" {
#endif

// Constantes de la pantalla
#define BSP_LCD_H_RES           170
#define BSP_LCD_V_RES           320

// Funciones exportadas por bsp_display.c
esp_err_t bsp_display_init(void);
void bsp_display_set_brightness(int percentage);
void bsp_display_turn_on(void);
void bsp_display_turn_off(void);
esp_lcd_panel_handle_t bsp_get_display_handle(void);
esp_lcd_panel_io_handle_t bsp_get_panel_io_handle(void);
int bsp_get_display_hres(void);
int bsp_get_display_vres(void);
size_t bsp_get_display_buffer_size(void);

#ifdef __cplusplus
}
#endif

#endif // BSP_DISPLAY_H
--- END OF FILE: .\components\bsp\WS1.9TS\bsp_display.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_i2c.c ---
/*
 * Fichero: ./diymon_bsp/WS1.9TS/bsp_i2c.c
 * Fecha: 12/08/2025 - 05:05 pm
 * Último cambio: Implementada la inicialización idempotente.
 * Descripción: Centraliza la inicialización del bus I2C. La función sp_i2c_init es ahora idempotente, lo que significa que puede ser llamada múltiples veces de forma segura, pero solo ejecutará la inicialización del bus la primera vez, evitando errores de reinicialización.
 */
#include "bsp_api.h"
#include "esp_log.h"
#include "driver/i2c_master.h"

static const char *TAG = "bsp_i2c";

// Pines definidos para el bus I2C
#define PIN_I2C_SCL      8
#define PIN_I2C_SDA      18
#define I2C_PORT_NUM     I2C_NUM_0
#define I2C_CLK_SPEED_HZ 400000

// Variable estática para almacenar el manejador del bus I2C
static i2c_master_bus_handle_t g_bus_handle = NULL;
// Bandera para asegurar la inicialización única (idempotencia)
static bool g_i2c_bus_initialized = false;

esp_err_t bsp_i2c_init(void)
{
    if (g_i2c_bus_initialized) {
        ESP_LOGD(TAG, "I2C master bus ya está inicializado.");
        return ESP_OK;
    }

    ESP_LOGI(TAG, "Initializing I2C master bus (Modern API)...");

    i2c_master_bus_config_t i2c_bus_config = {
        .i2c_port = I2C_PORT_NUM,
        .sda_io_num = PIN_I2C_SDA,
        .scl_io_num = PIN_I2C_SCL,
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .glitch_ignore_cnt = 7,
        .flags.enable_internal_pullup = true,
    };
    
    ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_config, &g_bus_handle));

    g_i2c_bus_initialized = true;
    ESP_LOGI(TAG, "I2C bus initialized successfully.");
    return ESP_OK;
}

i2c_master_bus_handle_t bsp_get_i2c_bus_handle(void)
{
    return g_bus_handle;
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_i2c.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_i2c.h ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_i2c.h
 * Fecha: 13/08/2025 - 05:00 
 * Último cambio: Corregido el contenido del fichero.
 * Descripción: Cabecera privada para el módulo I2C del BSP. Se ha corregido un error de copiado y pegado que contenía declaraciones incorrectas.
 */
#ifndef BSP_I2C_H__
#define BSP_I2C_H__

// Este es un header privado. Las declaraciones públicas están en bsp_api.h.

#endif // BSP_I2C_H__

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_i2c.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_qmi8658.c ---
/*
  Fichero: ./components/diymon_bsp/WS1.9TS/bsp_qmi8658.c
  Fecha: 13/08/2025 - 12:03 
  Último cambio: Eliminadas las funciones de interrupción no utilizadas.
  Descripción: Driver del IMU. Se han eliminado las implementaciones de las funciones
               de interrupción (bsp_imu_interrupt_init, bsp_imu_enable_motion_interrupt,
               bsp_imu_clear_interrupt) para limpiar el código, ya que la detección
               de 'shake' ahora se realiza por sondeo en la capa de la UI.
*/
#include "bsp_api.h"
#include "bsp_qmi8658.h"
#include "esp_log.h"
#include "driver/i2c_master.h"
#include "driver/gpio.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static const char *TAG = "bsp_qmi8658";

#define IMU_I2C_ADDRESS  0x6B
#define I2C_CLK_SPEED_HZ 400000

static i2c_master_dev_handle_t g_imu_dev_handle = NULL;

// --- Funciones de ayuda estáticas ---
static void qmi8658_on_demand_cali(void) {
    ESP_LOGI(TAG, "Performing on-demand calibration...");
    
    uint8_t reset_buf[] = {QMI8658_RESET, 0xb0};
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, reset_buf, sizeof(reset_buf), pdMS_TO_TICKS(100)));
    vTaskDelay(pdMS_TO_TICKS(20));

    uint8_t cali_cmd_buf[] = {QMI8658_CTRL9, QMI8658_CTRL9_CMD_ON_DEMAND_CALI};
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, cali_cmd_buf, sizeof(cali_cmd_buf), pdMS_TO_TICKS(100)));
    
    vTaskDelay(pdMS_TO_TICKS(2200));

    uint8_t nop_cmd_buf[] = {QMI8658_CTRL9, QMI8658_CTRL9_CMD_NOP};
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, nop_cmd_buf, sizeof(nop_cmd_buf), pdMS_TO_TICKS(100)));
    vTaskDelay(pdMS_TO_TICKS(100));

    ESP_LOGI(TAG, "On-demand calibration finished.");
}


// --- Funciones públicas ---

esp_err_t bsp_imu_init(void)
{
    ESP_LOGI(TAG, "Initializing IMU QMI8658 with Modern I2C API...");
    
    i2c_master_bus_handle_t bus_handle = bsp_get_i2c_bus_handle();
    if (bus_handle == NULL) {
        ESP_LOGE(TAG, "I2C bus handle is not initialized!");
        return ESP_FAIL;
    }

    i2c_device_config_t dev_cfg = {
        .device_address = IMU_I2C_ADDRESS,
        .scl_speed_hz = I2C_CLK_SPEED_HZ,
    };
    
    ESP_ERROR_CHECK(i2c_master_bus_add_device(bus_handle, &dev_cfg, &g_imu_dev_handle));
    ESP_LOGI(TAG, "IMU device added to I2C bus successfully.");

    uint8_t who_am_i = 0;
    ESP_ERROR_CHECK(i2c_master_transmit_receive(g_imu_dev_handle, 
                                                (uint8_t[]){QMI8658_WHO_AM_I}, 1, 
                                                &who_am_i, 1, 
                                                pdMS_TO_TICKS(100)));

    if (who_am_i != 0x05) {
        ESP_LOGE(TAG, "QMI8658 not found! WhoAmI check failed. Read value: 0x%02X", who_am_i);
        return ESP_FAIL;
    }
    ESP_LOGI(TAG, "QMI8658 found successfully! WhoAmI: 0x%02X", who_am_i);

    qmi8658_on_demand_cali();
    
    uint8_t ctrl1_buf[] = {QMI8658_CTRL1, 0x60}; // Habilitar Address Auto-Increment
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, ctrl1_buf, sizeof(ctrl1_buf), pdMS_TO_TICKS(100)));

    uint8_t ctrl_regs_data[][2] = {
        {QMI8658_CTRL7, 0x03}, // Habilitar Accel y Gyro
        {QMI8658_CTRL2, 0x23}, // Accel: +-8g, 250Hz ODR
        {QMI8658_CTRL3, 0x53}  // Gyro:  +-1024dps, 250Hz ODR
    };

    for (int i = 0; i < sizeof(ctrl_regs_data) / sizeof(ctrl_regs_data[0]); i++) {
        ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, ctrl_regs_data[i], 2, pdMS_TO_TICKS(100)));
    }
    
    ESP_LOGI(TAG, "IMU initialized.");
    return ESP_OK;
}

void bsp_imu_read(float acc[3], float gyro[3])
{
    if (g_imu_dev_handle == NULL) {
        ESP_LOGE(TAG, "IMU device handle not initialized, cannot read.");
        acc[0] = acc[1] = acc[2] = 0;
        gyro[0] = gyro[1] = gyro[2] = 0;
        return;
    }

    uint8_t buf_reg[12];
    short raw_acc_xyz[3];
    short raw_gyro_xyz[3];

    esp_err_t ret = i2c_master_transmit_receive(g_imu_dev_handle,
                                (uint8_t[]){QMI8658_AX_L}, 1,
                                buf_reg, 12,
                                pdMS_TO_TICKS(100));

    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to read IMU data via I2C");
        acc[0] = acc[1] = acc[2] = 0;
        gyro[0] = gyro[1] = gyro[2] = 0;
        return;
    }

    raw_acc_xyz[0] = (int16_t)((buf_reg[1] << 8) | buf_reg[0]);
    raw_acc_xyz[1] = (int16_t)((buf_reg[3] << 8) | buf_reg[2]);
    raw_acc_xyz[2] = (int16_t)((buf_reg[5] << 8) | buf_reg[4]);
    raw_gyro_xyz[0] = (int16_t)((buf_reg[7] << 8) | buf_reg[6]);
    raw_gyro_xyz[1] = (int16_t)((buf_reg[9] << 8) | buf_reg[8]);
    raw_gyro_xyz[2] = (int16_t)((buf_reg[11] << 8) | buf_reg[10]);

    // Conversión a m/s^2 (+-8g)
    acc[0] = ((float)raw_acc_xyz[0] / 4096.0f) * 9.81f;
    acc[1] = ((float)raw_acc_xyz[1] / 4096.0f) * 9.81f;
    acc[2] = ((float)raw_acc_xyz[2] / 4096.0f) * 9.81f;
    
    // Conversión a dps (+-1024dps)
    gyro[0] = (float)raw_gyro_xyz[0] / 32.0f;
    gyro[1] = (float)raw_gyro_xyz[1] / 32.0f;
    gyro[2] = (float)raw_gyro_xyz[2] / 32.0f;
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_qmi8658.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_qmi8658.h ---
/*
 * Fichero: ./diymon_bsp/WS1.9TS/bsp_qmi8658.h
 * Fecha: 12/08/2025 - 09:25 pm
 * Último cambio: Corregidos los valores de los registros y añadidos los de calibración.
 * Descripción: Cabecera privada para el sensor QMI8658. Se han corregido las direcciones
 *              de los registros de datos (temperatura, acelerómetro, etc.) para que coincidan
 *              con la hoja de datos oficial y se han añadido los registros y comandos
 *              necesarios para la calibración y configuración avanzada del sensor.
 */
#ifndef BSP_QMI8658_H
#define BSP_QMI8658_H

#include <stdint.h>

// Definición de los registros del sensor QMI8658 (corregidos según datasheet)
typedef enum
{
    QMI8658_WHO_AM_I        = 0x00,
    QMI8658_REVISION_ID     = 0x01,
    QMI8658_CTRL1           = 0x02,
    QMI8658_CTRL2           = 0x03,
    QMI8658_CTRL3           = 0x04,
    QMI8658_CTRL4           = 0x05,
    QMI8658_CTRL5           = 0x06,
    QMI8658_CTRL6           = 0x07,
    QMI8658_CTRL7           = 0x08,
    QMI8658_CTRL9           = 0x0A,
    QMI8658_CAL1_L          = 0x0B,
    QMI8658_STATUS_INT      = 0x2D,
    QMI8658_TEMP_L          = 0x33,
    QMI8658_TEMP_H          = 0x34,
    QMI8658_AX_L            = 0x35,
    QMI8658_AX_H            = 0x36,
    QMI8658_AY_L            = 0x37,
    QMI8658_AY_H            = 0x38,
    QMI8658_AZ_L            = 0x39,
    QMI8658_AZ_H            = 0x3A,
    QMI8658_GX_L            = 0x3B,
    QMI8658_GX_H            = 0x3C,
    QMI8658_GY_L            = 0x3D,
    QMI8658_GY_H            = 0x3E,
    QMI8658_GZ_L            = 0x3F,
    QMI8658_GZ_H            = 0x40,
    QMI8658_RESET           = 0x60
} qmi8658_reg_t;

// Comandos para el registro CTRL9
typedef enum {
    QMI8658_CTRL9_CMD_NOP = 0x00,
    QMI8658_CTRL9_CMD_ON_DEMAND_CALI = 0xA2,
} qmi8658_ctrl9_cmd_t;

#endif // BSP_QMI8658_H

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_qmi8658.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_sdcard.c ---
/*
 * Archivo: components/diymon_bsp/WS1.9TS/bsp_sdcard.c
 * Versión: Final (con max_files aumentado)
 */
#include "bsp_api.h"
#include "esp_log.h"
#include "esp_vfs_fat.h"
#include "sdmmc_cmd.h"
#include "driver/sdspi_host.h"
#include "driver/spi_common.h"
#include "bsp_sdcard.h" 

static const char *TAG = "bsp_sdcard";

// --- CONFIGURACIÓN PRIVADA ---
#define PIN_NUM_MISO  (GPIO_NUM_19)
#define PIN_NUM_MOSI  (GPIO_NUM_4)
#define PIN_NUM_CLK   (GPIO_NUM_5)
#define PIN_NUM_CS    (GPIO_NUM_20)
#define MOUNT_POINT   "/sdcard"

static sdmmc_card_t *g_card = NULL;
static sdmmc_host_t g_host = SDSPI_HOST_DEFAULT();

// --- IMPLEMENTACIÓN DE LA FUNCIÓN PÚBLICA ---
esp_err_t bsp_sdcard_init(void)
{
    ESP_LOGI(TAG, "Initializing SD card...");
    esp_err_t ret;

    // 1. Configurar el sistema de ficheros FAT que se va a montar
    esp_vfs_fat_sdmmc_mount_config_t mount_config = {
        .format_if_mount_failed = false,
        // [CAMBIO CLAVE] Aumentamos el límite para permitir la navegación por subdirectorios.
        .max_files = 10,  // <-- El único cambio está aquí. Antes era 5.
        .allocation_unit_size = 16 * 1024
    };

    g_host.slot = SPI2_HOST;

    sdspi_device_config_t slot_config = SDSPI_DEVICE_CONFIG_DEFAULT();
    slot_config.gpio_cs = PIN_NUM_CS;
    slot_config.host_id = SPI2_HOST;

    ret = esp_vfs_fat_sdspi_mount(MOUNT_POINT, &g_host, &slot_config, &mount_config, &g_card);

    if (ret != ESP_OK) {
        if (ret == ESP_FAIL) {
            ESP_LOGE(TAG, "Failed to mount filesystem.");
        } else {
            ESP_LOGE(TAG, "Failed to initialize the card (%s).", esp_err_to_name(ret));
        }
        return ret;
    }
    
    sdmmc_card_print_info(stdout, g_card);
    ESP_LOGI(TAG, "SD card initialized successfully!");
    
    return ESP_OK;
}
--- END OF FILE: .\components\bsp\WS1.9TS\bsp_sdcard.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_sdcard.h ---
/*
 * Fichero: bsp_sdcard.h
 * Fecha: 08/08/2025
 * Último cambio: Añadida la declaración de bsp_sdcard_init.
 * Descripción: Interfaz pública para el controlador de la tarjeta SD.
 */
#ifndef __BSP_SDCARD_H_
#define __BSP_SDCARD_H_

#include "esp_err.h"
#include <stdint.h> // Para uint64_t

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el bus SPI y monta el sistema de ficheros FAT en la tarjeta SD.
 * 
 * @return esp_err_t 
 *         - ESP_OK si la inicialización y el montaje son exitosos.
 *         - ESP_FAIL u otros códigos de error si algo falla.
 */
esp_err_t bsp_sdcard_init(void);

/**
 * @brief Obtiene el tamaño total de la tarjeta SD en bytes.
 * 
 * @note Esta función debe ser llamada después de una inicialización exitosa.
 * @return uint64_t Tamaño de la tarjeta en bytes.
 */
uint64_t bsp_sdcard_get_size(void);


#ifdef __cplusplus
}
#endif

#endif // __BSP_SDCARD_H_
--- END OF FILE: .\components\bsp\WS1.9TS\bsp_sdcard.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_spi.c ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_spi.c
 * Fecha: 12/08/2025 - 05:05 pm
 * Último cambio: Implementada la inicialización idempotente.
 * Descripción: Driver para la inicialización del bus SPI. La función sp_spi_init es ahora idempotente, asegurando que el bus SPI solo se inicializa una vez, previniendo crashes por múltiples llamadas.
 */
#include "bsp_api.h"
#include "esp_log.h"
#include "driver/spi_master.h"
#include "bsp_display.h" 

static const char *TAG = "bsp_spi";

#define BSP_SPI_HOST            SPI2_HOST
#define PIN_NUM_SPI_SCLK        5
#define PIN_NUM_SPI_MOSI        4
#define PIN_NUM_SPI_MISO        19 

// Bandera para asegurar la inicialización única (idempotencia)
static bool g_spi_bus_initialized = false;

esp_err_t bsp_spi_init(void) {
    if (g_spi_bus_initialized) {
        ESP_LOGD(TAG, "SPI bus (Host: %d) ya está inicializado.", BSP_SPI_HOST);
        return ESP_OK;
    }

    ESP_LOGI(TAG, "Initializing main SPI bus (Host: %d)...", BSP_SPI_HOST);

    spi_bus_config_t buscfg = {
        .sclk_io_num = PIN_NUM_SPI_SCLK, 
        .mosi_io_num = PIN_NUM_SPI_MOSI,
        .miso_io_num = PIN_NUM_SPI_MISO, 
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = BSP_LCD_H_RES * 100 * sizeof(uint16_t)
    };
    
    esp_err_t ret = spi_bus_initialize(BSP_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize SPI bus!");
    } else {
        g_spi_bus_initialized = true;
        ESP_LOGI(TAG, "SPI bus initialized successfully.");
    }

    return ret;
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_spi.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_touch.c ---
/*
  Fichero: ./components/diymon_bsp/WS1.9TS/bsp_touch.c
  Fecha: 12/08/2025 - 09:00
  Último cambio: Corregido para usar el bus I2C global en lugar de pasarlo.
  Descripción: Driver del panel táctil CST816S. Ahora utiliza la función pública
               `bsp_get_i2c_bus_handle` para obtener el manejador del bus I2C.
*/
#include "bsp_api.h"
#include "esp_log.h"
#include "esp_lcd_touch_cst816s.h"

static const char *TAG = "bsp_touch";
static esp_lcd_touch_handle_t g_touch_handle = NULL;

esp_err_t bsp_touch_init(void)
{
    ESP_LOGI(TAG, "Initializing touch controller CST816S (Modern API)...");

    i2c_master_bus_handle_t bus_handle = bsp_get_i2c_bus_handle();
    if (bus_handle == NULL) {
        ESP_LOGE(TAG, "I2C bus handle is not initialized!");
        return ESP_FAIL;
    }

    esp_lcd_panel_io_handle_t tp_io_handle = NULL;
    const esp_lcd_panel_io_i2c_config_t tp_io_config = {
        .dev_addr = ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS,
        .control_phase_bytes = 1,
        .lcd_cmd_bits = 8,
        .lcd_param_bits = 8,
        .scl_speed_hz = 400000,
        .flags = {
            .dc_low_on_data = 0,
            .disable_control_phase = 1,
        }
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_io_i2c(bus_handle, &tp_io_config, &tp_io_handle));

    const esp_lcd_touch_config_t tp_cfg = {
        .x_max = 170,
        .y_max = 320,
        .rst_gpio_num = GPIO_NUM_NC,
        .int_gpio_num = GPIO_NUM_NC,
    };
    ESP_ERROR_CHECK(esp_lcd_touch_new_i2c_cst816s(tp_io_handle, &tp_cfg, &g_touch_handle));
    
    ESP_LOGI(TAG, "Touch driver initialized successfully.");
    return ESP_OK;
}

esp_lcd_touch_handle_t bsp_get_touch_handle(void)
{
    return g_touch_handle;
}
--- END OF FILE: .\components\bsp\WS1.9TS\bsp_touch.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_touch.h ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_touch.h
 * Fecha: 13/08/2025 - 05:00 
 * Último cambio: Corregido el header del driver de touch.
 * Descripción: Cabecera privada para el módulo táctil. Se ha corregido la inclusión de la cabecera del driver para que apunte a cst816s en lugar de axs5106 y se han eliminado defines no utilizados.
 */
#ifndef BSP_TOUCH_H__
#define BSP_TOUCH_H__

#include "driver/i2c_master.h"
#include "esp_lcd_touch_cst816s.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif

#endif // BSP_TOUCH_H__

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_touch.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_wifi.c ---
/* Fecha: 18/08/2025 - 09:01  */
/* Fichero: components/bsp/WS1.9TS/bsp_wifi.c */
/* Último cambio: Añadida la función bsp_wifi_deinit para una limpieza completa de recursos. */
/* Descripción: Se ha implementado `bsp_wifi_deinit` para desregistrar los manejadores de eventos y liberar la memoria del semáforo. Esto resuelve un problema de fuga de recursos que ocurría al salir del modo de configuración y asegura que el sistema WiFi pueda reinicializarse de forma limpia, evitando el fallo de asignación del buffer de animación. */

#include "bsp_api.h"
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "freertos/semphr.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "lwip/err.h"
#include "lwip/sys.h"
#include <assert.h>

#define PORTAL_AP_SSID          "DIYTogether"
#define PORTAL_AP_PASS          "MakeItYours"
#define PORTAL_AP_CHANNEL       1
#define PORTAL_AP_MAX_CONN      4

static const char *TAG = "bsp_wifi";
static SemaphoreHandle_t s_ip_acquired_sem = NULL;
static bool g_network_stack_initialized = false;
static esp_event_handler_instance_t s_wifi_event_instance;
static esp_event_handler_instance_t s_ip_event_instance;

static void event_handler(void* arg, esp_event_base_t event_base,
                                int32_t event_id, void* event_data)
{
    if (event_base == WIFI_EVENT) {
        switch(event_id) {
            case WIFI_EVENT_STA_START:
                esp_wifi_connect();
                break;
            case WIFI_EVENT_STA_CONNECTED:
                ESP_LOGI(TAG, "Conectado al AP, esperando IP.");
                break;
            case WIFI_EVENT_STA_DISCONNECTED: {
                vTaskDelay(pdMS_TO_TICKS(1000));
                ESP_LOGI(TAG, "Reintentando conexión...");
                esp_wifi_connect();
                break;
            }
            default:
                break;
        }
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "¡IP Obtenida!: " IPSTR, IP2STR(&event->ip_info.ip));
        if (s_ip_acquired_sem) {
            xSemaphoreGive(s_ip_acquired_sem);
        }
    }
}

void bsp_wifi_init_stack(void) {
    if (g_network_stack_initialized) {
        ESP_LOGD(TAG, "El stack de red ya ha sido inicializado.");
        return;
    }
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    g_network_stack_initialized = true;
    ESP_LOGI(TAG, "Stack de red (netif, event loop) inicializado por primera vez.");
}

void bsp_wifi_start_ap(void) {
    esp_netif_create_default_wifi_ap();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    wifi_config_t wifi_config = {
        .ap = {
            .ssid = PORTAL_AP_SSID, .ssid_len = strlen(PORTAL_AP_SSID),
            .channel = PORTAL_AP_CHANNEL, .password = PORTAL_AP_PASS,
            .max_connection = PORTAL_AP_MAX_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK
        },
    };
    if (strlen(PORTAL_AP_PASS) == 0) {
        wifi_config.ap.authmode = WIFI_AUTH_OPEN;
    }

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());
}

void bsp_wifi_init_sta_from_nvs(void) {
    esp_netif_create_default_wifi_sta();
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &event_handler, NULL, &s_wifi_event_instance));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &event_handler, NULL, &s_ip_event_instance));

    s_ip_acquired_sem = xSemaphoreCreateBinary();

    char ssid[32] = {0}, pass[64] = {0};
    size_t len_ssid = sizeof(ssid), len_pass = sizeof(pass);

    nvs_handle_t nvs_handle;
    if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
        nvs_get_str(nvs_handle, "wifi_ssid", ssid, &len_ssid);
        nvs_get_str(nvs_handle, "wifi_pass", pass, &len_pass);
        nvs_close(nvs_handle);
    }

    if (len_ssid > 1) {
        wifi_config_t wifi_config = {0};
        strcpy((char *)wifi_config.sta.ssid, ssid);
        strcpy((char *)wifi_config.sta.password, pass);
        wifi_config.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;
        
        ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
        ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
        ESP_ERROR_CHECK(esp_wifi_start());
    }
}

bool bsp_wifi_wait_for_ip(uint32_t timeout_ms) {
    if (!s_ip_acquired_sem) return false;
    return (xSemaphoreTake(s_ip_acquired_sem, pdMS_TO_TICKS(timeout_ms)) == pdTRUE);
}

void bsp_wifi_get_ip(char *ip) {
    esp_netif_t* netif = esp_netif_get_handle_from_ifkey("WIFI_STA_DEF");
    if(netif) {
        esp_netif_ip_info_t ip_info;
        esp_netif_get_ip_info(netif, &ip_info);
        sprintf(ip, IPSTR, IP2STR(&ip_info.ip));
    }
}

void bsp_wifi_init_sta(const char *ssid, const char *pass) {
    esp_netif_create_default_wifi_sta();
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &event_handler, NULL, &s_wifi_event_instance));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &event_handler, NULL, &s_ip_event_instance));

    s_ip_acquired_sem = xSemaphoreCreateBinary();

    if (ssid && strlen(ssid) > 0) {
        wifi_config_t wifi_config = {0};
        strcpy((char *)wifi_config.sta.ssid, ssid);
        if (pass) { strcpy((char *)wifi_config.sta.password, pass); }
        wifi_config.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;

        ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
        ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
        ESP_ERROR_CHECK(esp_wifi_start());
    }
}

void bsp_wifi_deinit(void) {
    ESP_LOGI(TAG, "Desinicializando WiFi y liberando recursos...");
    // Detener WiFi
    esp_wifi_stop();
    
    // Desregistrar manejadores de eventos
    if (s_wifi_event_instance) {
        esp_event_handler_instance_unregister(WIFI_EVENT, ESP_EVENT_ANY_ID, s_wifi_event_instance);
        s_wifi_event_instance = NULL;
    }
    if (s_ip_event_instance) {
        esp_event_handler_instance_unregister(IP_EVENT, IP_EVENT_STA_GOT_IP, s_ip_event_instance);
        s_ip_event_instance = NULL;
    }
    
    // Liberar recursos de WiFi
    esp_wifi_deinit();
    
    // Liberar semáforo
    if (s_ip_acquired_sem) {
        vSemaphoreDelete(s_ip_acquired_sem);
        s_ip_acquired_sem = NULL;
    }

    // Destruir interfaces de red
    esp_netif_t* sta_netif = esp_netif_get_handle_from_ifkey("WIFI_STA_DEF");
    if (sta_netif) {
        esp_netif_destroy(sta_netif);
    }
    esp_netif_t* ap_netif = esp_netif_get_handle_from_ifkey("WIFI_AP_DEF");
    if (ap_netif) {
        esp_netif_destroy(ap_netif);
    }

    ESP_LOGI(TAG, "WiFi desinicializado y recursos liberados.");
}

void bsp_wifi_erase_credentials(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) abriendo NVS para borrar credenciales.", esp_err_to_name(err));
        return;
    }
    nvs_erase_key(nvs_handle, "wifi_ssid");
    nvs_erase_key(nvs_handle, "wifi_pass");
    nvs_erase_key(nvs_handle, "wifi_authmode");
    nvs_commit(nvs_handle);
    nvs_close(nvs_handle);
    ESP_LOGI(TAG, "Credenciales WiFi borradas de NVS.");
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_wifi.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_wifi.h ---
/*
  Fichero: ./components/diymon_bsp/WS1.9TS/bsp_wifi.h
  Fecha: 12/08/2025 - 05:05 pm
  Último cambio: Actualizadas las declaraciones de funciones para reflejar la implementación.
  Descripción: Interfaz pública del gestor WiFi del BSP. Se han corregido las declaraciones para que coincidan con las funciones realmente exportadas por sp_wifi.c, resolviendo posibles errores de 'implicit declaration'.
*/
#ifndef __BSP_WIFI_H__
#define __BSP_WIFI_H__

#include "esp_err.h"
#include "esp_wifi.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el stack de red (netif y event loop).
 */
void bsp_wifi_init_stack(void);

/**
 * @brief Escanea redes WiFi disponibles y las muestra en el log.
 * @return ESP_OK si el escaneo fue exitoso.
 */
esp_err_t bsp_wifi_scan(void);

/**
 * @brief Inicia el dispositivo en modo Punto de Acceso (AP).
 */
void bsp_wifi_start_ap(void);

/**
 * @brief Inicia el dispositivo en modo Estación (STA) usando credenciales de NVS.
 */
void bsp_wifi_init_sta_from_nvs(void);

/**
 * @brief Espera de forma bloqueante hasta obtener una dirección IP.
 * @param timeout_ms Tiempo máximo de espera en milisegundos.
 * @return true si se obtuvo IP, false en caso de timeout.
 */
bool bsp_wifi_wait_for_ip(uint32_t timeout_ms);

/**
 * @brief Obtiene la dirección IP actual del dispositivo en modo STA.
 * @param ip Puntero a un buffer de caracteres donde se escribirá la IP.
 */
void bsp_wifi_get_ip(char *ip);

#ifdef __cplusplus
}
#endif

#endif // __BSP_WIFI_H__

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_wifi.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp.c ---
/* Fecha: 16/08/2025 - 08:17  */
/* Fichero: components/diymon_bsp/WS1.9TS/bsp.c */
/* Último cambio: Modificado para manejar el fallo de inicialización de la tarjeta SD sin abortar. */
/* Descripción: Orquestador del BSP. Ahora trata el fallo de la tarjeta SD como un error no fatal, permitiendo que el dispositivo arranque sin la SD. Esto es crucial para los modos de configuración que no dependen de los assets de la tarjeta y para la robustez general del sistema. */

#include "bsp_api.h"
#include "esp_err.h"
#include "esp_log.h" 
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static const char *TAG = "bsp";

// Inicialización completa para la aplicación principal
esp_err_t bsp_init(void) {
    ESP_LOGI(TAG, "Inicializando TODO el hardware para la aplicación principal...");
    ESP_ERROR_CHECK(bsp_i2c_init());
    ESP_ERROR_CHECK(bsp_spi_init());
    ESP_ERROR_CHECK(bsp_display_init());
    ESP_ERROR_CHECK(bsp_touch_init());
    ESP_ERROR_CHECK(bsp_imu_init());
    
    // [CORRECCIÓN] Manejar fallo de SD sin abortar.
    if (bsp_sdcard_init() != ESP_OK) {
        ESP_LOGE(TAG, "Fallo al inicializar la tarjeta SD, pero se continúa el arranque. Las animaciones no funcionarán.");
    }
    
    ESP_ERROR_CHECK(bsp_battery_init());
    return ESP_OK;
}

// Inicialización para modos de servicio que necesitan mostrar una imagen
esp_err_t bsp_init_service_mode(void) {
    ESP_LOGI(TAG, "Inicializando hardware para modo de servicio con pantalla...");
    ESP_ERROR_CHECK(bsp_i2c_init());
    ESP_ERROR_CHECK(bsp_spi_init());
    
    // [CORRECCIÓN] Manejar fallo de SD sin abortar.
    if (bsp_sdcard_init() != ESP_OK) {
        ESP_LOGE(TAG, "Fallo al inicializar la tarjeta SD en modo servicio. El servidor de ficheros no funcionará.");
    }

    ESP_ERROR_CHECK(bsp_display_init());
    ESP_ERROR_CHECK(bsp_touch_init());
    bsp_display_set_brightness(100);
    return ESP_OK;
}

// Inicialización mínima para modos de servicio que no usan pantalla
esp_err_t bsp_init_minimal_headless(void) {
    ESP_LOGI(TAG, "Inicializando hardware MÍNIMO para modo headless (SPI + SD)...");
    ESP_ERROR_CHECK(bsp_spi_init());
    
    // [CORRECCIÓN] Manejar fallo de SD sin abortar.
    if (bsp_sdcard_init() != ESP_OK) {
        ESP_LOGE(TAG, "Fallo al inicializar la tarjeta SD en modo headless.");
    }

    return ESP_OK;
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp.c ---

--- START OF FILE: .\components\bsp\CMakeLists.txt ---
# Fecha: 17/08/2025 - 02:55 
# Fichero: components/bsp/CMakeLists.txt
# Último cambio: Eliminada la dependencia explícita de 'esp_driver_i2c' para resolver un conflicto de compilación.
# Descripción: Se ha eliminado la dependencia 'esp_driver_i2c' de la lista REQUIRES. Requerir sub-componentes de 'driver' individualmente es una práctica no estándar que puede corromper el árbol de dependencias del build system. El componente 'driver' ya se incluye y proporciona acceso a todas las APIs de controladores necesarias (I2C, SPI, etc.), solucionando el fallo de compilación en el componente 'esp_twai'.

set(BOARD_SUBDIR "WS1.9TS")

file(GLOB component_sources "${BOARD_SUBDIR}/*.c")

idf_component_register(
    SRCS ${component_sources}
    
    INCLUDE_DIRS "include"
    PRIV_INCLUDE_DIRS "${BOARD_SUBDIR}"
    
    REQUIRES 
        driver
        esp_lcd
        sdmmc
        fatfs
        esp_adc
        esp_wifi
        nvs_flash
        lvgl
        esp_lvgl_port
        esp_lcd_touch_cst816s
        esp_lcd_sh8601
)

--- END OF FILE: .\components\bsp\CMakeLists.txt ---

--- START OF FILE: .\components\bsp\Kconfig ---
# Fichero: ./components/diymon_bsp/Kconfig
# Fecha: 12/08/2025 - 07:45 pm
# Último cambio: Añadida opción para habilitar/deshabilitar la tarjeta SD.
# Descripción: Fichero de configuración para el BSP. Se añade una opción booleana
#              que permite compilar con o sin el soporte para la tarjeta SD.
#              Esto es crucial para resolver un conflicto de hardware en la placa,
#              donde el pin de la SD (GPIO20) interfiere con el monitor serie USB.

menu "DIYMON Board Options"

    config BSP_SD_CARD_ENABLED
        bool "Enable SD Card Support"
        default y
        help
            Enable this option to initialize and use the onboard SD card reader.

            WARNING: On the Waveshare ESP32-C6 Touch LCD board, the SD Card's
            Chip Select (CS) pin is connected to GPIO20. This pin is also used
            by the internal USB-JTAG interface for the serial monitor output.

            If you enable this option, YOU WILL LOSE THE SERIAL MONITOR LOGS
            as soon as the SD card is initialized.

            Disable this option during development and debugging if you need to
            see log output via the USB port. Re-enable it for final deployment.

endmenu

--- END OF FILE: .\components\bsp\Kconfig ---

--- START OF FILE: .\components\bsp\Kconfig.projbuild ---
menu "DIYMON Board Support Package"
    choice DIYMON_TARGET_BOARD
        prompt "Target DIYMON Hardware"
        default DIYMON_BOARD_ORIGINAL
        help
            Select the specific hardware board you are compiling for.

        config DIYMON_BOARD_ORIGINAL
            bool "Placa Original (ESP32-S3)"

        config DIYMON_BOARD_WAVESHARE_C6
            bool "Waveshare ESP32-C6 LCD 1.9"

    endchoice
endmenu
--- END OF FILE: .\components\bsp\Kconfig.projbuild ---

--- START OF FILE: .\components\core\include\diymon_evolution.h ---
/*
 * Fichero: ./components/diymon_core/include/diymon_evolution.h
 * Fecha: 13/08/2025 - 19:45
 * Último cambio: Añadida la declaración para resetear el estado.
 * Descripción: Cabecera del motor de evolución. Expone las funciones para gestionar el estado y la secuencia de evolución del DIYMON, incluyendo la involución y el reseteo de estado.
 */
#ifndef DIYMON_EVOLUTION_H
#define DIYMON_EVOLUTION_H

#include <stdint.h> // Para usar tipos como uint8_t

// Estructura para almacenar las estadísticas de una forma canónica
typedef struct {
    uint8_t fue;
    uint8_t res;
    uint8_t vel;
    uint8_t intel;
} diymon_stats_t;

/**
 * @brief Inicializa el motor de evolución.
 */
void diymon_evolution_init(void);

/**
 * @brief Obtiene las estadísticas base para un Código Evolutivo dado.
 * @param evo_code El código a buscar (ej: "1.2.3").
 * @return Un puntero a las estadísticas (solo lectura) o NULL si no se encuentra.
 */
const diymon_stats_t* diymon_get_stats_for_code(const char* evo_code);

/**
 * @brief Establece el código evolutivo del DIYMON activo.
 * @param new_code El nuevo código a establecer.
 */
void diymon_set_current_code(const char* new_code);

/**
 * @brief Obtiene el código evolutivo del DIYMON activo.
 * @return Un puntero al código actual.
 */
const char* diymon_get_current_code(void);

/**
 * @brief Obtiene el siguiente código en la secuencia de evolución predefinida.
 * @param current_code El código actual.
 * @return El siguiente código en la secuencia, o NULL si es la evolución final.
 */
const char* diymon_get_next_evolution_in_sequence(const char* current_code);

/**
 * @brief Obtiene el código anterior en la secuencia de evolución predefinida.
 * @param current_code El código actual.
 * @return El código anterior en la secuencia, o NULL si es la forma inicial.
 */
const char* diymon_get_previous_evolution_in_sequence(const char* current_code);

/**
 * @brief Construye un código de evolución ramificado y comprueba si existe.
 * @param current_code El código de evolución actual.
 * @param branch_id El identificador de la rama elemental (1-4).
 * @return El nuevo código de evolución si es válido, o NULL si no existe.
 */
const char* diymon_get_branched_evolution(const char* current_code, int branch_id);

/**
 * @brief Borra el estado de evolución guardado en la NVS.
 */
void diymon_evolution_reset_state(void);


#endif // DIYMON_EVOLUTION_H

--- END OF FILE: .\components\core\include\diymon_evolution.h ---

--- START OF FILE: .\components\core\CMakeLists.txt ---
idf_component_register(SRCS "diymon_evolution.c"
                    INCLUDE_DIRS "include"
                    # Le damos permiso para usar tanto los logs como la memoria flash
                    REQUIRES "log" "nvs_flash"
                    )
--- END OF FILE: .\components\core\CMakeLists.txt ---

--- START OF FILE: .\components\core\diymon_evolution.c ---
/* Fecha: 15/08/2025 - 09:54  */
/* Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_core\diymon_evolution.c */
/* Último cambio: Añadidas las evoluciones de la Etapa 3 para resolver el error de "evolución no válida". */
/* Descripción: Se ha expandido la tabla maestra de evoluciones (`G_MASTER_TABLE`) para incluir las ramificaciones de la Etapa 3 que faltaban (ej: desde "3.3" a "3.3.1"). Esto corrige el error reportado por el usuario y permite que el DIYMON continúe evolucionando. */

#include "diymon_evolution.h"
#include <string.h>
#include <stdlib.h>
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"

static const char* TAG = "DIYMON_CORE";

// --- LA TABLA MAESTRA DE ESTADÍSTICAS ---
static const struct {
    const char* evo_code;
    const diymon_stats_t stats;
} G_MASTER_TABLE[] = {
    // Base
    {"0",       {5, 5, 5, 5}},
    // Etapa 1
    {"1",       {8, 5, 6, 5}}, // Fuego
    {"2",       {5, 8, 5, 6}}, // Agua
    {"3",       {6, 5, 8, 5}}, // Tierra
    {"4",       {5, 6, 5, 8}}, // Aire
    // Etapa 2 (ramas de "1" - Fuego)
    {"1.1",     {10, 5, 7, 7}}, // Fuego+Fuego
    {"1.2",     {7, 8, 7, 7}}, // Fuego+Agua
    {"1.3",     {8, 7, 8, 6}}, // Fuego+Tierra
    {"1.4",     {7, 7, 6, 8}}, // Fuego+Aire
    // Etapa 2 (ramas de "2" - Agua)
    {"2.1",     {8, 7, 7, 7}}, // Agua+Fuego
    {"2.2",     {5, 10, 7, 7}}, // Agua+Agua
    // Etapa 2 (ramas de "3" - Tierra)
    {"3.1",     {8, 6, 8, 7}}, // Tierra+Fuego
    {"3.3",     {7, 7, 10, 5}}, // Tierra+Tierra
    // Etapa 2 (ramas de "4" - Aire)
    {"4.1",     {8, 7, 6, 8}}, // Aire+Fuego
    {"4.4",     {6, 7, 5, 10}}, // Aire+Aire
    // Etapa 3 (ramas de "1.1")
    {"1.1.1",   {12, 5, 8, 8}},
    {"1.1.2",   {10, 8, 7, 8}},
    // Etapa 3 (ramas de "2.2")
    {"2.2.1",   {8, 11, 8, 8}},
    {"2.2.2",   {5, 13, 8, 9}},
    // Etapa 3 (ramas de "3.3")
    {"3.3.1",   {10, 8, 11, 6}},
    {"3.3.2",   {8, 10, 11, 6}},
    {"3.3.3",   {9, 8, 13, 5}},
    {"3.3.4",   {8, 8, 11, 8}},
    // Etapa 3 (ramas de "4.4")
    {"4.4.1",   {9, 8, 6, 11}},
    {"4.4.4",   {6, 8, 5, 13}},
};

static char G_CURRENT_DIYMON_CODE[16] = "0";
// Búfer estático para construir códigos de evolución candidatos.
static char G_EVO_CODE_BUFFER[16];


// ----- Funciones para interactuar con la memoria FLASH (NVS) -----

static void diymon_core_save_state(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("diymon_storage", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) abriendo NVS para escribir!", esp_err_to_name(err));
        return;
    }
    err = nvs_set_str(nvs_handle, "evo_code", G_CURRENT_DIYMON_CODE);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) guardando 'evo_code' en NVS!", esp_err_to_name(err));
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) haciendo commit en NVS!", esp_err_to_name(err));
    }
    nvs_close(nvs_handle);
    ESP_LOGI(TAG, "Estado guardado en memoria flash: %s", G_CURRENT_DIYMON_CODE);
}

static void diymon_core_load_state(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("diymon_storage", NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGI(TAG, "NVS: No se encontró partición, empezando de cero.");
        strcpy(G_CURRENT_DIYMON_CODE, "0"); // Asegurar estado inicial si no hay NVS
        return;
    }
    size_t required_size = sizeof(G_CURRENT_DIYMON_CODE);
    err = nvs_get_str(nvs_handle, "evo_code", G_CURRENT_DIYMON_CODE, &required_size);
    switch (err) {
        case ESP_OK:
            ESP_LOGI(TAG, "Estado cargado de memoria flash: %s", G_CURRENT_DIYMON_CODE);
            break;
        case ESP_ERR_NVS_NOT_FOUND:
            ESP_LOGI(TAG, "NVS: Clave 'evo_code' no encontrada. Es la primera ejecución.");
            strcpy(G_CURRENT_DIYMON_CODE, "0"); // Estado inicial
            break;
        default:
            ESP_LOGE(TAG, "Error (%s) cargando 'evo_code' desde NVS!", esp_err_to_name(err));
    }
    nvs_close(nvs_handle);
}

// ----- Funciones públicas -----

void diymon_evolution_init(void) {
    ESP_LOGI(TAG, "Motor de evolución inicializado.");
    diymon_core_load_state();
}

void diymon_set_current_code(const char* new_code) {
    strncpy(G_CURRENT_DIYMON_CODE, new_code, sizeof(G_CURRENT_DIYMON_CODE) - 1);
    diymon_core_save_state();
}

const diymon_stats_t* diymon_get_stats_for_code(const char* evo_code) {
    for (int i = 0; i < sizeof(G_MASTER_TABLE) / sizeof(G_MASTER_TABLE[0]); ++i) {
        if (strcmp(G_MASTER_TABLE[i].evo_code, evo_code) == 0) {
            return &G_MASTER_TABLE[i].stats;
        }
    }
    return NULL;
}

const char* diymon_get_current_code(void) {
    return G_CURRENT_DIYMON_CODE;
}

const char* diymon_get_next_evolution_in_sequence(const char* current_code) {
    if (strcmp(current_code, "0") == 0) return "1";
    if (strcmp(current_code, "1") == 0) return "1.1";
    if (strcmp(current_code, "1.1") == 0) return "1.1.1";
    return NULL;
}

const char* diymon_get_previous_evolution_in_sequence(const char* current_code) {
    if (strcmp(current_code, "0") == 0) {
        return NULL; // Ya está en la forma base.
    }

    const char* last_dot = strrchr(current_code, '.');
    
    // Si no hay punto (ej: "1", "2", "3", "4"), la involución es hacia "0".
    if (!last_dot) {
        return "0";
    }

    // Si hay un punto, se trunca el código para obtener el padre.
    size_t parent_len = last_dot - current_code;
    strncpy(G_EVO_CODE_BUFFER, current_code, parent_len);
    G_EVO_CODE_BUFFER[parent_len] = '\0';

    // Se busca el código padre en la tabla para devolver un puntero válido.
    for (int i = 0; i < sizeof(G_MASTER_TABLE) / sizeof(G_MASTER_TABLE[0]); ++i) {
        if (strcmp(G_MASTER_TABLE[i].evo_code, G_EVO_CODE_BUFFER) == 0) {
            return G_MASTER_TABLE[i].evo_code;
        }
    }

    return NULL; // El padre no existe en la tabla.
}

const char* diymon_get_branched_evolution(const char* current_code, int branch_id) {
    // Si el código actual es "0", la evolución es directamente a la rama, sin prefijo.
    if (strcmp(current_code, "0") == 0) {
        snprintf(G_EVO_CODE_BUFFER, sizeof(G_EVO_CODE_BUFFER), "%d", branch_id);
    } else {
        // Para cualquier otro estado, la evolución es una sub-rama.
        snprintf(G_EVO_CODE_BUFFER, sizeof(G_EVO_CODE_BUFFER), "%s.%d", current_code, branch_id);
    }

    // Buscar si el código generado existe en la tabla de evoluciones
    for (int i = 0; i < sizeof(G_MASTER_TABLE) / sizeof(G_MASTER_TABLE[0]); ++i) {
        if (strcmp(G_MASTER_TABLE[i].evo_code, G_EVO_CODE_BUFFER) == 0) {
            return G_MASTER_TABLE[i].evo_code; // Devuelve el puntero de la tabla
        }
    }

    return NULL; // La evolución no es válida
}

void diymon_evolution_reset_state(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("diymon_storage", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) abriendo NVS para borrar estado de evolución.", esp_err_to_name(err));
        return;
    }
    err = nvs_erase_key(nvs_handle, "evo_code");
    if (err == ESP_OK) {
        ESP_LOGI(TAG, "Clave 'evo_code' borrada de NVS.");
    } else {
        ESP_LOGE(TAG, "Error al borrar 'evo_code': %s", esp_err_to_name(err));
    }
    nvs_commit(nvs_handle);
    nvs_close(nvs_handle);
}

--- END OF FILE: .\components\core\diymon_evolution.c ---

--- START OF FILE: .\components\iot_button\include\button_adc.h ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once

#include "driver/gpio.h"
#include "esp_adc/adc_oneshot.h"
#include "button_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief adc button configuration
 *
 */
typedef struct {
    adc_oneshot_unit_handle_t *adc_handle;           /**< handle of adc unit, if NULL will create new one internal, else will use the handle */
    adc_unit_t unit_id;                              /**< ADC unit */
    uint8_t adc_channel;                             /**< Channel of ADC */
    uint8_t button_index;                            /**< button index on the channel */
    uint16_t min;                                    /**< min voltage in mv corresponding to the button */
    uint16_t max;                                    /**< max voltage in mv corresponding to the button */
} button_adc_config_t;

/**
 * @brief Create a new ADC button device
 *
 * This function initializes and configures a new ADC button device using the given configuration parameters.
 * It manages the ADC unit, channels, and button-specific parameters, and ensures proper resource allocation
 * for the ADC button object.
 *
 * @param[in] button_config Configuration for the button device, including callbacks and debounce parameters.
 * @param[in] adc_config Configuration for the ADC channel and button, including the ADC unit, channel,
 *                        button index, and voltage range (min and max).
 * @param[out] ret_button Handle to the newly created button device.
 *
 * @return
 *     - ESP_OK: Successfully created the ADC button device.
 *     - ESP_ERR_INVALID_ARG: Invalid argument provided.
 *     - ESP_ERR_NO_MEM: Memory allocation failed.
 *     - ESP_ERR_INVALID_STATE: The requested button index or channel is already in use, or no channels are available.
 *     - ESP_FAIL: Failed to initialize or configure the ADC or button device.
 *
 * @note
 * - If the ADC unit is not already configured, it will be initialized with the provided or default settings.
 * - If the ADC channel is not initialized, it will be configured for the specified unit and calibrated.
 * - This function ensures that ADC resources are reused whenever possible to optimize resource allocation.
 */
esp_err_t iot_button_new_adc_device(const button_config_t *button_config, const button_adc_config_t *adc_config, button_handle_t *ret_button);

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\include\button_adc.h ---

--- START OF FILE: .\components\iot_button\include\button_gpio.h ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once

#include "esp_err.h"
#include "button_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief gpio button configuration
 *
 */
typedef struct {
    int32_t gpio_num;              /**< num of gpio */
    uint8_t active_level;          /**< gpio level when press down */
    bool enable_power_save;        /**< enable power save mode */
    bool disable_pull;             /**< disable internal pull up or down */
} button_gpio_config_t;

/**
 * @brief Create a new GPIO button device
 *
 * This function initializes and configures a GPIO-based button device using the given configuration parameters.
 * It sets up the GPIO pin, configures its input mode, and optionally enables power-saving features or wake-up functionality.
 *
 * @param[in] button_config Configuration for the button device, including callbacks and debounce parameters.
 * @param[in] gpio_cfg Configuration for the GPIO, including the pin number, active level, and power-save options.
 * @param[out] ret_button Handle to the newly created GPIO button device.
 *
 * @return
 *     - ESP_OK: Successfully created the GPIO button device.
 *     - ESP_ERR_INVALID_ARG: Invalid argument provided, such as an invalid GPIO number.
 *     - ESP_ERR_NO_MEM: Memory allocation failed.
 *     - ESP_ERR_INVALID_STATE: Failed to configure GPIO wake-up or interrupt settings.
 *     - ESP_FAIL: General failure, such as unsupported wake-up configuration on the target.
 *
 * @note
 * - If power-saving is enabled, the GPIO will be configured as a wake-up source for light sleep.
 * - Pull-up or pull-down resistors are configured based on the `active_level` and the `disable_pull` flag.
 * - This function checks for the validity of the GPIO as a wake-up source when power-saving is enabled.
 * - If power-saving is not supported by the hardware or configuration, the function will return an error.
 */
esp_err_t iot_button_new_gpio_device(const button_config_t *button_config, const button_gpio_config_t *gpio_config, button_handle_t *ret_button);

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\include\button_gpio.h ---

--- START OF FILE: .\components\iot_button\include\button_matrix.h ---
/*
 * SPDX-FileCopyrightText: 2023-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#pragma once

#include "esp_err.h"
#include "button_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Button matrix key configuration.
 *        Just need to configure the GPIO associated with this GPIO in the matrix keyboard.
 *
 *        Matrix Keyboard Layout (3x3):
 *        ----------------------------------------
 *        |  Button 1  |  Button 2  |  Button 3  |
 *        |  (R1-C1)   |  (R1-C2)   |  (R1-C3)   |
 *        |--------------------------------------|
 *        |  Button 4  |  Button 5  |  Button 6  |
 *        |  (R2-C1)   |  (R2-C2)   |  (R2-C3)   |
 *        |--------------------------------------|
 *        |  Button 7  |  Button 8  |  Button 9  |
 *        |  (R3-C1)   |  (R3-C2)   |  (R3-C3)   |
 *        ----------------------------------------
 *
 *        - Button matrix key is driven using row scanning.
 *        - Buttons within the same column cannot be detected simultaneously,
 *          but buttons within the same row can be detected without conflicts.
 */
typedef struct {
    int32_t *row_gpios;        /**< GPIO number list for the row */
    int32_t *col_gpios;        /**< GPIO number list for the column */
    uint32_t row_gpio_num;     /**< Number of GPIOs associated with the row */
    uint32_t col_gpio_num;     /**< Number of GPIOs associated with the column */
} button_matrix_config_t;

/**
 * @brief Create a new button matrix device
 *
 * This function initializes and configures a button matrix device using the specified row and column GPIOs.
 * Each button in the matrix is represented as an independent button object, and its handle is returned in the `ret_button` array.
 *
 * @param[in] button_config Configuration for the button device, including callbacks and debounce parameters.
 * @param[in] matrix_config Configuration for the matrix, including row and column GPIOs and their counts.
 * @param[out] ret_button Array of handles for the buttons in the matrix.
 * @param[inout] size Pointer to the total number of buttons in the matrix. Must match the product of row and column GPIO counts.
 *                    On success, this value is updated to reflect the size of the button matrix.
 *
 * @return
 *     - ESP_OK: Successfully created the button matrix device.
 *     - ESP_ERR_INVALID_ARG: Invalid argument provided, such as null pointers or mismatched matrix dimensions.
 *     - ESP_ERR_NO_MEM: Memory allocation failed.
 *     - ESP_FAIL: General failure, such as button creation failure for one or more buttons.
 *
 * @note
 * - Each row GPIO is configured as an output, while each column GPIO is configured as an input.
 * - The total number of buttons in the matrix must equal the product of the row and column GPIO counts.
 * - The `ret_button` array must be large enough to store handles for all buttons in the matrix.
 * - If any button creation fails, the function will free all allocated resources and return an error.
 */
esp_err_t iot_button_new_matrix_device(const button_config_t *button_config, const button_matrix_config_t *matrix_config, button_handle_t *ret_button, size_t *size);

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\include\button_matrix.h ---

--- START OF FILE: .\components\iot_button\include\button_types.h ---
/*
 * SPDX-FileCopyrightText: 2024-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#pragma once

#include <stdint.h>
#include "esp_err.h"
#include "button_interface.h"

#ifdef __cplusplus
extern "C" {
#endif

enum {
    BUTTON_INACTIVE = 0,
    BUTTON_ACTIVE,
};

typedef struct button_dev_t *button_handle_t;

/**
 * @brief Button configuration
 *
 */
typedef struct {
    uint16_t long_press_time;                         /**< Trigger time(ms) for long press, if 0 default to BUTTON_LONG_PRESS_TIME_MS */
    uint16_t short_press_time;                        /**< Trigger time(ms) for short press, if 0 default to BUTTON_SHORT_PRESS_TIME_MS */
} button_config_t;

/**
 * @brief Create a new IoT button instance
 *
 * This function initializes a new button instance with the specified configuration
 * and driver. It also sets up internal resources such as the button timer if not
 * already initialized.
 *
 * @param[in] config        Pointer to the button configuration structure
 * @param[in] driver        Pointer to the button driver structure
 * @param[out] ret_button   Pointer to where the handle of the created button will be stored
 *
 * @return
 *      - ESP_OK: Successfully created the button
 *      - ESP_ERR_INVALID_ARG: Invalid arguments passed to the function
 *      - ESP_ERR_NO_MEM: Memory allocation failed
 *
 * @note
 * - The first call to this function logs the IoT Button version.
 * - The function initializes a global button timer if it is not already running.
 * - Timer is started only if the driver does not enable power-saving mode.
 */
esp_err_t iot_button_create(const button_config_t *config, const button_driver_t *driver, button_handle_t *ret_button);

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\include\button_types.h ---

--- START OF FILE: .\components\iot_button\include\iot_button.h ---
/* SPDX-FileCopyrightText: 2022-2024 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once

#include "sdkconfig.h"
#include "esp_err.h"
#include "button_types.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef void (* button_cb_t)(void *button_handle, void *usr_data);

typedef void (* button_power_save_cb_t)(void *usr_data);

/**
 * @brief Structs to store power save callback info
 *
 */
typedef struct {
    button_power_save_cb_t enter_power_save_cb;  /**< Callback function when entering power save mode */
    void *usr_data;                              /**< User data for the callback */
} button_power_save_config_t;

/**
 * @brief Button events
 *
 */
typedef enum {
    BUTTON_PRESS_DOWN = 0,
    BUTTON_PRESS_UP,
    BUTTON_PRESS_REPEAT,
    BUTTON_PRESS_REPEAT_DONE,
    BUTTON_SINGLE_CLICK,
    BUTTON_DOUBLE_CLICK,
    BUTTON_MULTIPLE_CLICK,
    BUTTON_LONG_PRESS_START,
    BUTTON_LONG_PRESS_HOLD,
    BUTTON_LONG_PRESS_UP,
    BUTTON_PRESS_END,
    BUTTON_EVENT_MAX,
    BUTTON_NONE_PRESS,
} button_event_t;

/**
 * @brief Button events arg
 *
 */
typedef union {
    /**
     * @brief Long press time event data
     *
     */
    struct long_press_t {
        uint16_t press_time;    /**< press time(ms) for the corresponding callback to trigger */
    } long_press;               /**< long press struct, for event BUTTON_LONG_PRESS_START and BUTTON_LONG_PRESS_UP */

    /**
     * @brief Multiple clicks event data
     *
     */
    struct multiple_clicks_t {
        uint16_t clicks;        /**< number of clicks, to trigger the callback */
    } multiple_clicks;          /**< multiple clicks struct, for event BUTTON_MULTIPLE_CLICK */
} button_event_args_t;

/**
 * @brief Button parameter
 *
 */
typedef enum {
    BUTTON_LONG_PRESS_TIME_MS = 0,
    BUTTON_SHORT_PRESS_TIME_MS,
    BUTTON_PARAM_MAX,
} button_param_t;

/**
 * @brief Delete a button
 *
 * @param btn_handle A button handle to delete
 *
 * @return
 *      - ESP_OK  Success
 *      - ESP_FAIL Failure
 */
esp_err_t iot_button_delete(button_handle_t btn_handle);

/**
 * @brief Register the button event callback function.
 *
 * @param btn_handle A button handle to register
 * @param event Button event
 * @param event_args Button event arguments
 * @param cb Callback function.
 * @param usr_data user data
 *
 * @return
 *      - ESP_OK on success
 *      - ESP_ERR_INVALID_ARG   Arguments is invalid.
 *      - ESP_ERR_INVALID_STATE The Callback is already registered. No free Space for another Callback.
 *      - ESP_ERR_NO_MEM        No more memory allocation for the event
 */
esp_err_t iot_button_register_cb(button_handle_t btn_handle, button_event_t event, button_event_args_t *event_args, button_cb_t cb, void *usr_data);

/**
 * @brief Unregister all the callbacks associated with the event.
 *
 * @param btn_handle A button handle to unregister
 * @param event Button event
 * @param event_args Used for unregistering a specific callback.
 *
 * @return
 *      - ESP_OK on success
 *      - ESP_ERR_INVALID_ARG   Arguments is invalid.
 *      - ESP_ERR_INVALID_STATE No callbacks registered for the event
 */
esp_err_t iot_button_unregister_cb(button_handle_t btn_handle, button_event_t event, button_event_args_t *event_args);

/**
 * @brief counts total callbacks registered
 *
 * @param btn_handle A button handle to the button
 *
 * @return
 *      - 0 if no callbacks registered, or 1 .. (BUTTON_EVENT_MAX-1) for the number of Registered Buttons.
 *      - ESP_ERR_INVALID_ARG if btn_handle is invalid
 */
size_t iot_button_count_cb(button_handle_t btn_handle);

/**
 * @brief how many callbacks are registered for the event
 *
 * @param btn_handle A button handle to the button
 *
 * @param event Button event
 *
 * @return
 *      - 0 if no callbacks registered, or 1 .. (BUTTON_EVENT_MAX-1) for the number of Registered Buttons.
 *      - ESP_ERR_INVALID_ARG if btn_handle is invalid
 */
size_t iot_button_count_event_cb(button_handle_t btn_handle, button_event_t event);

/**
 * @brief Get button event
 *
 * @param btn_handle Button handle
 *
 * @return Current button event. See button_event_t
 */
button_event_t iot_button_get_event(button_handle_t btn_handle);

/**
 * @brief Get the string representation of a button event.
 *
 * This function returns the corresponding string for a given button event.
 * If the event value is outside the valid range, the function returns error string "event value is invalid".
 *
 * @param[in] event The button event to be converted to a string.
 *
 * @return
 *      - Pointer to the event string if the event is valid.
 *      - "invalid event" if the event value is invalid.
 */
const char *iot_button_get_event_str(button_event_t event);

/**
 * @brief Log the current button event as a string.
 *
 * This function prints the string representation of the current event associated with the button.
 *
 * @param[in] btn_handle Handle to the button object.
 *
 * @return
 *      - ESP_OK: Successfully logged the event string.
 *      - ESP_FAIL: Invalid button handle.
 */
esp_err_t iot_button_print_event(button_handle_t btn_handle);

/**
 * @brief Get button repeat times
 *
 * @param btn_handle Button handle
 *
 * @return button pressed times. For example, double-click return 2, triple-click return 3, etc.
 */
uint8_t iot_button_get_repeat(button_handle_t btn_handle);

/**
 * @brief Get button ticks time
 *
 * @param btn_handle Button handle
 *
 * @return Actual time from press down to up (ms).
 */
uint32_t iot_button_get_ticks_time(button_handle_t btn_handle);

/**
 * @brief Get button long press hold count
 *
 * @param btn_handle Button handle
 *
 * @return Count of trigger cb(BUTTON_LONG_PRESS_HOLD)
 */
uint16_t iot_button_get_long_press_hold_cnt(button_handle_t btn_handle);

/**
 * @brief Dynamically change the parameters of the iot button
 *
 * @param btn_handle Button handle
 * @param param Button parameter
 * @param value new value
 * @return
 *      - ESP_OK on success
 *      - ESP_ERR_INVALID_ARG   Arguments is invalid.
 */
esp_err_t iot_button_set_param(button_handle_t btn_handle, button_param_t param, void *value);

/**
 * @brief Get button key level
 *
 * @param btn_handle Button handle
 * @return
 *      - 1 if key is pressed
 *      - 0 if key is released or invalid button handle
 */
uint8_t iot_button_get_key_level(button_handle_t btn_handle);

/**
 * @brief resume button timer, if button timer is stopped. Make sure iot_button_create() is called before calling this API.
 *
 * @return
 *     - ESP_OK on success
 *     - ESP_ERR_INVALID_STATE   timer state is invalid.
 */
esp_err_t iot_button_resume(void);

/**
 * @brief stop button timer, if button timer is running. Make sure iot_button_create() is called before calling this API.
 *
 * @return
 *     - ESP_OK on success
 *     - ESP_ERR_INVALID_STATE   timer state is invalid
 */
esp_err_t iot_button_stop(void);

/**
 * @brief Register a callback function for power saving.
 *        The config->enter_power_save_cb function will be called when all keys stop working.
 *
 * @param config Button power save config
 * @return
 *     - ESP_OK                  on success
 *     - ESP_ERR_INVALID_STATE   No button registered
 *     - ESP_ERR_INVALID_ARG     Arguments is invalid
 *     - ESP_ERR_NO_MEM          Not enough memory
 */
esp_err_t iot_button_register_power_save_cb(const button_power_save_config_t *config);

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\include\iot_button.h ---

--- START OF FILE: .\components\iot_button\interface\button_interface.h ---
/*
 * SPDX-FileCopyrightText: 2024 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#pragma once

#include <stdbool.h>
#include <stdint.h>
#include "esp_err.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct button_driver_t button_driver_t; /*!< Type of button object */

struct button_driver_t {
    /*!< (optional) Need Support Power Save */
    bool enable_power_save;

    /*!< (necessary) Get key level */
    uint8_t (*get_key_level)(button_driver_t *button_driver);

    /*!< (optional) Enter Power Save cb */
    esp_err_t (*enter_power_save)(button_driver_t *button_driver);

    /*!< (optional) Del the hardware driver and cleanup */
    esp_err_t (*del)(button_driver_t *button_driver);
};

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\interface\button_interface.h ---

--- START OF FILE: .\components\iot_button\test_apps\main\adc_button_test.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/timers.h"
#include "freertos/semphr.h"
#include "freertos/event_groups.h"
#include "esp_idf_version.h"
#include "esp_log.h"
#include "unity.h"
#include "iot_button.h"
#include "button_adc.h"

static const char *TAG = "ADC BUTTON TEST";

static void button_event_cb(void *arg, void *data)
{
    button_event_t event = iot_button_get_event(arg);
    ESP_LOGI(TAG, "BTN[%d] %s", (int)data, iot_button_get_event_str(event));
    if (BUTTON_PRESS_REPEAT == event || BUTTON_PRESS_REPEAT_DONE == event) {
        ESP_LOGI(TAG, "\tREPEAT[%d]", iot_button_get_repeat(arg));
    }

    if (BUTTON_PRESS_UP == event || BUTTON_LONG_PRESS_HOLD == event || BUTTON_LONG_PRESS_UP == event) {
        ESP_LOGI(TAG, "\tTICKS[%"PRIu32"]", iot_button_get_ticks_time(arg));
    }

    if (BUTTON_MULTIPLE_CLICK == event) {
        ESP_LOGI(TAG, "\tMULTIPLE[%d]", (int)data);
    }
}

TEST_CASE("adc button test", "[button][adc]")
{
    /** ESP32-S3-Korvo2 board */
    const button_config_t btn_cfg = {0};
    button_adc_config_t btn_adc_cfg = {
        .unit_id = ADC_UNIT_1,
        .adc_channel = 4,
    };

    button_handle_t btns[6] = {NULL};

    const uint16_t vol[6] = {380, 820, 1180, 1570, 1980, 2410};
    for (size_t i = 0; i < 6; i++) {
        btn_adc_cfg.button_index = i;
        if (i == 0) {
            btn_adc_cfg.min = (0 + vol[i]) / 2;
        } else {
            btn_adc_cfg.min = (vol[i - 1] + vol[i]) / 2;
        }

        if (i == 5) {
            btn_adc_cfg.max = (vol[i] + 3000) / 2;
        } else {
            btn_adc_cfg.max = (vol[i] + vol[i + 1]) / 2;
        }

        esp_err_t ret = iot_button_new_adc_device(&btn_cfg, &btn_adc_cfg, &btns[i]);
        TEST_ASSERT(ret == ESP_OK);
        TEST_ASSERT_NOT_NULL(btns[i]);
        iot_button_register_cb(btns[i], BUTTON_PRESS_DOWN, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_UP, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_REPEAT, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_SINGLE_CLICK, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_DOUBLE_CLICK, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_START, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_UP, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_END, NULL, button_event_cb, (void *)i);
    }

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    for (size_t i = 0; i < 6; i++) {
        iot_button_delete(btns[i]);
    }
}

TEST_CASE("adc button test memory leak", "[button][adc][memory leak]")
{
    /** ESP32-S3-Korvo2 board */
    const button_config_t btn_cfg = {0};
    button_adc_config_t btn_adc_cfg = {
        .unit_id = ADC_UNIT_1,
        .adc_channel = 4,
    };

    button_handle_t btns[6] = {NULL};

    const uint16_t vol[6] = {380, 820, 1180, 1570, 1980, 2410};
    for (size_t i = 0; i < 6; i++) {
        btn_adc_cfg.button_index = i;
        if (i == 0) {
            btn_adc_cfg.min = (0 + vol[i]) / 2;
        } else {
            btn_adc_cfg.min = (vol[i - 1] + vol[i]) / 2;
        }

        if (i == 5) {
            btn_adc_cfg.max = (vol[i] + 3000) / 2;
        } else {
            btn_adc_cfg.max = (vol[i] + vol[i + 1]) / 2;
        }

        esp_err_t ret = iot_button_new_adc_device(&btn_cfg, &btn_adc_cfg, &btns[i]);
        TEST_ASSERT(ret == ESP_OK);

        TEST_ASSERT_NOT_NULL(btns[i]);
        iot_button_register_cb(btns[i], BUTTON_PRESS_DOWN, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_UP, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_REPEAT, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_SINGLE_CLICK, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_DOUBLE_CLICK, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_START, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_UP, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_END, NULL, button_event_cb, (void *)i);
    }

    for (size_t i = 0; i < 6; i++) {
        iot_button_delete(btns[i]);
    }
}

--- END OF FILE: .\components\iot_button\test_apps\main\adc_button_test.c ---

--- START OF FILE: .\components\iot_button\test_apps\main\auto_test.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "freertos/event_groups.h"
#include "esp_log.h"
#include "unity.h"
#include "iot_button.h"
#include "button_gpio.h"
#include "driver/gpio.h"

static const char *TAG = "BUTTON AUTO TEST";

#define GPIO_OUTPUT_IO_45 45
#define BUTTON_IO_NUM  0
#define BUTTON_ACTIVE_LEVEL   0

static EventGroupHandle_t g_check = NULL;
static SemaphoreHandle_t g_auto_check_pass = NULL;

static button_event_t state = BUTTON_PRESS_DOWN;

static void button_auto_press_test_task(void *arg)
{
    // test BUTTON_PRESS_DOWN
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));

    // // test BUTTON_PRESS_UP
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(200));

    // test BUTTON_PRESS_REPEAT
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));

    // test BUTTON_PRESS_REPEAT_DONE
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(200));

    // test BUTTON_SINGLE_CLICK
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(200));

    // test BUTTON_DOUBLE_CLICK
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(200));

    // test BUTTON_MULTIPLE_CLICK
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    for (int i = 0; i < 4; i++) {
        gpio_set_level(GPIO_OUTPUT_IO_45, 0);
        vTaskDelay(pdMS_TO_TICKS(100));
        gpio_set_level(GPIO_OUTPUT_IO_45, 1);
        vTaskDelay(pdMS_TO_TICKS(100));
    }
    vTaskDelay(pdMS_TO_TICKS(100));

    // test BUTTON_LONG_PRESS_START
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(1600));

    // test BUTTON_LONG_PRESS_HOLD and BUTTON_LONG_PRESS_UP
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);

    ESP_LOGI(TAG, "Auto Press Success!");
    vTaskDelete(NULL);
}
static void button_auto_check_cb_1(void *arg, void *data)
{
    if (iot_button_get_event(arg) == state) {
        xEventGroupSetBits(g_check, BIT(1));
    }
}
static void button_auto_check_cb(void *arg, void *data)
{
    if (iot_button_get_event(arg) == state) {
        ESP_LOGI(TAG, "Auto check: button event %s pass", iot_button_get_event_str(state));
        xEventGroupSetBits(g_check, BIT(0));
        if (++state >= BUTTON_EVENT_MAX) {
            xSemaphoreGive(g_auto_check_pass);
            return;
        }
    }
}

TEST_CASE("gpio button auto-test", "[button][iot][auto]")
{
    state = BUTTON_PRESS_DOWN;
    g_check = xEventGroupCreate();
    g_auto_check_pass = xSemaphoreCreateBinary();
    xEventGroupSetBits(g_check, BIT(0) | BIT(1));
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);

    /* register iot_button callback for all the button_event */
    for (uint8_t i = 0; i < BUTTON_EVENT_MAX; i++) {
        if (i == BUTTON_MULTIPLE_CLICK) {
            button_event_args_t args = {
                .multiple_clicks.clicks = 4,
            };
            iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_auto_check_cb_1, NULL);
            iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_auto_check_cb, NULL);
        } else {
            iot_button_register_cb(btn, i, NULL, button_auto_check_cb_1, NULL);
            iot_button_register_cb(btn, i, NULL, button_auto_check_cb, NULL);
        }
    }

    TEST_ASSERT_EQUAL(ESP_OK, iot_button_set_param(btn, BUTTON_LONG_PRESS_TIME_MS, (void *)1500));

    gpio_config_t io_conf = {
        .intr_type = GPIO_INTR_DISABLE,
        .mode = GPIO_MODE_OUTPUT,
        .pin_bit_mask = (1ULL << GPIO_OUTPUT_IO_45),
        .pull_down_en = 0,
        .pull_up_en = 0,
    };
    gpio_config(&io_conf);
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);

    xTaskCreate(button_auto_press_test_task, "button_auto_press_test_task", 1024 * 4, NULL, 10, NULL);

    TEST_ASSERT_EQUAL(pdTRUE, xSemaphoreTake(g_auto_check_pass, pdMS_TO_TICKS(6000)));

    for (uint8_t i = 0; i < BUTTON_EVENT_MAX; i++) {
        button_event_args_t args;

        if (i == BUTTON_MULTIPLE_CLICK) {
            args.multiple_clicks.clicks = 4;
            iot_button_unregister_cb(btn, i, &args);
        } else if (i == BUTTON_LONG_PRESS_UP || i == BUTTON_LONG_PRESS_START) {
            args.long_press.press_time = 1500;
            iot_button_unregister_cb(btn, i, &args);
        } else {
            iot_button_unregister_cb(btn, i, NULL);
        }
    }

    TEST_ASSERT_EQUAL(ESP_OK, iot_button_delete(btn));
    vEventGroupDelete(g_check);
    vSemaphoreDelete(g_auto_check_pass);
    vTaskDelay(pdMS_TO_TICKS(100));
}

#define TOLERANCE (CONFIG_BUTTON_PERIOD_TIME_MS * 4)

uint16_t long_press_time[5] = {2000, 2500, 3000, 3500, 4000};
static SemaphoreHandle_t long_press_check = NULL;
static SemaphoreHandle_t long_press_auto_check_pass = NULL;
unsigned int status = 0;

static void button_auto_long_press_test_task(void *arg)
{
    // Test for BUTTON_LONG_PRESS_START
    for (int i = 0; i < 5; i++) {
        xSemaphoreTake(long_press_check, portMAX_DELAY);
        gpio_set_level(GPIO_OUTPUT_IO_45, 0);
        status = (BUTTON_LONG_PRESS_START << 16) | long_press_time[i];
        if (i > 0) {
            vTaskDelay(pdMS_TO_TICKS(long_press_time[i] - long_press_time[i - 1]));
        } else {
            vTaskDelay(pdMS_TO_TICKS(long_press_time[i]));
        }
    }
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    xSemaphoreGive(long_press_auto_check_pass);
    vTaskDelay(pdMS_TO_TICKS(100));
    // Test for BUTTON_LONG_PRESS_UP
    for (int i = 0; i < 5; i++) {
        xSemaphoreTake(long_press_check, portMAX_DELAY);
        status = (BUTTON_LONG_PRESS_UP << 16) | long_press_time[i];
        gpio_set_level(GPIO_OUTPUT_IO_45, 0);
        vTaskDelay(pdMS_TO_TICKS(long_press_time[i] + 10));
        gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    }

    ESP_LOGI(TAG, "Auto Long Press Success!");
    vTaskDelete(NULL);
}

static void button_long_press_auto_check_cb(void *arg, void *data)
{
    uint32_t value = (uint32_t)data;
    uint16_t event = (0xffff0000 & value) >> 16;
    uint16_t time = 0xffff & value;
    uint32_t ticks_time = iot_button_get_ticks_time(arg);
    int32_t diff = ticks_time - time;
    if (status == value && abs(diff) <= TOLERANCE) {
        ESP_LOGI(TAG, "Auto check: button event: %s and time: %d pass", iot_button_get_event_str(event), time);

        if (event == BUTTON_LONG_PRESS_UP && time == long_press_time[4]) {
            xSemaphoreGive(long_press_auto_check_pass);
        }

        xSemaphoreGive(long_press_check);
    }
}

TEST_CASE("gpio button long_press auto-test", "[button][long_press][auto]")
{
    ESP_LOGI(TAG, "Starting the test");
    long_press_check = xSemaphoreCreateBinary();
    long_press_auto_check_pass = xSemaphoreCreateBinary();
    xSemaphoreGive(long_press_check);
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);

    for (int i = 0; i < 5; i++) {
        button_event_args_t args = {
            .long_press.press_time = long_press_time[i],
        };

        uint32_t data = (BUTTON_LONG_PRESS_START << 16) | long_press_time[i];
        iot_button_register_cb(btn, BUTTON_LONG_PRESS_START, &args, button_long_press_auto_check_cb, (void*)data);
    }

    gpio_config_t io_conf = {
        .intr_type = GPIO_INTR_DISABLE,
        .mode = GPIO_MODE_OUTPUT,
        .pin_bit_mask = (1ULL << GPIO_OUTPUT_IO_45),
        .pull_down_en = 0,
        .pull_up_en = 0,
    };
    gpio_config(&io_conf);
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    xTaskCreate(button_auto_long_press_test_task, "button_auto_long_press_test_task", 1024 * 4, NULL, 10, NULL);

    xSemaphoreTake(long_press_auto_check_pass, portMAX_DELAY);
    iot_button_unregister_cb(btn, BUTTON_LONG_PRESS_START, NULL);

    for (int i = 0; i < 5; i++) {
        button_event_args_t args = {
            .long_press.press_time = long_press_time[i]
        };

        uint32_t data = (BUTTON_LONG_PRESS_UP << 16) | long_press_time[i];
        iot_button_register_cb(btn, BUTTON_LONG_PRESS_UP, &args, button_long_press_auto_check_cb, (void*)data);
    }
    TEST_ASSERT_EQUAL(pdTRUE, xSemaphoreTake(long_press_auto_check_pass, pdMS_TO_TICKS(17000)));
    TEST_ASSERT_EQUAL(ESP_OK, iot_button_delete(btn));
    vSemaphoreDelete(long_press_check);
    vSemaphoreDelete(long_press_auto_check_pass);
    vTaskDelay(pdMS_TO_TICKS(100));
}

--- END OF FILE: .\components\iot_button\test_apps\main\auto_test.c ---

--- START OF FILE: .\components\iot_button\test_apps\main\button_test_main.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include "unity.h"
#include "unity_test_runner.h"
#include "unity_test_utils_memory.h"
#include "esp_heap_caps.h"
#include "sdkconfig.h"

#define LEAKS (400)

void setUp(void)
{
    unity_utils_record_free_mem();
}

void tearDown(void)
{
    unity_utils_evaluate_leaks_direct(LEAKS);
}

void app_main(void)
{
    /*
    * ____          _    _                  _______          _
    *|  _ \        | |  | |                |__   __|        | |
    *| |_) | _   _ | |_ | |_  ___   _ __      | |  ___  ___ | |_
    *|  _ < | | | || __|| __|/ _ \ | '_ \     | | / _ \/ __|| __|
    *| |_) || |_| || |_ | |_| (_) || | | |    | ||  __/\__ \| |_
    *|____/  \__,_| \__| \__|\___/ |_| |_|    |_| \___||___/ \__|
    */
    printf("  ____          _    _                  _______          _   \n");
    printf(" |  _ \\        | |  | |                |__   __|        | |  \n");
    printf(" | |_) | _   _ | |_ | |_  ___   _ __      | |  ___  ___ | |_ \n");
    printf(" |  _ < | | | || __|| __|/ _ \\ | '_ \\     | | / _ \\/ __|| __|\n");
    printf(" | |_) || |_| || |_ | |_| (_) || | | |    | ||  __/\\__ \\| |_ \n");
    printf(" |____/  \\__,_| \\__| \\__|\\___/ |_| |_|    |_| \\___||___/ \\__|\n");
    unity_run_menu();
}

--- END OF FILE: .\components\iot_button\test_apps\main\button_test_main.c ---

--- START OF FILE: .\components\iot_button\test_apps\main\CMakeLists.txt ---
if("${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}" VERSION_GREATER_EQUAL "5.0")
    list(APPEND PRIVREQ esp_adc)
endif()

idf_component_register(SRC_DIRS "."
                       PRIV_INCLUDE_DIRS "."
                       PRIV_REQUIRES esp_event unity test_utils button ${PRIVREQ}
                       WHOLE_ARCHIVE)

--- END OF FILE: .\components\iot_button\test_apps\main\CMakeLists.txt ---

--- START OF FILE: .\components\iot_button\test_apps\main\custom_button_test.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "unity.h"
#include "iot_button.h"
#include "driver/gpio.h"

static const char *TAG = "CUSTOM BUTTON TEST";

#define BUTTON_IO_NUM  0
#define BUTTON_ACTIVE_LEVEL   0

static void button_event_cb(void *arg, void *data)
{
    button_event_t event = iot_button_get_event(arg);
    ESP_LOGI(TAG, "%s", iot_button_get_event_str(event));
    if (BUTTON_PRESS_REPEAT == event || BUTTON_PRESS_REPEAT_DONE == event) {
        ESP_LOGI(TAG, "\tREPEAT[%d]", iot_button_get_repeat(arg));
    }

    if (BUTTON_PRESS_UP == event || BUTTON_LONG_PRESS_HOLD == event || BUTTON_LONG_PRESS_UP == event) {
        ESP_LOGI(TAG, "\tTICKS[%"PRIu32"]", iot_button_get_ticks_time(arg));
    }

    if (BUTTON_MULTIPLE_CLICK == event) {
        ESP_LOGI(TAG, "\tMULTIPLE[%d]", (int)data);
    }
}

typedef struct {
    button_driver_t base;
    int32_t gpio_num;              /**< num of gpio */
    uint8_t active_level;          /**< gpio level when press down */
} custom_gpio_obj;

static uint8_t button_get_key_level(button_driver_t *button_driver)
{
    custom_gpio_obj *custom_btn = __containerof(button_driver, custom_gpio_obj, base);
    int level = gpio_get_level(custom_btn->gpio_num);
    return level == custom_btn->active_level ? 1 : 0;
}

static esp_err_t button_del(button_driver_t *button_driver)
{
    return ESP_OK;
}

TEST_CASE("custom button test", "[button][custom]")
{
    gpio_config_t gpio_conf = {
        .pin_bit_mask = 1ULL << BUTTON_IO_NUM,
                             .mode = GPIO_MODE_INPUT,
                             .pull_up_en = 1,
                             .pull_down_en = 0,
                             .intr_type = GPIO_INTR_DISABLE,
    };
    gpio_config(&gpio_conf);

    custom_gpio_obj *custom_btn = (custom_gpio_obj *)calloc(1, sizeof(custom_gpio_obj));
    TEST_ASSERT_NOT_NULL(custom_btn);
    custom_btn->active_level = BUTTON_ACTIVE_LEVEL;
    custom_btn->gpio_num = BUTTON_IO_NUM;

    button_handle_t btn = NULL;
    const button_config_t btn_cfg = {0};
    custom_btn->base.get_key_level = button_get_key_level;
    custom_btn->base.del = button_del;
    esp_err_t ret = iot_button_create(&btn_cfg, &custom_btn->base, &btn);
    TEST_ASSERT(ESP_OK == ret);
    TEST_ASSERT_NOT_NULL(btn);
    iot_button_register_cb(btn, BUTTON_PRESS_DOWN, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_SINGLE_CLICK, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_DOUBLE_CLICK, NULL, button_event_cb, NULL);

    /*!< Multiple Click must provide button_event_args_t */
    /*!< Double Click */
    button_event_args_t args = {
        .multiple_clicks.clicks = 2,
    };
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)2);
    /*!< Triple Click */
    args.multiple_clicks.clicks = 3;
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)3);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_START, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_END, NULL, button_event_cb, NULL);

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    iot_button_delete(btn);
}

--- END OF FILE: .\components\iot_button\test_apps\main\custom_button_test.c ---

--- START OF FILE: .\components\iot_button\test_apps\main\gpio_button_test.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "unity.h"
#include "iot_button.h"
#include "button_gpio.h"

static const char *TAG = "GPIO BUTTON TEST";

#define BUTTON_IO_NUM  0
#define BUTTON_ACTIVE_LEVEL   0

static void button_event_cb(void *arg, void *data)
{
    button_event_t event = iot_button_get_event(arg);
    ESP_LOGI(TAG, "%s", iot_button_get_event_str(event));
    if (BUTTON_PRESS_REPEAT == event || BUTTON_PRESS_REPEAT_DONE == event) {
        ESP_LOGI(TAG, "\tREPEAT[%d]", iot_button_get_repeat(arg));
    }

    if (BUTTON_PRESS_UP == event || BUTTON_LONG_PRESS_HOLD == event || BUTTON_LONG_PRESS_UP == event) {
        ESP_LOGI(TAG, "\tTICKS[%"PRIu32"]", iot_button_get_ticks_time(arg));
    }

    if (BUTTON_MULTIPLE_CLICK == event) {
        ESP_LOGI(TAG, "\tMULTIPLE[%d]", (int)data);
    }
}

TEST_CASE("gpio button test", "[button][gpio]")
{
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);
    iot_button_register_cb(btn, BUTTON_PRESS_DOWN, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_SINGLE_CLICK, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_DOUBLE_CLICK, NULL, button_event_cb, NULL);

    /*!< Multiple Click must provide button_event_args_t */
    /*!< Double Click */
    button_event_args_t args = {
        .multiple_clicks.clicks = 2,
    };
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)2);
    /*!< Triple Click */
    args.multiple_clicks.clicks = 3;
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)3);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_START, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_END, NULL, button_event_cb, NULL);

    uint8_t level = 0;
    level = iot_button_get_key_level(btn);
    ESP_LOGI(TAG, "button level is %d", level);

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    iot_button_delete(btn);
}

TEST_CASE("gpio button get event test", "[button][gpio][event test]")
{
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);

    uint8_t level = 0;
    level = iot_button_get_key_level(btn);
    ESP_LOGI(TAG, "button level is %d", level);

    while (1) {
        button_event_t event = iot_button_get_event(btn);
        if (event != BUTTON_NONE_PRESS) {
            ESP_LOGI(TAG, "event is %s", iot_button_get_event_str(event));
        }
        vTaskDelay(pdMS_TO_TICKS(1));
    }

    iot_button_delete(btn);
}

TEST_CASE("gpio button test power save", "[button][gpio][power save]")
{
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
        .enable_power_save = true,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);

    iot_button_register_cb(btn, BUTTON_PRESS_DOWN, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_SINGLE_CLICK, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_DOUBLE_CLICK, NULL, button_event_cb, NULL);

    /*!< Multiple Click must provide button_event_args_t */
    /*!< Double Click */
    button_event_args_t args = {
        .multiple_clicks.clicks = 2,
    };
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)2);
    /*!< Triple Click */
    args.multiple_clicks.clicks = 3;
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)3);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_START, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_END, NULL, button_event_cb, NULL);

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    iot_button_delete(btn);
}

TEST_CASE("gpio button test memory leak", "[button][gpio][memory leak]")
{
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);

    iot_button_register_cb(btn, BUTTON_PRESS_DOWN, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_SINGLE_CLICK, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_DOUBLE_CLICK, NULL, button_event_cb, NULL);

    /*!< Multiple Click must provide button_event_args_t */
    /*!< Double Click */
    button_event_args_t args = {
        .multiple_clicks.clicks = 2,
    };
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)2);
    /*!< Triple Click */
    args.multiple_clicks.clicks = 3;
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)3);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_START, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_END, NULL, button_event_cb, NULL);

    iot_button_delete(btn);
}

--- END OF FILE: .\components\iot_button\test_apps\main\gpio_button_test.c ---

--- START OF FILE: .\components\iot_button\test_apps\main\matrix_button_test.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "unity.h"
#include "iot_button.h"
#include "button_matrix.h"

static const char *TAG = "MATRIX BUTTON TEST";

static void button_event_cb(void *arg, void *data)
{
    button_event_t event = iot_button_get_event(arg);
    ESP_LOGI(TAG, "BUTTON[%d] %s", (int)data, iot_button_get_event_str(event));
    if (BUTTON_PRESS_REPEAT == event || BUTTON_PRESS_REPEAT_DONE == event) {
        ESP_LOGI(TAG, "\tREPEAT[%d]", iot_button_get_repeat(arg));
    }

    if (BUTTON_PRESS_UP == event || BUTTON_LONG_PRESS_HOLD == event || BUTTON_LONG_PRESS_UP == event) {
        ESP_LOGI(TAG, "\tTICKS[%"PRIu32"]", iot_button_get_ticks_time(arg));
    }

    if (BUTTON_MULTIPLE_CLICK == event) {
        ESP_LOGI(TAG, "\tMULTIPLE[%d]", (int)data);
    }
}

TEST_CASE("matrix keyboard button test", "[button][matrix key]")
{
    const button_config_t btn_cfg = {0};
    const button_matrix_config_t matrix_cfg = {
        .row_gpios = (int32_t[]){4, 5, 6, 7},
        .col_gpios = (int32_t[]){3, 8, 16, 15},
        .row_gpio_num = 4,
        .col_gpio_num = 4,
    };

    button_handle_t btns[16] = {0};
    size_t btn_num = 16;
    esp_err_t ret = iot_button_new_matrix_device(&btn_cfg, &matrix_cfg, btns, &btn_num);
    TEST_ASSERT(ret == ESP_OK);

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            int index = i * 4 + j;
            TEST_ASSERT_NOT_NULL(btns[index]);
            iot_button_register_cb(btns[index], BUTTON_PRESS_DOWN, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_PRESS_UP, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_PRESS_REPEAT, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_SINGLE_CLICK, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_DOUBLE_CLICK, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_LONG_PRESS_START, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_LONG_PRESS_UP, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_PRESS_END, NULL, button_event_cb, (void *)index);
        }
    }

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            iot_button_delete(btns[i * 4 + j]);
        }
    }
}

--- END OF FILE: .\components\iot_button\test_apps\main\matrix_button_test.c ---

--- START OF FILE: .\components\iot_button\test_apps\CMakeLists.txt ---

# The following lines of boilerplate have to be in your project's CMakeLists
# in this exact order for cmake to work correctly
cmake_minimum_required(VERSION 3.5)

set(EXTRA_COMPONENT_DIRS "$ENV{IDF_PATH}/tools/unit-test-app/components"
                         "../../button")
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(button_test)

--- END OF FILE: .\components\iot_button\test_apps\CMakeLists.txt ---

--- START OF FILE: .\components\iot_button\button_adc.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <string.h>
#include <inttypes.h>
#include "esp_log.h"
#include "esp_check.h"
#include "esp_timer.h"
#include "esp_idf_version.h"
#include "soc/soc_caps.h"
#include "esp_adc/adc_oneshot.h"
#include "esp_adc/adc_cali.h"
#include "esp_adc/adc_cali_scheme.h"
#include "button_adc.h"
#include "button_interface.h"

static const char *TAG = "adc_button";

#define DEFAULT_VREF    1100
#define NO_OF_SAMPLES   CONFIG_ADC_BUTTON_SAMPLE_TIMES     //Multisampling

/*!< Using atten bigger than 6db by default, it will be 11db or 12db in different target */
#define DEFAULT_ADC_ATTEN         (ADC_ATTEN_DB_6 + 1)

#define ADC_BUTTON_WIDTH          SOC_ADC_RTC_MAX_BITWIDTH
#define ADC_BUTTON_CHANNEL_MAX    SOC_ADC_MAX_CHANNEL_NUM
#define ADC_BUTTON_ATTEN          DEFAULT_ADC_ATTEN

#define ADC_BUTTON_MAX_CHANNEL  CONFIG_ADC_BUTTON_MAX_CHANNEL
#define ADC_BUTTON_MAX_BUTTON   CONFIG_ADC_BUTTON_MAX_BUTTON_PER_CHANNEL

// ESP32C3 ADC2 it has been deprecated.
#if (SOC_ADC_PERIPH_NUM >= 2) && !CONFIG_IDF_TARGET_ESP32C3
#define ADC_UNIT_NUM 2
#else
#define ADC_UNIT_NUM 1
#endif

typedef struct {
    uint16_t min;
    uint16_t max;
} button_data_t;

typedef struct {
    uint8_t channel;
    uint8_t is_init;
    button_data_t btns[ADC_BUTTON_MAX_BUTTON];  /* all button on the channel */
    uint64_t last_time;  /* the last time of adc sample */
} btn_adc_channel_t;

typedef enum {
    ADC_NONE_INIT = 0,
    ADC_INIT_BY_ADC_BUTTON,
    ADC_INIT_BY_USER,
} adc_init_info_t;

typedef struct {
    adc_init_info_t is_configured;
    adc_cali_handle_t adc_cali_handle;
    adc_oneshot_unit_handle_t adc_handle;
    btn_adc_channel_t ch[ADC_BUTTON_MAX_CHANNEL];
    uint8_t ch_num;
} btn_adc_unit_t;

typedef struct {
    btn_adc_unit_t unit[ADC_UNIT_NUM];
} button_adc_t;
typedef struct {
    button_driver_t base;
    adc_unit_t unit_id;
    uint32_t ch;
    uint32_t index;
} button_adc_obj;

static button_adc_t g_button = {0};

static int find_unused_channel(adc_unit_t unit_id)
{
    for (size_t i = 0; i < ADC_BUTTON_MAX_CHANNEL; i++) {
        if (0 == g_button.unit[unit_id].ch[i].is_init) {
            return i;
        }
    }
    return -1;
}

static int find_channel(adc_unit_t unit_id, uint8_t channel)
{
    for (size_t i = 0; i < ADC_BUTTON_MAX_CHANNEL; i++) {
        if (channel == g_button.unit[unit_id].ch[i].channel) {
            return i;
        }
    }
    return -1;
}

static bool adc_calibration_init(adc_unit_t unit, adc_atten_t atten, adc_cali_handle_t *out_handle)
{
    adc_cali_handle_t handle = NULL;
    esp_err_t ret = ESP_ERR_NOT_SUPPORTED;
    bool calibrated = false;

#if ADC_CALI_SCHEME_CURVE_FITTING_SUPPORTED
    if (!calibrated) {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Curve Fitting");
        adc_cali_curve_fitting_config_t cali_config = {
            .unit_id = unit,
            .atten = atten,
            .bitwidth = ADC_BUTTON_WIDTH,
        };
        ret = adc_cali_create_scheme_curve_fitting(&cali_config, &handle);
        if (ret == ESP_OK) {
            calibrated = true;
        }
    }
#endif

#if ADC_CALI_SCHEME_LINE_FITTING_SUPPORTED
    if (!calibrated) {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Line Fitting");
        adc_cali_line_fitting_config_t cali_config = {
            .unit_id = unit,
            .atten = atten,
            .bitwidth = ADC_BUTTON_WIDTH,
        };
        ret = adc_cali_create_scheme_line_fitting(&cali_config, &handle);
        if (ret == ESP_OK) {
            calibrated = true;
        }
    }
#endif

    *out_handle = handle;
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "Calibration Success");
    } else if (ret == ESP_ERR_NOT_SUPPORTED || !calibrated) {
        ESP_LOGW(TAG, "eFuse not burnt, skip software calibration");
    } else if (ret == ESP_ERR_NOT_SUPPORTED) {
        ESP_LOGW(TAG, "Calibration not supported");
    } else {
        ESP_LOGE(TAG, "Invalid arg or no memory");
    }

    return calibrated;
}

static bool adc_calibration_deinit(adc_cali_handle_t handle)
{
#if ADC_CALI_SCHEME_CURVE_FITTING_SUPPORTED
    if (adc_cali_delete_scheme_curve_fitting(handle) == ESP_OK) {
        return true;
    }
#endif

#if ADC_CALI_SCHEME_LINE_FITTING_SUPPORTED
    if (adc_cali_delete_scheme_line_fitting(handle) == ESP_OK) {
        return true;
    }
#endif

    return false;
}

esp_err_t button_adc_del(button_driver_t *button_driver)
{
    button_adc_obj *adc_btn = __containerof(button_driver, button_adc_obj, base);
    ESP_RETURN_ON_FALSE(adc_btn->ch < ADC_BUTTON_CHANNEL_MAX, ESP_ERR_INVALID_ARG, TAG, "channel out of range");
    ESP_RETURN_ON_FALSE(adc_btn->index < ADC_BUTTON_MAX_BUTTON, ESP_ERR_INVALID_ARG, TAG, "button_index out of range");

    int ch_index = find_channel(adc_btn->unit_id, adc_btn->ch);
    ESP_RETURN_ON_FALSE(ch_index >= 0, ESP_ERR_INVALID_ARG, TAG, "can't find the channel");

    g_button.unit[adc_btn->unit_id].ch[ch_index].btns[adc_btn->index].max = 0;
    g_button.unit[adc_btn->unit_id].ch[ch_index].btns[adc_btn->index].min = 0;

    /** check button usage on the channel*/
    uint8_t unused_button = 0;
    for (size_t i = 0; i < ADC_BUTTON_MAX_BUTTON; i++) {
        if (0 == g_button.unit[adc_btn->unit_id].ch[ch_index].btns[i].max) {
            unused_button++;
        }
    }
    if (unused_button == ADC_BUTTON_MAX_BUTTON && g_button.unit[adc_btn->unit_id].ch[ch_index].is_init) {  /**< if all button is unused, deinit the channel */
        g_button.unit[adc_btn->unit_id].ch[ch_index].is_init = 0;
        g_button.unit[adc_btn->unit_id].ch[ch_index].channel = ADC_BUTTON_CHANNEL_MAX;
        ESP_LOGD(TAG, "all button is unused on channel%d, deinit the channel", g_button.unit[adc_btn->unit_id].ch[ch_index].channel);
    }

    /** check channel usage on the adc*/
    uint8_t unused_ch = 0;
    for (size_t i = 0; i < ADC_BUTTON_MAX_CHANNEL; i++) {
        if (0 == g_button.unit[adc_btn->unit_id].ch[i].is_init) {
            unused_ch++;
        }
    }
    if (unused_ch == ADC_BUTTON_MAX_CHANNEL && g_button.unit[adc_btn->unit_id].is_configured) { /**< if all channel is unused, deinit the adc */
        if (g_button.unit[adc_btn->unit_id].is_configured == ADC_INIT_BY_ADC_BUTTON) {
            esp_err_t ret = adc_oneshot_del_unit(g_button.unit[adc_btn->unit_id].adc_handle);
            ESP_RETURN_ON_FALSE(ret == ESP_OK, ret, TAG, "adc oneshot del unit fail");
            adc_calibration_deinit(g_button.unit[adc_btn->unit_id].adc_cali_handle);
        }

        g_button.unit[adc_btn->unit_id].is_configured = ADC_NONE_INIT;
        memset(&g_button.unit[adc_btn->unit_id], 0, sizeof(btn_adc_unit_t));
        ESP_LOGD(TAG, "all channel is unused, , deinit adc");
    }
    free(adc_btn);

    return ESP_OK;
}

static uint32_t get_adc_volatge(adc_unit_t unit_id, uint8_t channel)
{
    uint32_t adc_reading = 0;
    int adc_raw = 0;
    for (int i = 0; i < NO_OF_SAMPLES; i++) {
        adc_oneshot_read(g_button.unit[unit_id].adc_handle, channel, &adc_raw);
        adc_reading += adc_raw;
    }
    adc_reading /= NO_OF_SAMPLES;
    //Convert adc_reading to voltage in mV
    int voltage = 0;
    adc_cali_raw_to_voltage(g_button.unit[unit_id].adc_cali_handle, adc_reading, &voltage);
    ESP_LOGV(TAG, "Raw: %"PRIu32"\tVoltage: %dmV", adc_reading, voltage);
    return voltage;
}

uint8_t button_adc_get_key_level(button_driver_t *button_driver)
{
    button_adc_obj *adc_btn = __containerof(button_driver, button_adc_obj, base);
    static uint16_t vol = 0;
    uint32_t ch = adc_btn->ch;
    uint32_t index = adc_btn->index;
    ESP_RETURN_ON_FALSE(ch < ADC_BUTTON_CHANNEL_MAX, 0, TAG, "channel out of range");
    ESP_RETURN_ON_FALSE(index < ADC_BUTTON_MAX_BUTTON, 0, TAG, "button_index out of range");

    int ch_index = find_channel(adc_btn->unit_id, ch);
    ESP_RETURN_ON_FALSE(ch_index >= 0, 0, TAG, "The button_index is not init");

    /** It starts only when the elapsed time is more than 1ms */
    if ((esp_timer_get_time() - g_button.unit[adc_btn->unit_id].ch[ch_index].last_time) > 1000) {
        vol = get_adc_volatge(adc_btn->unit_id, ch);
        g_button.unit[adc_btn->unit_id].ch[ch_index].last_time = esp_timer_get_time();
    }

    if (vol <= g_button.unit[adc_btn->unit_id].ch[ch_index].btns[index].max &&
            vol >= g_button.unit[adc_btn->unit_id].ch[ch_index].btns[index].min) {
        return BUTTON_ACTIVE;
    }
    return BUTTON_INACTIVE;
}

esp_err_t iot_button_new_adc_device(const button_config_t *button_config, const button_adc_config_t *adc_config, button_handle_t *ret_button)
{
    esp_err_t ret = ESP_OK;
    ESP_RETURN_ON_FALSE(button_config && adc_config && ret_button, ESP_ERR_INVALID_ARG, TAG, "Invalid argument");
    ESP_RETURN_ON_FALSE(adc_config->unit_id < ADC_UNIT_NUM, ESP_ERR_INVALID_ARG, TAG, "adc_handle out of range");
    ESP_RETURN_ON_FALSE(adc_config->adc_channel < ADC_BUTTON_CHANNEL_MAX, ESP_ERR_INVALID_ARG, TAG, "channel out of range");
    ESP_RETURN_ON_FALSE(adc_config->button_index < ADC_BUTTON_MAX_BUTTON, ESP_ERR_INVALID_ARG, TAG, "button_index out of range");
    ESP_RETURN_ON_FALSE(adc_config->max > 0, ESP_ERR_INVALID_ARG, TAG, "key max voltage invalid");
    button_adc_obj *adc_btn = calloc(1, sizeof(button_adc_obj));
    ESP_RETURN_ON_FALSE(adc_btn, ESP_ERR_NO_MEM, TAG, "calloc fail");
    adc_btn->unit_id = adc_config->unit_id;

    int ch_index = find_channel(adc_btn->unit_id, adc_config->adc_channel);
    if (ch_index >= 0) { /**< the channel has been initialized */
        ESP_GOTO_ON_FALSE(g_button.unit[adc_btn->unit_id].ch[ch_index].btns[adc_config->button_index].max == 0, ESP_ERR_INVALID_STATE, err, TAG, "The button_index has been used");
    } else { /**< this is a new channel */
        int unused_ch_index = find_unused_channel(adc_config->unit_id);
        ESP_GOTO_ON_FALSE(unused_ch_index >= 0, ESP_ERR_INVALID_STATE, err, TAG, "exceed max channel number, can't create a new channel");
        ch_index = unused_ch_index;
    }

    /** initialize adc */
    if (0 == g_button.unit[adc_btn->unit_id].is_configured) {
        esp_err_t ret;
        if (NULL == adc_config->adc_handle) {
            //ADC1 Init
            adc_oneshot_unit_init_cfg_t init_config = {
                .unit_id = adc_btn->unit_id,
            };
            ret = adc_oneshot_new_unit(&init_config, &g_button.unit[adc_btn->unit_id].adc_handle);
            ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "adc oneshot new unit fail!");
            g_button.unit[adc_btn->unit_id].is_configured = ADC_INIT_BY_ADC_BUTTON;
        } else {
            g_button.unit[adc_btn->unit_id].adc_handle = *adc_config->adc_handle;
            ESP_LOGI(TAG, "ADC1 has been initialized");
            g_button.unit[adc_btn->unit_id].is_configured = ADC_INIT_BY_USER;
        }

    }

    /** initialize adc channel */
    if (0 == g_button.unit[adc_btn->unit_id].ch[ch_index].is_init) {
        //ADC1 Config
        adc_oneshot_chan_cfg_t oneshot_config = {
            .bitwidth = ADC_BUTTON_WIDTH,
            .atten = ADC_BUTTON_ATTEN,
        };
        esp_err_t ret = adc_oneshot_config_channel(g_button.unit[adc_btn->unit_id].adc_handle, adc_config->adc_channel, &oneshot_config);
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "adc oneshot config channel fail!");
        //-------------ADC1 Calibration Init---------------//
        adc_calibration_init(adc_btn->unit_id, ADC_BUTTON_ATTEN, &g_button.unit[adc_btn->unit_id].adc_cali_handle);
        g_button.unit[adc_btn->unit_id].ch[ch_index].channel = adc_config->adc_channel;
        g_button.unit[adc_btn->unit_id].ch[ch_index].is_init = 1;
        g_button.unit[adc_btn->unit_id].ch[ch_index].last_time = 0;
    }
    g_button.unit[adc_btn->unit_id].ch[ch_index].btns[adc_config->button_index].max = adc_config->max;
    g_button.unit[adc_btn->unit_id].ch[ch_index].btns[adc_config->button_index].min = adc_config->min;
    g_button.unit[adc_btn->unit_id].ch_num++;

    adc_btn->ch = adc_config->adc_channel;
    adc_btn->index = adc_config->button_index;
    adc_btn->base.get_key_level = button_adc_get_key_level;
    adc_btn->base.del = button_adc_del;
    ret = iot_button_create(button_config, &adc_btn->base, ret_button);
    ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Create button failed");

    return ESP_OK;
err:
    if (adc_btn) {
        free(adc_btn);
    }
    return ret;
}

--- END OF FILE: .\components\iot_button\button_adc.c ---

--- START OF FILE: .\components\iot_button\button_gpio.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include "esp_log.h"
#include "esp_err.h"
#include "esp_check.h"
#include "driver/gpio.h"
#include "button_gpio.h"
#include "esp_sleep.h"
#include "button_interface.h"
#include "iot_button.h"

static const char *TAG = "gpio_button";

typedef struct {
    button_driver_t base;          /**< button driver */
    int32_t gpio_num;              /**< num of gpio */
    uint8_t active_level;          /**< gpio level when press down */
    bool enable_power_save;        /**< enable power save */
} button_gpio_obj;

static esp_err_t button_gpio_del(button_driver_t *button_driver)
{
    button_gpio_obj *gpio_btn = __containerof(button_driver, button_gpio_obj, base);
    esp_err_t ret = gpio_reset_pin(gpio_btn->gpio_num);
    free(gpio_btn);
    return ret;
}

static uint8_t button_gpio_get_key_level(button_driver_t *button_driver)
{
    button_gpio_obj *gpio_btn = __containerof(button_driver, button_gpio_obj, base);
    int level = gpio_get_level(gpio_btn->gpio_num);
    return level == gpio_btn->active_level ? 1 : 0;
}

static esp_err_t button_gpio_enable_gpio_wakeup(uint32_t gpio_num, uint8_t active_level, bool enable)
{
    esp_err_t ret;
    if (enable) {
        gpio_intr_enable(gpio_num);
        ret = gpio_wakeup_enable(gpio_num, active_level == 0 ? GPIO_INTR_LOW_LEVEL : GPIO_INTR_HIGH_LEVEL);
    } else {
        gpio_intr_disable(gpio_num);
        ret = gpio_wakeup_disable(gpio_num);
    }
    return ret;
}

static esp_err_t button_gpio_set_intr(int gpio_num, gpio_int_type_t intr_type, gpio_isr_t isr_handler)
{
    static bool isr_service_installed = false;
    gpio_set_intr_type(gpio_num, intr_type);
    if (!isr_service_installed) {
        gpio_install_isr_service(ESP_INTR_FLAG_IRAM);
        isr_service_installed = true;
    }
    gpio_isr_handler_add(gpio_num, isr_handler, (void *)gpio_num);
    return ESP_OK;
}

static void button_power_save_isr_handler(void* arg)
{
    /*!< resume the button */
    iot_button_resume();
    /*!< disable gpio wakeup not need active level*/
    button_gpio_enable_gpio_wakeup((uint32_t)arg, 0, false);
}

static esp_err_t button_enter_power_save(button_driver_t *button_driver)
{
    button_gpio_obj *gpio_btn = __containerof(button_driver, button_gpio_obj, base);
    return button_gpio_enable_gpio_wakeup(gpio_btn->gpio_num, gpio_btn->active_level, true);
}

esp_err_t iot_button_new_gpio_device(const button_config_t *button_config, const button_gpio_config_t *gpio_cfg, button_handle_t *ret_button)
{
    button_gpio_obj *gpio_btn = NULL;
    esp_err_t ret = ESP_OK;
    ESP_GOTO_ON_FALSE(button_config && gpio_cfg && ret_button, ESP_ERR_INVALID_ARG, err, TAG, "Invalid argument");
    ESP_GOTO_ON_FALSE(GPIO_IS_VALID_GPIO(gpio_cfg->gpio_num), ESP_ERR_INVALID_ARG, err, TAG, "GPIO number error");

    gpio_btn = (button_gpio_obj *)calloc(1, sizeof(button_gpio_obj));
    ESP_GOTO_ON_FALSE(gpio_btn, ESP_ERR_NO_MEM, err, TAG, "No memory for gpio button");
    gpio_btn->gpio_num = gpio_cfg->gpio_num;
    gpio_btn->active_level = gpio_cfg->active_level;
    gpio_btn->enable_power_save = gpio_cfg->enable_power_save;

    gpio_config_t gpio_conf = {0};
    gpio_conf.intr_type = GPIO_INTR_DISABLE;
    gpio_conf.mode = GPIO_MODE_INPUT;
    gpio_conf.pin_bit_mask = (1ULL << gpio_cfg->gpio_num);
    if (!gpio_cfg->disable_pull) {
        if (gpio_cfg->active_level) {
            gpio_conf.pull_down_en = GPIO_PULLDOWN_ENABLE;
            gpio_conf.pull_up_en = GPIO_PULLUP_DISABLE;
        } else {
            gpio_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
            gpio_conf.pull_up_en = GPIO_PULLUP_ENABLE;
        }
    }
    gpio_config(&gpio_conf);

    if (gpio_cfg->enable_power_save) {
#if CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP
        if (!esp_sleep_is_valid_wakeup_gpio(gpio_cfg->gpio_num)) {
            ESP_LOGE(TAG, "GPIO %ld is not a valid wakeup source under CONFIG_GPIO_BUTTON_SUPPORT_POWER_SAVE", gpio_cfg->gpio_num);
            return ESP_FAIL;
        }
        gpio_hold_en(gpio_cfg->gpio_num);
#endif
        /* Enable wake up from GPIO */
        esp_err_t ret = gpio_wakeup_enable(gpio_cfg->gpio_num, gpio_cfg->active_level == 0 ? GPIO_INTR_LOW_LEVEL : GPIO_INTR_HIGH_LEVEL);
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_ERR_INVALID_STATE, err, TAG, "Enable gpio wakeup failed");
#if CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP
#if SOC_PM_SUPPORT_EXT1_WAKEUP
        ret = esp_sleep_enable_ext1_wakeup_io((1ULL << gpio_cfg->gpio_num), gpio_cfg->active_level == 0 ? ESP_EXT1_WAKEUP_ANY_LOW : ESP_EXT1_WAKEUP_ANY_HIGH);
#else
        /*!< Not support etc: esp32c2, esp32c3. Target must support ext1 wakeup */
        ret = ESP_FAIL;
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Target must support ext1 wakeup");
#endif
#else
        ret = esp_sleep_enable_gpio_wakeup();
#endif
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Configure gpio as wakeup source failed");

        ret = button_gpio_set_intr(gpio_btn->gpio_num, gpio_cfg->active_level == 0 ? GPIO_INTR_LOW_LEVEL : GPIO_INTR_HIGH_LEVEL, button_power_save_isr_handler);
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Set gpio interrupt failed");

        gpio_btn->base.enable_power_save = true;
        gpio_btn->base.enter_power_save = button_enter_power_save;
    }

    gpio_btn->base.get_key_level = button_gpio_get_key_level;
    gpio_btn->base.del = button_gpio_del;

    ret = iot_button_create(button_config, &gpio_btn->base, ret_button);
    ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Create button failed");

    return ESP_OK;
err:
    if (gpio_btn) {
        free(gpio_btn);
    }
    return ret;
}

--- END OF FILE: .\components\iot_button\button_gpio.c ---

--- START OF FILE: .\components\iot_button\button_matrix.c ---
/*
 * SPDX-FileCopyrightText: 2023-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <inttypes.h>
#include "esp_log.h"
#include "esp_check.h"
#include "driver/gpio.h"
#include "button_matrix.h"
#include "button_interface.h"

static const char *TAG = "matrix_button";

typedef struct {
    button_driver_t base;          /**< base button driver */
    int32_t row_gpio_num;          /**< row gpio */
    int32_t col_gpio_num;          /**< col gpio */
} button_matrix_obj;

static esp_err_t button_matrix_gpio_init(int32_t gpio_num, gpio_mode_t mode)
{
    ESP_RETURN_ON_FALSE(GPIO_IS_VALID_GPIO(gpio_num), ESP_ERR_INVALID_ARG, TAG, "gpio_num error");
    gpio_config_t gpio_conf = {0};
    gpio_conf.intr_type = GPIO_INTR_DISABLE;
    gpio_conf.pull_down_en = GPIO_PULLDOWN_ENABLE;
    gpio_conf.pin_bit_mask = (1ULL << gpio_num);
    gpio_conf.mode = mode;
    gpio_config(&gpio_conf);
    return ESP_OK;
}

esp_err_t button_matrix_del(button_driver_t *button_driver)
{
    button_matrix_obj *matrix_btn = __containerof(button_driver, button_matrix_obj, base);
    //Reset an gpio to default state (select gpio function, enable pullup and disable input and output).
    gpio_reset_pin(matrix_btn->row_gpio_num);
    gpio_reset_pin(matrix_btn->col_gpio_num);
    free(matrix_btn);
    return ESP_OK;
}

uint8_t button_matrix_get_key_level(button_driver_t *button_driver)
{
    button_matrix_obj *matrix_btn = __containerof(button_driver, button_matrix_obj, base);
    gpio_set_level(matrix_btn->row_gpio_num, 1);
    uint8_t level = gpio_get_level(matrix_btn->col_gpio_num);
    gpio_set_level(matrix_btn->row_gpio_num, 0);
    return level;
}

esp_err_t iot_button_new_matrix_device(const button_config_t *button_config, const button_matrix_config_t *matrix_config, button_handle_t *ret_button, size_t *size)
{
    esp_err_t ret = ESP_OK;
    ESP_RETURN_ON_FALSE(button_config && matrix_config && ret_button, ESP_ERR_INVALID_ARG, TAG, "Invalid argument");
    ESP_RETURN_ON_FALSE(matrix_config->col_gpios && matrix_config->row_gpios, ESP_ERR_INVALID_ARG, TAG, "Invalid matrix config");
    ESP_RETURN_ON_FALSE(matrix_config->col_gpio_num > 0 && matrix_config->row_gpio_num > 0, ESP_ERR_INVALID_ARG, TAG, "Invalid matrix config");
    ESP_RETURN_ON_FALSE(*size == matrix_config->row_gpio_num * matrix_config->col_gpio_num, ESP_ERR_INVALID_ARG, TAG, "Invalid size");

    button_matrix_obj *matrix_btn = calloc(*size, sizeof(button_matrix_obj));
    for (int i = 0; i < matrix_config->row_gpio_num; i++) {
        button_matrix_gpio_init(matrix_config->row_gpios[i], GPIO_MODE_OUTPUT);
    }

    for (int i = 0; i < matrix_config->col_gpio_num; i++) {
        button_matrix_gpio_init(matrix_config->col_gpios[i], GPIO_MODE_INPUT);
    }

    for (int i = 0; i < *size; i++) {
        matrix_btn[i].base.get_key_level = button_matrix_get_key_level;
        matrix_btn[i].base.del = button_matrix_del;
        matrix_btn[i].row_gpio_num = matrix_config->row_gpios[i / matrix_config->col_gpio_num];
        matrix_btn[i].col_gpio_num = matrix_config->col_gpios[i % matrix_config->col_gpio_num];
        ESP_LOGD(TAG, "row_gpio_num: %"PRId32", col_gpio_num: %"PRId32"", matrix_btn[i].row_gpio_num, matrix_btn[i].col_gpio_num);
        ret = iot_button_create(button_config, &matrix_btn[i].base, &ret_button[i]);
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Create button failed");
    }
    *size = matrix_config->row_gpio_num * matrix_config->col_gpio_num;
    return ESP_OK;

err:
    if (matrix_btn) {
        free(matrix_btn);
    }

    return ret;
}

--- END OF FILE: .\components\iot_button\button_matrix.c ---

--- START OF FILE: .\components\iot_button\CMakeLists.txt ---
# Fecha: 15/08/2025 - 03:42 
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\iot_button\CMakeLists.txt
# Último cambio: Eliminadas las llamadas a 'package_manager' y 'cu_pkg_define_version' para resolver el error de compilación en PlatformIO.
# Descripción: Registro del componente 'iot_button'. Se han eliminado las funciones de gestión de paquetes que requerían un fichero 'idf_component.yml' inexistente, causando el fallo de CMake. El componente ahora se registra de forma estándar, permitiendo que PlatformIO lo compile correctamente.

set(PRIVREQ esp_timer)
set(REQ driver)
set(SRC_FILES "button_gpio.c" "iot_button.c" "button_matrix.c")

if("${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}" VERSION_GREATER_EQUAL "5.0")
    list(APPEND REQ esp_adc)
    if(CONFIG_SOC_ADC_SUPPORTED)
        list(APPEND SRC_FILES "button_adc.c")
    endif()
endif()

idf_component_register(SRCS ${SRC_FILES}
                        INCLUDE_DIRS include interface
                        REQUIRES ${REQ}
                        PRIV_REQUIRES ${PRIVREQ})

# [CORRECCIÓN] Se eliminaron las siguientes líneas que causaban el error de CMake,
# ya que este componente es local y no necesita gestionar su versión a través
# del registro de componentes de Espressif.
# include(package_manager)
# cu_pkg_define_version(${CMAKE_CURRENT_LIST_DIR})

--- END OF FILE: .\components\iot_button\CMakeLists.txt ---

--- START OF FILE: .\components\iot_button\iot_button.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/timers.h"
#include "driver/gpio.h"
#include "esp_timer.h"
#include "esp_log.h"
#include "esp_check.h"
#include "iot_button.h"
#include "sdkconfig.h"
#include "button_interface.h"

static const char *TAG = "button";
static portMUX_TYPE s_button_lock = portMUX_INITIALIZER_UNLOCKED;
#define BUTTON_ENTER_CRITICAL()           portENTER_CRITICAL(&s_button_lock)
#define BUTTON_EXIT_CRITICAL()            portEXIT_CRITICAL(&s_button_lock)

#define BTN_CHECK(a, str, ret_val)                                \
    if (!(a)) {                                                   \
        ESP_LOGE(TAG, "%s(%d): %s", __FUNCTION__, __LINE__, str); \
        return (ret_val);                                         \
    }

#define IOT_BUTTON_VER_MAJOR 1
#define IOT_BUTTON_VER_MINOR 0
#define IOT_BUTTON_VER_PATCH 0

static const char *button_event_str[] = {
    "BUTTON_PRESS_DOWN",
    "BUTTON_PRESS_UP",
    "BUTTON_PRESS_REPEAT",
    "BUTTON_PRESS_REPEAT_DONE",
    "BUTTON_SINGLE_CLICK",
    "BUTTON_DOUBLE_CLICK",
    "BUTTON_MULTIPLE_CLICK",
    "BUTTON_LONG_PRESS_START",
    "BUTTON_LONG_PRESS_HOLD",
    "BUTTON_LONG_PRESS_UP",
    "BUTTON_PRESS_END",
    "BUTTON_EVENT_MAX",
    "BUTTON_NONE_PRESS",
};

enum {
    PRESS_DOWN_CHECK = 0,
    PRESS_UP_CHECK,
    PRESS_REPEAT_DOWN_CHECK,
    PRESS_REPEAT_UP_CHECK,
    PRESS_LONG_PRESS_UP_CHECK,
};

/**
 * @brief Structs to store callback info
 *
 */
typedef struct {
    button_cb_t cb;
    void *usr_data;
    button_event_args_t event_args;
} button_cb_info_t;

/**
 * @brief Structs to record individual key parameters
 *
 */
typedef struct button_dev_t {
    uint32_t              ticks;                    /*!< Count for the current button state. */
    uint32_t              long_press_ticks;         /*!< Trigger ticks for long press,  */
    uint32_t              short_press_ticks;        /*!< Trigger ticks for repeat press */
    uint32_t              long_press_hold_cnt;      /*!< Record long press hold count */
    uint8_t               repeat;
    uint8_t               state: 3;
    uint8_t               debounce_cnt: 4;          /*!< Max 15 */
    uint8_t               button_level: 1;
    button_event_t        event;
    button_driver_t       *driver;
    button_cb_info_t      *cb_info[BUTTON_EVENT_MAX];
    size_t                size[BUTTON_EVENT_MAX];
    int                   count[2];
    struct button_dev_t   *next;
} button_dev_t;

//button handle list head.
static button_dev_t *g_head_handle = NULL;
static esp_timer_handle_t g_button_timer_handle = NULL;
static bool g_is_timer_running = false;
static button_power_save_config_t power_save_usr_cfg = {0};

#define TICKS_INTERVAL    CONFIG_BUTTON_PERIOD_TIME_MS
#define DEBOUNCE_TICKS    CONFIG_BUTTON_DEBOUNCE_TICKS //MAX 8
#define SHORT_TICKS       (CONFIG_BUTTON_SHORT_PRESS_TIME_MS /TICKS_INTERVAL)
#define LONG_TICKS        (CONFIG_BUTTON_LONG_PRESS_TIME_MS /TICKS_INTERVAL)
#define SERIAL_TICKS      (CONFIG_BUTTON_LONG_PRESS_HOLD_SERIAL_TIME_MS /TICKS_INTERVAL)
#define TOLERANCE         (CONFIG_BUTTON_PERIOD_TIME_MS*4)

#define CALL_EVENT_CB(ev)                                                   \
    if (btn->cb_info[ev]) {                                                 \
        for (int i = 0; i < btn->size[ev]; i++) {                           \
            btn->cb_info[ev][i].cb(btn, btn->cb_info[ev][i].usr_data);      \
        }                                                                   \
    }                                                                       \

#define TIME_TO_TICKS(time, congfig_time)  (0 == (time))?congfig_time:(((time) / TICKS_INTERVAL))?((time) / TICKS_INTERVAL):1

/**
  * @brief  Button driver core function, driver state machine.
  */
static void button_handler(button_dev_t *btn)
{
    uint8_t read_gpio_level = btn->driver->get_key_level(btn->driver);

    /** ticks counter working.. */
    if ((btn->state) > 0) {
        btn->ticks++;
    }

    /**< button debounce handle */
    if (read_gpio_level != btn->button_level) {
        if (++(btn->debounce_cnt) >= DEBOUNCE_TICKS) {
            btn->button_level = read_gpio_level;
            btn->debounce_cnt = 0;
        }
    } else {
        btn->debounce_cnt = 0;
    }

    /** State machine */
    switch (btn->state) {
    case PRESS_DOWN_CHECK:
        if (btn->button_level == BUTTON_ACTIVE) {
            btn->event = (uint8_t)BUTTON_PRESS_DOWN;
            CALL_EVENT_CB(BUTTON_PRESS_DOWN);
            btn->ticks = 0;
            btn->repeat = 1;
            btn->state = PRESS_UP_CHECK;
        } else {
            btn->event = (uint8_t)BUTTON_NONE_PRESS;
        }
        break;

    case PRESS_UP_CHECK:
        if (btn->button_level != BUTTON_ACTIVE) {
            btn->event = (uint8_t)BUTTON_PRESS_UP;
            CALL_EVENT_CB(BUTTON_PRESS_UP);
            btn->ticks = 0;
            btn->state = PRESS_REPEAT_DOWN_CHECK;

        } else if (btn->ticks >= btn->long_press_ticks) {
            btn->event = (uint8_t)BUTTON_LONG_PRESS_START;
            btn->state = PRESS_LONG_PRESS_UP_CHECK;
            /** Calling callbacks for BUTTON_LONG_PRESS_START */
            uint32_t ticks_time = iot_button_get_ticks_time(btn);
            int32_t diff = ticks_time - btn->long_press_ticks * TICKS_INTERVAL;
            if (btn->cb_info[btn->event] && btn->count[0] == 0) {
                if (abs(diff) <= TOLERANCE && btn->cb_info[btn->event][btn->count[0]].event_args.long_press.press_time == (btn->long_press_ticks * TICKS_INTERVAL)) {
                    do {
                        btn->cb_info[btn->event][btn->count[0]].cb(btn, btn->cb_info[btn->event][btn->count[0]].usr_data);
                        btn->count[0]++;
                        if (btn->count[0] >= btn->size[btn->event]) {
                            break;
                        }
                    } while (btn->cb_info[btn->event][btn->count[0]].event_args.long_press.press_time == btn->long_press_ticks * TICKS_INTERVAL);
                }
            }
        }
        break;

    case PRESS_REPEAT_DOWN_CHECK:
        if (btn->button_level == BUTTON_ACTIVE) {
            btn->event = (uint8_t)BUTTON_PRESS_DOWN;
            CALL_EVENT_CB(BUTTON_PRESS_DOWN);
            btn->event = (uint8_t)BUTTON_PRESS_REPEAT;
            btn->repeat++;
            CALL_EVENT_CB(BUTTON_PRESS_REPEAT); // repeat hit
            btn->ticks = 0;
            btn->state = PRESS_REPEAT_UP_CHECK;
        } else if (btn->ticks > btn->short_press_ticks) {
            if (btn->repeat == 1) {
                btn->event = (uint8_t)BUTTON_SINGLE_CLICK;
                CALL_EVENT_CB(BUTTON_SINGLE_CLICK);
            } else if (btn->repeat == 2) {
                btn->event = (uint8_t)BUTTON_DOUBLE_CLICK;
                CALL_EVENT_CB(BUTTON_DOUBLE_CLICK); // repeat hit
            }

            btn->event = (uint8_t)BUTTON_MULTIPLE_CLICK;

            /** Calling the callbacks for MULTIPLE BUTTON CLICKS */
            for (int i = 0; i < btn->size[btn->event]; i++) {
                if (btn->repeat == btn->cb_info[btn->event][i].event_args.multiple_clicks.clicks) {
                    do {
                        btn->cb_info[btn->event][i].cb(btn, btn->cb_info[btn->event][i].usr_data);
                        i++;
                        if (i >= btn->size[btn->event]) {
                            break;
                        }
                    } while (btn->cb_info[btn->event][i].event_args.multiple_clicks.clicks == btn->repeat);
                }
            }

            btn->event = (uint8_t)BUTTON_PRESS_REPEAT_DONE;
            CALL_EVENT_CB(BUTTON_PRESS_REPEAT_DONE); // repeat hit
            btn->repeat = 0;
            btn->state = 0;
            btn->event = (uint8_t)BUTTON_PRESS_END;
            CALL_EVENT_CB(BUTTON_PRESS_END);
        }
        break;

    case 3:
        if (btn->button_level != BUTTON_ACTIVE) {
            btn->event = (uint8_t)BUTTON_PRESS_UP;
            CALL_EVENT_CB(BUTTON_PRESS_UP);
            if (btn->ticks < btn->short_press_ticks) {
                btn->ticks = 0;
                btn->state = PRESS_REPEAT_DOWN_CHECK; //repeat press
            } else {
                btn->state = PRESS_DOWN_CHECK;
                btn->event = (uint8_t)BUTTON_PRESS_END;
                CALL_EVENT_CB(BUTTON_PRESS_END);
            }
        }
        break;

    case PRESS_LONG_PRESS_UP_CHECK:
        if (btn->button_level == BUTTON_ACTIVE) {
            //continue hold trigger
            if (btn->ticks >= (btn->long_press_hold_cnt + 1) * SERIAL_TICKS + btn->long_press_ticks) {
                btn->event = (uint8_t)BUTTON_LONG_PRESS_HOLD;
                btn->long_press_hold_cnt++;
                CALL_EVENT_CB(BUTTON_LONG_PRESS_HOLD);
            }

            /** Calling callbacks for BUTTON_LONG_PRESS_START based on press_time */
            uint32_t ticks_time = iot_button_get_ticks_time(btn);
            if (btn->cb_info[BUTTON_LONG_PRESS_START]) {
                button_cb_info_t *cb_info = btn->cb_info[BUTTON_LONG_PRESS_START];
                uint16_t time = cb_info[btn->count[0]].event_args.long_press.press_time;
                if (btn->long_press_ticks * TICKS_INTERVAL > time) {
                    for (int i = btn->count[0] + 1; i < btn->size[BUTTON_LONG_PRESS_START]; i++) {
                        time = cb_info[i].event_args.long_press.press_time;
                        if (btn->long_press_ticks * TICKS_INTERVAL <= time) {
                            btn->count[0] = i;
                            break;
                        }
                    }
                }
                if (btn->count[0] < btn->size[BUTTON_LONG_PRESS_START] && abs((int)ticks_time - (int)time) <= TOLERANCE) {
                    btn->event = (uint8_t)BUTTON_LONG_PRESS_START;
                    do {
                        cb_info[btn->count[0]].cb(btn, cb_info[btn->count[0]].usr_data);
                        btn->count[0]++;
                        if (btn->count[0] >= btn->size[BUTTON_LONG_PRESS_START]) {
                            break;
                        }
                    } while (time == cb_info[btn->count[0]].event_args.long_press.press_time);
                }
            }

            /** Updating counter for BUTTON_LONG_PRESS_UP press_time */
            if (btn->cb_info[BUTTON_LONG_PRESS_UP]) {
                button_cb_info_t *cb_info = btn->cb_info[BUTTON_LONG_PRESS_UP];
                uint16_t time = cb_info[btn->count[1] + 1].event_args.long_press.press_time;
                if (btn->long_press_ticks * TICKS_INTERVAL > time) {
                    for (int i = btn->count[1] + 1; i < btn->size[BUTTON_LONG_PRESS_UP]; i++) {
                        time = cb_info[i].event_args.long_press.press_time;
                        if (btn->long_press_ticks * TICKS_INTERVAL <= time) {
                            btn->count[1] = i;
                            break;
                        }
                    }
                }
                if (btn->count[1] + 1 < btn->size[BUTTON_LONG_PRESS_UP] && abs((int)ticks_time - (int)time) <= TOLERANCE) {
                    do {
                        btn->count[1]++;
                        if (btn->count[1] + 1 >= btn->size[BUTTON_LONG_PRESS_UP]) {
                            break;
                        }
                    } while (time == cb_info[btn->count[1] + 1].event_args.long_press.press_time);
                }
            }
        } else { //releasd

            btn->event = BUTTON_LONG_PRESS_UP;

            /** calling callbacks for BUTTON_LONG_PRESS_UP press_time */
            if (btn->cb_info[btn->event] && btn->count[1] >= 0) {
                button_cb_info_t *cb_info = btn->cb_info[btn->event];
                do {
                    cb_info[btn->count[1]].cb(btn, cb_info[btn->count[1]].usr_data);
                    if (!btn->count[1]) {
                        break;
                    }
                    btn->count[1]--;
                } while (cb_info[btn->count[1]].event_args.long_press.press_time == cb_info[btn->count[1] + 1].event_args.long_press.press_time);

                /** Reset the counter */
                btn->count[1] = -1;
            }
            /** Reset counter */
            if (btn->cb_info[BUTTON_LONG_PRESS_START]) {
                btn->count[0] = 0;
            }

            btn->event = (uint8_t)BUTTON_PRESS_UP;
            CALL_EVENT_CB(BUTTON_PRESS_UP);
            btn->state = PRESS_DOWN_CHECK; //reset
            btn->long_press_hold_cnt = 0;
            btn->event = (uint8_t)BUTTON_PRESS_END;
            CALL_EVENT_CB(BUTTON_PRESS_END);
        }
        break;
    }
}

static void button_cb(void *args)
{
    button_dev_t *target;
    /*!< When all buttons enter the BUTTON_NONE_PRESS state, the system enters low-power mode */
    bool enter_power_save_flag = true;
    for (target = g_head_handle; target; target = target->next) {
        button_handler(target);
        if (!(target->driver->enable_power_save && target->debounce_cnt == 0 && target->event == BUTTON_NONE_PRESS)) {
            enter_power_save_flag = false;
        }
    }
    if (enter_power_save_flag) {
        /*!< Stop esp timer for power save */
        if (g_is_timer_running) {
            esp_timer_stop(g_button_timer_handle);
            g_is_timer_running = false;
        }
        for (target = g_head_handle; target; target = target->next) {
            if (target->driver->enable_power_save && target->driver->enter_power_save) {
                target->driver->enter_power_save(target->driver);
            }
        }
        /*!< Notify the user that the Button has entered power save mode by calling this callback function. */
        if (power_save_usr_cfg.enter_power_save_cb) {
            power_save_usr_cfg.enter_power_save_cb(power_save_usr_cfg.usr_data);
        }
    }
}

esp_err_t iot_button_register_cb(button_handle_t btn_handle, button_event_t event, button_event_args_t *event_args, button_cb_t cb, void *usr_data)
{
    ESP_RETURN_ON_FALSE(NULL != btn_handle, ESP_ERR_INVALID_ARG, TAG, "Pointer of handle is invalid");
    button_dev_t *btn = (button_dev_t *) btn_handle;
    ESP_RETURN_ON_FALSE(event < BUTTON_EVENT_MAX, ESP_ERR_INVALID_ARG, TAG, "event is invalid");
    ESP_RETURN_ON_FALSE(NULL != cb, ESP_ERR_INVALID_ARG, TAG, "Pointer of cb is invalid");
    ESP_RETURN_ON_FALSE(event != BUTTON_MULTIPLE_CLICK || event_args, ESP_ERR_INVALID_ARG, TAG, "event is invalid");

    if (event_args) {
        ESP_RETURN_ON_FALSE(!(event == BUTTON_LONG_PRESS_START || event == BUTTON_LONG_PRESS_UP) || event_args->long_press.press_time > btn->short_press_ticks * TICKS_INTERVAL, ESP_ERR_INVALID_ARG, TAG, "event_args is invalid");
        ESP_RETURN_ON_FALSE(event != BUTTON_MULTIPLE_CLICK || event_args->multiple_clicks.clicks, ESP_ERR_INVALID_ARG, TAG, "event_args is invalid");
    }

    if (!btn->cb_info[event]) {
        btn->cb_info[event] = calloc(1, sizeof(button_cb_info_t));
        BTN_CHECK(NULL != btn->cb_info[event], "calloc cb_info failed", ESP_ERR_NO_MEM);
        if (event == BUTTON_LONG_PRESS_START) {
            btn->count[0] = 0;
        } else if (event == BUTTON_LONG_PRESS_UP) {
            btn->count[1] = -1;
        }
    } else {
        button_cb_info_t *p = realloc(btn->cb_info[event], sizeof(button_cb_info_t) * (btn->size[event] + 1));
        BTN_CHECK(NULL != p, "realloc cb_info failed", ESP_ERR_NO_MEM);
        btn->cb_info[event] = p;
    }

    btn->cb_info[event][btn->size[event]].cb = cb;
    btn->cb_info[event][btn->size[event]].usr_data = usr_data;
    btn->size[event]++;

    /** Inserting the event_args in sorted manner */
    if (event == BUTTON_LONG_PRESS_START || event == BUTTON_LONG_PRESS_UP) {
        uint16_t press_time = btn->long_press_ticks * TICKS_INTERVAL;
        if (event_args) {
            press_time = event_args->long_press.press_time;
        }
        BTN_CHECK(press_time / TICKS_INTERVAL > btn->short_press_ticks, "press_time event_args is less than short_press_ticks", ESP_ERR_INVALID_ARG);
        if (btn->size[event] >= 2) {
            for (int i = btn->size[event] - 2; i >= 0; i--) {
                if (btn->cb_info[event][i].event_args.long_press.press_time > press_time) {
                    btn->cb_info[event][i + 1] = btn->cb_info[event][i];

                    btn->cb_info[event][i].event_args.long_press.press_time = press_time;
                    btn->cb_info[event][i].cb = cb;
                    btn->cb_info[event][i].usr_data = usr_data;
                } else {
                    btn->cb_info[event][i + 1].event_args.long_press.press_time = press_time;
                    btn->cb_info[event][i + 1].cb = cb;
                    btn->cb_info[event][i + 1].usr_data = usr_data;
                    break;
                }
            }
        } else {
            btn->cb_info[event][btn->size[event] - 1].event_args.long_press.press_time = press_time;
        }

        int32_t press_ticks = press_time / TICKS_INTERVAL;
        if (btn->short_press_ticks < press_ticks && press_ticks < btn->long_press_ticks) {
            iot_button_set_param(btn, BUTTON_LONG_PRESS_TIME_MS, (void*)(intptr_t)press_time);
        }
    }

    if (event == BUTTON_MULTIPLE_CLICK) {
        uint16_t clicks = btn->long_press_ticks * TICKS_INTERVAL;
        if (event_args) {
            clicks = event_args->multiple_clicks.clicks;
        }
        if (btn->size[event] >= 2) {
            for (int i = btn->size[event] - 2; i >= 0; i--) {
                if (btn->cb_info[event][i].event_args.multiple_clicks.clicks > clicks) {
                    btn->cb_info[event][i + 1] = btn->cb_info[event][i];

                    btn->cb_info[event][i].event_args.multiple_clicks.clicks = clicks;
                    btn->cb_info[event][i].cb = cb;
                    btn->cb_info[event][i].usr_data = usr_data;
                } else {
                    btn->cb_info[event][i + 1].event_args.multiple_clicks.clicks = clicks;
                    btn->cb_info[event][i + 1].cb = cb;
                    btn->cb_info[event][i + 1].usr_data = usr_data;
                    break;
                }
            }
        } else {
            btn->cb_info[event][btn->size[event] - 1].event_args.multiple_clicks.clicks = clicks;
        }
    }
    return ESP_OK;
}

esp_err_t iot_button_unregister_cb(button_handle_t btn_handle, button_event_t event, button_event_args_t *event_args)
{
    ESP_RETURN_ON_FALSE(NULL != btn_handle, ESP_ERR_INVALID_ARG, TAG, "Pointer of handle is invalid");
    ESP_RETURN_ON_FALSE(event < BUTTON_EVENT_MAX, ESP_ERR_INVALID_ARG, TAG, "event is invalid");
    button_dev_t *btn = (button_dev_t *) btn_handle;
    ESP_RETURN_ON_FALSE(btn->cb_info[event], ESP_ERR_INVALID_STATE, TAG, "No callbacks registered for the event");

    int check = -1;

    if ((event == BUTTON_LONG_PRESS_START || event == BUTTON_LONG_PRESS_UP) && event_args) {
        if (event_args->long_press.press_time != 0) {
            goto unregister_event;
        }
    }

    if (event == BUTTON_MULTIPLE_CLICK && event_args) {
        if (event_args->multiple_clicks.clicks != 0) {
            goto unregister_event;
        }
    }

    if (btn->cb_info[event]) {
        free(btn->cb_info[event]);

        /** Reset the counter */
        if (event == BUTTON_LONG_PRESS_START) {
            btn->count[0] = 0;
        } else if (event == BUTTON_LONG_PRESS_UP) {
            btn->count[1] = -1;
        }

    }

    btn->cb_info[event] = NULL;
    btn->size[event] = 0;
    return ESP_OK;

unregister_event:

    for (int i = 0; i < btn->size[event]; i++) {
        if ((event == BUTTON_LONG_PRESS_START || event == BUTTON_LONG_PRESS_UP) && event_args->long_press.press_time) {
            if (event_args->long_press.press_time != btn->cb_info[event][i].event_args.long_press.press_time) {
                continue;
            }
        }

        if (event == BUTTON_MULTIPLE_CLICK && event_args->multiple_clicks.clicks) {
            if (event_args->multiple_clicks.clicks != btn->cb_info[event][i].event_args.multiple_clicks.clicks) {
                continue;
            }
        }
        check = i;
        for (int j = i; j <= btn->size[event] - 1; j++) {
            btn->cb_info[event][j] = btn->cb_info[event][j + 1];
        }

        if (btn->size[event] != 1) {
            button_cb_info_t *p = realloc(btn->cb_info[event], sizeof(button_cb_info_t) * (btn->size[event] - 1));
            BTN_CHECK(NULL != p, "realloc cb_info failed", ESP_ERR_NO_MEM);
            btn->cb_info[event] = p;
            btn->size[event]--;
        } else {
            free(btn->cb_info[event]);
            btn->cb_info[event] = NULL;
            btn->size[event] = 0;
        }
        break;
    }

    ESP_RETURN_ON_FALSE(check != -1, ESP_ERR_NOT_FOUND, TAG, "No such callback registered for the event");
    return ESP_OK;
}

size_t iot_button_count_cb(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", ESP_ERR_INVALID_ARG);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    size_t ret = 0;
    for (size_t i = 0; i < BUTTON_EVENT_MAX; i++) {
        if (btn->cb_info[i]) {
            ret += btn->size[i];
        }
    }
    return ret;
}

size_t iot_button_count_event_cb(button_handle_t btn_handle, button_event_t event)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", ESP_ERR_INVALID_ARG);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    return btn->size[event];
}

button_event_t iot_button_get_event(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", BUTTON_NONE_PRESS);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    return btn->event;
}

const char *iot_button_get_event_str(button_event_t event)
{
    BTN_CHECK(event <= BUTTON_NONE_PRESS && event >= BUTTON_PRESS_DOWN, "event value is invalid", "invalid event");
    return button_event_str[event];
}

esp_err_t iot_button_print_event(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", ESP_FAIL);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    ESP_LOGI(TAG, "%s", button_event_str[btn->event]);
    return ESP_OK;
}

uint8_t iot_button_get_repeat(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", 0);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    return btn->repeat;
}

uint32_t iot_button_get_ticks_time(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", 0);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    return (btn->ticks * TICKS_INTERVAL);
}

uint16_t iot_button_get_long_press_hold_cnt(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", 0);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    return btn->long_press_hold_cnt;
}

esp_err_t iot_button_set_param(button_handle_t btn_handle, button_param_t param, void *value)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", ESP_ERR_INVALID_ARG);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    BUTTON_ENTER_CRITICAL();
    switch (param) {
    case BUTTON_LONG_PRESS_TIME_MS:
        btn->long_press_ticks = (int32_t)value / TICKS_INTERVAL;
        break;
    case BUTTON_SHORT_PRESS_TIME_MS:
        btn->short_press_ticks = (int32_t)value / TICKS_INTERVAL;
        break;
    default:
        break;
    }
    BUTTON_EXIT_CRITICAL();
    return ESP_OK;
}

uint8_t iot_button_get_key_level(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", 0);
    button_dev_t *btn = (button_dev_t *)btn_handle;
    uint8_t level = btn->driver->get_key_level(btn->driver);
    return level;
}

esp_err_t iot_button_resume(void)
{
    if (!g_button_timer_handle) {
        return ESP_ERR_INVALID_STATE;
    }
    if (!g_is_timer_running) {
        esp_timer_start_periodic(g_button_timer_handle, TICKS_INTERVAL * 1000U);
        g_is_timer_running = true;
    }
    return ESP_OK;
}

esp_err_t iot_button_stop(void)
{
    BTN_CHECK(g_button_timer_handle, "Button timer handle is invalid", ESP_ERR_INVALID_STATE);
    BTN_CHECK(g_is_timer_running, "Button timer is not running", ESP_ERR_INVALID_STATE);

    esp_err_t err = esp_timer_stop(g_button_timer_handle);
    BTN_CHECK(ESP_OK == err, "Button timer stop failed", ESP_FAIL);
    g_is_timer_running = false;
    return ESP_OK;
}

esp_err_t iot_button_register_power_save_cb(const button_power_save_config_t *config)
{
    BTN_CHECK(g_head_handle, "No button registered", ESP_ERR_INVALID_STATE);
    BTN_CHECK(config->enter_power_save_cb, "Enter power save callback is invalid", ESP_ERR_INVALID_ARG);

    power_save_usr_cfg.enter_power_save_cb = config->enter_power_save_cb;
    power_save_usr_cfg.usr_data = config->usr_data;
    return ESP_OK;
}

esp_err_t iot_button_create(const button_config_t *config, const button_driver_t *driver, button_handle_t *ret_button)
{
    if (!g_head_handle) {
        ESP_LOGI(TAG, "IoT Button Version: %d.%d.%d", IOT_BUTTON_VER_MAJOR, IOT_BUTTON_VER_MINOR, IOT_BUTTON_VER_PATCH);
    }
    ESP_RETURN_ON_FALSE(driver && config && ret_button, ESP_ERR_INVALID_ARG, TAG, "Invalid argument");
    button_dev_t *btn = (button_dev_t *) calloc(1, sizeof(button_dev_t));
    ESP_RETURN_ON_FALSE(btn, ESP_ERR_NO_MEM, TAG, "Button memory alloc failed");

    btn->driver = (button_driver_t *)driver;
    btn->long_press_ticks = TIME_TO_TICKS(config->long_press_time, LONG_TICKS);
    btn->short_press_ticks = TIME_TO_TICKS(config->short_press_time, SHORT_TICKS);
    btn->event = BUTTON_NONE_PRESS;
    btn->button_level = BUTTON_INACTIVE;

    btn->next = g_head_handle;
    g_head_handle = btn;
    
    if (!g_button_timer_handle) {
        esp_timer_create_args_t button_timer = {0};
        button_timer.arg = NULL;
        button_timer.callback = button_cb;
        button_timer.dispatch_method = ESP_TIMER_TASK;
        button_timer.name = "button_timer";
        esp_timer_create(&button_timer, &g_button_timer_handle);
    }

    if (!driver->enable_power_save && !g_is_timer_running) {
        esp_timer_start_periodic(g_button_timer_handle, TICKS_INTERVAL * 1000U);
        g_is_timer_running = true;
    }

    *ret_button = (button_handle_t)btn;
    return ESP_OK;
}

esp_err_t iot_button_delete(button_handle_t btn_handle)
{
    esp_err_t ret = ESP_OK;
    ESP_RETURN_ON_FALSE(NULL != btn_handle, ESP_ERR_INVALID_ARG, TAG, "Pointer of handle is invalid");
    button_dev_t *btn = (button_dev_t *)btn_handle;

    for (int i = 0; i < BUTTON_EVENT_MAX; i++) {
        if (btn->cb_info[i]) {
            free(btn->cb_info[i]);
        }
    }

    ret = btn->driver->del(btn->driver);
    ESP_RETURN_ON_FALSE(ESP_OK == ret, ret, TAG, "Failed to delete button driver");

    button_dev_t **curr;
    for (curr = &g_head_handle; *curr;) {
        button_dev_t *entry = *curr;
        if (entry == btn) {
            *curr = entry->next;
            free(entry);
        } else {
            curr = &entry->next;
        }
    }

    /* count button number */
    uint16_t number = 0;
    button_dev_t *target = g_head_handle;
    while (target) {
        target = target->next;
        number++;
    }
    ESP_LOGD(TAG, "remain btn number=%d", number);

    if (0 == number && g_is_timer_running) { /**<  if all button is deleted, stop the timer */
        esp_timer_stop(g_button_timer_handle);
        esp_timer_delete(g_button_timer_handle);
        g_button_timer_handle = NULL;
        g_is_timer_running = false;
    }
    return ESP_OK;
}

--- END OF FILE: .\components\iot_button\iot_button.c ---

--- START OF FILE: .\components\iot_button\Kconfig ---
menu "IoT Button"

    config BUTTON_PERIOD_TIME_MS
        int "BUTTON PERIOD TIME (MS)"
        range 2 500
        default 5
        help
            "Button scan interval"

    config BUTTON_DEBOUNCE_TICKS
        int "BUTTON DEBOUNCE TICKS"
        range 1 7
        default 2
        help
            "One CONFIG_BUTTON_DEBOUNCE_TICKS equal to CONFIG_BUTTON_PERIOD_TIME_MS"

    config BUTTON_SHORT_PRESS_TIME_MS
        int "BUTTON SHORT PRESS TIME (MS)"
        range 50 800
        default 180

    config BUTTON_LONG_PRESS_TIME_MS
        int "BUTTON LONG PRESS TIME (MS)"
        range 500 5000
        default 1500

    config BUTTON_LONG_PRESS_HOLD_SERIAL_TIME_MS
        int "BUTTON LONG_PRESS_HOLD SERIAL TIME (MS)"
        range 2 1000
        default 20
        help
            "Long press hold Serial trigger interval"

    config ADC_BUTTON_MAX_CHANNEL
        int "ADC BUTTON MAX CHANNEL"
        range 1 5
        default 3
        help
            "Maximum number of channels for ADC buttons"

    config ADC_BUTTON_MAX_BUTTON_PER_CHANNEL
        int "ADC BUTTON MAX BUTTON PER CHANNEL"
        range 1 10
        default 8
        help
            "Maximum number of buttons per channel"

    config ADC_BUTTON_SAMPLE_TIMES
        int "ADC BUTTON SAMPLE TIMES"
        range 1 4
        default 1
        help
            "Number of samples per scan"

endmenu

--- END OF FILE: .\components\iot_button\Kconfig ---

--- START OF FILE: .\components\iot_button\README.md ---
[![Component Registry](https://components.espressif.com/components/espressif/button/badge.svg)](https://components.espressif.com/components/espressif/button)

# Component: Button
[Online documentation](https://docs.espressif.com/projects/esp-iot-solution/en/latest/input_device/button.html)

After creating a new button object by calling function `button_create()`, the button object can create press events, every press event can have its own callback.

List of supported events:
 * Button pressed
 * Button released
 * Button pressed repeat
 * Button press repeat done
 * Button single click
 * Button double click
 * Button multiple click
 * Button long press start
 * Button long press hold
 * Button long press up
 * Button Press end

![](https://dl.espressif.com/AE/esp-iot-solution/button_3.3.1.svg)

There are three ways this driver can handle buttons:
1. Buttons connected to standard digital GPIO
2. Multiple buttons connected to single ADC channel
3. Matrix keyboard employs multiple GPIOs for operation.
4. Custom button connect to any driver

The component supports the following functionalities:
1. Creation of an unlimited number of buttons, accommodating various types simultaneously.
2. Multiple callback functions for a single event.
3. Allowing customization of the consecutive key press count to any desired number.
4. Facilitating the setup of callbacks for any specified long-press duration.
5. Support power save mode (Only for gpio button)

## Add component to your project

Please use the component manager command `add-dependency` to add the `button` to your project's dependency, during the `CMake` step the component will be downloaded automatically

```
idf.py add-dependency "espressif/button=*"
```
--- END OF FILE: .\components\iot_button\README.md ---

--- START OF FILE: .\components\screen_manager\CMakeLists.txt ---
# Fecha: 16/08/2025 - 09:27 
# Fichero: components/screen_manager/CMakeLists.txt
# Último cambio: Actualizada la dependencia de 'diymon_bsp' a 'bsp' para resolver el error de compilación.
# Descripción: Fichero de compilación para el gestor de pantalla. Se ha corregido el nombre de la dependencia del BSP para que coincida con el nuevo nombre del directorio, solucionando el error 'Failed to resolve component'.

idf_component_register(SRCS "screen_manager.c"
                    INCLUDE_DIRS "."
                    REQUIRES 
                        log
                        bsp # Corregido de 'diymon_bsp' a 'bsp'
                        )

--- END OF FILE: .\components\screen_manager\CMakeLists.txt ---

--- START OF FILE: .\components\screen_manager\screen_manager.c ---
/*
  Fichero: ./components/screen_manager/screen_manager.c
  Fecha: 13/08/2025 - 12:03 
  Último cambio: Eliminada completamente la lógica de 'shake-to-wake'.
  Descripción: Se ha eliminado toda la funcionalidad de shake-to-wake, incluyendo la tarea,
               el semáforo y la inicialización de la interrupción del BSP. Esta funcionalidad
               será re-implementada dentro de la nueva tarea de telemetría en la capa de la UI
               para consolidar la lógica y resolver conflictos de I2C.
*/
#include "screen_manager.h"
#include "bsp_api.h"
#include "esp_log.h"

static const char *TAG = "SCREEN_MANAGER";
static bool g_is_screen_off = false;

esp_err_t screen_manager_init(void) {
    ESP_LOGI(TAG, "Gestor de pantalla inicializado.");
    return ESP_OK;
}

void screen_manager_turn_on(void) {
    bsp_display_turn_on();
    g_is_screen_off = false;
    ESP_LOGI(TAG, "Petición para encender pantalla ejecutada.");
}

void screen_manager_turn_off(void) {
    bsp_display_turn_off();
    g_is_screen_off = true;
    ESP_LOGI(TAG, "Petición para apagar pantalla ejecutada.");
}

void screen_manager_set_brightness(int percentage) {
    bsp_display_set_brightness(percentage);
}

bool screen_manager_is_off(void) {
    return g_is_screen_off;
}

--- END OF FILE: .\components\screen_manager\screen_manager.c ---

--- START OF FILE: .\components\screen_manager\screen_manager.h ---
#ifndef SCREEN_MANAGER_H
#define SCREEN_MANAGER_H

#include "esp_err.h"
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el gestor de pantalla.
 * 
 * @return ESP_OK si la inicialización es correcta.
 */
esp_err_t screen_manager_init(void);

/**
 * @brief Enciende la pantalla y restaura el último nivel de brillo.
 */
void screen_manager_turn_on(void);

/**
 * @brief Apaga la pantalla y el backlight.
 */
void screen_manager_turn_off(void);

/**
 * @brief Establece el nivel de brillo de la pantalla.
 * 
 * @param percentage Brillo en porcentaje (0-100).
 */
void screen_manager_set_brightness(int percentage);

/**
 * @brief Devuelve si la pantalla está actualmente apagada.
 * 
 * @return true si la pantalla está apagada, false en caso contrario.
 */
bool screen_manager_is_off(void);


#ifdef __cplusplus
}
#endif

#endif // SCREEN_MANAGER_H
--- END OF FILE: .\components\screen_manager\screen_manager.h ---

--- START OF FILE: .\components\service_screen\CMakeLists.txt ---
# Fecha: 16/08/2025 - 09:41 
# Fichero: components/service_screen/CMakeLists.txt
# Último cambio: Actualizada la dependencia de 'diymon_bsp' a 'bsp' para resolver el error de compilación.
# Descripción: Fichero de compilación para la pantalla de servicio. Se ha corregido el nombre de la dependencia del BSP para que coincida con el nuevo nombre del directorio ('bsp'), solucionando el error 'Failed to resolve component'.

idf_component_register(SRCS "service_screen.c"
                    INCLUDE_DIRS "."
                    REQUIRES
                        log
                        bsp
)

--- END OF FILE: .\components\service_screen\CMakeLists.txt ---

--- START OF FILE: .\components\service_screen\service_screen.c ---
/*
Fichero: Z:\DIYTOGETHER\DIYtogether\components\service_screen\service_screen.c
Fecha: 14/08/2025 - 05:52 
Último cambio: Refactorizado para usar un asset de imagen compilado en el firmware en lugar de leer desde la SD.
Descripción: Lógica para mostrar una pantalla de servicio sin LVGL. Se ha modificado para dibujar directamente en el framebuffer del display un array de C que representa una imagen (el asset 'bg_config_img'), eliminando la dependencia de la tarjeta SD para los modos de servicio y haciéndolos más rápidos y robustos.
*/
#include "service_screen.h"
#include "bsp_api.h"
#include "esp_log.h"
#include "esp_lcd_panel_ops.h" // Necesario para esp_lcd_panel_draw_bitmap
#include <lvgl.h> // Necesario para el tipo lv_img_dsc_t

static const char *TAG = "SERVICE_SCREEN";

// --- EXPLICACIÓN DEL PROCESO ---
// Para plasmar una imagen en pantalla sin LVGL, seguimos estos pasos:
// 1. Convertir la imagen (ej: "config_bg.png") a un fichero C usando el conversor de LVGL.
//    - Formato de color: RGB565 (para que coincida con el display).
//    - Salida: Array C.
// 2. Este proceso genera un fichero, por ejemplo "bg_config_img.c", que contiene
//    una estructura 'const lv_img_dsc_t bg_config_img = { ... };'.
// 3. Declaramos esa estructura como 'extern' para poder usarla aquí.
//    Esto le dice al compilador que la definición real está en otro fichero.
extern const lv_img_dsc_t bg_config;

// 4. Usamos la función de bajo nivel del driver del display sp_lcd_panel_draw_bitmap.
//    Esta función toma un puntero directo a los datos de píxeles (bg_config_img.data)
//    y los envía al hardware de la pantalla.

esp_err_t service_screen_show_from_rom(void) {
    ESP_LOGI(TAG, "Mostrando pantalla de servicio NATIVA desde asset en firmware...");
    
    // Asumimos que el hardware (SPI y display) ya ha sido inicializado por main.c
    
    // Obtenemos el manejador del display desde el BSP
    esp_lcd_panel_handle_t panel_handle = bsp_get_display_handle();
    if (!panel_handle) {
        ESP_LOGE(TAG, "El manejador del display no está inicializado.");
        return ESP_FAIL;
    }
    
    // Obtenemos las dimensiones para asegurarnos de que cubrimos toda la pantalla
    const int h_res = bsp_get_display_hres();
    const int v_res = bsp_get_display_vres();

    // Verificamos que las dimensiones de la imagen coincidan (opcional pero recomendado)
    if (bg_config.header.w != h_res || bg_config.header.h != v_res) {
        ESP_LOGW(TAG, "Las dimensiones de la imagen (%dx%d) no coinciden con las de la pantalla (%dx%d).",
                 bg_config.header.w, bg_config.header.h, h_res, v_res);
    }

    // Volcamos el búfer del asset directamente al display (sin LVGL)
    ESP_LOGI(TAG, "Renderizando imagen nativa en el display...");
    esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, h_res, v_res, bg_config.data);

    ESP_LOGI(TAG, "Pantalla de servicio mostrada con éxito.");
    return ESP_OK;
}

// La función original que cargaba desde la SD se mantiene por si se necesita,
// pero la nueva lógica usa la ROM.
esp_err_t service_screen_show_from_sd(const char* image_path) {
    ESP_LOGE(TAG, "service_screen_show_from_sd está obsoleta. Usar service_screen_show_from_rom.");
    return ESP_ERR_NOT_SUPPORTED;
}

--- END OF FILE: .\components\service_screen\service_screen.c ---

--- START OF FILE: .\components\service_screen\service_screen.h ---
/*
  Fichero: ./components/service_screen/service_screen.h
  Fecha: 12/08/2025 - 07:00
  Último cambio: Creación del componente.
  Descripción: Interfaz pública para el gestor de pantallas de servicio.
*/
#ifndef SERVICE_SCREEN_H
#define SERVICE_SCREEN_H

#include "esp_err.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Muestra una imagen a pantalla completa desde la tarjeta SD.
 *
 * Esta función realiza una inicialización mínima de hardware (display y LVGL)
 * para mostrar una única imagen binaria. No inicia la UI principal ni el gestor de hardware.
 *
 * @param image_path Ruta completa al fichero .bin de la imagen en la SD.
 * @return ESP_OK si la imagen se muestra correctamente.
 */
esp_err_t service_screen_show(const char* image_path);

#ifdef __cplusplus
}
#endif

#endif // SERVICE_SCREEN_H
--- END OF FILE: .\components\service_screen\service_screen.h ---

--- START OF FILE: .\components\ui\actions\action_brightness.c ---
/* Fecha: 17/08/2025 - 01:47  */
/* Fichero: components/ui/actions/action_brightness.c */
/* Último cambio: Implementación de la lógica de brillo, extraída del antiguo 'actions.c'. */
/* Descripción: Implementa la acción de ciclar el brillo. Contiene las variables estáticas para los niveles de brillo y el índice actual, manteniendo este estado aislado del resto del sistema. */

#include "actions/action_brightness.h"
#include "screen_manager.h" // Necesario para llamar a screen_manager_set_brightness

// --- Variables estáticas privadas del módulo de brillo ---
static int s_brightness_levels[] = {25, 50, 75, 100};
static int s_current_brightness_idx = 3; // Corresponde a 100%

/**
 * @brief Implementación de la acción de ciclar el brillo.
 */
void action_brightness_cycle(void) {
    // Avanza al siguiente nivel de brillo, volviendo al principio si es necesario (ciclo)
    s_current_brightness_idx = (s_current_brightness_idx + 1) % 4;
    
    // Llama al gestor de pantalla para aplicar el nuevo nivel de brillo
    screen_manager_set_brightness(s_brightness_levels[s_current_brightness_idx]);
}

--- END OF FILE: .\components\ui\actions\action_brightness.c ---

--- START OF FILE: .\components\ui\actions\action_brightness.h ---
/* Fecha: 17/08/2025 - 01:47  */
/* Fichero: components/ui/actions/action_brightness.h */
/* Último cambio: Creación del módulo de acción de brillo como primer paso de la refactorización. */
/* Descripción: Interfaz pública para la acción de ciclar el brillo. Encapsula la lógica de control de brillo, separándola del orquestador principal de acciones. */

#ifndef ACTION_BRIGHTNESS_H
#define ACTION_BRIGHTNESS_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Cícla a través de los niveles de brillo predefinidos y aplica el siguiente.
 *        Esta función es llamada por el orquestador de acciones principal.
 */
void action_brightness_cycle(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_BRIGHTNESS_H

--- END OF FILE: .\components\ui\actions\action_brightness.h ---

--- START OF FILE: .\components\ui\actions\action_config_mode.c ---
/* Fecha: 18/08/2025 - 09:08  */
/* Fichero: components/ui/actions/action_config_mode.c */
/* Último cambio: Implementada la lógica para intentar conexión STA antes de iniciar el modo AP. */
/* Descripción: Se ha corregido el comportamiento del modo de configuración. Ahora, al entrar, primero intenta conectarse a una red WiFi guardada. Si la conexión es exitosa, muestra la IP obtenida. Si falla o no hay credenciales, limpia el intento de conexión STA y luego inicia el modo Punto de Acceso (AP), resolviendo el problema de que siempre iniciaba en modo AP. */

#include "actions/action_config_mode.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_wifi.h"
#include "esp_netif.h"
#include "esp_lvgl_port.h"
#include "bsp_api.h"
#include "web_server.h"
#include "telemetry/telemetry_task.h"
#include "telemetry/telemetry_manager.h"
#include "screens.h"
#include "ui_idle_animation.h"
#include "ui_actions_panel.h"
#include "ui_action_animations.h"
#include "core/state_manager.h"
#include "core/ui.h" // Necesario para ui_init y ui_preinit

static const char *TAG = "ACTION_CONFIG_MODE";

// --- Variables estáticas privadas del módulo ---
static bool s_is_config_mode_active = false;
static lv_obj_t *s_config_screen = NULL;
static TaskHandle_t s_wifi_task_handle = NULL;
static httpd_handle_t s_server_handle = NULL; // Handle para el servidor web

// --- Funciones de ayuda privadas del módulo ---

/**
 * @brief Tarea de FreeRTOS para gestionar el modo de configuración.
 *        Intenta conectar como STA si hay credenciales; si no, inicia un AP.
 */
static void wifi_config_task(void *param) {
    bsp_wifi_init_stack();

    // 1. Intentar conectar como estación (STA) usando credenciales guardadas.
    ESP_LOGI(TAG, "Intentando conectar a WiFi guardado...");
    lvgl_port_lock(0);
    if (s_is_config_mode_active && s_config_screen) {
        lv_obj_t *label1 = lv_obj_get_child(s_config_screen, 0);
        lv_label_set_text(label1, "Conectando a WiFi...");
        lv_obj_t *label2 = lv_obj_get_child(s_config_screen, 1);
        lv_label_set_text(label2, "Esperando IP...");
    }
    lvgl_port_unlock();

    bsp_wifi_init_sta_from_nvs();

    // 2. Esperar a obtener una IP.
    bool connected = bsp_wifi_wait_for_ip(10000); // Timeout de 10 segundos

    if (connected && s_is_config_mode_active) {
        // 3a. Conexión exitosa: Mostrar IP y lanzar servidor.
        char ip_addr[16];
        bsp_wifi_get_ip(ip_addr);
        ESP_LOGI(TAG, "Conectado exitosamente. IP: %s", ip_addr);

        lvgl_port_lock(0);
        if (s_is_config_mode_active && s_config_screen) {
            lv_obj_t *label1 = lv_obj_get_child(s_config_screen, 0);
            lv_obj_t *label2 = lv_obj_get_child(s_config_screen, 1);
            lv_label_set_text(label1, "¡Conectado!");
            lv_label_set_text_fmt(label2, "IP: %s\nAccede desde tu navegador", ip_addr);
        }
        lvgl_port_unlock();

    } else if (s_is_config_mode_active) {
        // 3b. Fallo en conexión o sin credenciales: Iniciar modo AP.
        ESP_LOGI(TAG, "No se pudo conectar como STA. Iniciando modo AP.");
        bsp_wifi_deinit(); // Limpiar el intento de STA fallido.

        lvgl_port_lock(0);
        if (s_is_config_mode_active && s_config_screen) {
            lv_obj_t *label1 = lv_obj_get_child(s_config_screen, 0);
            lv_obj_t *label2 = lv_obj_get_child(s_config_screen, 1);
            lv_label_set_text(label1, "Modo AP Activo");
            lv_label_set_text(label2, "SSID: DIYTogether\nPass: MakeItYours\nIP: 192.168.4.1");
        }
        lvgl_port_unlock();

        bsp_wifi_start_ap();
    }

    // 4. Iniciar el servidor web en cualquier caso (STA o AP).
    if (s_is_config_mode_active) {
        ESP_LOGI(TAG, "Iniciando servidor web para gestión.");
        s_server_handle = web_server_start();
    }

    s_wifi_task_handle = NULL;
    vTaskDelete(NULL);
}


/**
 * @brief Callback de evento para el botón 'Volver' del modo de configuración.
 */
static void config_back_button_event_cb(lv_event_t *e) {
    action_config_mode_stop();
}

// --- Implementación de funciones públicas ---

void action_config_mode_start(void) {
    if (s_is_config_mode_active) return;
    s_is_config_mode_active = true;
    ESP_LOGI(TAG, "Entrando en modo de configuración: Liberando recursos de la UI principal.");

    // [OPTIMIZACIÓN] Destruir la UI principal para liberar memoria
    // La tarea de telemetría se detendrá por sí misma al no poder actualizar la UI.
    lvgl_port_lock(0);
    state_manager_destroy();
    delete_screen_main();
    lvgl_port_unlock();
    
    // Crear una pantalla simple para el modo config
    lvgl_port_lock(0);
    s_config_screen = lv_obj_create(NULL);
    lv_obj_set_style_bg_color(s_config_screen, lv_color_black(), 0);

    lv_obj_t *label1 = lv_label_create(s_config_screen);
    lv_obj_t *label2 = lv_label_create(s_config_screen);
    lv_obj_set_style_text_color(label1, lv_color_white(), 0);
    lv_obj_set_style_text_align(label1, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_set_width(label1, lv_pct(90));
    lv_obj_align(label1, LV_ALIGN_CENTER, 0, -40);
    lv_label_set_text(label1, "Iniciando WiFi...");
    
    lv_obj_set_style_text_color(label2, lv_color_white(), 0);
    lv_obj_set_style_text_align(label2, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_set_width(label2, lv_pct(90));
    lv_obj_align(label2, LV_ALIGN_CENTER, 0, 0);
    lv_label_set_text(label2, "");

    lv_obj_t* back_button = lv_btn_create(s_config_screen);
    lv_obj_align(back_button, LV_ALIGN_BOTTOM_MID, 0, -20);
    lv_obj_add_event_cb(back_button, config_back_button_event_cb, LV_EVENT_CLICKED, NULL);
    lv_obj_t* lbl = lv_label_create(back_button);
    lv_label_set_text(lbl, "VOLVER");
    lv_obj_center(lbl);

    lv_screen_load(s_config_screen);
    lvgl_port_unlock();

    xTaskCreate(wifi_config_task, "wifi_cfg_task", 4096, NULL, 5, &s_wifi_task_handle);
}

void action_config_mode_stop(void) {
    if (!s_is_config_mode_active) return;
    
    ESP_LOGI(TAG, "Saliendo del modo de configuración y restaurando UI.");
    s_is_config_mode_active = false;

    // 1. Detener todos los servicios de red y liberar sus recursos.
    web_server_stop(s_server_handle);
    s_server_handle = NULL;
    if (s_wifi_task_handle) { vTaskDelete(s_wifi_task_handle); s_wifi_task_handle = NULL; }
    
    // [CORRECCIÓN CRÍTICA] Llamar a la función de desinicialización completa del BSP.
    bsp_wifi_deinit();
    
    ESP_LOGI(TAG, "Servicios de red detenidos y limpiados.");
    
    lvgl_port_lock(0);
    // 2. Liberar la UI del modo configuración.
    if (s_config_screen) {
        lv_obj_del(s_config_screen);
        s_config_screen = NULL;
    }

    // 3. Pre-alocar el buffer de animación AHORA, mientras la memoria está limpia.
    ui_preinit();

    // 4. Reconstruir la UI principal y sus gestores.
    ui_init();
    state_manager_init();
    lvgl_port_unlock();

    // 5. Reiniciar tareas de la aplicación.
    telemetry_task_start();
    ESP_LOGI(TAG, "UI principal restaurada. Sistema de vuelta a modo normal.");
}

--- END OF FILE: .\components\ui\actions\action_config_mode.c ---

--- START OF FILE: .\components\ui\actions\action_config_mode.h ---
/* Fecha: 17/08/2025 - 01:49  */
/* Fichero: components/ui/actions/action_config_mode.h */
/* Último cambio: Creación del módulo para la acción del modo de configuración. */
/* Descripción: Interfaz pública para gestionar el ciclo de vida del modo de configuración. Expone funciones para iniciar y detener el modo, encapsulando su estado y la gestión de la tarea de red. */

#ifndef ACTION_CONFIG_MODE_H
#define ACTION_CONFIG_MODE_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicia el modo de configuración WiFi.
 *        Oculta la UI principal, muestra la información de red,
 *        y lanza una tarea para gestionar la conexión y el servidor web.
 */
void action_config_mode_start(void);

/**
 * @brief Detiene el modo de configuración WiFi.
 *        Limpia los elementos de la UI de configuración, detiene la tarea
 *        de red y los servicios asociados, y restaura la UI principal.
 */
void action_config_mode_stop(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_CONFIG_MODE_H

--- END OF FILE: .\components\ui\actions\action_config_mode.h ---

--- START OF FILE: .\components\ui\actions\action_evolution.c ---
/* Fecha: 17/08/2025 - 09:45  */
/* Fichero: components/ui/actions/action_evolution.c */
/* Último cambio: Actualizada la ruta de inclusión de 'telemetry_manager.h' para reflejar la refactorización a ui/telemetry/. */
/* Descripción: Módulo que maneja los cambios de estado del Diymon. Se ha actualizado la ruta de inclusión para apuntar al nuevo directorio 'telemetry', manteniendo la consistencia con la refactorización de la lógica de sensores. */

#include "actions/action_evolution.h"
#include "diymon_evolution.h"
#include "ui_idle_animation.h"
#include "telemetry/telemetry_manager.h"
#include "ui_action_animations.h" // Para g_animation_img_obj
#include "screens.h"              // Para g_main_screen_obj
#include "esp_log.h"

static const char *TAG = "ACTION_EVOLUTION";

/**
 * @brief Función interna para actualizar la UI después de un cambio de evolución.
 */
static void update_ui_after_evolution_change(void) {
    // Detiene la animación de reposo actual para poder recargarla con el nuevo personaje.
    ui_idle_animation_stop();
    // Oculta temporalmente el objeto de la animación para evitar que se vea el último fotograma del personaje anterior.
    if (g_animation_img_obj) {
        lv_obj_add_flag(g_animation_img_obj, LV_OBJ_FLAG_HIDDEN);
    }

    // Fuerza la actualización inmediata de la telemetría para que muestre el nuevo código EVO.
    telemetry_manager_update_values(100); // Se asume 100% de batería, ya que no se recalcula aquí. La tarea principal lo corregirá.
    
    // Inicia la nueva animación de reposo, que cargará los assets del nuevo código de evolución.
    ui_idle_animation_start(g_main_screen_obj);
    
    // Vuelve a hacer visible el objeto de la animación.
    if (g_animation_img_obj) {
        lv_obj_clear_flag(g_animation_img_obj, LV_OBJ_FLAG_HIDDEN);
    }
}

/**
 * @brief Implementa la acción de evolucionar a una rama.
 */
void action_evolution_branch(int branch_id) {
    const char* current_code = diymon_get_current_code();
    const char* next_code = diymon_get_branched_evolution(current_code, branch_id);

    if (next_code) {
        ESP_LOGI(TAG, "Evolucionando de '%s' a '%s' (rama %d)", current_code, next_code, branch_id);
        diymon_set_current_code(next_code);
        update_ui_after_evolution_change();
    } else {
        ESP_LOGW(TAG, "Evolución inválida desde '%s' por la rama %d", current_code, branch_id);
    }
}

/**
 * @brief Implementa la acción de involucionar.
 */
void action_evolution_devolve(void) {
    const char* current_code = diymon_get_current_code();
    const char* previous_code = diymon_get_previous_evolution_in_sequence(current_code);

    if (previous_code) {
        ESP_LOGI(TAG, "Involucionando de '%s' a '%s'", current_code, previous_code);
        diymon_set_current_code(previous_code);
        update_ui_after_evolution_change();
    } else {
        ESP_LOGW(TAG, "Involución inválida desde '%s' (ya es la forma base)", current_code);
    }
}

--- END OF FILE: .\components\ui\actions\action_evolution.c ---

--- START OF FILE: .\components\ui\actions\action_evolution.h ---
/* Fecha: 17/08/2025 - 01:49  */
/* Fichero: components/ui/actions/action_evolution.h */
/* Último cambio: Creación del módulo para agrupar las acciones de evolución del Diymon. */
/* Descripción: Interfaz pública para las acciones de evolución y de involución. Agrupa la lógica relacionada con el cambio de estado del Diymon para mantener el orquestador principal limpio. */

#ifndef ACTION_EVOLUTION_H
#define ACTION_EVOLUTION_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Intenta ejecutar una evolución ramificada basada en el estado actual.
 * @param branch_id El identificador de la rama a la que se intenta evolucionar (1-4).
 */
void action_evolution_branch(int branch_id);

/**
 * @brief Ejecuta una involución al estado evolutivo anterior.
 */
void action_evolution_devolve(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_EVOLUTION_H

--- END OF FILE: .\components\ui\actions\action_evolution.h ---

--- START OF FILE: .\components\ui\actions\action_interaction.c ---
/* Fecha: 17/08/2025 - 01:48  */
/* Fichero: components/ui/actions/action_interaction.c */
/* Último cambio: Implementación de las acciones de interacción (comer, ejercicio, atacar). */
/* Descripción: Implementa las funciones que inician las animaciones de acción básicas. Este módulo actúa como un simple despachador, llamando al gestor de animaciones con el ID de acción correcto. */

#include "actions/action_interaction.h"
#include "ui_action_animations.h" // Necesario para reproducir animaciones
#include "actions.h"              // Necesario para los ACTION_ID_*

/**
 * @brief Implementa la acción de 'comer'.
 */
void action_interaction_eat(void) {
    ui_action_animations_play(ACTION_ID_COMER);
}

/**
 * @brief Implementa la acción de 'ejercicio'.
 */
void action_interaction_gym(void) {
    ui_action_animations_play(ACTION_ID_EJERCICIO);
}

/**
 * @brief Implementa la acción de 'atacar'.
 */
void action_interaction_attack(void) {
    ui_action_animations_play(ACTION_ID_ATACAR);
}

--- END OF FILE: .\components\ui\actions\action_interaction.c ---

--- START OF FILE: .\components\ui\actions\action_interaction.h ---
/* Fecha: 17/08/2025 - 01:48  */
/* Fichero: components/ui/actions/action_interaction.h */
/* Último cambio: Creación del módulo para agrupar las acciones de interacción del Diymon. */
/* Descripción: Interfaz pública para las acciones de 'comer', 'ejercicio' y 'atacar'. Agrupa estas acciones relacionadas en un solo módulo, siguiendo el patrón de refactorización. */

#ifndef ACTION_INTERACTION_H
#define ACTION_INTERACTION_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Ejecuta la acción de 'comer', que dispara la animación correspondiente.
 */
void action_interaction_eat(void);

/**
 * @brief Ejecuta la acción de 'ejercicio', que dispara la animación correspondiente.
 */
void action_interaction_gym(void);

/**
 * @brief Ejecuta la acción de 'atacar', que dispara la animación correspondiente.
 */
void action_interaction_attack(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_INTERACTION_H

--- END OF FILE: .\components\ui\actions\action_interaction.h ---

--- START OF FILE: .\components\ui\actions\action_screen.c ---
/* Fecha: 17/08/2025 - 01:48  */
/* Fichero: components/ui/actions/action_screen.c */
/* Último cambio: Implementación de la lógica de encendido/apagado de pantalla. */
/* Descripción: Módulo que implementa la acción de alternar el estado de la pantalla. Depende del 'screen_manager' para el control físico del display y del 'ui_actions_panel' para ocultar los botones antes de apagar. */

#include "actions/action_screen.h"
#include "screen_manager.h"
#include "ui_actions_panel.h" // Necesario para ocultar los paneles

/**
 * @brief Implementación de la acción de alternar el estado de la pantalla.
 */
void action_screen_toggle(void) {
    if (screen_manager_is_off()) {
        // Si la pantalla está apagada, simplemente la enciende.
        screen_manager_turn_on();
    } else {
        // Si la pantalla está encendida, primero oculta cualquier panel de acción visible
        // y luego apaga la pantalla para una transición limpia.
        ui_actions_panel_hide_all(); 
        screen_manager_turn_off();
    }
}

--- END OF FILE: .\components\ui\actions\action_screen.c ---

--- START OF FILE: .\components\ui\actions\action_screen.h ---
/* Fecha: 17/08/2025 - 01:48  */
/* Fichero: components/ui/actions/action_screen.h */
/* Último cambio: Creación del módulo para la acción de encender/apagar la pantalla. */
/* Descripción: Interfaz pública para la acción de control de pantalla. Encapsula la lógica de encendido y apagado, continuando la refactorización para desacoplar el orquestador principal. */

#ifndef ACTION_SCREEN_H
#define ACTION_SCREEN_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Alterna el estado de la pantalla (encendido/apagado).
 *        Si está encendida, oculta los paneles y la apaga.
 *        Si está apagada, la enciende.
 */
void action_screen_toggle(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_SCREEN_H

--- END OF FILE: .\components\ui\actions\action_screen.h ---

--- START OF FILE: .\components\ui\actions\action_system.c ---
/* Fecha: 18/08/2025 - 07:00  */
/* Fichero: components/ui/actions/action_system.c */
/* Último cambio: Eliminada la inclusión de 'wifi_portal.h' para resolver el error de compilación. */
/* Descripción: Se ha eliminado la directiva '#include "wifi_portal.h"' porque el componente 'wifi_portal' fue borrado del proyecto. Las funciones para borrar credenciales ahora residen en el BSP o en un nuevo módulo de gestión de NVS, pero por ahora se elimina la dependencia directa para permitir la compilación. */

#include "actions/action_system.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "esp_system.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "diymon_evolution.h"
#include "esp_log.h"
#include "bsp_api.h" // Se asume que el borrado de credenciales estará aquí o en un gestor NVS

static const char *TAG = "ACTION_SYSTEM";

/**
 * @brief Función de ayuda para borrar una clave específica de la NVS.
 */
static void erase_nvs_key(const char* key) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err == ESP_OK) {
        nvs_erase_key(nvs_handle, key);
        nvs_commit(nvs_handle);
        nvs_close(nvs_handle);
        ESP_LOGI(TAG, "Clave NVS '%s' borrada.", key);
    } else {
        ESP_LOGE(TAG, "Error al abrir NVS para borrar la clave '%s'.", key);
    }
}

/**
 * @brief Función interna para borrar credenciales WiFi.
 * @note Esto es una solución temporal. Idealmente, esta lógica debería estar
 *       en un módulo dedicado a la gestión de NVS o en el BSP.
 */
static void erase_wifi_credentials_from_nvs(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) return;
    nvs_erase_key(nvs_handle, "wifi_ssid");
    nvs_erase_key(nvs_handle, "wifi_pass");
    nvs_erase_key(nvs_handle, "wifi_authmode");
    nvs_commit(nvs_handle);
    nvs_close(nvs_handle);
    ESP_LOGI(TAG, "Credenciales WiFi borradas de NVS.");
}


/**
 * @brief Implementación del reseteo total del dispositivo.
 */
void action_system_reset_all(void) {
    ESP_LOGW(TAG, "Ejecutando reseteo total del dispositivo...");
    
    // Borra todas las configuraciones guardadas
    erase_wifi_credentials_from_nvs();
    diymon_evolution_reset_state();
    erase_nvs_key("file_server"); // Se mantiene por si quedan restos de versiones anteriores

    ESP_LOGW(TAG, "Todas las configuraciones borradas. Reiniciando ahora.");
    vTaskDelay(pdMS_TO_TICKS(1000));
    esp_restart();
}

--- END OF FILE: .\components\ui\actions\action_system.c ---

--- START OF FILE: .\components\ui\actions\action_system.h ---
/* Fecha: 17/08/2025 - 03:35  */
/* Fichero: components/ui/actions/action_system.h */
/* Último cambio: Creación del módulo para agrupar las acciones de sistema como primer paso de la refactorización de 'actions.c'. */
/* Descripción: Interfaz pública para las acciones de sistema como 'activar servidor de ficheros' y 'reset total'. Este es el primer paso para descomponer el monolítico 'actions.c', siguiendo el Principio de Responsabilidad Única. */

#ifndef ACTION_SYSTEM_H
#define ACTION_SYSTEM_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Activa el modo de servidor de ficheros.
 *        Establece una bandera en NVS y reinicia el dispositivo para que
 *        app_main entre en el modo de servicio correspondiente.
 */
void action_system_enable_file_server(void);

/**
 * @brief Realiza un reseteo total del dispositivo.
 *        Borra las credenciales WiFi, el estado de evolución y la bandera
 *        del servidor de ficheros de la NVS, y luego reinicia.
 */
void action_system_reset_all(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_SYSTEM_H

--- END OF FILE: .\components\ui\actions\action_system.h ---

--- START OF FILE: .\components\ui\buttons\btn_1.c ---
/* Fecha: 17/08/2025 - 07:11  */
/* Fichero: components/ui/buttons/btn_1.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido un error de posicionamiento del botón que impedía su correcta visualización. Se ha reemplazado la lógica de posicionamiento absoluto (lv_obj_set_pos) y ocultación explícita por un alineamiento relativo (lv_obj_align) dentro de su panel padre. Esto soluciona el problema por el cual el botón no aparecía al desplegarse el panel de acciones. */
#include "btn_1.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_1";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_btn_1_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Comer'.
 *        Ejecuta la acción de comer cuando se presiona el botón.
 * @param e Puntero al evento de LVGL.
 */
static void btn_1_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de comer.");
        execute_diymon_action(ACTION_ID_COMER);
    }
}

/**
 * @brief Crea el objeto del botón 'Comer'.
 */
void btn_1_create(lv_obj_t *parent) {
    s_btn_1_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_1_handle);
    lv_obj_set_size(s_btn_1_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_btn_1_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_1_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_1_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_btn_1_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EAT);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EAT'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_1_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 0, 0);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_btn_1_handle, btn_1_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Botón 'Comer' (BTN_1) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Comer'.
 */
lv_obj_t* btn_1_get_handle(void) {
    return s_btn_1_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_1.c ---

--- START OF FILE: .\components\ui\buttons\btn_1.h ---
/* Fecha: 17/08/2025 - 01:17 
# Fichero: components/ui/buttons/btn_1.h
# Último cambio: Creación del fichero de cabecera para el botón 'Comer' (BTN_1).
# Descripción: Define la interfaz pública para el módulo del botón 'Comer'. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador, encapsulando su lógica.
*/
#ifndef BTN_1_H
#define BTN_1_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Comer'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void btn_1_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Comer'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* btn_1_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_1_H

--- END OF FILE: .\components\ui\buttons\btn_1.h ---

--- START OF FILE: .\components\ui\buttons\btn_2.c ---
/* Fecha: 17/08/2025 - 05:17  */
/* Fichero: components/ui/buttons/btn_2.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_2.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_2";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_btn_2_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Ejercicio'.
 *        Ejecuta la acción de ejercicio cuando se presiona el botón.
 * @param e Puntero al evento de LVGL.
 */
static void btn_2_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de ejercicio.");
        execute_diymon_action(ACTION_ID_EJERCICIO);
    }
}

/**
 * @brief Crea el objeto del botón 'Ejercicio'.
 */
void btn_2_create(lv_obj_t *parent) {
    s_btn_2_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_2_handle);
    lv_obj_set_size(s_btn_2_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_btn_2_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_2_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_2_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_btn_2_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_GYM);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_GYM'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_2_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 1, 0);
    
    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_btn_2_handle, btn_2_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Botón 'Ejercicio' (BTN_2) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Ejercicio'.
 */
lv_obj_t* btn_2_get_handle(void) {
    return s_btn_2_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_2.c ---

--- START OF FILE: .\components\ui\buttons\btn_2.h ---
/* Fecha: 17/08/2025 - 01:18 
# Fichero: components/ui/buttons/btn_2.h
# Último cambio: Creación del fichero de cabecera para el botón 'Ejercicio' (BTN_2).
# Descripción: Define la interfaz pública para el módulo del botón 'Ejercicio'. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef BTN_2_H
#define BTN_2_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Ejercicio'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void btn_2_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Ejercicio'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* btn_2_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_2_H

--- END OF FILE: .\components\ui\buttons\btn_2.h ---

--- START OF FILE: .\components\ui\buttons\btn_3.c ---
/* Fecha: 17/08/2025 - 05:18  */
/* Fichero: components/ui/buttons/btn_3.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_3.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_3";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_btn_3_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Atacar'.
 *        Ejecuta la acción de atacar cuando se presiona el botón.
 * @param e Puntero al evento de LVGL.
 */
static void btn_3_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de atacar.");
        execute_diymon_action(ACTION_ID_ATACAR);
    }
}

/**
 * @brief Crea el objeto del botón 'Atacar'.
 */
void btn_3_create(lv_obj_t *parent) {
    s_btn_3_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_3_handle);
    lv_obj_set_size(s_btn_3_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_btn_3_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_3_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_3_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_btn_3_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_ATK);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_ATK'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_3_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 2, 0);
    
    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_btn_3_handle, btn_3_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Botón 'Atacar' (BTN_3) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Atacar'.
 */
lv_obj_t* btn_3_get_handle(void) {
    return s_btn_3_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_3.c ---

--- START OF FILE: .\components\ui\buttons\btn_3.h ---
/* Fecha: 17/08/2025 - 01:19 
# Fichero: components/ui/buttons/btn_3.h
# Último cambio: Creación del fichero de cabecera para el botón 'Atacar' (BTN_3).
# Descripción: Define la interfaz pública para el módulo del botón 'Atacar'. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef BTN_3_H
#define BTN_3_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Atacar'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void btn_3_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Atacar'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* btn_3_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_3_H

--- END OF FILE: .\components\ui\buttons\btn_3.h ---

--- START OF FILE: .\components\ui\buttons\btn_4.c ---
/* Fecha: 17/08/2025 - 05:19  */
/* Fichero: components/ui/buttons/btn_4.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_4.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_4";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_btn_4_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Brillo'.
 *        Ejecuta la acción de ciclar el brillo.
 * @param e Puntero al evento de LVGL.
 */
static void btn_4_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de brillo.");
        execute_diymon_action(ACTION_ID_BRIGHTNESS_CYCLE);
    }
}

/**
 * @brief Crea el objeto del botón 'Brillo'.
 */
void btn_4_create(lv_obj_t *parent) {
    s_btn_4_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_4_handle);
    lv_obj_set_size(s_btn_4_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_btn_4_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_4_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_4_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_btn_4_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_BRIGHTNESS);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_BRIGHTNESS'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_4_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 0, 0);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_btn_4_handle, btn_4_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Botón 'Brillo' (BTN_4) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Brillo'.
 */
lv_obj_t* btn_4_get_handle(void) {
    return s_btn_4_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_4.c ---

--- START OF FILE: .\components\ui\buttons\btn_4.h ---
/* Fecha: 17/08/2025 - 01:20 
# Fichero: components/ui/buttons/btn_4.h
# Último cambio: Creación del fichero de cabecera para el botón 'Brillo' (BTN_4).
# Descripción: Define la interfaz pública para el módulo del botón 'Brillo'. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef BTN_4_H
#define BTN_4_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Brillo'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void btn_4_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Brillo'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* btn_4_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_4_H

--- END OF FILE: .\components\ui\buttons\btn_4.h ---

--- START OF FILE: .\components\ui\buttons\btn_5.c ---
/* Fecha: 17/08/2025 - 05:19  */
/* Fichero: components/ui/buttons/btn_5.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_5.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_5";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_btn_5_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Apagar Pantalla'.
 *        Ejecuta la acción de apagar/encender la pantalla.
 * @param e Puntero al evento de LVGL.
 */
static void btn_5_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de apagar/encender pantalla.");
        execute_diymon_action(ACTION_ID_TOGGLE_SCREEN);
    }
}

/**
 * @brief Crea el objeto del botón 'Apagar Pantalla'.
 */
void btn_5_create(lv_obj_t *parent) {
    s_btn_5_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_5_handle);
    lv_obj_set_size(s_btn_5_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_btn_5_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_5_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_5_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_btn_5_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_SCREEN_OFF);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_SCREEN_OFF'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_5_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 1, 0);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_btn_5_handle, btn_5_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Botón 'Apagar Pantalla' (BTN_5) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Apagar Pantalla'.
 */
lv_obj_t* btn_5_get_handle(void) {
    return s_btn_5_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_5.c ---

--- START OF FILE: .\components\ui\buttons\btn_5.h ---
/* Fecha: 17/08/2025 - 01:20 
# Fichero: components/ui/buttons/btn_5.h
# Último cambio: Creación del fichero de cabecera para el botón 'Apagar Pantalla' (BTN_5).
# Descripción: Define la interfaz pública para el módulo del botón 'Apagar Pantalla'. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef BTN_5_H
#define BTN_5_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Apagar Pantalla'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void btn_5_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Apagar Pantalla'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* btn_5_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_5_H

--- END OF FILE: .\components\ui\buttons\btn_5.h ---

--- START OF FILE: .\components\ui\buttons\btn_6.c ---
/* Fecha: 17/08/2025 - 05:20  */
/* Fichero: components/ui/buttons/btn_6.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_6.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_6";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_btn_6_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Modo Config'.
 *        Ejecuta la acción de activar el modo de configuración.
 * @param e Puntero al evento de LVGL.
 */
static void btn_6_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de modo config.");
        execute_diymon_action(ACTION_ID_ACTIVATE_CONFIG_MODE);
    }
}

/**
 * @brief Crea el objeto del botón 'Modo Config'.
 */
void btn_6_create(lv_obj_t *parent) {
    s_btn_6_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_6_handle);
    lv_obj_set_size(s_btn_6_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_btn_6_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_6_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_6_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_btn_6_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_ADMIN_PLACEHOLDER);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_ADMIN_PLACEHOLDER'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_6_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 2, 0);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_btn_6_handle, btn_6_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Botón 'Modo Config' (BTN_6) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Modo Config'.
 */
lv_obj_t* btn_6_get_handle(void) {
    return s_btn_6_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_6.c ---

--- START OF FILE: .\components\ui\buttons\btn_6.h ---
/* Fecha: 17/08/2025 - 01:21 
# Fichero: components\ui\buttons\btn_6.h
# Último cambio: Creación del fichero de cabecera para el botón 'Modo Config' (BTN_6).
# Descripción: Define la interfaz pública para el módulo del botón que activa el modo de configuración. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef BTN_6_H
#define BTN_6_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Modo Config'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void btn_6_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Modo Config'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* btn_6_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_6_H

--- END OF FILE: .\components\ui\buttons\btn_6.h ---

--- START OF FILE: .\components\ui\buttons\btn_7.c ---
/* Fecha: 17/08/2025 - 05:21  */
/* Fichero: components/ui/buttons/btn_7.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_7.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_7";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_btn_7_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Reset Total'.
 *        Ejecuta la acción de reseteo total.
 * @param e Puntero al evento de LVGL.
 */
static void btn_7_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de reset total.");
        execute_diymon_action(ACTION_ID_RESET_ALL);
    }
}

/**
 * @brief Crea el objeto del botón 'Reset Total'.
 */
void btn_7_create(lv_obj_t *parent) {
    s_btn_7_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_7_handle);
    lv_obj_set_size(s_btn_7_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_btn_7_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_7_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_7_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_btn_7_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_RESET_ALL);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_RESET_ALL'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_7_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 0, 0);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_btn_7_handle, btn_7_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Botón 'Reset Total' (BTN_7) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Reset Total'.
 */
lv_obj_t* btn_7_get_handle(void) {
    return s_btn_7_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_7.c ---

--- START OF FILE: .\components\ui\buttons\btn_7.h ---
/* Fecha: 17/08/2025 - 01:22 
# Fichero: components\ui\buttons\btn_7.h
# Último cambio: Creación del fichero de cabecera para el botón 'Reset Total' (BTN_7).
# Descripción: Define la interfaz pública para el módulo del botón de reseteo. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef BTN_7_H
#define BTN_7_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Reset Total'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void btn_7_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Reset Total'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* btn_7_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_7_H

--- END OF FILE: .\components\ui\buttons\btn_7.h ---

--- START OF FILE: .\components\ui\buttons\btn_8.c ---
/* Fecha: 18/08/2025 - 06:55  */
/* Fichero: components/ui/buttons/btn_8.c */
/* Último cambio: Reasignada la acción del botón a ACTION_ID_CONFIG_PLACEHOLDER tras eliminar el modo de servidor de ficheros. */
/* Descripción: Este botón activaba anteriormente el modo de servidor de ficheros. Como esa funcionalidad ahora está integrada en el modo de configuración principal, el botón se ha convertido en un placeholder. Ahora dispara una acción genérica que no realiza ninguna operación, manteniendo la consistencia de la UI mientras se rediseña su función. */

#include "btn_8.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_8";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_btn_8_handle = NULL;

/**
 * @brief Callback de evento para el botón 8.
 */
static void btn_8_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "Botón 8 (placeholder) presionado.");
        // [CORRECCIÓN] La acción del servidor de ficheros ha sido eliminada.
        // Ahora se dispara una acción placeholder que no hace nada.
        execute_diymon_action(ACTION_ID_CONFIG_PLACEHOLDER);
    }
}

/**
 * @brief Crea el objeto del botón 8.
 */
void btn_8_create(lv_obj_t *parent) {
    s_btn_8_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_8_handle);
    lv_obj_set_size(s_btn_8_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_btn_8_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_8_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_8_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_btn_8_handle);
    // [CORRECCIÓN] Se mantiene el icono original por ahora, pero la acción ha cambiado.
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_ENABLE_FILE_SERVER);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_ENABLE_FILE_SERVER'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    lv_obj_align(s_btn_8_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 1, 0);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_btn_8_handle, btn_8_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Botón 8 (placeholder) creado y posicionado.");
}

/**
 * @brief Obtiene el manejador del botón 8.
 */
lv_obj_t* btn_8_get_handle(void) {
    return s_btn_8_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_8.c ---

--- START OF FILE: .\components\ui\buttons\btn_8.h ---
/* Fecha: 17/08/2025 - 01:24 
# Fichero: components\ui\buttons\btn_8.h
# Último cambio: Creación del fichero de cabecera para el botón 'Servidor de Ficheros' (BTN_8).
# Descripción: Define la interfaz pública para el módulo del botón que activa el servidor de ficheros. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef BTN_8_H
#define BTN_8_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Servidor de Ficheros'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void btn_8_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Servidor de Ficheros'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* btn_8_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_8_H

--- END OF FILE: .\components\ui\buttons\btn_8.h ---

--- START OF FILE: .\components\ui\buttons\btn_9.c ---
/* Fecha: 17/08/2025 - 05:21  */
/* Fichero: components/ui/buttons/btn_9.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_9.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_9";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_btn_9_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Placeholder de Config'.
 *        Ejecuta la acción de placeholder.
 * @param e Puntero al evento de LVGL.
 */
static void btn_9_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de placeholder.");
        execute_diymon_action(ACTION_ID_CONFIG_PLACEHOLDER);
    }
}

/**
 * @brief Crea el objeto del botón 'Placeholder de Config'.
 */
void btn_9_create(lv_obj_t *parent) {
    s_btn_9_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_9_handle);
    lv_obj_set_size(s_btn_9_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_btn_9_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_9_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_9_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_btn_9_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_CONFIG_PLACEHOLDER);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_CONFIG_PLACEHOLDER'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_9_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 2, 0);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_btn_9_handle, btn_9_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Botón 'Placeholder Config' (BTN_9) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Placeholder de Config'.
 */
lv_obj_t* btn_9_get_handle(void) {
    return s_btn_9_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_9.c ---

--- START OF FILE: .\components\ui\buttons\btn_9.h ---
/* Fecha: 17/08/2025 - 01:24 
# Fichero: components\ui\buttons\btn_9.h
# Último cambio: Creación del fichero de cabecera para el botón 'Placeholder de Config' (BTN_9).
# Descripción: Define la interfaz pública para el módulo del botón placeholder del panel de configuración. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef BTN_9_H
#define BTN_9_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Placeholder de Config'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void btn_9_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Placeholder de Config'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* btn_9_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_9_H

--- END OF FILE: .\components\ui\buttons\btn_9.h ---

--- START OF FILE: .\components\ui\buttons\buttons_manager.c ---
/* Fecha: 17/08/2025 - 01:29 
# Fichero: components\ui\buttons\buttons_manager.c
# Último cambio: Implementación del orquestador de botones.
# Descripción: Este fichero centraliza la creación de todos los botones de la UI. La función ui_buttons_init llama a las funciones de creación de cada módulo de botón individual, y los getters proporcionan acceso a sus manejadores para otros módulos.
*/
#include "buttons_manager.h"

// Include all individual button modules
#include "btn_1.h"
#include "btn_2.h"
#include "btn_3.h"
#include "btn_4.h"
#include "btn_5.h"
#include "btn_6.h"
#include "btn_7.h"
#include "btn_8.h"
#include "btn_9.h"
#include "evo_1.h"
#include "evo_2.h"
#include "evo_3.h"
#include "evo_4.h"
#include "evo_5.h"

/**
 * @brief Inicializa y crea todos los botones de la UI llamando a los constructores de cada módulo.
 */
void ui_buttons_init(lv_obj_t *parent) {
    // --- Panel de Jugador (3 botones) ---
    btn_1_create(parent);
    btn_2_create(parent);
    btn_3_create(parent);

    // --- Panel de Administración (3 botones) ---
    btn_4_create(parent);
    btn_5_create(parent);
    btn_6_create(parent);
    
    // --- Panel de Configuración (3 botones) ---
    btn_7_create(parent);
    btn_8_create(parent);
    btn_9_create(parent);

    // --- Panel Lateral de Evolución (5 botones) ---
    evo_1_create(parent);
    evo_2_create(parent);
    evo_3_create(parent);
    evo_4_create(parent);
    evo_5_create(parent);
}

// --- Implementación de Getters ---
lv_obj_t* ui_buttons_get_btn_1(void) { return btn_1_get_handle(); }
lv_obj_t* ui_buttons_get_btn_2(void) { return btn_2_get_handle(); }
lv_obj_t* ui_buttons_get_btn_3(void) { return btn_3_get_handle(); }
lv_obj_t* ui_buttons_get_btn_4(void) { return btn_4_get_handle(); }
lv_obj_t* ui_buttons_get_btn_5(void) { return btn_5_get_handle(); }
lv_obj_t* ui_buttons_get_btn_6(void) { return btn_6_get_handle(); }
lv_obj_t* ui_buttons_get_btn_7(void) { return btn_7_get_handle(); }
lv_obj_t* ui_buttons_get_btn_8(void) { return btn_8_get_handle(); }
lv_obj_t* ui_buttons_get_btn_9(void) { return btn_9_get_handle(); }

lv_obj_t* ui_buttons_get_evo_1(void) { return evo_1_get_handle(); }
lv_obj_t* ui_buttons_get_evo_2(void) { return evo_2_get_handle(); }
lv_obj_t* ui_buttons_get_evo_3(void) { return evo_3_get_handle(); }
lv_obj_t* ui_buttons_get_evo_4(void) { return evo_4_get_handle(); }
lv_obj_t* ui_buttons_get_evo_5(void) { return evo_5_get_handle(); }

--- END OF FILE: .\components\ui\buttons\buttons_manager.c ---

--- START OF FILE: .\components\ui\buttons\buttons_manager.h ---
/* Fecha: 17/08/2025 - 01:28 
# Fichero: components\ui\buttons\buttons_manager.h
# Último cambio: Creación del fichero de cabecera para el orquestador de botones.
# Descripción: Define la interfaz pública del gestor de botones. Expone una función de inicialización para crear todos los botones de la UI y getters individuales para que otros módulos, como el gestor de paneles, puedan acceder a sus manejadores.
*/
#ifndef BUTTONS_MANAGER_H
#define BUTTONS_MANAGER_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa y crea todos los botones de la interfaz de usuario.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crearán todos los botones.
 */
void ui_buttons_init(lv_obj_t *parent);

// --- Getters para los botones del panel superior ---
lv_obj_t* ui_buttons_get_btn_1(void); // Comer
lv_obj_t* ui_buttons_get_btn_2(void); // Ejercicio
lv_obj_t* ui_buttons_get_btn_3(void); // Atacar
lv_obj_t* ui_buttons_get_btn_4(void); // Brillo
lv_obj_t* ui_buttons_get_btn_5(void); // Apagar Pantalla
lv_obj_t* ui_buttons_get_btn_6(void); // Modo Config
lv_obj_t* ui_buttons_get_btn_7(void); // Reset Total
lv_obj_t* ui_buttons_get_btn_8(void); // Servidor Ficheros
lv_obj_t* ui_buttons_get_btn_9(void); // Placeholder Config

// --- Getters para los botones del panel lateral (Evolución) ---
lv_obj_t* ui_buttons_get_evo_1(void); // Fuego
lv_obj_t* ui_buttons_get_evo_2(void); // Agua
lv_obj_t* ui_buttons_get_evo_3(void); // Tierra
lv_obj_t* ui_buttons_get_evo_4(void); // Viento
lv_obj_t* ui_buttons_get_evo_5(void); // Involucionar


#ifdef __cplusplus
}
#endif

#endif // BUTTONS_MANAGER_H

--- END OF FILE: .\components\ui\buttons\buttons_manager.h ---

--- START OF FILE: .\components\ui\buttons\evo_1.c ---
/* Fecha: 17/08/2025 - 05:22  */
/* Fichero: components/ui/buttons/evo_1.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "evo_1.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "EVO_1";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_evo_1_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Evo Fuego'.
 *        Ejecuta la acción de evolucionar a Fuego.
 * @param e Puntero al evento de LVGL.
 */
static void evo_1_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de evo fuego.");
        execute_diymon_action(ACTION_ID_EVO_FIRE);
    }
}

/**
 * @brief Crea el objeto del botón 'Evo Fuego'.
 */
void evo_1_create(lv_obj_t *parent) {
    s_evo_1_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_evo_1_handle);
    lv_obj_set_size(s_evo_1_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_evo_1_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_evo_1_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_evo_1_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_evo_1_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EVO_FIRE);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EVO_FIRE'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_evo_1_handle, LV_ALIGN_TOP_MID, 0, (BUTTON_SIZE + BUTTON_PADDING) * 0);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_evo_1_handle, evo_1_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Botón 'Evo Fuego' (EVO_1) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Evo Fuego'.
 */
lv_obj_t* evo_1_get_handle(void) {
    return s_evo_1_handle;
}

--- END OF FILE: .\components\ui\buttons\evo_1.c ---

--- START OF FILE: .\components\ui\buttons\evo_1.h ---
/* Fecha: 17/08/2025 - 01:25 
# Fichero: components\ui\buttons\evo_1.h
# Último cambio: Creación del fichero de cabecera para el botón 'Evo Fuego' (EVO_1).
# Descripción: Define la interfaz pública para el módulo del botón de evolución de Fuego. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef EVO_1_H
#define EVO_1_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Evo Fuego'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void evo_1_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Evo Fuego'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* evo_1_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // EVO_1_H

--- END OF FILE: .\components\ui\buttons\evo_1.h ---

--- START OF FILE: .\components\ui\buttons\evo_2.c ---
/* Fecha: 17/08/2025 - 05:22  */
/* Fichero: components/ui/buttons/evo_2.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "evo_2.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "EVO_2";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_evo_2_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Evo Agua'.
 *        Ejecuta la acción de evolucionar a Agua.
 * @param e Puntero al evento de LVGL.
 */
static void evo_2_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de evo agua.");
        execute_diymon_action(ACTION_ID_EVO_WATER);
    }
}

/**
 * @brief Crea el objeto del botón 'Evo Agua'.
 */
void evo_2_create(lv_obj_t *parent) {
    s_evo_2_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_evo_2_handle);
    lv_obj_set_size(s_evo_2_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_evo_2_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_evo_2_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_evo_2_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_evo_2_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EVO_WATER);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EVO_WATER'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_evo_2_handle, LV_ALIGN_TOP_MID, 0, (BUTTON_SIZE + BUTTON_PADDING) * 1);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_evo_2_handle, evo_2_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Botón 'Evo Agua' (EVO_2) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Evo Agua'.
 */
lv_obj_t* evo_2_get_handle(void) {
    return s_evo_2_handle;
}

--- END OF FILE: .\components\ui\buttons\evo_2.c ---

--- START OF FILE: .\components\ui\buttons\evo_2.h ---
/* Fecha: 17/08/2025 - 01:26 
# Fichero: components\ui\buttons\evo_2.h
# Último cambio: Creación del fichero de cabecera para el botón 'Evo Agua' (EVO_2).
# Descripción: Define la interfaz pública para el módulo del botón de evolución de Agua. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef EVO_2_H
#define EVO_2_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Evo Agua'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void evo_2_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Evo Agua'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* evo_2_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // EVO_2_H

--- END OF FILE: .\components\ui\buttons\evo_2.h ---

--- START OF FILE: .\components\ui\buttons\evo_3.c ---
/* Fecha: 17/08/2025 - 05:23  */
/* Fichero: components/ui/buttons/evo_3.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "evo_3.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "EVO_3";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_evo_3_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Evo Tierra'.
 *        Ejecuta la acción de evolucionar a Tierra.
 * @param e Puntero al evento de LVGL.
 */
static void evo_3_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de evo tierra.");
        execute_diymon_action(ACTION_ID_EVO_EARTH);
    }
}

/**
 * @brief Crea el objeto del botón 'Evo Tierra'.
 */
void evo_3_create(lv_obj_t *parent) {
    s_evo_3_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_evo_3_handle);
    lv_obj_set_size(s_evo_3_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_evo_3_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_evo_3_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_evo_3_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_evo_3_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EVO_EARTH);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EVO_EARTH'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_evo_3_handle, LV_ALIGN_TOP_MID, 0, (BUTTON_SIZE + BUTTON_PADDING) * 2);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_evo_3_handle, evo_3_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Botón 'Evo Tierra' (EVO_3) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Evo Tierra'.
 */
lv_obj_t* evo_3_get_handle(void) {
    return s_evo_3_handle;
}

--- END OF FILE: .\components\ui\buttons\evo_3.c ---

--- START OF FILE: .\components\ui\buttons\evo_3.h ---
/* Fecha: 17/08/2025 - 01:26 
# Fichero: components\ui\buttons\evo_3.h
# Último cambio: Creación del fichero de cabecera para el botón 'Evo Tierra' (EVO_3).
# Descripción: Define la interfaz pública para el módulo del botón de evolución de Tierra. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef EVO_3_H
#define EVO_3_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Evo Tierra'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void evo_3_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Evo Tierra'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* evo_3_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // EVO_3_H

--- END OF FILE: .\components\ui\buttons\evo_3.h ---

--- START OF FILE: .\components\ui\buttons\evo_4.c ---
/* Fecha: 17/08/2025 - 05:24  */
/* Fichero: components/ui/buttons/evo_4.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "evo_4.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "EVO_4";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_evo_4_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Evo Viento'.
 *        Ejecuta la acción de evolucionar a Viento.
 * @param e Puntero al evento de LVGL.
 */
static void evo_4_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de evo viento.");
        execute_diymon_action(ACTION_ID_EVO_WIND);
    }
}

/**
 * @brief Crea el objeto del botón 'Evo Viento'.
 */
void evo_4_create(lv_obj_t *parent) {
    s_evo_4_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_evo_4_handle);
    lv_obj_set_size(s_evo_4_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_evo_4_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_evo_4_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_evo_4_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_evo_4_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EVO_WIND);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EVO_WIND'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_evo_4_handle, LV_ALIGN_TOP_MID, 0, (BUTTON_SIZE + BUTTON_PADDING) * 3);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_evo_4_handle, evo_4_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Botón 'Evo Viento' (EVO_4) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Evo Viento'.
 */
lv_obj_t* evo_4_get_handle(void) {
    return s_evo_4_handle;
}

--- END OF FILE: .\components\ui\buttons\evo_4.c ---

--- START OF FILE: .\components\ui\buttons\evo_4.h ---
/* Fecha: 17/08/2025 - 01:27 
# Fichero: components\ui\buttons\evo_4.h
# Último cambio: Creación del fichero de cabecera para el botón 'Evo Viento' (EVO_4).
# Descripción: Define la interfaz pública para el módulo del botón de evolución de Viento. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef EVO_4_H
#define EVO_4_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Evo Viento'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void evo_4_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Evo Viento'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* evo_4_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // EVO_4_H

--- END OF FILE: .\components\ui\buttons\evo_4.h ---

--- START OF FILE: .\components\ui\buttons\evo_5.c ---
/* Fecha: 17/08/2025 - 05:24  */
/* Fichero: components/ui/buttons/evo_5.c */
/* Último cambio: Corregido el posicionamiento del botón para que se mueva con su panel padre. */
/* Descripción: Se ha corregido el error de posicionamiento del botón. En lugar de tener su propia lógica de ocultación y posición fuera de pantalla, ahora se alinea estáticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el botón aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "evo_5.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de diseño locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "EVO_5";

// --- Variable estática para el manejador del botón ---
static lv_obj_t *s_evo_5_handle = NULL;

/**
 * @brief Callback de evento específico para el botón 'Involucionar'.
 *        Ejecuta la acción de involucionar.
 * @param e Puntero al evento de LVGL.
 */
static void evo_5_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¡Evento CLICK recibido! Ejecutando acción de involucionar.");
        execute_diymon_action(ACTION_ID_EVO_BACK);
    }
}

/**
 * @brief Crea el objeto del botón 'Involucionar'.
 */
void evo_5_create(lv_obj_t *parent) {
    s_evo_5_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_evo_5_handle);
    lv_obj_set_size(s_evo_5_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del botón ---
    lv_obj_set_style_bg_opa(s_evo_5_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_evo_5_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_evo_5_handle, 0, LV_STATE_ANY);

    // --- Icono del botón ---
    lv_obj_t *img = lv_img_create(s_evo_5_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EVO_BACK);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EVO_BACK'.");
    }
    lv_obj_center(img);

    // --- Posición DENTRO de su panel padre ---
    // [CORRECCIÓN] Se alinea el botón dentro del panel. El panel es el que se anima.
    lv_obj_align(s_evo_5_handle, LV_ALIGN_TOP_MID, 0, (BUTTON_SIZE + BUTTON_PADDING) * 4);

    // --- Conexión del evento ---
    lv_obj_add_event_cb(s_evo_5_handle, evo_5_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Botón 'Involucionar' (EVO_5) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del botón 'Involucionar'.
 */
lv_obj_t* evo_5_get_handle(void) {
    return s_evo_5_handle;
}

--- END OF FILE: .\components\ui\buttons\evo_5.c ---

--- START OF FILE: .\components\ui\buttons\evo_5.h ---
/* Fecha: 17/08/2025 - 01:28 
# Fichero: components\ui\buttons\evo_5.h
# Último cambio: Creación del fichero de cabecera para el botón 'Involucionar' (EVO_5).
# Descripción: Define la interfaz pública para el módulo del botón de involución. Expone funciones para crear el objeto LVGL del botón y para obtener su manejador.
*/
#ifndef EVO_5_H
#define EVO_5_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el botón 'Involucionar'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se creará el botón.
 */
void evo_5_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del botón 'Involucionar'.
 * 
 * @return Un puntero al objeto lv_obj_t del botón.
 */
lv_obj_t* evo_5_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // EVO_5_H

--- END OF FILE: .\components\ui\buttons\evo_5.h ---

--- START OF FILE: .\components\ui\core\state_manager.c ---
/* Fecha: 18/08/2025 - 08:01  */
/* Fichero: components/ui/core/state_manager.c */
/* Último cambio: Implementada la función state_manager_destroy para liberar los temporizadores. */
/* Descripción: Se ha añadido la implementación de state_manager_destroy, que se encarga de eliminar de forma segura todos los temporizadores de LVGL que el gestor de estado crea. Esto permite liberar memoria y detener la lógica de inactividad cuando se entra en modos de operación donde no es necesaria, como el modo de configuración. */

#include "state_manager.h"
#include "screen_manager.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "esp_log.h"

static const char *TAG = "UI_STATE_MANAGER";

// --- Tipos y variables de estado internas ---
typedef enum {
    WAKE_STATE_OFF,
    WAKE_STATE_PRIMED,
} wake_up_state_t;

static bool s_is_dimmed = false;
static int s_user_brightness = 100;
static bool s_user_brightness_known = false;
static wake_up_state_t s_wake_state = WAKE_STATE_OFF;
static uint8_t s_wake_click_count = 0;
static lv_timer_t *s_double_click_timer = NULL;
static lv_timer_t *s_wake_prime_timer = NULL;
static lv_timer_t *s_inactivity_timer = NULL;
static bool s_is_paused = false; // Flag para pausar el gestor

// --- Funciones de ayuda y callbacks ---

static void read_user_brightness_from_nvs(void) {
    if (s_user_brightness_known) return;
    nvs_handle_t nvs_handle;
    if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
        nvs_get_i32(nvs_handle, "brightness", (int32_t*)&s_user_brightness);
        nvs_close(nvs_handle);
        s_user_brightness_known = true;
    }
}

static void double_click_timer_cb(lv_timer_t * timer) {
    s_wake_click_count = 0;
    s_double_click_timer = NULL;
}

static void wake_prime_timer_cb(lv_timer_t * timer) {
    s_wake_state = WAKE_STATE_OFF;
    s_wake_click_count = 0;
    s_wake_prime_timer = NULL;
}

static void screen_touch_event_cb(lv_event_t * e) {
    if (s_is_paused) return; // Ignorar eventos si está pausado
    lv_event_code_t code = lv_event_get_code(e);
    lv_disp_t * disp = lv_display_get_default();
    if (!disp) return;
    
    lv_display_trigger_activity(disp);

    if (code == LV_EVENT_PRESSED && s_is_dimmed && !screen_manager_is_off()) {
        read_user_brightness_from_nvs();
        screen_manager_set_brightness(s_user_brightness);
        s_is_dimmed = false;
        return;
    }

    if (code == LV_EVENT_CLICKED && screen_manager_is_off()) {
        if (s_wake_state == WAKE_STATE_OFF) {
            s_wake_click_count++;
            if (s_wake_click_count == 1) {
                s_double_click_timer = lv_timer_create(double_click_timer_cb, 500, NULL);
                lv_timer_set_repeat_count(s_double_click_timer, 1);
            } else if (s_wake_click_count == 2) {
                if (s_double_click_timer) lv_timer_del(s_double_click_timer);
                s_double_click_timer = NULL;
                s_wake_state = WAKE_STATE_PRIMED;
                s_wake_click_count = 0;
                s_wake_prime_timer = lv_timer_create(wake_prime_timer_cb, 3000, NULL);
                lv_timer_set_repeat_count(s_wake_prime_timer, 1);
            }
        } else if (s_wake_state == WAKE_STATE_PRIMED) {
            s_wake_click_count++;
            if (s_wake_click_count == 1) {
                s_double_click_timer = lv_timer_create(double_click_timer_cb, 500, NULL);
                lv_timer_set_repeat_count(s_double_click_timer, 1);
            } else if (s_wake_click_count >= 2) {
                if (s_double_click_timer) lv_timer_del(s_double_click_timer);
                if (s_wake_prime_timer) lv_timer_del(s_wake_prime_timer);
                s_double_click_timer = NULL;
                s_wake_prime_timer = NULL;
                screen_manager_turn_on();
                s_is_dimmed = false;
                s_wake_state = WAKE_STATE_OFF;
                s_wake_click_count = 0;
            }
        }
    }
}

static void inactivity_timer_cb(lv_timer_t * timer) {
    if (s_is_paused) return; // No hacer nada si está pausado

    lv_disp_t * disp = lv_display_get_default();
    if (!disp) return;
    
    uint32_t inactivity_ms = lv_display_get_inactive_time(disp);
    bool is_off = screen_manager_is_off();

    if (inactivity_ms < 30000 && s_is_dimmed) {
        s_is_dimmed = false;
    }

    if (!is_off && inactivity_ms > 60000) {
        screen_manager_turn_off();
        s_is_dimmed = false;
    } else if (!is_off && !s_is_dimmed && inactivity_ms > 30000) {
        read_user_brightness_from_nvs();
        screen_manager_set_brightness(10);
        s_is_dimmed = true;
    }
}

// --- Funciones de inicialización y control públicas ---

void state_manager_init(void) {
    s_inactivity_timer = lv_timer_create(inactivity_timer_cb, 5000, NULL);
    lv_obj_t * scr = lv_screen_active();
    if (scr) {
        lv_obj_add_event_cb(scr, screen_touch_event_cb, LV_EVENT_ALL, NULL);
    }
    ESP_LOGI(TAG, "Gestor de estado de UI inicializado. Manejadores de inactividad activos.");
}

void state_manager_pause(void) {
    if (!s_is_paused) {
        s_is_paused = true;
        ESP_LOGI(TAG, "Gestor de estado PAUSADO. La pantalla no se atenuará ni apagará por inactividad.");
    }
}

void state_manager_resume(void) {
    if (s_is_paused) {
        s_is_paused = false;
        // Resetea el contador de inactividad para dar al usuario tiempo completo antes del próximo evento.
        lv_disp_t * disp = lv_display_get_default();
        if (disp) {
            lv_display_trigger_activity(disp);
        }
        ESP_LOGI(TAG, "Gestor de estado REANUDADO.");
    }
}

void state_manager_destroy(void) {
    if (s_inactivity_timer) {
        lv_timer_del(s_inactivity_timer);
        s_inactivity_timer = NULL;
    }
    if (s_double_click_timer) {
        lv_timer_del(s_double_click_timer);
        s_double_click_timer = NULL;
    }
    if (s_wake_prime_timer) {
        lv_timer_del(s_wake_prime_timer);
        s_wake_prime_timer = NULL;
    }
    // No es necesario eliminar el screen_touch_event_cb, ya que la pantalla
    // a la que está asociado será eliminada por el llamante.
    ESP_LOGI(TAG, "Gestor de estado DESTRUIDO. Todos los temporizadores liberados.");
}

--- END OF FILE: .\components\ui\core\state_manager.c ---

--- START OF FILE: .\components\ui\core\state_manager.h ---
/* Fecha: 18/08/2025 - 08:00  */
/* Fichero: components/ui/core/state_manager.h */
/* Último cambio: Añadida la función state_manager_destroy para liberar recursos. */
/* Descripción: Interfaz pública del gestor de estado. Se añade una función 'destroy' para eliminar los temporizadores de LVGL y liberar memoria cuando el gestor no es necesario, como en el modo de configuración. Esto optimiza el uso de recursos y previene la ejecución de callbacks innecesarios. */

#ifndef STATE_MANAGER_H
#define STATE_MANAGER_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el gestor de estado de la UI.
 * 
 * Configura los temporizadores y callbacks necesarios para gestionar la
 * inactividad, el atenuado/apagado de la pantalla y la lógica de despertar.
 * Debe ser llamado una vez después de que la UI principal haya sido creada.
 */
void state_manager_init(void);

/**
 * @brief Pausa el gestor de estado, deteniendo los temporizadores de inactividad.
 */
void state_manager_pause(void);

/**
 * @brief Reanuda el gestor de estado, reactivando los temporizadores de inactividad.
 */
void state_manager_resume(void);

/**
 * @brief Destruye el gestor de estado y libera sus recursos.
 *
 * Elimina todos los temporizadores de LVGL creados por el gestor,
 * liberando memoria y deteniendo su lógica por completo.
 */
void state_manager_destroy(void);


#ifdef __cplusplus
}
#endif

#endif // STATE_MANAGER_H

--- END OF FILE: .\components\ui\core\state_manager.h ---

--- START OF FILE: .\components\ui\core\ui.c ---
/* Fecha: 17/08/2025 - 02:29  */
/* Fichero: components/ui/core/ui.c */
/* Último cambio: Movido desde la raíz del componente 'ui' como parte de la refactorización. */
/* Descripción: Orquestador principal de la UI. Inicializa las pantallas y los sistemas subyacentes. Su movimiento al subdirectorio 'core' centraliza la lógica fundamental de la interfaz. */

#include "ui.h"
#include "screens.h"
#include "ui_action_animations.h"
#include "esp_log.h"

extern lv_obj_t *g_main_screen_obj; 

static const char *TAG = "DIYMON_UI_MAIN";

// La función 'ui_connect_actions' y su 'button_event_cb' han sido eliminados.
// La conexión de eventos ahora está encapsulada dentro de cada módulo de botón.

void ui_preinit(void) {
    ESP_LOGI(TAG, "Pre-inicializando UI: reservando buffer de animación...");
    ui_action_animations_preinit_buffer();
}

void ui_init(void) {
    create_screens();
    
    if (g_main_screen_obj) {
        // La llamada a ui_connect_actions() ha sido eliminada.
        lv_obj_add_event_cb(g_main_screen_obj, (lv_event_cb_t)delete_screen_main, LV_EVENT_DELETE, NULL);
    }
    
    lv_screen_load(g_main_screen_obj);
    ESP_LOGI(TAG, "UI modularizada y lista.");
}

--- END OF FILE: .\components\ui\core\ui.c ---

--- START OF FILE: .\components\ui\core\ui.h ---
/* Fecha: 17/08/2025 - 02:29  */
/* Fichero: components/ui/core/ui.h */
/* Último cambio: Movido a ui/core/ como parte de la refactorización del núcleo de la UI. */
/* Descripción: Interfaz PÚBLICA del componente de la UI. Define las funciones de alto nivel para controlar la UI desde el exterior. Se ha movido a este subdirectorio para encapsular la lógica principal. */

#ifndef UI_H
#define UI_H

#ifdef __cplusplus
extern "C" {
#endif

// --- DEFINICIONES COMPARTIDAS ---

// Enum para identificar las pantallas. Se mantiene aquí porque es parte de la
// interfaz pública para, potencialmente, cambiar de pantalla.
enum ScreensEnum {
    SCREEN_ID_MAIN = 1,
};


// --- FUNCIONES PÚBLICAS DE LA UI ---

/**
 * @brief Pre-inicializa la UI reservando los buffers de memoria más grandes.
 *
 * Esta función debe llamarse al principio de app_main para evitar la fragmentación
 * de la memoria RAM, asegurando que la asignación de memoria más grande (el buffer
 * de animación) tenga éxito.
 */
void ui_preinit(void);

/**
 * @brief Inicializa y configura toda la interfaz de usuario.
 *
 * Esta es la función principal que se debe llamar desde fuera del componente
 * (por ejemplo, desde main.c) para poner en marcha toda la UI.
 */
void ui_init(void);


#ifdef __cplusplus
}
#endif

#endif // UI_H

--- END OF FILE: .\components\ui\core\ui.h ---

--- START OF FILE: .\components\ui\screens\config.c ---
/* Fecha: 17/08/2025 - 10:16  */
/* Fichero: components/ui/screens/config.c */
/* Último cambio: Actualizada la inclusión del asset de fondo para usar la cabecera centralizada 'ui_assets.h'. */
/* Descripción: Implementación de la pantalla de configuración. Se ha modificado para incluir 'assets/images/ui_assets.h', que ahora declara todos los assets de imagen del proyecto, incluyendo 'bg_config'. Esto completa la refactorización para centralizar los recursos gráficos. */

#include "config.h"
#include "esp_log.h"
#include "esp_system.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "assets/images/ui_assets.h" // Actualizado para usar la cabecera central de assets

static const char *TAG = "UI_CONFIG_SCREEN";

/**
 * @brief Callback que se ejecuta al presionar el botón de reinicio.
 */
static void reset_button_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
        ESP_LOGW(TAG, "Botón de reinicio presionado. Reiniciando el dispositivo...");
        vTaskDelay(pdMS_TO_TICKS(500)); // Pequeña pausa para que el log se envíe
        esp_restart();
    }
}

/**
 * @brief Crea y muestra la pantalla de configuración estática.
 */
void config_show(void) {
    // Crear una pantalla nueva y limpia
    lv_obj_t *scr = lv_obj_create(NULL);
    lv_obj_remove_style_all(scr); // Empezamos sin estilos por defecto
    lv_obj_set_size(scr, 170, 320);

    // Crear un objeto de imagen para el fondo de pantalla
    lv_obj_t *bg_img = lv_image_create(scr);
    lv_image_set_src(bg_img, &bg_config); // Usa el asset declarado en ui_assets.h
    lv_obj_set_pos(bg_img, 0, 0);
    lv_obj_add_flag(bg_img, LV_OBJ_FLAG_IGNORE_LAYOUT); // Asegura que no afecte a otros elementos

    // Botón de Reinicio
    lv_obj_t *btn_reset = lv_btn_create(scr);
    lv_obj_add_event_cb(btn_reset, reset_button_event_cb, LV_EVENT_CLICKED, NULL);
    lv_obj_align(btn_reset, LV_ALIGN_BOTTOM_MID, 0, -20); // Centrado abajo con padding

    lv_obj_t *lbl_btn = lv_label_create(btn_reset);
    lv_label_set_text(lbl_btn, "Reiniciar");
    lv_obj_center(lbl_btn);

    // Cargar la nueva pantalla
    lv_screen_load(scr);
    ESP_LOGI(TAG, "Pantalla de configuración estática con fondo mostrada.");
}

--- END OF FILE: .\components\ui\screens\config.c ---

--- START OF FILE: .\components\ui\screens\config.h ---
/* Fecha: 17/08/2025 - 03:32  */
/* Fichero: components/ui/screens/config.h */
/* Último cambio: Renombrada la función 'config_screen_show' a 'config_show' para estandarizar y eliminar redundancia. */
/* Descripción: Define la interfaz pública para la pantalla de configuración. La estandarización de nombres (eliminando '_screen') mejora la legibilidad y sigue el principio DRY, ya que el contexto del directorio 'screens' es suficiente. */

#ifndef CONFIG_H
#define CONFIG_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea y muestra la pantalla de configuración estática con una imagen de fondo y un botón de reinicio.
 */
void config_show(void);

#ifdef __cplusplus
}
#endif

#endif // CONFIG_H

--- END OF FILE: .\components\ui\screens\config.h ---

--- START OF FILE: .\components\ui\screens\screen_interface.h ---
/* Fecha: 17/08/2025 - 03:35  */
/* Fichero: components/ui/screens/screen_interface.h */
/* Último cambio: Creación de la interfaz común para las pantallas para estandarizar su ciclo de vida. */
/* Descripción: Define una interfaz común (un 'contrato') para todas las pantallas de la aplicación. Esto permite que un futuro gestor de navegación trate a todas las pantallas de manera uniforme, llamando a sus funciones de ciclo de vida (crear, mostrar, etc.) sin conocer su implementación específica, reduciendo así el acoplamiento y mejorando la modularidad. */

#ifndef SCREEN_INTERFACE_H
#define SCREEN_INTERFACE_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Define una interfaz común para el ciclo de vida de una pantalla.
 *
 * Esta estructura de punteros a función permite manejar diferentes pantallas
 * de forma polimórfica.
 */
typedef struct {
    /**
     * @brief Crea los widgets de la pantalla sobre un objeto padre.
     * @param parent El objeto LVGL que actuará como contenedor.
     */
    void (*create)(lv_obj_t *parent);

    /**
     * @brief Hace visible la pantalla y sus elementos.
     */
    void (*show)(void);

    /**
     * @brief Oculta la pantalla y sus elementos.
     */
    void (*hide)(void);

    /**
     * @brief Destruye la pantalla y libera todos sus recursos.
     */
    void (*destroy)(void);
} screen_interface_t;

#ifdef __cplusplus
}
#endif

#endif // SCREEN_INTERFACE_H

--- END OF FILE: .\components\ui\screens\screen_interface.h ---

--- START OF FILE: .\components\ui\screens\screens.c ---
/* Fecha: 17/08/2025 - 10:19  */
/* Fichero: components/ui/screens/screens.c */
/* Último cambio: Actualizada la inclusión de 'diymon_ui_helpers.h' a 'helpers.h' para reflejar el renombramiento del fichero. */
/* Descripción: Orquesta la creación de la pantalla principal. Se ha actualizado la ruta de inclusión para apuntar a 'helpers.h', manteniendo la consistencia con la refactorización de nombres. */

#include "screens.h"
#include "ui_idle_animation.h"
#include "ui_actions_panel.h"
#include "ui_action_animations.h"
#include "telemetry/telemetry_manager.h"
#include "helpers.h" // Actualizado desde diymon_ui_helpers.h
#include "esp_log.h"
#include "bsp_api.h"
#include "screen_manager.h"
#include "ui_asset_loader.h"

static const char *TAG = "SCREENS";

static lv_timer_t *s_resume_idle_timer = NULL;

lv_obj_t *g_idle_animation_obj = NULL;
lv_obj_t *g_main_screen_obj = NULL;

static lv_coord_t touch_start_x = -1;
static lv_coord_t touch_start_y = -1;

static void main_screen_event_cb(lv_event_t *e);

static void resume_idle_timer_cb(lv_timer_t *timer) {
    ESP_LOGD(TAG, "Temporizador de reanudación de idle disparado.");
    ui_idle_animation_resume();
    s_resume_idle_timer = NULL;
}

void create_screen_main(void) {
    g_main_screen_obj = lv_obj_create(NULL);
    lv_obj_set_size(g_main_screen_obj, 170, 320);
    lv_obj_add_flag(g_main_screen_obj, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_add_event_cb(g_main_screen_obj, main_screen_event_cb, LV_EVENT_ALL, NULL);
    
    lv_obj_set_scroll_dir(g_main_screen_obj, LV_DIR_ALL);
    lv_obj_set_scrollbar_mode(g_main_screen_obj, LV_SCROLLBAR_MODE_OFF);

    ui_helpers_load_background(g_main_screen_obj);

    ui_action_animations_create(g_main_screen_obj);
    g_idle_animation_obj = ui_idle_animation_start(g_main_screen_obj);
    ui_actions_panel_create(g_main_screen_obj);
    telemetry_manager_create(g_main_screen_obj);

    ESP_LOGI(TAG, "Pantalla principal creada delegando en módulos.");
}

static void main_screen_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    lv_indev_t *indev = lv_indev_get_act();

    switch(code) {
        case LV_EVENT_PRESSED: {
            if (s_resume_idle_timer) {
                lv_timer_del(s_resume_idle_timer);
                s_resume_idle_timer = NULL;
            }

            lv_point_t p;
            lv_indev_get_point(indev, &p);
            touch_start_x = p.x;
            touch_start_y = p.y;
            if (!screen_manager_is_off()) {
                ui_idle_animation_pause();
            }
            break;
        }
        case LV_EVENT_RELEASED: {
            touch_start_x = -1;
            touch_start_y = -1;
            
            if (!screen_manager_is_off() && s_resume_idle_timer == NULL) {
                s_resume_idle_timer = lv_timer_create(resume_idle_timer_cb, 500, NULL);
                lv_timer_set_repeat_count(s_resume_idle_timer, 1);
            }
            break;
        }
        case LV_EVENT_GESTURE: {
            if (!screen_manager_is_off()) { 
                lv_dir_t dir = lv_indev_get_gesture_dir(indev);
                ui_actions_panel_handle_gesture(dir, touch_start_x, touch_start_y);
            }
            break;
        }
        case LV_EVENT_CLICKED: {
            if (!screen_manager_is_off()) {
                ESP_LOGD(TAG, "Click en la pantalla, ocultando paneles.");
                ui_actions_panel_hide_all();
            }
            break;
        }
        default:
            break;
    }
}

void delete_screen_main(void) {
    if (g_main_screen_obj) {
        lv_obj_del(g_main_screen_obj);
        g_main_screen_obj = NULL;
        g_idle_animation_obj = NULL;
    }
    ui_idle_animation_stop();
    ui_action_animations_destroy();
    telemetry_manager_destroy();
    ui_assets_deinit();
}

void create_screens(void) {
    create_screen_main();
}

--- END OF FILE: .\components\ui\screens\screens.c ---

--- START OF FILE: .\components\ui\screens\screens.h ---
/* Fecha: 17/08/2025 - 02:49  */
/* Fichero: components/ui/screens/screens.h */
/* Último cambio: Movido a 'screens/' y refactorizado como el gestor de pantallas. */
/* Descripción: Interfaz pública del módulo de pantallas. Orquesta la creación y destrucción de las diferentes pantallas de la aplicación, empezando por la principal. */

#ifndef SCREENS_H
#define SCREENS_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif

// --- DECLARACIONES DE OBJETOS GLOBALES ---
// Se expone para que otros módulos (core, telemetry, etc.) puedan añadir widgets.
extern lv_obj_t *g_main_screen_obj;


// --- DECLARACIONES DE FUNCIONES ---
/**
 * @brief Crea todas las pantallas de la aplicación.
 *        Actualmente, solo invoca la creación de la pantalla principal.
 */
void create_screens(void);

/**
 * @brief Destruye la pantalla principal y libera sus recursos.
 */
void delete_screen_main(void);


#ifdef __cplusplus
}
#endif

#endif // SCREENS_H

--- END OF FILE: .\components\ui\screens\screens.h ---

--- START OF FILE: .\components\ui\screens\welcome.c ---
/* Fecha: 17/08/2025 - 02:48  */
/* Fichero: components/ui/screens/welcome.c */
/* Último cambio: Refactorizado y movido a 'screens/', renombrado de 'welcome_screen.c'. */
/* Descripción: Implementación de la pantalla de bienvenida. Encapsula la lógica de esta vista específica como parte de la refactorización de la UI. */

#include "welcome.h"
#include "esp_log.h"

static const char *TAG = "WELCOME_SCREEN";

// Puntero estático para almacenar el callback de inicio.
static void (*g_on_start_callback)(void) = NULL;

/**
 * @brief Callback del evento del botón "INICIAR".
 *        Llama a la función de callback registrada si existe.
 */
static void start_button_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
        ESP_LOGI(TAG, "Botón 'INICIAR' presionado.");
        if (g_on_start_callback) {
            g_on_start_callback();
        }
    }
}

/**
 * @brief Implementación de la creación de la pantalla de bienvenida.
 */
void welcome_screen_show(void (*on_start_cb)(void)) {
    g_on_start_callback = on_start_cb;

    // Se crea un nuevo screen para asegurar que no hay elementos previos.
    lv_obj_t *scr = lv_obj_create(NULL);
    lv_obj_set_style_bg_color(scr, lv_color_hex(0x000000), LV_PART_MAIN);
    lv_obj_set_layout(scr, LV_LAYOUT_FLEX);
    lv_obj_set_flex_flow(scr, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(scr, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_set_style_pad_row(scr, 20, LV_PART_MAIN);

    const char *texts[] = {"SSID: DIYTogether", "PASS: MakeItYours", "192.168.4.1"};
    for (int i = 0; i < 3; i++) {
        lv_obj_t *label = lv_label_create(scr);
        lv_label_set_text(label, texts[i]);
        lv_obj_set_style_text_color(label, lv_color_hex(0xFFFFFF), LV_PART_MAIN);
    }

    lv_obj_t *btn = lv_btn_create(scr);
    lv_obj_add_event_cb(btn, start_button_event_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *label_btn = lv_label_create(btn);
    lv_label_set_text(label_btn, "INICIAR");
    lv_obj_center(label_btn);

    // Se carga la nueva pantalla para reemplazar la activa.
    lv_screen_load(scr);
    ESP_LOGI(TAG, "Pantalla de bienvenida mostrada.");
}

--- END OF FILE: .\components\ui\screens\welcome.c ---

--- START OF FILE: .\components\ui\screens\welcome.h ---
/* Fecha: 17/08/2025 - 02:47  */
/* Fichero: components/ui/screens/welcome.h */
/* Último cambio: Refactorizado y movido a 'screens/', renombrado de 'welcome_screen.h'. */
/* Descripción: Define la interfaz pública para la pantalla de bienvenida. Encapsula la lógica de esta vista específica como parte de la refactorización de la UI. */

#ifndef WELCOME_H
#define WELCOME_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Muestra la pantalla de bienvenida.
 *
 * @param on_start_cb Puntero a una función que se llamará cuando se pulse el botón "INICIAR".
 */
void welcome_screen_show(void (*on_start_cb)(void));

#ifdef __cplusplus
}
#endif

#endif // WELCOME_H

--- END OF FILE: .\components\ui\screens\welcome.h ---

--- START OF FILE: .\components\ui\telemetry\telemetry_manager.c ---
/* Fecha: 17/08/2025 - 09:42  */
/* Fichero: components/ui/telemetry/telemetry_manager.c */
/* Último cambio: Movido a ui/telemetry/ como parte de la refactorización de telemetría. */
/* Descripción: Implementación del módulo de telemetría de la UI. Es un receptor pasivo de datos que actualiza los labels cuando la función 'telemetry_manager_update_values' es llamada por una tarea externa. */

#include "telemetry_manager.h"
#include "esp_log.h"
#include "diymon_evolution.h"
#include "esp_lvgl_port.h" // Necesario para el bloqueo thread-safe

static const char *TAG = "TELEMETRY_MANAGER";

/* Variables estáticas para los objetos de la UI */
static lv_obj_t *s_battery_label = NULL;
static lv_obj_t *s_evo_label = NULL;

/**
 * @brief Crea y configura los elementos de la UI para la telemetría.
 */
void telemetry_manager_create(lv_obj_t *parent) {
    if (!parent) {
        ESP_LOGE(TAG, "El objeto padre es nulo. No se puede crear la telemetría.");
        return;
    }

    // Contenedor para la telemetría en la esquina inferior derecha
    lv_obj_t * telemetry_cont = lv_obj_create(parent);
    lv_obj_remove_style_all(telemetry_cont);
    lv_obj_set_size(telemetry_cont, 120, 50);
    lv_obj_align(telemetry_cont, LV_ALIGN_BOTTOM_RIGHT, -5, -5);
    lv_obj_set_flex_flow(telemetry_cont, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(telemetry_cont, LV_FLEX_ALIGN_END, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);

    // Etiqueta para el nivel de batería
    s_battery_label = lv_label_create(telemetry_cont);
    lv_obj_set_style_text_color(s_battery_label, lv_color_white(), 0);
    lv_label_set_text(s_battery_label, "Bateria...");

    // Etiqueta para el código de evolución
    s_evo_label = lv_label_create(telemetry_cont);
    lv_obj_set_style_text_color(s_evo_label, lv_color_white(), 0);
    lv_label_set_text(s_evo_label, "EVO: ...");
    
    // Forzar una actualización inicial con valores por defecto
    telemetry_manager_update_values(100);
    ESP_LOGI(TAG, "Módulo de telemetría creado.");
}

/**
 * @brief Destruye los recursos asociados al módulo de telemetría.
 */
void telemetry_manager_destroy(void) {
    // Ya no hay temporizador que borrar. LVGL se encarga de los objetos hijos.
    s_battery_label = NULL;
    s_evo_label = NULL;
    ESP_LOGI(TAG, "Módulo de telemetría destruido.");
}

/**
 * @brief Actualiza los valores mostrados en los labels de telemetría.
 */
void telemetry_manager_update_values(uint8_t battery_percentage) {
    // Bloquear el mutex de LVGL ya que esta función será llamada desde otra tarea
    if (lvgl_port_lock(0)) {
        if (s_battery_label) {
            lv_label_set_text_fmt(s_battery_label, "%s %d%%", LV_SYMBOL_BATTERY_FULL, battery_percentage);
        }
        if (s_evo_label) {
            const char* evo_code = diymon_get_current_code();
            lv_label_set_text_fmt(s_evo_label, "EVO: %s", evo_code ? evo_code : "N/A");
        }
        lvgl_port_unlock();
    }
}

--- END OF FILE: .\components\ui\telemetry\telemetry_manager.c ---

--- START OF FILE: .\components\ui\telemetry\telemetry_manager.h ---
/* Fecha: 17/08/2025 - 09:41  */
/* Fichero: components/ui/telemetry/telemetry_manager.h */
/* Último cambio: Movido a ui/telemetry/ como parte de la refactorización de telemetría. */
/* Descripción: Interfaz del módulo de telemetría de la UI. Expone funciones para crear, destruir y actualizar los elementos visuales de telemetría (batería, EVO). */

#ifndef TELEMETRY_MANAGER_H
#define TELEMETRY_MANAGER_H

#include <lvgl.h>
#include <stdint.h> // for uint8_t

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea y configura los elementos de la UI para la telemetría.
 * 
 * @param parent El objeto padre sobre el cual se crearán los labels.
 */
void telemetry_manager_create(lv_obj_t *parent);

/**
 * @brief Destruye los recursos asociados al módulo de telemetría.
 */
void telemetry_manager_destroy(void);

/**
 * @brief Actualiza los valores mostrados en los labels de telemetría.
 *        Esta función es segura para ser llamada desde otras tareas (thread-safe).
 * 
 * @param battery_percentage El nivel de batería actual en porcentaje (0-100).
 */
void telemetry_manager_update_values(uint8_t battery_percentage);

#ifdef __cplusplus
}
#endif

#endif // TELEMETRY_MANAGER_H

--- END OF FILE: .\components\ui\telemetry\telemetry_manager.h ---

--- START OF FILE: .\components\ui\telemetry\telemetry_task.c ---
/* Fecha: 18/08/2025 - 07:37  */
/* Fichero: components/ui/telemetry/telemetry_task.c */
/* Último cambio: Pausada la lógica de la tarea cuando el WiFi está en modo AP para resolver el error de socket del servidor web. */
/* Descripción: Se ha añadido una comprobación al inicio del bucle de la tarea para detectar si el dispositivo está en modo Punto de Acceso (AP). Si es así, la tarea se detiene y espera, evitando leer sensores y actualizar la UI. Esto elimina la contención de recursos con el servidor web, que es la causa raíz de los errores de socket ('error in send : 11') durante la transferencia de ficheros. */

#include "telemetry_task.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "bsp_api.h"
#include "telemetry_manager.h"
#include <math.h> // Para fmax y fmin
#include "esp_wifi.h" // Necesario para comprobar el modo WiFi

static const char *TAG = "TELEMETRY_TASK";

// --- Constantes de configuración de la tarea ---
#define TELEMETRY_TASK_STACK_SIZE   4096
#define TELEMETRY_TASK_PRIORITY     5
#define TELEMETRY_TASK_DELAY_MS     200
#define UI_UPDATE_INTERVAL_MS       5000 // Actualizar la UI cada 5 segundos

/**
 * @brief Tarea principal que se ejecuta en segundo plano.
 */
static void telemetry_task_main(void *pvParameters) {
    ESP_LOGI(TAG, "Tarea de telemetría iniciada.");

    uint32_t ui_update_counter = 0;
    const uint32_t ui_update_ticks = UI_UPDATE_INTERVAL_MS / TELEMETRY_TASK_DELAY_MS;

    while (1) {
        // [CORRECCIÓN] Pausar la telemetría si el modo AP está activo para evitar conflictos con el servidor web.
        wifi_mode_t current_mode;
        if (esp_wifi_get_mode(&current_mode) == ESP_OK && current_mode == WIFI_MODE_AP) {
            vTaskDelay(pdMS_TO_TICKS(1000)); // Esperar un segundo y volver a comprobar.
            continue; // Saltar el resto del bucle.
        }

        vTaskDelay(pdMS_TO_TICKS(TELEMETRY_TASK_DELAY_MS));

        // --- Actualización de la UI (periódica) ---
        ui_update_counter++;
        if (ui_update_counter >= ui_update_ticks) {
            ui_update_counter = 0;
            
            // --- Lectura del Sensor de Batería ---
            float voltage;
            uint16_t adc_val;
            bsp_battery_get_voltage(&voltage, &adc_val);
            // Lógica simple para convertir voltaje a porcentaje (ajustar según la curva de la batería)
            uint8_t battery_percentage = (uint8_t)fmax(0.0, fmin(100.0, (voltage - 3.2) / (4.2 - 3.2) * 100.0));

            // Empujar los nuevos valores a la UI para que los muestre
            telemetry_manager_update_values(battery_percentage);
        }
    }
}

/**
 * @brief Inicia la tarea de telemetría.
 */
void telemetry_task_start(void) {
    xTaskCreate(
        telemetry_task_main,
        "telemetry_task",
        TELEMETRY_TASK_STACK_SIZE,
        NULL,
        TELEMETRY_TASK_PRIORITY,
        NULL
    );
}

--- END OF FILE: .\components\ui\telemetry\telemetry_task.c ---

--- START OF FILE: .\components\ui\telemetry\telemetry_task.h ---
/* Fecha: 17/08/2025 - 09:42  */
/* Fichero: components/ui/telemetry/telemetry_task.h */
/* Último cambio: Movido a ui/telemetry/ como parte de la refactorización de telemetría. */
/* Descripción: Interfaz pública para la tarea de telemetría. Esta tarea se ejecuta en segundo plano para leer periódicamente el estado de la batería y actualizar la UI. */

#ifndef TELEMETRY_TASK_H
#define TELEMETRY_TASK_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicia la tarea de telemetría en segundo plano.
 *
 * Crea y lanza una tarea de FreeRTOS que se encargará de leer periódicamente
 * el estado de la batería del dispositivo y de actualizar la UI con
 * esta información.
 */
void telemetry_task_start(void);

#ifdef __cplusplus
}
#endif

#endif // TELEMETRY_TASK_H

--- END OF FILE: .\components\ui\telemetry\telemetry_task.h ---

--- START OF FILE: .\components\ui\actions.c ---
/* Fecha: 18/08/2025 - 06:54  */
/* Fichero: components/ui/actions.c */
/* Último cambio: Eliminado el case para ACTION_ID_ENABLE_FILE_SERVER para reflejar la unificación de los modos de configuración. */
/* Descripción: Orquestador de acciones refactorizado. Se ha eliminado el punto de entrada para el antiguo modo de servidor de ficheros. Ahora, toda la funcionalidad de configuración se inicia a través de ACTION_ID_ACTIVATE_CONFIG_MODE, que activa una UI con un servidor web integrado. */

#include "actions.h"
#include "esp_log.h"

// --- Inclusión de todos los módulos de acción refactorizados ---
#include "actions/action_brightness.h"
#include "actions/action_config_mode.h"
#include "actions/action_evolution.h"
#include "actions/action_interaction.h"
#include "actions/action_screen.h"
#include "actions/action_system.h"

static const char *TAG = "DIYMON_ACTIONS";

void execute_diymon_action(diymon_action_id_t action_id) {
    ESP_LOGI(TAG, "Ejecutando acción ID: %d", action_id);

    if (action_id == ACTION_ID_ACTIVATE_CONFIG_MODE) {
        action_config_mode_start();
        return;
    }
    
    switch(action_id) {
        // --- Acciones de Interacción ---
        case ACTION_ID_COMER:
            action_interaction_eat();
            break;
        case ACTION_ID_EJERCICIO:
            action_interaction_gym();
            break;
        case ACTION_ID_ATACAR:
            action_interaction_attack();
            break;

        // --- Acciones de UI/Sistema ---
        case ACTION_ID_BRIGHTNESS_CYCLE:
            action_brightness_cycle();
            break;
        case ACTION_ID_TOGGLE_SCREEN:
            action_screen_toggle();
            break;

        // --- Acciones de Sistema (Reset) ---
        case ACTION_ID_RESET_ALL:
            action_system_reset_all();
            break;

        // --- Acciones de Evolución ---
        case ACTION_ID_EVO_FIRE:
            action_evolution_branch(1); // 1 = Fuego
            break;
        case ACTION_ID_EVO_WATER:
            action_evolution_branch(2); // 2 = Agua
            break;
        case ACTION_ID_EVO_EARTH:
            action_evolution_branch(3); // 3 = Tierra
            break;
        case ACTION_ID_EVO_WIND:
            action_evolution_branch(4); // 4 = Viento
            break;
        case ACTION_ID_EVO_BACK:
            action_evolution_devolve();
            break;
        
        // --- Acciones Placeholder (no hacen nada) ---
        case ACTION_ID_ADMIN_PLACEHOLDER:
        case ACTION_ID_CONFIG_PLACEHOLDER:
            ESP_LOGI(TAG, "Acción Placeholder (ID %d) ejecutada. No se realiza ninguna operación.", action_id);
            break;

        default:
            ESP_LOGW(TAG, "Acción con ID %d desconocida.", action_id);
            break;
    }
}

--- END OF FILE: .\components\ui\actions.c ---

--- START OF FILE: .\components\ui\actions.h ---
/* Fecha: 18/08/2025 - 06:53  */
/* Fichero: components/ui/actions.h */
/* Último cambio: Eliminada la acción ACTION_ID_ENABLE_FILE_SERVER para unificar la configuración en un único modo. */
/* Descripción: Define la interfaz para el sistema de acciones, incluyendo los IDs de acción y la función principal de ejecución. Es el punto central para entender qué interacciones de usuario son posibles. */

#ifndef ACTIONS_H
#define ACTIONS_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif

// --- El Modelo de Datos para las Acciones ---
typedef enum {
    // Acciones del panel de jugador (superior 1)
    ACTION_ID_COMER,          // 0
    ACTION_ID_EJERCICIO,      // 1
    ACTION_ID_ATACAR,         // 2

    // Acciones del panel de administración (superior 2)
    ACTION_ID_BRIGHTNESS_CYCLE,       // 3
    ACTION_ID_TOGGLE_SCREEN,          // 4
    ACTION_ID_ADMIN_PLACEHOLDER,      // 5

    // Acciones del panel de evolución (lateral)
    ACTION_ID_EVO_FIRE,       // 6
    ACTION_ID_EVO_WATER,      // 7
    ACTION_ID_EVO_EARTH,      // 8
    ACTION_ID_EVO_WIND,       // 9
    ACTION_ID_EVO_BACK,       // 10
    
    // Acciones del panel de configuración (superior 3)
    ACTION_ID_ACTIVATE_CONFIG_MODE,   // 11
    ACTION_ID_RESET_ALL,              // 12
    ACTION_ID_CONFIG_PLACEHOLDER,     // 13

    ACTION_ID_COUNT 
} diymon_action_id_t;


// --- El Orquestador de Acciones ---
void execute_diymon_action(diymon_action_id_t action_id);

#ifdef __cplusplus
}
#endif

#endif // ACTIONS_H

--- END OF FILE: .\components\ui\actions.h ---

--- START OF FILE: .\components\ui\animation_loader.c ---
/* Fecha: 18/08/2025 - 08:59  */
/* Fichero: components/ui/animation_loader.c */
/* Último cambio: Restaurado el formato de color a RGB565A8 y el tamaño del buffer a 3 bytes por píxel para corregir la pérdida de transparencias. */
/* Descripción: Se ha revertido un cambio incorrecto que establecía el formato de color en RGB565 (2 bytes/píxel). El formato correcto para los assets de animación es RGB565A8 (3 bytes/píxel), que incluye un canal alfa de 8 bits. Esta corrección restaura la transparencia de las animaciones y asegura que el buffer de animación se reserve con el tamaño adecuado. */

#include "animation_loader.h"
#include "esp_log.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static const char *TAG = "ANIM_LOADER";
#define LVGL_BIN_HEADER_SIZE 12

animation_t animation_loader_init(const char *path, uint16_t width, uint16_t height, uint16_t num_frames) {
    animation_t anim = { 0 };
    anim.base_path = path ? strdup(path) : NULL;
    anim.frame_count = num_frames;
    anim.width = width;
    anim.height = height;
    
    uint32_t rgb_stride = width * 2; 
    // [CORRECCIÓN] Restaurado a 3 bytes por píxel para soportar el canal alfa (A8).
    size_t buffer_size = (size_t)width * height * 3;

    anim.img_dsc.data = (uint8_t *)malloc(buffer_size);
    if (!anim.img_dsc.data) { 
        ESP_LOGE(TAG, "Fallo al reservar buffer de animación de tamaño %u!", (unsigned int)buffer_size);
        animation_loader_free(&anim); 
        return anim; 
    }
    
    anim.img_dsc.header.w = width;
    anim.img_dsc.header.h = height;
    anim.img_dsc.header.stride = rgb_stride;
    // [CORRECCIÓN] Restaurado el formato de color que incluye el canal alfa.
    anim.img_dsc.header.cf = LV_COLOR_FORMAT_RGB565A8;
    anim.img_dsc.data_size = buffer_size;
    
    ESP_LOGD(TAG, "Gestor de animación inicializado. Buffer de %u bytes.", (unsigned int)buffer_size);
    return anim;
}

bool animation_loader_load_frame(animation_t *anim, uint16_t frame_index, const char *prefix) {
    if (!anim || !anim->base_path || !anim->img_dsc.data) return false;
    char full_path[128];
    snprintf(full_path, sizeof(full_path), "%s/%s%d.bin", anim->base_path, prefix, frame_index + 1);

    lv_fs_file_t f;
    lv_fs_res_t res = lv_fs_open(&f, full_path, LV_FS_MODE_RD);
    if (res != LV_FS_RES_OK) {
        ESP_LOGW(TAG, "Fallo al abrir frame (LVGL): %s", full_path);
        return false;
    }
    
    lv_fs_seek(&f, LVGL_BIN_HEADER_SIZE, LV_FS_SEEK_SET);
    uint32_t bytes_read = 0;
    lv_fs_read(&f, (void *)anim->img_dsc.data, anim->img_dsc.data_size, &bytes_read);
    lv_fs_close(&f);

    return true;
}

void animation_loader_free(animation_t *anim) {
    if (!anim) return;
    if(anim->base_path) {
        free(anim->base_path);
        anim->base_path = NULL;
    }
    if (anim->img_dsc.data) {
        free((void*)anim->img_dsc.data);
        anim->img_dsc.data = NULL;
    }
    anim->frame_count = 0;
}

uint16_t animation_loader_count_frames(const char *path, const char *prefix) {
    if (!path || !prefix) {
        return 0;
    }

    uint16_t count = 0;
    ESP_LOGD(TAG, "Abriendo directorio de animación (LVGL): '%s' para contar frames con prefijo '%s'", path, prefix);
    
    lv_fs_dir_t d;
    lv_fs_res_t res = lv_fs_dir_open(&d, path);

    if(res != LV_FS_RES_OK) {
        ESP_LOGE(TAG, "No se pudo abrir el directorio (LVGL): %s. Código de error: %d", path, res);
        return 0;
    }

    char fn[256];
    size_t prefix_len = strlen(prefix);

    while(lv_fs_dir_read(&d, fn, sizeof(fn)) == LV_FS_RES_OK && fn[0] != '\0') {
        // Compara si el nombre del fichero empieza con el prefijo deseado.
        if (strncmp(fn, prefix, prefix_len) == 0) {
            count++;
        }
    }

    lv_fs_dir_close(&d);
    ESP_LOGD(TAG, "Cierre de directorio. Total de fotogramas con prefijo '%s': %d", prefix, count);
    return count;
}

--- END OF FILE: .\components\ui\animation_loader.c ---

--- START OF FILE: .\components\ui\animation_loader.h ---
/*
 * Fichero: ./components/diymon_ui/animation_loader.h
 * Fecha: 11/08/2025 - 12:00
 * Último cambio: Sin cambios en esta iteración.
 * Descripción: Define la interfaz para el cargador de animaciones. Se añade una
 *              función que permite contar el número de fotogramas de una animación
 *              en un directorio específico, basado en un prefijo de fichero.
 */
#ifndef ANIMATION_LOADER_H
#define ANIMATION_LOADER_H

#include "lvgl.h"

typedef struct {
    char *base_path;
    uint16_t frame_count;
    uint16_t width;
    uint16_t height;
    lv_img_dsc_t img_dsc;
} animation_t;

animation_t animation_loader_init(const char *path, uint16_t width, uint16_t height, uint16_t num_frames);
bool animation_loader_load_frame(animation_t *anim, uint16_t frame_index, const char *prefix);
void animation_loader_free(animation_t *anim);
uint16_t animation_loader_count_frames(const char *path, const char *prefix);

#endif // ANIMATION_LOADER_H
--- END OF FILE: .\components\ui\animation_loader.h ---

--- START OF FILE: .\components\ui\CMakeLists.txt ---
# Fecha: 18/08/2025 - 06:55 
# Fichero: components/ui/CMakeLists.txt
# Último cambio: Eliminada la dependencia 'wifi_portal' al centralizar la configuración.
# Descripción: Se ha eliminado 'wifi_portal' de la lista de dependencias. La funcionalidad de portal cautivo ya no se utiliza, ya que el único modo de configuración es el servidor web accesible desde la UI, que es manejado por los componentes 'bsp' (para el AP) y 'web_server'.

file(GLOB component_sources
    "*.c" 
    "core/*.c"
    "screens/*.c"
    "actions/*.c"
    "assets/styles/*.c"
    "buttons/*.c"
    "telemetry/*.c"
)

# Buscar y añadir automáticamente TODOS los ficheros .c del directorio de imágenes.
file(GLOB asset_sources "assets/images/*.c")
list(APPEND component_sources ${asset_sources})

idf_component_register(
    SRCS ${component_sources}
    INCLUDE_DIRS
        "."
        "buttons"
        "actions"
        "core"
        "screens"
        "assets/styles"
        "assets/fonts"
        "assets/images"
        "telemetry"
    PRIV_INCLUDE_DIRS "."
    REQUIRES
        lvgl
        bsp
        core
        screen_manager
        web_server
)

--- END OF FILE: .\components\ui\CMakeLists.txt ---

--- START OF FILE: .\components\ui\fonts.h ---
#ifndef EEZ_LVGL_UI_FONTS_H
#define EEZ_LVGL_UI_FONTS_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#endif /*EEZ_LVGL_UI_FONTS_H*/
--- END OF FILE: .\components\ui\fonts.h ---

--- START OF FILE: .\components\ui\helpers.c ---
/* Fecha: 17/08/2025 - 10:18  */
/* Fichero: components/ui/helpers.c */
/* Último cambio: Renombrado de 'diymon_ui_helpers.c' y actualizada la inclusión de la cabecera. */
/* Descripción: Implementación de las funciones de ayuda de la UI. Se ha renombrado el fichero y se ha actualizado la directiva #include para que apunte a 'helpers.h', completando la estandarización de nombres. */

#include "helpers.h"
#include "diymon_evolution.h"
#include "esp_log.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "assets/images/ui_assets.h"

static const char* TAG_HELPERS = "UI_HELPERS";

// Función interna para obtener el nombre del directorio de evolución (ej: "1.1.1" -> "111")
static void get_evolution_dir_name(char* dir_name_buffer, size_t buffer_size) {
    const char* evo_code = diymon_get_current_code();
    memset(dir_name_buffer, 0, buffer_size);
    int j = 0;
    for (int i = 0; evo_code[i] != '\0' && j < buffer_size - 1; i++) {
        if (evo_code[i] != '.') {
            dir_name_buffer[j++] = evo_code[i];
        }
    }
}

// Construye la ruta a un asset de animación en la SD.
void ui_helpers_build_asset_path(char* buffer, size_t buffer_size, const char* asset_filename) {
    char dir_name[9];
    get_evolution_dir_name(dir_name, sizeof(dir_name));
    snprintf(buffer, buffer_size, "S:/diymon/%s/%s/", dir_name, asset_filename);
}

// Carga la imagen de fondo desde el firmware creando un objeto de imagen.
void ui_helpers_load_background(lv_obj_t* parent) {
    ESP_LOGI(TAG_HELPERS, "Creando objeto de imagen para el fondo desde firmware.");
    lv_obj_t *bg_img = lv_image_create(parent);
    lv_image_set_src(bg_img, &bg_0); // Usa el asset declarado en ui_assets.h
    lv_obj_set_pos(bg_img, 0, 0); 
    lv_obj_move_background(bg_img); 
}

// La función para liberar el buffer de fondo ya no es necesaria.
void ui_helpers_free_background_buffer(void) {
    ESP_LOGD(TAG_HELPERS, "ui_helpers_free_background_buffer ya no es necesaria y ha sido ignorada.");
}

// Implementaciones placeholder para que compile
void ui_helpers_create_diymon_gif(lv_obj_t* parent) {}
void ui_helpers_free_gif_buffer(void) {}

--- END OF FILE: .\components\ui\helpers.c ---

--- START OF FILE: .\components\ui\helpers.h ---
/* Fecha: 17/08/2025 - 10:18  */
/* Fichero: components/ui/helpers.h */
/* Último cambio: Renombrado de 'diymon_ui_helpers.h' para simplificar y estandarizar. */
/* Descripción: Funciones de ayuda para la interfaz de usuario. Proporciona utilidades para construir rutas de assets y cargar elementos visuales como el fondo de pantalla. */
#ifndef HELPERS_H
#define HELPERS_H

#include "lvgl.h"

void ui_helpers_build_asset_path(char* buffer, size_t buffer_size, const char* asset_filename);
void ui_helpers_load_background(lv_obj_t* parent);
void ui_helpers_free_background_buffer(void);
void ui_helpers_create_diymon_gif(lv_obj_t* parent);
void ui_helpers_free_gif_buffer(void);

#endif // HELPERS_H

--- END OF FILE: .\components\ui\helpers.h ---

--- START OF FILE: .\components\ui\styles.c ---
/*
 * Fichero: ./components/diymon_ui/styles.c
 * Fecha: 13/08/2025 - 11:39 
 * Último cambio: Limpieza de comentarios.
 * Descripción: Fichero para la inicialización de estilos de LVGL.
 */
#include "styles.h"
#include "lvgl.h"

void init_styles(void) {
    // Inicializa aquí los estilos que necesites
}

--- END OF FILE: .\components\ui\styles.c ---

--- START OF FILE: .\components\ui\styles.h ---
#ifndef EEZ_LVGL_UI_STYLES_H
#define EEZ_LVGL_UI_STYLES_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#endif /*EEZ_LVGL_UI_STYLES_H*/
--- END OF FILE: .\components\ui\styles.h ---

--- START OF FILE: .\components\ui\ui_action_animations.c ---
/* Fecha: 17/08/2025 - 10:25  */
/* Fichero: components/ui/ui_action_animations.c */
/* Último cambio: Actualizada la inclusión de 'diymon_ui_helpers.h' a 'helpers.h' para corregir el error de compilación. */
/* Descripción: Se ha corregido la directiva de inclusión para que apunte al fichero de cabecera renombrado 'helpers.h'. Esto resuelve el error 'No such file or directory' que impedía la compilación. */

#include "ui_action_animations.h"
#include "animation_loader.h"
#include "helpers.h" // Corregido desde diymon_ui_helpers.h
#include "ui_idle_animation.h"
#include "esp_log.h"
#include <stdio.h>
#include <string.h>

static const char *TAG = "UI_ACTION_ANIM";

// --- Variables Globales y Estáticas ---
lv_obj_t *g_animation_img_obj = NULL;
static animation_t g_animation_player; // Player global que contiene el búfer compartido

static lv_timer_t *s_anim_timer;
static bool s_is_action_in_progress = false;
static int s_current_frame_index;

#define FRAME_INTERVAL_MS 500

// --- Declaraciones de Funciones Internas ---
static void animation_timer_cb(lv_timer_t *timer);
static void animation_finished(void);
static const char* get_anim_prefix(diymon_action_id_t action_id);

// --- Implementación de Funciones Públicas ---

void ui_action_animations_preinit_buffer(void) {
    // Reservar el búfer de animación compartido UNA SOLA VEZ.
    g_animation_player = animation_loader_init(NULL, 150, 230, 0);
    if (g_animation_player.img_dsc.data == NULL) {
        ESP_LOGE(TAG, "FALLO CRÍTICO: No se pudo reservar memoria para el búfer de animación compartido.");
    } else {
        ESP_LOGI(TAG, "Búfer de animación compartido (150x230) pre-reservado correctamente.");
    }
}

void ui_action_animations_create(lv_obj_t *parent) {
    if (g_animation_player.img_dsc.data == NULL) {
        ESP_LOGE(TAG, "El búfer de animación compartido no fue pre-reservado. No se puede crear el objeto de animación.");
        return;
    }
    
    g_animation_img_obj = lv_image_create(parent);
    lv_image_set_src(g_animation_img_obj, &g_animation_player.img_dsc);
    
    lv_obj_set_style_bg_opa(g_animation_img_obj, LV_OPA_TRANSP, 0);
    lv_obj_align(g_animation_img_obj, LV_ALIGN_BOTTOM_MID, 0, -30);
}

void ui_action_animations_play(diymon_action_id_t action_id) {
    if (s_is_action_in_progress || action_id >= ACTION_ID_COUNT) return;
    if (g_animation_player.img_dsc.data == NULL) {
        ESP_LOGE(TAG, "No se puede iniciar la animación: el búfer compartido no está disponible.");
        return;
    }

    s_is_action_in_progress = true;
    
    ui_idle_animation_pause();

    const char *prefix = get_anim_prefix(action_id);
    char path_buffer[128];
    ui_helpers_build_asset_path(path_buffer, sizeof(path_buffer), "");
    size_t len = strlen(path_buffer);
    if (len > 0 && path_buffer[len - 1] == '/') path_buffer[len - 1] = '\0';
    
    uint16_t frame_count = animation_loader_count_frames(path_buffer, prefix);
    if (frame_count == 0) {
        ESP_LOGE(TAG, "No se encontraron fotogramas para la animación '%s' en '%s'.", prefix, path_buffer);
        animation_finished(); 
        return;
    }
    
    ESP_LOGI(TAG, "Reproduciendo animación '%s' (%d fotogramas) a %dms/frame.", prefix, frame_count, FRAME_INTERVAL_MS);

    if (g_animation_player.base_path) free(g_animation_player.base_path);
    g_animation_player.base_path = strdup(path_buffer);
    g_animation_player.frame_count = frame_count;

    s_current_frame_index = 0;
    if (animation_loader_load_frame(&g_animation_player, s_current_frame_index, prefix)) {
        lv_obj_invalidate(g_animation_img_obj);
        s_anim_timer = lv_timer_create(animation_timer_cb, FRAME_INTERVAL_MS, (void*)(intptr_t)action_id);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el primer fotograma (%s).", prefix);
        animation_finished();
    }
}

void ui_action_animations_destroy(void) {
    ESP_LOGI(TAG, "Liberando búfer de animación compartido.");
    animation_loader_free(&g_animation_player);
}

animation_t* ui_action_animations_get_player(void) {
    return &g_animation_player;
}

static void animation_timer_cb(lv_timer_t *timer) {
    s_current_frame_index++;
    if (s_current_frame_index >= g_animation_player.frame_count) {
        animation_finished();
        return;
    }

    diymon_action_id_t action_id = (diymon_action_id_t)(intptr_t)timer->user_data;
    const char *prefix = get_anim_prefix(action_id);

    if (animation_loader_load_frame(&g_animation_player, s_current_frame_index, prefix)) {
        lv_obj_invalidate(g_animation_img_obj);
    } else {
        ESP_LOGW(TAG, "No se pudo cargar el fotograma %d para %s. Finalizando animación.", s_current_frame_index + 1, prefix);
        animation_finished();
    }
}

static void animation_finished(void) {
    if (s_anim_timer) {
        lv_timer_del(s_anim_timer);
        s_anim_timer = NULL;
    }
    
    if (g_animation_player.base_path) {
        free(g_animation_player.base_path);
        g_animation_player.base_path = NULL;
    }
    g_animation_player.frame_count = 0;
    
    ui_idle_animation_resume();
    
    s_is_action_in_progress = false;
    ESP_LOGI(TAG, "Animación de acción finalizada. Control devuelto a idle.");
}

static const char* get_anim_prefix(diymon_action_id_t action_id) {
    switch(action_id) {
        case ACTION_ID_COMER:     return "ANIM_EAT_";
        case ACTION_ID_EJERCICIO: return "ANIM_GYM_";
        case ACTION_ID_ATACAR:    return "ANIM_ATK_";
        default:                  return "";
    }
}

--- END OF FILE: .\components\ui\ui_action_animations.c ---

--- START OF FILE: .\components\ui\ui_action_animations.h ---
/*
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_action_animations.h
# Fecha: $timestamp
# Último cambio: Añadida la declaración de la función de pre-reserva de buffer.
# Descripción: Interfaz pública para el módulo de animaciones de acción. Se añade la declaración de `ui_action_animations_preinit_buffer` para que la función sea visible para otros módulos y se resuelva así el error de compilación por declaración implícita.
*/
#ifndef UI_ACTION_ANIMATIONS_H
#define UI_ACTION_ANIMATIONS_H

#include <lvgl.h>
#include "actions.h"
#include "animation_loader.h"

#ifdef __cplusplus
extern "C" {
#endif

// --- OBJETO GLOBAL COMPARTIDO ---
extern lv_obj_t *g_animation_img_obj;

// --- FUNCIONES PÚBLICAS ---
void ui_action_animations_preinit_buffer(void);
void ui_action_animations_create(lv_obj_t *parent);
void ui_action_animations_play(diymon_action_id_t action_id);
void ui_action_animations_destroy(void);
animation_t* ui_action_animations_get_player(void);

#ifdef __cplusplus
}
#endif

#endif // UI_ACTION_ANIMATIONS_H

--- END OF FILE: .\components\ui\ui_action_animations.h ---

--- START OF FILE: .\components\ui\ui_actions_panel.c ---
/* Fecha: 17/08/2025 - 05:12  */
/* Fichero: components/ui/ui_actions_panel.c */
/* Último cambio: Eliminada la bandera LV_OBJ_FLAG_CLICKABLE de los paneles contenedores para solucionar el problema de eventos no recibidos. */
/* Descripción: Se ha corregido el error por el cual los botones no respondían a los clics. Los paneles contenedores, aunque transparentes, interceptaban los eventos de toque por defecto. Al hacerlos no-clicables con 'lv_obj_remove_flag', los eventos ahora se propagan correctamente a los botones hijos, que es el comportamiento esperado. Se han añadido logs para confirmar la creación y configuración de cada panel. */

#include "ui_actions_panel.h"
#include "ui_idle_animation.h"
#include "esp_log.h"
#include <stdio.h>

// --- Inclusión directa de los módulos de botones ---
#include "buttons/btn_1.h"
#include "buttons/btn_2.h"
#include "buttons/btn_3.h"
#include "buttons/btn_4.h"
#include "buttons/btn_5.h"
#include "buttons/btn_6.h"
#include "buttons/btn_7.h"
#include "buttons/btn_8.h"
#include "buttons/btn_9.h"
#include "buttons/evo_1.h"
#include "buttons/evo_2.h"
#include "buttons/evo_3.h"
#include "buttons/evo_4.h"
#include "buttons/evo_5.h"

static const char *TAG = "UI_PANELS";

// --- Constantes de configuración ---
#define PANEL_AUTO_HIDE_DELAY 10000 
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
#define ANIM_TIME_MS 300
#define EDGE_SWIPE_THRESHOLD 50
#define TOP_PANEL_WIDTH (BUTTON_SIZE * 3 + BUTTON_PADDING * 2)
#define TOP_PANEL_HEIGHT (BUTTON_SIZE)
#define SIDE_PANEL_WIDTH (BUTTON_SIZE)
#define SIDE_PANEL_HEIGHT (BUTTON_SIZE * 5 + BUTTON_PADDING * 4)


typedef enum {
    PANEL_STATE_HIDDEN,
    PANEL_STATE_PLAYER_VISIBLE,
    PANEL_STATE_ADMIN_VISIBLE,
    PANEL_STATE_CONFIG_VISIBLE,
    PANEL_STATE_SIDE_VISIBLE,
} panel_state_t;

// --- Variables estáticas del módulo ---
static lv_obj_t *s_panel_player;
static lv_obj_t *s_panel_admin;
static lv_obj_t *s_panel_config;
static lv_obj_t *s_panel_evo;

static lv_timer_t *s_hide_timer = NULL;
static panel_state_t s_panel_state = PANEL_STATE_HIDDEN;
static bool s_is_animating = false;

// --- Declaraciones de funciones internas ---
static void animate_panel_in_top(lv_obj_t *panel);
static void animate_panel_out_top(lv_obj_t *panel);
static void animate_panel_in_side(lv_obj_t *panel);
static void animate_panel_out_side(lv_obj_t *panel);
static void timer_auto_hide_callback(lv_timer_t *timer);
static void animation_finish_cb(lv_anim_t *a);

// --- Implementación de Funciones Públicas ---

void ui_actions_panel_create(lv_obj_t *parent) {
    // --- Crear Contenedor Panel Player ---
    s_panel_player = lv_obj_create(parent);
    lv_obj_remove_style_all(s_panel_player);
    lv_obj_set_size(s_panel_player, TOP_PANEL_WIDTH, TOP_PANEL_HEIGHT);
    lv_obj_align(s_panel_player, LV_ALIGN_TOP_MID, 0, -TOP_PANEL_HEIGHT);
    lv_obj_add_flag(s_panel_player, LV_OBJ_FLAG_HIDDEN);
    lv_obj_remove_flag(s_panel_player, LV_OBJ_FLAG_CLICKABLE); // [CORRECCIÓN CLAVE]
    btn_1_create(s_panel_player);
    btn_2_create(s_panel_player);
    btn_3_create(s_panel_player);
    ESP_LOGI(TAG, "Panel 'Player' creado y configurado para no interceptar clics.");

    // --- Crear Contenedor Panel Admin ---
    s_panel_admin = lv_obj_create(parent);
    lv_obj_remove_style_all(s_panel_admin);
    lv_obj_set_size(s_panel_admin, TOP_PANEL_WIDTH, TOP_PANEL_HEIGHT);
    lv_obj_align(s_panel_admin, LV_ALIGN_TOP_MID, 0, -TOP_PANEL_HEIGHT);
    lv_obj_add_flag(s_panel_admin, LV_OBJ_FLAG_HIDDEN);
    lv_obj_remove_flag(s_panel_admin, LV_OBJ_FLAG_CLICKABLE); // [CORRECCIÓN CLAVE]
    btn_4_create(s_panel_admin);
    btn_5_create(s_panel_admin);
    btn_6_create(s_panel_admin);
    ESP_LOGI(TAG, "Panel 'Admin' creado y configurado para no interceptar clics.");


    // --- Crear Contenedor Panel Config ---
    s_panel_config = lv_obj_create(parent);
    lv_obj_remove_style_all(s_panel_config);
    lv_obj_set_size(s_panel_config, TOP_PANEL_WIDTH, TOP_PANEL_HEIGHT);
    lv_obj_align(s_panel_config, LV_ALIGN_TOP_MID, 0, -TOP_PANEL_HEIGHT);
    lv_obj_add_flag(s_panel_config, LV_OBJ_FLAG_HIDDEN);
    lv_obj_remove_flag(s_panel_config, LV_OBJ_FLAG_CLICKABLE); // [CORRECCIÓN CLAVE]
    btn_7_create(s_panel_config);
    btn_8_create(s_panel_config);
    btn_9_create(s_panel_config);
    ESP_LOGI(TAG, "Panel 'Config' creado y configurado para no interceptar clics.");


    // --- Crear Contenedor Panel Evolución ---
    s_panel_evo = lv_obj_create(parent);
    lv_obj_remove_style_all(s_panel_evo);
    lv_obj_set_size(s_panel_evo, SIDE_PANEL_WIDTH, SIDE_PANEL_HEIGHT);
    lv_obj_align(s_panel_evo, LV_ALIGN_LEFT_MID, -SIDE_PANEL_WIDTH, 0);
    lv_obj_add_flag(s_panel_evo, LV_OBJ_FLAG_HIDDEN);
    lv_obj_remove_flag(s_panel_evo, LV_OBJ_FLAG_CLICKABLE); // [CORRECCIÓN CLAVE]
    evo_1_create(s_panel_evo);
    evo_2_create(s_panel_evo);
    evo_3_create(s_panel_evo);
    evo_4_create(s_panel_evo);
    evo_5_create(s_panel_evo);
    ESP_LOGI(TAG, "Panel 'Evo' creado y configurado para no interceptar clics.");

}

static void animation_finish_cb(lv_anim_t *a) { 
    s_is_animating = false; 
    if(lv_obj_get_y((lv_obj_t *)a->var) < 0 || lv_obj_get_x((lv_obj_t *)a->var) < 0) {
        lv_obj_add_flag((lv_obj_t *)a->var, LV_OBJ_FLAG_HIDDEN);
    }
}

static void animate_panel_in_top(lv_obj_t *panel) {
    if (s_hide_timer) lv_timer_del(s_hide_timer);
    s_is_animating = true;
    lv_obj_clear_flag(panel, LV_OBJ_FLAG_HIDDEN);

    lv_anim_t a;
    lv_anim_init(&a);
    lv_anim_set_var(&a, panel);
    lv_anim_set_values(&a, lv_obj_get_y(panel), BUTTON_PADDING);
    lv_anim_set_time(&a, ANIM_TIME_MS);
    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_y);
    lv_anim_set_path_cb(&a, lv_anim_path_ease_out);
    lv_anim_set_ready_cb(&a, animation_finish_cb);
    lv_anim_start(&a);

    s_hide_timer = lv_timer_create(timer_auto_hide_callback, PANEL_AUTO_HIDE_DELAY, NULL);
    lv_timer_set_repeat_count(s_hide_timer, 1);
}

static void animate_panel_out_top(lv_obj_t *panel) {
    if (s_hide_timer) { lv_timer_del(s_hide_timer); s_hide_timer = NULL; }
    s_is_animating = true;

    lv_anim_t a;
    lv_anim_init(&a);
    lv_anim_set_var(&a, panel);
    lv_anim_set_values(&a, lv_obj_get_y(panel), -TOP_PANEL_HEIGHT);
    lv_anim_set_time(&a, ANIM_TIME_MS);
    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_y);
    lv_anim_set_path_cb(&a, lv_anim_path_ease_in);
    lv_anim_set_ready_cb(&a, animation_finish_cb);
    lv_anim_start(&a);
}

static void animate_panel_in_side(lv_obj_t *panel) {
    if (s_hide_timer) lv_timer_del(s_hide_timer);
    s_is_animating = true;
    lv_obj_clear_flag(panel, LV_OBJ_FLAG_HIDDEN);

    lv_anim_t a;
    lv_anim_init(&a);
    lv_anim_set_var(&a, panel);
    lv_anim_set_values(&a, lv_obj_get_x(panel), BUTTON_PADDING);
    lv_anim_set_time(&a, ANIM_TIME_MS);
    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_x);
    lv_anim_set_path_cb(&a, lv_anim_path_ease_out);
    lv_anim_set_ready_cb(&a, animation_finish_cb);
    lv_anim_start(&a);

    s_hide_timer = lv_timer_create(timer_auto_hide_callback, PANEL_AUTO_HIDE_DELAY, NULL);
    lv_timer_set_repeat_count(s_hide_timer, 1);
}

static void animate_panel_out_side(lv_obj_t *panel) {
    if (s_hide_timer) { lv_timer_del(s_hide_timer); s_hide_timer = NULL; }
    s_is_animating = true;

    lv_anim_t a;
    lv_anim_init(&a);
    lv_anim_set_var(&a, panel);
    lv_anim_set_values(&a, lv_obj_get_x(panel), -SIDE_PANEL_WIDTH);
    lv_anim_set_time(&a, ANIM_TIME_MS);
    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_x);
    lv_anim_set_path_cb(&a, lv_anim_path_ease_in);
    lv_anim_set_ready_cb(&a, animation_finish_cb);
    lv_anim_start(&a);
}

static void timer_auto_hide_callback(lv_timer_t *timer) {
    ui_actions_panel_hide_all();
    s_hide_timer = NULL;
}

void ui_actions_panel_handle_gesture(lv_dir_t dir, lv_coord_t start_x, lv_coord_t start_y) {
    if (s_is_animating) return;
    if (s_hide_timer) lv_timer_reset(s_hide_timer);

    switch(s_panel_state) {
        case PANEL_STATE_HIDDEN:
            if (dir == LV_DIR_BOTTOM && start_y < EDGE_SWIPE_THRESHOLD) {
                animate_panel_in_top(s_panel_player);
                s_panel_state = PANEL_STATE_PLAYER_VISIBLE;
            } else if (dir == LV_DIR_RIGHT && start_x < EDGE_SWIPE_THRESHOLD) {
                animate_panel_in_side(s_panel_evo);
                s_panel_state = PANEL_STATE_SIDE_VISIBLE;
            } else {
                ui_idle_animation_resume();
            }
            break;
        case PANEL_STATE_PLAYER_VISIBLE:
            if (dir == LV_DIR_BOTTOM) {
                animate_panel_out_top(s_panel_player);
                animate_panel_in_top(s_panel_admin);
                s_panel_state = PANEL_STATE_ADMIN_VISIBLE;
            } else if (dir == LV_DIR_TOP) {
                animate_panel_out_top(s_panel_player);
                s_panel_state = PANEL_STATE_HIDDEN;
                ui_idle_animation_resume();
            }
            break;
        case PANEL_STATE_ADMIN_VISIBLE:
            if (dir == LV_DIR_BOTTOM) {
                animate_panel_out_top(s_panel_admin);
                animate_panel_in_top(s_panel_config);
                s_panel_state = PANEL_STATE_CONFIG_VISIBLE;
            } else if (dir == LV_DIR_TOP) {
                animate_panel_out_top(s_panel_admin);
                animate_panel_in_top(s_panel_player);
                s_panel_state = PANEL_STATE_PLAYER_VISIBLE;
            }
            break;
        case PANEL_STATE_CONFIG_VISIBLE:
             if (dir == LV_DIR_TOP) {
                animate_panel_out_top(s_panel_config);
                animate_panel_in_top(s_panel_admin);
                s_panel_state = PANEL_STATE_ADMIN_VISIBLE;
            }
            break;
        case PANEL_STATE_SIDE_VISIBLE:
            if (dir == LV_DIR_LEFT) {
                animate_panel_out_side(s_panel_evo);
                s_panel_state = PANEL_STATE_HIDDEN;
                ui_idle_animation_resume();
            }
            break;
    }
}

void ui_actions_panel_hide_all(void) {
    if (s_panel_state == PANEL_STATE_HIDDEN || s_is_animating) return;

    if (s_panel_state == PANEL_STATE_PLAYER_VISIBLE) animate_panel_out_top(s_panel_player);
    else if (s_panel_state == PANEL_STATE_ADMIN_VISIBLE) animate_panel_out_top(s_panel_admin);
    else if (s_panel_state == PANEL_STATE_CONFIG_VISIBLE) animate_panel_out_top(s_panel_config);
    else if (s_panel_state == PANEL_STATE_SIDE_VISIBLE) animate_panel_out_side(s_panel_evo);
    
    s_panel_state = PANEL_STATE_HIDDEN;
    if (s_hide_timer) { lv_timer_del(s_hide_timer); s_hide_timer = NULL; }
    ui_idle_animation_resume();
}

--- END OF FILE: .\components\ui\ui_actions_panel.c ---

--- START OF FILE: .\components\ui\ui_actions_panel.h ---
/* Fecha: 17/08/2025 - 01:29 
# Fichero: components/ui/ui_actions_panel.h
# Último cambio: Eliminados los getters de botones individuales tras la refactorización a un gestor de botones.
# Descripción: Interfaz pública para el gestor de paneles de acciones. Ahora solo expone las funciones de alto nivel para crear, mostrar/ocultar y manejar gestos, ya que la gestión de los botones individuales se ha delegado al uttons_manager.
*/
#ifndef UI_ACTIONS_PANEL_H
#define UI_ACTIONS_PANEL_H

#include <lvgl.h>

/**
 * @brief Crea todos los paneles de acción, delegando la creación de botones al `buttons_manager`.
 * @param parent El objeto padre sobre el cual se crearán los botones.
 */
void ui_actions_panel_create(lv_obj_t *parent);

/**
 * @brief Procesa un gesto de deslizamiento para mostrar u ocultar paneles.
 * @param dir La dirección del gesto detectado por LVGL.
 * @param start_x Coordenada X inicial del gesto.
 * @param start_y Coordenada Y inicial del gesto.
 */
void ui_actions_panel_handle_gesture(lv_dir_t dir, lv_coord_t start_x, lv_coord_t start_y);

/**
 * @brief Oculta inmediatamente cualquier panel de acciones que esté visible.
 *        Útil para forzar el cierre de los paneles, por ejemplo, al apagar la pantalla.
 */
void ui_actions_panel_hide_all(void);

#endif // UI_ACTIONS_PANEL_H

--- END OF FILE: .\components\ui\ui_actions_panel.h ---

--- START OF FILE: .\components\ui\ui_asset_loader.c ---
/* Fecha: 17/08/2025 - 03:09  */
/* Fichero: components/ui/ui_asset_loader.c */
/* Último cambio: Actualizada la ruta de inclusión para 'ui_assets.h' para reflejar la nueva estructura de directorios. */
/* Descripción: Implementa el cargador de assets. Se ha corregido la ruta de inclusión de los assets de imagen para que apunte a 'assets/images/ui_assets.h', adaptándose a la refactorización que centraliza todos los recursos de apariencia. */

#include "ui_asset_loader.h"
#include "assets/images/ui_assets.h" // Actualizado para reflejar la nueva ubicación
#include "esp_log.h"

static const char *TAG = "UI_ASSET_LOADER";

// --- Mapeo de IDs de assets a los punteros de los descriptores de imagen compilados ---
static const lv_img_dsc_t* g_asset_dsc_pointers[ASSET_COUNT] = {
    [ASSET_ICON_EAT]                  = &asset_btn_1,
    [ASSET_ICON_GYM]                  = &asset_btn_2,
    [ASSET_ICON_ATK]                  = &asset_btn_3,
    [ASSET_ICON_BRIGHTNESS]           = &asset_btn_4,
    [ASSET_ICON_SCREEN_OFF]           = &asset_btn_5,
    [ASSET_ICON_ADMIN_PLACEHOLDER]    = &asset_btn_6,
    [ASSET_ICON_RESET_ALL]            = &asset_btn_7,
    [ASSET_ICON_ENABLE_FILE_SERVER]   = &asset_btn_8,
    [ASSET_ICON_CONFIG_PLACEHOLDER]   = &asset_btn_9,
    [ASSET_ICON_EVO_FIRE]             = &asset_evo_1,
    [ASSET_ICON_EVO_WATER]            = &asset_evo_2,
    [ASSET_ICON_EVO_EARTH]            = &asset_evo_3,
    [ASSET_ICON_EVO_WIND]             = &asset_evo_4,
    [ASSET_ICON_EVO_BACK]             = &asset_evo_5,
};

/**
 * @brief Inicializa el gestor de assets. En este modo no hace nada.
 */
void ui_assets_init(void) {
    ESP_LOGI(TAG, "Asset loader inicializado en modo 'firmware-linked'.");
}

/**
 * @brief Desinicializa el gestor de assets. No hace nada en este modo.
 */
void ui_assets_deinit(void) {
    // No hay memoria dinámica que liberar.
}

/**
 * @brief Obtiene un puntero al descriptor de imagen de un icono compilado en el firmware.
 * @param asset_id El identificador del icono.
 * @return Un puntero constante al descriptor de imagen LVGL.
 */
const lv_img_dsc_t* ui_assets_get_icon(ui_asset_id_t asset_id) {
    if (asset_id < 0 || asset_id >= ASSET_COUNT) {
        ESP_LOGE(TAG, "Asset ID %d solicitado está fuera de rango.", asset_id);
        return NULL;
    }
    return g_asset_dsc_pointers[asset_id];
}

--- END OF FILE: .\components\ui\ui_asset_loader.c ---

--- START OF FILE: .\components\ui\ui_asset_loader.h ---
/*
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_asset_loader.h
# Fecha: $timestamp
# Último cambio: Corregido el tipo de retorno de `ui_assets_get_icon` a `const lv_img_dsc_t*`.
# Descripción: Se corrige la declaración de `ui_assets_get_icon` para que devuelva un puntero a un descriptor de imagen (`const lv_img_dsc_t*`), coincidiendo con la nueva implementación que utiliza assets compilados en el firmware. Esto resuelve el error de compilación por tipos conflictivos.
*/
#ifndef UI_ASSET_LOADER_H
#define UI_ASSET_LOADER_H

#include "lvgl.h"

// Identificadores únicos para cada asset precargado.
typedef enum {
    // Iconos del panel de jugador (superior 1)
    ASSET_ICON_EAT,
    ASSET_ICON_GYM,
    ASSET_ICON_ATK,

    // Iconos del panel de administración (superior 2)
    ASSET_ICON_BRIGHTNESS,
    ASSET_ICON_SCREEN_OFF,
    ASSET_ICON_ADMIN_PLACEHOLDER,
    
    // Iconos del panel de configuración (superior 3)
    ASSET_ICON_RESET_ALL,
    ASSET_ICON_ENABLE_FILE_SERVER,
    ASSET_ICON_CONFIG_PLACEHOLDER,

    // Iconos del panel de evolución (lateral)
    ASSET_ICON_EVO_FIRE,
    ASSET_ICON_EVO_WATER,
    ASSET_ICON_EVO_EARTH,
    ASSET_ICON_EVO_WIND,
    ASSET_ICON_EVO_BACK,

    ASSET_COUNT // Utilidad para contar el número de assets
} ui_asset_id_t;

/**
 * @brief Inicializa el gestor de assets.
 */
void ui_assets_init(void);

/**
 * @brief Desinicializa el gestor de assets.
 */
void ui_assets_deinit(void);

/**
 * @brief Obtiene un puntero al descriptor de imagen de un icono compilado en el firmware.
 * @param asset_id El identificador del icono a obtener.
 * @return Un puntero constante al descriptor de imagen LVGL.
 */
const lv_img_dsc_t* ui_assets_get_icon(ui_asset_id_t asset_id);

#endif // UI_ASSET_LOADER_H

--- END OF FILE: .\components\ui\ui_asset_loader.h ---

--- START OF FILE: .\components\ui\ui_idle_animation.c ---
/* Fecha: 17/08/2025 - 10:26  */
/* Fichero: components/ui/ui_idle_animation.c */
/* Último cambio: Corregida la declaración del buffer 'anim_path' de char a char[] para evitar corrupción de memoria. */
/* Descripción: Se ha corregido un error crítico donde el buffer para la ruta de la animación se declaraba como un único carácter en lugar de un array. Esto causaba un desbordamiento de buffer y comportamiento indefinido al construir la ruta, impidiendo que la animación de reposo se cargara correctamente. */

#include "ui_idle_animation.h"
#include "ui_action_animations.h" 
#include "animation_loader.h"
#include "helpers.h"
#include "esp_log.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static const char *TAG = "UI_IDLE_ANIM";

#define IDLE_FRAME_INTERVAL 1500

static lv_timer_t *g_anim_timer;
static animation_t s_idle_animation_player; // Player local, pero usará un búfer compartido
static int g_current_frame_index = -1;
static bool g_is_idle_running = false;

static void idle_animation_timer_cb(lv_timer_t *timer) {
    if (!g_is_idle_running || s_idle_animation_player.frame_count == 0) return;
    
    g_current_frame_index = (g_current_frame_index + 1) % s_idle_animation_player.frame_count;
    
    if (animation_loader_load_frame(&s_idle_animation_player, g_current_frame_index, "ANIM_IDLE_")) {
        if (g_animation_img_obj) {
            lv_image_set_src(g_animation_img_obj, &s_idle_animation_player.img_dsc);
            lv_obj_invalidate(g_animation_img_obj);
        }
    }
}

lv_obj_t* ui_idle_animation_start(lv_obj_t *parent) {
    animation_t* shared_player = ui_action_animations_get_player();
    if (shared_player == NULL || shared_player->img_dsc.data == NULL) {
        ESP_LOGE(TAG, "No se puede iniciar la animación idle: el búfer compartido no es válido.");
        return NULL;
    }

    // Copiar el descriptor, que incluye el puntero al búfer compartido.
    s_idle_animation_player.img_dsc = shared_player->img_dsc;

    char anim_path[128]; // [CORRECCIÓN] Declarado como un array de caracteres.
    ui_helpers_build_asset_path(anim_path, sizeof(anim_path), "");
    size_t len = strlen(anim_path);
    if (len > 0 && anim_path[len - 1] == '/') anim_path[len - 1] = '\0';
    
    s_idle_animation_player.base_path = strdup(anim_path);

    uint16_t frame_count = animation_loader_count_frames(anim_path, "ANIM_IDLE_");
    if (frame_count == 0) {
        ESP_LOGE(TAG, "No se encontraron fotogramas para la animación de reposo en '%s'. La animación no se iniciará y el personaje se ocultará.", anim_path);
        free(s_idle_animation_player.base_path);
        s_idle_animation_player.base_path = NULL;
        
        if (g_animation_img_obj) {
            lv_obj_add_flag(g_animation_img_obj, LV_OBJ_FLAG_HIDDEN);
        }
        
        return g_animation_img_obj;
    }
    ESP_LOGI(TAG, "Detectados %d fotogramas para la animación de reposo.", frame_count);
    s_idle_animation_player.frame_count = frame_count;

    if(g_animation_img_obj) {
        lv_image_set_src(g_animation_img_obj, &s_idle_animation_player.img_dsc);
        lv_obj_clear_flag(g_animation_img_obj, LV_OBJ_FLAG_HIDDEN);
    }
    
    g_is_idle_running = true;
    g_anim_timer = lv_timer_create(idle_animation_timer_cb, IDLE_FRAME_INTERVAL, NULL);
    lv_timer_ready(g_anim_timer);
    
    ESP_LOGI(TAG, "Animación de Idle iniciada desde %s (usando búfer compartido).", anim_path);
    return g_animation_img_obj;
}

void ui_idle_animation_stop(void) {
    ESP_LOGI(TAG, "Deteniendo y limpiando animación de idle.");
    g_is_idle_running = false;
    if (g_anim_timer) {
        lv_timer_del(g_anim_timer);
        g_anim_timer = NULL;
    }
    if (s_idle_animation_player.base_path) {
        free(s_idle_animation_player.base_path);
        s_idle_animation_player.base_path = NULL;
    }
    g_current_frame_index = -1;
}

void ui_idle_animation_pause(void) {
    if (g_anim_timer && g_is_idle_running) {
        lv_timer_pause(g_anim_timer);
        g_is_idle_running = false;
        ESP_LOGI(TAG, "Animación de Idle PAUSADA.");
    }
}

void ui_idle_animation_resume(void) {
    if (g_anim_timer && !g_is_idle_running) {
        if (g_animation_img_obj) {
             lv_image_set_src(g_animation_img_obj, &s_idle_animation_player.img_dsc);
        }
        
        g_is_idle_running = true;
        lv_timer_resume(g_anim_timer);
        idle_animation_timer_cb(g_anim_timer);
        ESP_LOGI(TAG, "Animación de Idle REANUDADA.");
    }
}

--- END OF FILE: .\components\ui\ui_idle_animation.c ---

--- START OF FILE: .\components\ui\ui_idle_animation.h ---
/*
 * Fichero: ./components/diymon_ui/ui_idle_animation.h
 * Fecha: 13/08/2025 - 11:43 
 * Último cambio: Corregida la firma de la función de inicio.
 * Descripción: Interfaz pública para la animación de reposo. Se corrige la
 *              declaración de 'ui_idle_animation_start' para que acepte un
 *              parámetro y devuelva un puntero a objeto, solucionando el error
 *              de compilación.
 */
#ifndef UI_IDLE_ANIMATION_H
#define UI_IDLE_ANIMATION_H

#include <lvgl.h>

/**
 * @brief Inicia la animación de idle a pantalla completa.
 * @param parent El objeto padre sobre el que se creará la animación (la pantalla principal).
 * @return Un puntero al objeto de imagen de la animación para que otros módulos puedan interactuar con él (ej: ocultarlo).
 */
lv_obj_t* ui_idle_animation_start(lv_obj_t *parent);

/**
 * @brief Detiene y libera todos los recursos de la animación de idle.
 */
void ui_idle_animation_stop(void);

/**
 * @brief Pausa el temporizador de la animación de idle.
 */
void ui_idle_animation_pause(void);

/**
 * @brief Reanuda el temporizador de la animación de idle.
 */
void ui_idle_animation_resume(void);

#endif // UI_IDLE_ANIMATION_H

--- END OF FILE: .\components\ui\ui_idle_animation.h ---

--- START OF FILE: .\components\ui\ui_layout.h ---
/* Fecha: 17/08/2025 - 02:08  */
/* Fichero: components/ui/ui_layout.h */
/* Último cambio: Centralizadas todas las constantes de diseño (tamaño de botones, tiempos de animación, etc.) en un único fichero para facilitar el mantenimiento y la coherencia visual. */
/* Descripción: Este fichero contiene todas las constantes mágicas que definen la apariencia y el comportamiento de la UI. Centraliza valores como el tamaño de los botones, los paddings y los tiempos de animación para aplicar el principio DRY (Don't Repeat Yourself) y facilitar cambios de diseño globales. */

#ifndef UI_LAYOUT_H
#define UI_LAYOUT_H

// --- Constantes de Diseño de Botones ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10

// --- Constantes de Animación y Comportamiento de Paneles ---
#define ANIM_TIME_MS 300
#define PANEL_AUTO_HIDE_DELAY 10000 
#define EDGE_SWIPE_THRESHOLD 50

// --- Constantes Estructurales de Paneles ---
#define NUM_TOP_BUTTONS 3
#define NUM_SIDE_BUTTONS 5


#endif // UI_LAYOUT_H

--- END OF FILE: .\components\ui\ui_layout.h ---

--- START OF FILE: .\components\ui\ui_priv.h ---
/*
 * Fichero: ui_priv.h
 * Fecha: 08/08/2025
 * Último cambio: Añadido puntero para el panel de acciones desplegable.
 * Descripción: Cabecera PRIVADA para el componente UI.
 *              Comparte definiciones y variables globales SOLO entre los .c de la UI.
 */
#ifndef UI_PRIV_H
#define UI_PRIV_H

#ifdef __cplusplus
extern "C" {
#endif

#include "lvgl.h"

/**
 * @struct objects_t
 * @brief  Contiene los punteros a todos los objetos LVGL gestionados por la UI.
 * 
 * Esta estructura centraliza el acceso a los elementos visuales. Se agrupan por
 * tipo (objetos principales, panel, botones, animaciones) para una mayor claridad.
 */
typedef struct {
    // --- Objetos Principales ---
    lv_obj_t *main;         // Objeto de la pantalla principal.
    lv_obj_t *idle;         // GIF de la animación de reposo.

    // --- Panel de Acciones Desplegable ---
    lv_obj_t *actions_panel; // El contenedor que se desliza desde arriba.

    // --- Botones de Acción (contenidos en el panel) ---
    lv_obj_t *comer;        // Botón para la acción 'Comer'.
    lv_obj_t *pesas;        // Botón para la acción 'Ejercicio'.
    lv_obj_t *atacar;       // Botón para la acción 'Atacar'.

    // --- Animaciones GIF de Acciones ---
    lv_obj_t *comiendo;     // GIF para la animación 'Comiendo'.
    lv_obj_t *ejercicio;    // GIF para la animación 'Ejercicio'.
    lv_obj_t *ataque;       // GIF para la animación 'Ataque'.

} objects_t;

/**
 * @brief Variable global 'objects'.
 * 
 * Declaración 'extern' que permite a todos los ficheros del componente UI
 * acceder a la instancia única de la estructura 'objects_t', que será
 * definida en 'screens.c'.
 */
extern objects_t objects;

#ifdef __cplusplus
}
#endif

#endif // UI_PRIV_H
--- END OF FILE: .\components\ui\ui_priv.h ---

--- START OF FILE: .\components\ui\ui_state_manager.c ---
/* Fecha: 17/08/2025 - 02:11  */
/* Fichero: components/ui/ui_state_manager.c */
/* Último cambio: Movida toda la lógica de gestión de estado de la pantalla (inactividad, atenuado, despertar) desde main.c a este nuevo módulo dedicado. */
/* Descripción: Implementación del gestor de estado de la UI. Este fichero ahora contiene todas las variables y funciones que manejan el comportamiento de la pantalla en respuesta a la inactividad del usuario. Centraliza la lógica de atenuado, apagado automático y el patrón de toques para despertar, limpiando significativamente la lógica de main.c. */

#include "ui_state_manager.h"
#include "screen_manager.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "esp_log.h"

static const char *TAG = "UI_STATE_MANAGER";

// --- Tipos y variables de estado internas ---
typedef enum {
    WAKE_STATE_OFF,
    WAKE_STATE_PRIMED,
} wake_up_state_t;

static bool s_is_dimmed = false;
static int s_user_brightness = 100;
static bool s_user_brightness_known = false;
static wake_up_state_t s_wake_state = WAKE_STATE_OFF;
static uint8_t s_wake_click_count = 0;
static lv_timer_t *s_double_click_timer = NULL;
static lv_timer_t *s_wake_prime_timer = NULL;

// --- Funciones de ayuda y callbacks ---

static void read_user_brightness_from_nvs(void) {
    if (s_user_brightness_known) return;
    nvs_handle_t nvs_handle;
    if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
        nvs_get_i32(nvs_handle, "brightness", (int32_t*)&s_user_brightness);
        nvs_close(nvs_handle);
        s_user_brightness_known = true;
    }
}

static void double_click_timer_cb(lv_timer_t * timer) {
    s_wake_click_count = 0;
    s_double_click_timer = NULL;
}

static void wake_prime_timer_cb(lv_timer_t * timer) {
    s_wake_state = WAKE_STATE_OFF;
    s_wake_click_count = 0;
    s_wake_prime_timer = NULL;
}

static void screen_touch_event_cb(lv_event_t * e) {
    lv_event_code_t code = lv_event_get_code(e);
    lv_disp_t * disp = lv_display_get_default();
    if (!disp) return;
    
    lv_display_trigger_activity(disp);

    if (code == LV_EVENT_PRESSED && s_is_dimmed && !screen_manager_is_off()) {
        read_user_brightness_from_nvs();
        screen_manager_set_brightness(s_user_brightness);
        s_is_dimmed = false;
        return;
    }

    if (code == LV_EVENT_CLICKED && screen_manager_is_off()) {
        if (s_wake_state == WAKE_STATE_OFF) {
            s_wake_click_count++;
            if (s_wake_click_count == 1) {
                s_double_click_timer = lv_timer_create(double_click_timer_cb, 500, NULL);
                lv_timer_set_repeat_count(s_double_click_timer, 1);
            } else if (s_wake_click_count == 2) {
                if (s_double_click_timer) lv_timer_del(s_double_click_timer);
                s_double_click_timer = NULL;
                s_wake_state = WAKE_STATE_PRIMED;
                s_wake_click_count = 0;
                s_wake_prime_timer = lv_timer_create(wake_prime_timer_cb, 3000, NULL);
                lv_timer_set_repeat_count(s_wake_prime_timer, 1);
            }
        } else if (s_wake_state == WAKE_STATE_PRIMED) {
            s_wake_click_count++;
            if (s_wake_click_count == 1) {
                s_double_click_timer = lv_timer_create(double_click_timer_cb, 500, NULL);
                lv_timer_set_repeat_count(s_double_click_timer, 1);
            } else if (s_wake_click_count >= 2) {
                if (s_double_click_timer) lv_timer_del(s_double_click_timer);
                if (s_wake_prime_timer) lv_timer_del(s_wake_prime_timer);
                s_double_click_timer = NULL;
                s_wake_prime_timer = NULL;
                screen_manager_turn_on();
                s_is_dimmed = false;
                s_wake_state = WAKE_STATE_OFF;
                s_wake_click_count = 0;
            }
        }
    }
}

static void inactivity_timer_cb(lv_timer_t * timer) {
    lv_disp_t * disp = lv_display_get_default();
    if (!disp) return;
    
    uint32_t inactivity_ms = lv_display_get_inactive_time(disp);
    bool is_off = screen_manager_is_off();

    if (inactivity_ms < 30000 && s_is_dimmed) {
        s_is_dimmed = false;
    }

    if (!is_off && inactivity_ms > 60000) {
        screen_manager_turn_off();
        s_is_dimmed = false;
    } else if (!is_off && !s_is_dimmed && inactivity_ms > 30000) {
        read_user_brightness_from_nvs();
        screen_manager_set_brightness(10);
        s_is_dimmed = true;
    }
}

// --- Función de inicialización pública ---
void ui_state_manager_init(void) {
    lv_timer_create(inactivity_timer_cb, 5000, NULL);
    lv_obj_t * scr = lv_screen_active();
    if (scr) {
        lv_obj_add_event_cb(scr, screen_touch_event_cb, LV_EVENT_ALL, NULL);
    }
    ESP_LOGI(TAG, "Gestor de estado de UI inicializado. Manejadores de inactividad activos.");
}

--- END OF FILE: .\components\ui\ui_state_manager.c ---

--- START OF FILE: .\components\ui\ui_state_manager.h ---
/* Fecha: 17/08/2025 - 02:10  */
/* Fichero: components/ui/ui_state_manager.h */
/* Último cambio: Creación del gestor de estado de la UI para encapsular la lógica de inactividad. */
/* Descripción: Interfaz pública del gestor de estado de la UI. Este módulo es responsable de manejar la inactividad del usuario, el atenuado y apagado automático de la pantalla, y la lógica de despertar. Expone una única función de inicialización para mantener su implementación interna encapsulada. */

#ifndef UI_STATE_MANAGER_H
#define UI_STATE_MANAGER_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el gestor de estado de la UI.
 * 
 * Configura los temporizadores y los callbacks de eventos necesarios para
 * gestionar la inactividad, el atenuado/apagado de la pantalla y la lógica
 * de despertar. Debe ser llamado una vez después de que la UI principal
 * haya sido creada.
 */
void ui_state_manager_init(void);

#ifdef __cplusplus
}
#endif

#endif // UI_STATE_MANAGER_H

--- END OF FILE: .\components\ui\ui_state_manager.h ---

--- START OF FILE: .\components\ui\ui.c ---
/* Fecha: 17/08/2025 - 01:31 
# Fichero: components/ui/ui.c
# Último cambio: Eliminada la función 'ui_connect_actions' y el callback de eventos centralizado para completar la refactorización de botones.
# Descripción: Orquestador principal de la UI. Se ha eliminado la lógica de conexión de eventos, ya que ahora cada módulo de botón es responsable de conectar su propio callback. Esta es la limpieza final de la refactorización, haciendo que este fichero sea agnóstico a los botones específicos.
*/
#include "ui.h"
#include "screens.h"
#include "ui_action_animations.h"
#include "esp_log.h"

extern lv_obj_t *g_main_screen_obj; 

static const char *TAG = "DIYMON_UI_MAIN";

// La función 'ui_connect_actions' y su 'button_event_cb' han sido eliminados.
// La conexión de eventos ahora está encapsulada dentro de cada módulo de botón.

void ui_preinit(void) {
    ESP_LOGI(TAG, "Pre-inicializando UI: reservando buffer de animación...");
    ui_action_animations_preinit_buffer();
}

void ui_init(void) {
    create_screens();
    
    if (g_main_screen_obj) {
        // La llamada a ui_connect_actions() ha sido eliminada.
        lv_obj_add_event_cb(g_main_screen_obj, (lv_event_cb_t)delete_screen_main, LV_EVENT_DELETE, NULL);
    }
    
    lv_screen_load(g_main_screen_obj);
    ESP_LOGI(TAG, "UI modularizada y lista.");
}

--- END OF FILE: .\components\ui\ui.c ---

--- START OF FILE: .\components\ui\ui.h ---
/*
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui.h
# Fecha: $timestamp
# Último cambio: Añadida la declaración de ui_preinit para la pre-reserva de memoria.
# Descripción: Interfaz PÚBLICA del componente de la UI. Define las funciones de alto nivel para controlar la UI desde el exterior. Se añade la declaración de `ui_preinit` para permitir la reserva del buffer de animación antes que cualquier otra inicialización, solucionando el error de compilación.
*/
#ifndef UI_H
#define UI_H

#ifdef __cplusplus
extern "C" {
#endif

// --- DEFINICIONES COMPARTIDAS ---

// Enum para identificar las pantallas. Se mantiene aquí porque es parte de la
// interfaz pública para, potencialmente, cambiar de pantalla.
enum ScreensEnum {
    SCREEN_ID_MAIN = 1,
};


// --- FUNCIONES PÚBLICAS DE LA UI ---

/**
 * @brief Pre-inicializa la UI reservando los buffers de memoria más grandes.
 *
 * Esta función debe llamarse al principio de app_main para evitar la fragmentación
 * de la memoria RAM, asegurando que la asignación de memoria más grande (el buffer
 * de animación) tenga éxito.
 */
void ui_preinit(void);

/**
 * @brief Inicializa y configura toda la interfaz de usuario.
 *
 * Esta es la función principal que se debe llamar desde fuera del componente
 * (por ejemplo, desde main.c) para poner en marcha toda la UI.
 */
void ui_init(void);


#ifdef __cplusplus
}
#endif

#endif // UI_H

--- END OF FILE: .\components\ui\ui.h ---

--- START OF FILE: .\components\web_server\CMakeLists.txt ---
# Fecha: 18/08/2025 - 07:45 
# Fichero: components/web_server/CMakeLists.txt
# Último cambio: Corregido el estilo de comentarios de C-style (/*) a CMake-style (#) para resolver el error de parser.
# Descripción: Registro del componente web_server. El error de compilación se debía a que se estaban usando comentarios de C en un fichero de CMake, lo cual es sintácticamente incorrecto. Se corrige el formato de los comentarios para que el sistema de build pueda procesar el fichero.

idf_component_register(SRCS
                        "web_server.c"
                        "web_server_handlers.c"
                        "web_server_helpers.c"
                    INCLUDE_DIRS "."
                    PRIV_INCLUDE_DIRS "."
                    REQUIRES
                        driver
                        esp_wifi
                        esp_event
                        nvs_flash
                        log
                        esp_http_server
                        bsp
                        sdmmc
)

--- END OF FILE: .\components\web_server\CMakeLists.txt ---

--- START OF FILE: .\components\web_server\web_server_handlers.c ---
/* Fecha: 18/08/2025 - 07:48  */
/* Fichero: components/web_server/web_server_handlers.c */
/* Último cambio: Eliminado el calificador 'static' de las definiciones de los handlers para resolver un error de enlazado (linkage error). */
/* Descripción: Se ha eliminado la palabra clave 'static' de la definición de todas las funciones handler. El error de compilación 'static declaration of '...' follows non-static declaration' ocurría porque las funciones se declaraban sin 'static' en la cabecera privada (web_server_priv.h) pero se definían con 'static' en este fichero, creando un conflicto de enlazado. Ahora las definiciones coinciden con las declaraciones, permitiendo que web_server.c las enlace correctamente. */

#include "web_server_priv.h"
#include "esp_log.h"
#include "esp_vfs.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "esp_system.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/stat.h>

static const char *TAG = "WEB_HANDLERS";

// --- Implementación de Handlers de Endpoints ---

esp_err_t root_get_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: GET /. Sirviendo página principal.");
    return serve_file_from_sd(req, "/sdcard/config/Index.html");
}

esp_err_t backup_get_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: GET /backup. Sirviendo página de respaldo.");
    return serve_file_from_sd(req, "/sdcard/config/backup.html");
}

esp_err_t list_files_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: GET /listfiles. Listando contenido de directorio.");
    char query_buf[128];
    char path_decoded[128] = "/";
    char current_path[256] = "/";

    if (httpd_req_get_url_query_str(req, query_buf, sizeof(query_buf)) == ESP_OK) {
        char param[128];
        if (httpd_query_key_value(query_buf, "path", param, sizeof(param)) == ESP_OK) {
            url_decode(path_decoded, param);
        }
    }
    if (path_decoded[0] != '/') {
        snprintf(current_path, sizeof(current_path), "/%s", path_decoded);
    } else {
        strncpy(current_path, path_decoded, sizeof(current_path) - 1);
    }

    if (strstr(current_path, "..")) {
        ESP_LOGE(TAG, "Intento de path traversal detectado: %s", current_path);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid path");
        return ESP_FAIL;
    }

    char full_path[512];
    snprintf(full_path, sizeof(full_path), "%s%s", WEB_MOUNT_POINT, strcmp(current_path, "/") == 0 ? "" : current_path);
    ESP_LOGD(TAG, "Listando directorio VFS: %s", full_path);
    
    DIR *d = opendir(full_path);
    if (!d) {
        ESP_LOGE(TAG, "No se pudo abrir el directorio: %s", full_path);
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    
    size_t buf_size = 1024;
    char *json_buf = malloc(buf_size);
    strcpy(json_buf, "[");
    bool first = true;
    struct dirent *dir;

    while ((dir = readdir(d)) != NULL) {
        if (strcmp(dir->d_name, ".") == 0 || strcmp(dir->d_name, "..") == 0) continue;
        if (!first) strcat(json_buf, ",");
        
        char item_path[512];
        int written = snprintf(item_path, sizeof(item_path), "%s/%s", full_path, dir->d_name);
        if (written < 0 || written >= sizeof(item_path)) {
            ESP_LOGE(TAG, "Error de truncamiento de ruta para: %s/%s", full_path, dir->d_name);
            continue;
        }
        
        struct stat st;
        char entry_buf[512];
        if (stat(item_path, &st) == 0) {
            snprintf(entry_buf, sizeof(entry_buf), 
                     "{\"name\":\"%s\",\"size\":%lld,\"type\":\"%s\"}", 
                     dir->d_name, (long long)st.st_size, S_ISDIR(st.st_mode) ? "dir" : "file");
        } else {
            snprintf(entry_buf, sizeof(entry_buf), 
                     "{\"name\":\"%s\",\"size\":0,\"type\":\"file\"}", dir->d_name);
        }

        if (strlen(json_buf) + strlen(entry_buf) + 2 > buf_size) {
            buf_size *= 2;
            char *new_buf = realloc(json_buf, buf_size);
            if (!new_buf) { free(json_buf); closedir(d); httpd_resp_send_500(req); return ESP_ERR_NO_MEM; }
            json_buf = new_buf;
        }
        strcat(json_buf, entry_buf);
        first = false;
    }
    closedir(d);

    strcat(json_buf, "]");
    ESP_LOGD(TAG, "JSON de ficheros generado: %s", json_buf);
    httpd_resp_send(req, json_buf, strlen(json_buf));
    free(json_buf);
    return ESP_OK;
}

esp_err_t upload_post_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: POST /upload. Iniciando subida de fichero.");
    char buf[UPLOAD_BUFFER_SIZE];
    char filepath[256];
    FILE *fd = NULL;
    int received;
    int remaining = req->content_len;
    ESP_LOGD(TAG, "Tamaño total del contenido: %d bytes.", remaining);

    received = httpd_req_recv(req, buf, MIN(remaining, sizeof(buf)));
    if (received <= 0) {
        ESP_LOGE(TAG, "Fallo al recibir el primer chunk de datos.");
        return ESP_FAIL;
    }
    
    char path[128] = "/";
    char filename[64] = "";
    get_multipart_value(buf, "path", path, sizeof(path));
    char *filename_start = strstr(buf, "filename=\"");
    if (!filename_start) { ESP_LOGE(TAG, "No se encontró 'filename' en la cabecera multipart."); return ESP_FAIL; }
    filename_start += strlen("filename=\"");
    char *filename_end = strchr(filename_start, '\"');
    if (!filename_end) { ESP_LOGE(TAG, "Formato de 'filename' inválido."); return ESP_FAIL; }
    strncpy(filename, filename_start, filename_end - filename_start);
    filename[filename_end - filename_start] = '\0';
    ESP_LOGD(TAG, "Path extraído: '%s', Filename: '%s'", path, filename);

    if (strlen(filename) == 0 || strstr(path, "..") || strstr(filename, "..")) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Ruta/fichero inválido.");
        return ESP_FAIL;
    }

    snprintf(filepath, sizeof(filepath), "%s%s/%s", WEB_MOUNT_POINT, strcmp(path, "/") == 0 ? "" : path, filename);
    ESP_LOGI(TAG, "Abriendo fichero para escritura: %s", filepath);
    fd = fopen(filepath, "wb");
    if (!fd) { ESP_LOGE(TAG, "Fallo al abrir fichero."); httpd_resp_send_500(req); return ESP_FAIL; }

    char *data_start = strstr(filename_end, "\r\n\r\n");
    if (!data_start) { ESP_LOGE(TAG, "No se encontró el delimitador de datos."); fclose(fd); return ESP_FAIL; }
    
    data_start += 4;
    int header_len = data_start - buf;
    int data_len = received - header_len;
    fwrite(data_start, 1, data_len, fd);
    remaining -= received;

    while (remaining > 0) {
        received = httpd_req_recv(req, buf, MIN(remaining, sizeof(buf)));
        if (received <= 0) { ESP_LOGE(TAG, "Error durante la recepción del stream."); fclose(fd); return ESP_FAIL; }
        
        char *boundary_start = strstr(buf, "\r\n--");
        if (boundary_start) {
             fwrite(buf, 1, boundary_start - buf, fd);
        } else {
             fwrite(buf, 1, received, fd);
        }
        remaining -= received;
    }

    fclose(fd);
    ESP_LOGI(TAG, "Subida de archivo a %s completa.", filepath);
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

esp_err_t delete_file_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: POST /delete. Petición de borrado recibida.");
    char buf[512];
    int ret = httpd_req_recv(req, buf, sizeof(buf) - 1);
    if (ret <= 0) return ESP_FAIL;
    buf[ret] = '\0';

    char path[128] = "";
    char filename[64] = "";
    get_multipart_value(buf, "path", path, sizeof(path));
    get_multipart_value(buf, "filename", filename, sizeof(filename));
    ESP_LOGD(TAG, "Petición de borrado: path='%s', filename='%s'", path, filename);
    
    if (strlen(filename) == 0 || strstr(path, "..") || strstr(filename, "..")) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Nombre de archivo o ruta inválidos.");
        return ESP_FAIL;
    }

    char filepath[256];
    snprintf(filepath, sizeof(filepath), "%s%s/%s", WEB_MOUNT_POINT, strcmp(path, "/") == 0 ? "" : path, filename);

    if (unlink(filepath) == 0) {
        ESP_LOGI(TAG, "Archivo borrado: %s", filepath);
        httpd_resp_send(req, "Archivo borrado.", HTTPD_RESP_USE_STRLEN);
    } else {
        ESP_LOGE(TAG, "Fallo al borrar el archivo: %s", filepath);
        httpd_resp_send_500(req);
    }
    return ESP_OK;
}

esp_err_t create_dir_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: POST /create. Petición de creación de directorio.");
    char buf[512];
    int ret = httpd_req_recv(req, buf, sizeof(buf) - 1);
    if (ret <= 0) return ESP_FAIL;
    buf[ret] = '\0';

    char path[128] = "";
    char dirname[64] = "";
    get_multipart_value(buf, "path", path, sizeof(path));
    get_multipart_value(buf, "dirname", dirname, sizeof(dirname));
    ESP_LOGD(TAG, "Petición de creación de dir: path='%s', dirname='%s'", path, dirname);
    
    if (strlen(dirname) == 0 || strstr(path, "..") || strstr(dirname, "..")) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Nombre de directorio o ruta inválidos.");
        return ESP_FAIL;
    }

    char full_path[256];
    snprintf(full_path, sizeof(full_path), "%s%s/%s", WEB_MOUNT_POINT, strcmp(path, "/") == 0 ? "" : path, dirname);

    if (mkdir(full_path, 0755) == 0) {
        ESP_LOGI(TAG, "Directorio creado: %s", full_path);
        httpd_resp_send(req, "Directorio creado.", HTTPD_RESP_USE_STRLEN);
    } else {
        ESP_LOGE(TAG, "Fallo al crear directorio: %s", full_path);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "No se pudo crear el directorio.");
    }
    return ESP_OK;
}

esp_err_t save_post_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: POST /save. Guardando configuración WiFi.");
    char buf[256];
    int ret = httpd_req_recv(req, buf, sizeof(buf) - 1);
    if (ret <= 0) return ESP_FAIL;
    buf[ret] = '\0';

    char ssid[32] = {0}, password_encoded[64] = {0}, password_decoded[64] = {0}, authmode_str[4] = {0};
    
    httpd_query_key_value(buf, "ssid", ssid, sizeof(ssid));
    httpd_query_key_value(buf, "password", password_encoded, sizeof(password_encoded));
    httpd_query_key_value(buf, "authmode", authmode_str, sizeof(authmode_str));
    int32_t authmode = atoi(authmode_str);

    url_decode(password_decoded, password_encoded);
    ESP_LOGI(TAG, "Guardando SSID: '%s'", ssid); // No loguear la contraseña por seguridad
    
    nvs_handle_t nvs_handle;
    ESP_ERROR_CHECK(nvs_open("storage", NVS_READWRITE, &nvs_handle));
    ESP_ERROR_CHECK(nvs_set_str(nvs_handle, "wifi_ssid", ssid));
    ESP_ERROR_CHECK(nvs_set_str(nvs_handle, "wifi_pass", password_decoded));
    ESP_ERROR_CHECK(nvs_set_i32(nvs_handle, "wifi_authmode", authmode));
    ESP_ERROR_CHECK(nvs_commit(nvs_handle));
    nvs_close(nvs_handle);
    ESP_LOGI(TAG, "Credenciales guardadas en NVS. Dispositivo se reiniciará.");

    const char* resp_str = "<h1>Configuracion guardada!</h1><p>El dispositivo se reiniciara.</p>";
    httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN);

    vTaskDelay(pdMS_TO_TICKS(2000));
    esp_restart();
    
    return ESP_OK;
}

--- END OF FILE: .\components\web_server\web_server_handlers.c ---

--- START OF FILE: .\components\web_server\web_server_helpers.c ---
/* Fecha: 18/08/2025 - 07:43  */
/* Fichero: components/web_server/web_server_helpers.c */
/* Último cambio: Creado como parte de la refactorización para aislar las funciones de ayuda. */
/* Descripción: Este fichero contiene funciones de utilidad utilizadas por los handlers del servidor web. Incluye la lógica para servir ficheros estáticos desde la tarjeta SD, decodificar URLs, parsear datos de formularios multipart y determinar el tipo de contenido de un fichero. Separar estas funciones mejora la legibilidad y permite reutilizarlas fácilmente. */

#include "web_server_priv.h"
#include "esp_log.h"
#include <stdio.h>
#include <string.h>
#include <ctype.h>

static const char *TAG = "WEB_HELPERS";

// --- Implementación de Funciones de Ayuda ---

esp_err_t set_content_type_from_file(httpd_req_t *req, const char *filename) {
    if (strstr(filename, ".html")) {
        return httpd_resp_set_type(req, "text/html");
    } else if (strstr(filename, ".css")) {
        return httpd_resp_set_type(req, "text/css");
    } else if (strstr(filename, ".js")) {
        return httpd_resp_set_type(req, "application/javascript");
    }
    // Añadir más tipos MIME si es necesario (ej: .json, .png, etc.)
    return httpd_resp_set_type(req, "text/plain");
}

esp_err_t serve_file_from_sd(httpd_req_t *req, const char *filepath) {
    ESP_LOGI(TAG, "Helper: Sirviendo fichero estático: %s", filepath);
    FILE *f = fopen(filepath, "r");
    if (f == NULL) {
        ESP_LOGE(TAG, "Helper: Fallo al abrir el fichero: %s", filepath);
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Fichero no encontrado.");
        return ESP_FAIL;
    }

    set_content_type_from_file(req, filepath);

    char chunk[1024];
    size_t chunksize;
    do {
        chunksize = fread(chunk, 1, sizeof(chunk), f);
        if (chunksize > 0) {
            if (httpd_resp_send_chunk(req, chunk, chunksize) != ESP_OK) {
                fclose(f);
                ESP_LOGE(TAG, "Helper: Fallo al enviar chunk del fichero.");
                // No se puede enviar un error aquí porque la respuesta ya ha comenzado.
                return ESP_FAIL;
            }
        }
    } while (chunksize != 0);

    fclose(f);
    ESP_LOGI(TAG, "Helper: Envío de fichero completado.");
    httpd_resp_send_chunk(req, NULL, 0); // Señal de finalización
    return ESP_OK;
}

void url_decode(char *dst, const char *src) {
    char a, b;
    while (*src) {
        if ((*src == '%') && ((a = src[1]) && (b = src[2])) && (isxdigit(a) && isxdigit(b))) {
            if (a >= 'a') a -= 'a'-'A';
            if (a >= 'A') a -= ('A' - 10); else a -= '0';
            if (b >= 'a') b -= 'a'-'A';
            if (b >= 'A') b -= ('A' - 10); else b -= '0';
            *dst++ = 16 * a + b;
            src += 3;
        } else if (*src == '+') {
            *dst++ = ' ';
            src++;
        } else {
            *dst++ = *src++;
        }
    }
    *dst++ = '\0';
}

bool get_multipart_value(const char* buf, const char* name, char* result, size_t max_len) {
    char field_name[128];
    snprintf(field_name, sizeof(field_name), "name=\"%s\"", name);
    
    char *val_start = strstr(buf, field_name);
    if (!val_start) return false;

    // Avanzar hasta el final de la línea del content-disposition
    val_start = strstr(val_start, "\r\n\r\n");
    if (!val_start) return false;
    val_start += 4; // Saltar el doble CRLF

    // El final del valor es el siguiente boundary
    char *val_end = strstr(val_start, "\r\n--");
    if (!val_end) return false;
    
    size_t len = val_end - val_start;
    if (len >= max_len) {
        ESP_LOGW(TAG, "Valor multipart para '%s' es demasiado largo (%d vs max %d)", name, len, max_len);
        return false;
    }

    strncpy(result, val_start, len);
    result[len] = '\0';
    return true;
}

--- END OF FILE: .\components\web_server\web_server_helpers.c ---

--- START OF FILE: .\components\web_server\web_server_priv.h ---
/* Fecha: 18/08/2025 - 07:41  */
/* Fichero: components/web_server/web_server_priv.h */
/* Último cambio: Creación del fichero como parte de la refactorización para declarar handlers y helpers internos. */
/* Descripción: Cabecera privada para el componente web_server. Declara las funciones de los handlers y helpers que son compartidas internamente entre los ficheros del componente, pero no expuestas públicamente. Esto permite a web_server.c registrar los handlers mientras que sus implementaciones residen en web_server_handlers.c. */

#ifndef WEB_SERVER_PRIV_H
#define WEB_SERVER_PRIV_H

#include "esp_http_server.h"
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

// --- Constantes internas del componente ---
#define WEB_MOUNT_POINT "/sdcard"
#define UPLOAD_BUFFER_SIZE 2048

// --- Declaraciones de Handlers (implementados en web_server_handlers.c) ---
esp_err_t root_get_handler(httpd_req_t *req);
esp_err_t backup_get_handler(httpd_req_t *req);
esp_err_t list_files_handler(httpd_req_t *req);
esp_err_t upload_post_handler(httpd_req_t *req);
esp_err_t delete_file_handler(httpd_req_t *req);
esp_err_t create_dir_handler(httpd_req_t *req);
esp_err_t save_post_handler(httpd_req_t *req);

// --- Declaraciones de Helpers (implementados en web_server_helpers.c) ---
esp_err_t serve_file_from_sd(httpd_req_t *req, const char *filepath);
void url_decode(char *dst, const char *src);
bool get_multipart_value(const char* buf, const char* name, char* result, size_t max_len);
esp_err_t set_content_type_from_file(httpd_req_t *req, const char *filename);

#ifdef __cplusplus
}
#endif

#endif // WEB_SERVER_PRIV_H

--- END OF FILE: .\components\web_server\web_server_priv.h ---

--- START OF FILE: .\components\web_server\web_server.c ---
/* Fecha: 18/08/2025 - 07:43  */
/* Fichero: components/web_server/web_server.c */
/* Último cambio: Aumentada la prioridad de la tarea del servidor HTTP a 3 para resolver el error de socket. */
/* Descripción: Orquestador del servidor web. La prioridad de la tarea se ha elevado a 3, que es mayor que la de la tarea de LVGL (prioridad 4). Esto es crucial para asegurar que el servidor web tenga la CPU necesaria para gestionar el envío de datos a través del socket, evitando que el buffer TCP se llene y cause el error EAGAIN ('error in send : 11'), que es la causa raíz del fallo en la transferencia de ficheros. */

#include "web_server.h"
#include "web_server_priv.h" // Cabecera privada con las declaraciones de los handlers
#include "esp_http_server.h"
#include "esp_log.h"

static const char *TAG = "WEB_SERVER";

// --- Funciones Públicas ---

httpd_handle_t web_server_start(void) {
    httpd_handle_t server = NULL;
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    config.uri_match_fn = httpd_uri_match_wildcard;
    config.stack_size = 8192;
    config.task_priority = 3; // [CORRECCIÓN] Prioridad > LVGL (4) para evitar inanición de la red.

    ESP_LOGI(TAG, "Iniciando servidor web de configuracion (Prioridad Tarea: %d).", config.task_priority);

    if (httpd_start(&server, &config) == ESP_OK) {
        // --- Registro de URI Handlers ---
        // Las implementaciones están en web_server_handlers.c
        
        httpd_uri_t root_uri = { .uri = "/", .method = HTTP_GET, .handler = root_get_handler };
        httpd_register_uri_handler(server, &root_uri);
        
        httpd_uri_t backup_uri = { .uri = "/backup", .method = HTTP_GET, .handler = backup_get_handler };
        httpd_register_uri_handler(server, &backup_uri);
        
        httpd_uri_t upload_uri = { .uri = "/upload", .method = HTTP_POST, .handler = upload_post_handler };
        httpd_register_uri_handler(server, &upload_uri);

        httpd_uri_t create_dir_uri = { .uri = "/create", .method = HTTP_POST, .handler = create_dir_handler };
        httpd_register_uri_handler(server, &create_dir_uri);

        httpd_uri_t list_uri = { .uri = "/listfiles*", .method = HTTP_GET, .handler = list_files_handler };
        httpd_register_uri_handler(server, &list_uri);
        
        httpd_uri_t delete_uri = { .uri = "/delete", .method = HTTP_POST, .handler = delete_file_handler };
        httpd_register_uri_handler(server, &delete_uri);

        httpd_uri_t save_uri = { .uri = "/save", .method = HTTP_POST, .handler = save_post_handler };
        httpd_register_uri_handler(server, &save_uri);
        
        ESP_LOGI(TAG, "Todos los handlers del servidor web registrados correctamente.");
        return server;
    }

    ESP_LOGE(TAG, "Error al iniciar el servidor web.");
    return NULL;
}

void web_server_stop(httpd_handle_t server) {
    if (server) {
        httpd_stop(server);
        ESP_LOGI(TAG, "Servidor web detenido.");
    }
}

--- END OF FILE: .\components\web_server\web_server.c ---

--- START OF FILE: .\components\web_server\web_server.h ---
/* Fecha: 18/08/2025 - 07:05  */
/* Fichero: components/web_server/web_server.h */
/* Último cambio: Modificadas las funciones start/stop para gestionar el handle del servidor y evitar errores de socket. */
/* Descripción: Interfaz pública para el componente del servidor web. La función 'web_server_start' ahora devuelve un handle al servidor iniciado. Se ha añadido 'web_server_stop' para permitir un apagado controlado del servidor, solucionando los errores de socket ('error in send : 11') que ocurrían al salir del modo de configuración. */
#ifndef WEB_SERVER_H
#define WEB_SERVER_H

#include "esp_http_server.h" // Necesario para el tipo httpd_handle_t

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicia el servidor web y devuelve su handle.
 * @return El handle del servidor HTTPD si se inicia correctamente, NULL en caso de error.
 */
httpd_handle_t web_server_start(void);

/**
 * @brief Detiene el servidor web de forma controlada.
 * @param server El handle del servidor a detener, obtenido de web_server_start.
 */
void web_server_stop(httpd_handle_t server);

#ifdef __cplusplus
}
#endif

#endif // WEB_SERVER_H

--- END OF FILE: .\components\web_server\web_server.h ---

--- START OF FILE: .\main\CMakeLists.txt ---
# Fecha: 18/08/2025 - 06:56 
# Fichero: main/CMakeLists.txt
# Último cambio: Eliminada la dependencia 'wifi_portal' al centralizar la configuración.
# Descripción: Se ha eliminado 'wifi_portal' de la lista de dependencias de 'main'. Esta funcionalidad ha quedado obsoleta tras unificar el modo de configuración en un único servidor web accesible desde la UI, simplificando la estructura de dependencias del proyecto.

idf_component_register(
    SRCS 
        "main.c"
        "hardware_manager.c"
    INCLUDE_DIRS "."
    
    REQUIRES
        # Componentes de la aplicación
        bsp
        core
        ui
        web_server
        screen_manager

        # Drivers y librerías de sistema base
        driver
        nvs_flash
        fatfs
        sdmmc
        
        # Componentes de UI y display
        lvgl
        esp_lvgl_port
        esp_lcd
        esp_lcd_touch
)

--- END OF FILE: .\main\CMakeLists.txt ---

--- START OF FILE: .\main\hardware_manager.c ---
/* Fecha: 15/08/2025 - 04:54  */
/* Fichero: Z:\DIYTOGETHER\DIYtogether\main\hardware_manager.c */
/* Último cambio: Corregida la concatenación de rutas en los callbacks del VFS para evitar dobles barras. */
/* Descripción: Se ha modificado la lógica en los callbacks 'fs_open_cb' y 'fs_dir_open_cb' para construir la ruta VFS completa de forma robusta. Ahora se comprueba si la ruta que llega de LVGL ya empieza con '/', evitando así la creación de rutas inválidas como '/sdcard//diymon/...' y solucionando definitivamente el error de 'directorio no encontrado'. */

#include "hardware_manager.h"
#include "esp_log.h"
#include "bsp_api.h"
#include "esp_lvgl_port.h"
#include "lvgl.h"

#include <stdio.h>
#include <string.h>
#include <dirent.h>
#include <unistd.h>

static const char *TAG = "HW_MANAGER";
#define BASE_PATH "/sdcard"

// --- Implementación del driver de LVGL v9 usando el VFS de ESP-IDF ---

static void * fs_open_cb(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode) {
    char vfs_path[256];
    // [CORRECCIÓN] Se comprueba si la ruta ya tiene un '/' para evitar duplicados.
    if (path[0] == '/') {
        snprintf(vfs_path, sizeof(vfs_path), "%s%s", BASE_PATH, path);
    } else {
        snprintf(vfs_path, sizeof(vfs_path), "%s/%s", BASE_PATH, path);
    }

    const char * fmode_str;
    if(mode == LV_FS_MODE_WR) fmode_str = "wb";
    else if(mode == LV_FS_MODE_RD) fmode_str = "rb";
    else if(mode == (LV_FS_MODE_WR | LV_FS_MODE_RD)) fmode_str = "rb+";
    else return NULL;

    return fopen(vfs_path, fmode_str);
}

static lv_fs_res_t fs_close_cb(lv_fs_drv_t * drv, void * file_p) {
    fclose((FILE *)file_p);
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_read_cb(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {
    *br = fread(buf, 1, btr, (FILE *)file_p);
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_write_cb(lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw) {
    *bw = fwrite(buf, 1, btw, (FILE *)file_p);
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_seek_cb(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence) {
    fseek((FILE *)file_p, pos, SEEK_SET);
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_tell_cb(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p) {
    *pos_p = ftell((FILE *)file_p);
    return LV_FS_RES_OK;
}

static void * fs_dir_open_cb(lv_fs_drv_t * drv, const char *path) {
    char vfs_path[256];
    // [CORRECCIÓN] Se comprueba si la ruta ya tiene un '/' para evitar duplicados.
    if (path[0] == '/') {
        snprintf(vfs_path, sizeof(vfs_path), "%s%s", BASE_PATH, path);
    } else {
        snprintf(vfs_path, sizeof(vfs_path), "%s/%s", BASE_PATH, path);
    }
    return opendir(vfs_path);
}

static lv_fs_res_t fs_dir_read_cb(lv_fs_drv_t * drv, void * rddir_p, char * fn, uint32_t fn_len) {
    struct dirent *ent = readdir((DIR *)rddir_p);
    if(ent == NULL) {
        fn[0] = '\0';
        return LV_FS_RES_OK;
    }
    
    // Para LVGL, los directorios deben empezar con '/'
    if(ent->d_type == DT_DIR) {
        snprintf(fn, fn_len, "/%s", ent->d_name);
    } else {
        snprintf(fn, fn_len, "%s", ent->d_name);
    }
    
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_dir_close_cb(lv_fs_drv_t * drv, void * rddir_p) {
    closedir((DIR *)rddir_p);
    return LV_FS_RES_OK;
}

esp_err_t hardware_manager_init(void) {
    ESP_LOGI(TAG, "Initializing BSP...");
    bsp_init(); 

    ESP_LOGI(TAG, "Initializing LVGL port...");
    const lvgl_port_cfg_t lvgl_cfg = ESP_LVGL_PORT_INIT_CONFIG();
    ESP_ERROR_CHECK(lvgl_port_init(&lvgl_cfg));
    
    const lvgl_port_display_cfg_t disp_cfg = {
        .io_handle = bsp_get_panel_io_handle(),
        .panel_handle = bsp_get_display_handle(),
        .buffer_size = bsp_get_display_buffer_size(),
        .double_buffer = 1,
        .hres = bsp_get_display_hres(),
        .vres = bsp_get_display_vres(),
        .flags = { .swap_bytes = true, }
    };
    lv_disp_t * disp = lvgl_port_add_disp(&disp_cfg);

    lv_display_set_color_format(disp, LV_COLOR_FORMAT_RGB565);

    ESP_LOGI(TAG, "Configuring touch driver orientation to match display rotation...");
    esp_lcd_touch_handle_t touch_handle = bsp_get_touch_handle();
    
    ESP_ERROR_CHECK(esp_lcd_touch_set_swap_xy(touch_handle, false));
    ESP_ERROR_CHECK(esp_lcd_touch_set_mirror_x(touch_handle, false));
    ESP_ERROR_CHECK(esp_lcd_touch_set_mirror_y(touch_handle, false));

    const lvgl_port_touch_cfg_t touch_cfg = { .disp = disp, .handle = touch_handle };
    lvgl_port_add_touch(&touch_cfg);
    
    return ESP_OK;
}

void hardware_manager_mount_lvgl_filesystem(void)
{
    ESP_LOGI(TAG, "Registrando el sistema de ficheros VFS (/sdcard) con LVGL...");
    
    static lv_fs_drv_t fs_drv;
    lv_fs_drv_init(&fs_drv);

    fs_drv.letter = 'S';
    fs_drv.open_cb = fs_open_cb;
    fs_drv.close_cb = fs_close_cb;
    fs_drv.read_cb = fs_read_cb;
    fs_drv.write_cb = fs_write_cb;
    fs_drv.seek_cb = fs_seek_cb;
    fs_drv.tell_cb = fs_tell_cb;
    fs_drv.dir_open_cb = fs_dir_open_cb;
    fs_drv.dir_read_cb = fs_dir_read_cb;
    fs_drv.dir_close_cb = fs_dir_close_cb;

    lv_fs_drv_register(&fs_drv);
    
    ESP_LOGI(TAG, "Sistema de ficheros montado para LVGL en la unidad 'S:' (apuntando a %s)", BASE_PATH);
}

--- END OF FILE: .\main\hardware_manager.c ---

--- START OF FILE: .\main\hardware_manager.h ---
/* Fecha: 15/08/2025 - 04:10  */
/* Fichero: Z:\DIYTOGETHER\DIYtogether\main\hardware_manager.h */
/* Último cambio: Añadida la declaración de hardware_manager_mount_lvgl_filesystem. */
/* Descripción: Define la interfaz pública del gestor de hardware. Se añade una nueva función para registrar explícitamente el sistema de ficheros de la tarjeta SD con LVGL, permitiendo que la librería acceda a los ficheros de animación. */

#ifndef HARDWARE_MANAGER_H
#define HARDWARE_MANAGER_H

#include "esp_err.h"

/**
 * @brief Inicializa los periféricos de hardware base (display, touch, bsp, etc.) y el port de LVGL.
 *
 * @return ESP_OK si la inicialización fue exitosa.
 */
esp_err_t hardware_manager_init(void);

/**
 * @brief Registra el sistema de ficheros de la tarjeta SD (montada en /sdcard) con LVGL.
 * 
 * Esta función asigna la letra de unidad 'S' al punto de montaje /sdcard,
 * permitiendo que LVGL acceda a los ficheros de animación usando rutas como "S:/DIYMON/..."
 */
void hardware_manager_mount_lvgl_filesystem(void);


#endif // HARDWARE_MANAGER_H

--- END OF FILE: .\main\hardware_manager.h ---

--- START OF FILE: .\main\Kconfig.projbuild ---
# put here your custom config value
menu "Example Configuration"
config ESP_WIFI_SSID
    string "WiFi SSID"
    default "myssid"
    help
	SSID (network name) for the example to connect to.

config ESP_WIFI_PASSWORD
    string "WiFi Password"
    default "mypassword"
    help
	WiFi password (WPA or WPA2) for the example to use.
endmenu

--- END OF FILE: .\main\Kconfig.projbuild ---

--- START OF FILE: .\main\main.c ---
/* Fecha: 18/08/2025 - 08:25  */
/* Fichero: main/main.c */
/* Último cambio: Eliminada la inicialización y conexión automática de WiFi en el arranque. */
/* Descripción: Se ha eliminado toda la lógica de inicialización de WiFi del arranque principal (app_main). Ahora, el dispositivo arranca sin activar la red. La responsabilidad de gestionar el ciclo de vida de WiFi (activar, conectar, desactivar) se delega completamente al módulo 'action_config_mode', que se invoca por interacción del usuario. */

#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "esp_system.h"
#include "esp_lvgl_port.h"
#include "sys/stat.h"
#include <dirent.h>
#include "driver/gpio.h"

#include "bsp_api.h"
#include "hardware_manager.h"
#include "diymon_evolution.h"
#include "core/ui.h"
#include "web_server.h"
#include "screen_manager.h"
#include "ui_asset_loader.h" 
#include "actions.h"
#include "core/state_manager.h"
#include "telemetry/telemetry_task.h"

#include "esp_err.h"
#include "esp_check.h"

static const char *TAG = "DIYMON_MAIN";

// --- Declaraciones de funciones ---
static void run_main_application_mode(void);
static bool verify_sdcard_contents(void);

void app_main(void) {
    // 1. Inicializar la memoria no volátil.
    nvs_flash_init();

    // [CORRECCIÓN] Se elimina la inicialización de WiFi del arranque.
    // La red solo se activará bajo demanda desde el menú de configuración.
    ESP_LOGI(TAG, "Arrancando en modo offline. WiFi se activará bajo demanda.");

    // 2. Pre-reservar los buffers de memoria más grandes para la UI para evitar fragmentación.
    ui_preinit();

    // 3. El sistema ahora arranca directamente en el modo de aplicación principal.
    run_main_application_mode();
    
    // Este bucle no debería alcanzarse, pero es una buena práctica tenerlo.
    while (1) { 
        vTaskDelay(pdMS_TO_TICKS(10000));
    }
}

static bool verify_sdcard_contents(void) {
    const char* dir_path = "/sdcard/diymon";
    DIR* dir = opendir(dir_path);
    if (!dir) {
        ESP_LOGE(TAG, "¡ERROR! No se pudo abrir el directorio '%s'. La funcionalidad de animación estará deshabilitada.", dir_path);
        return false;
    }
    closedir(dir);
    ESP_LOGI(TAG, "Verificación de la tarjeta SD completada. Directorio 'diymon' encontrado.");
    return true;
}

static void run_main_application_mode(void) {
    ESP_LOGI(TAG, "Cargando aplicación principal...");
    
    // 1. Inicializa todo el hardware y LVGL.
    hardware_manager_init();
    
    // 2. Verifica la tarjeta SD.
    bool is_sd_ok = verify_sdcard_contents();

    // 3. Inicializa los sistemas de software (Evolución y Assets).
    diymon_evolution_init();
    ui_assets_init();

    // 4. Construye la UI completa.
    if (lvgl_port_lock(0)) {
        if (is_sd_ok) {
            hardware_manager_mount_lvgl_filesystem();
        }
        
        ui_init(); // Crea todos los elementos.
        state_manager_init(); // Inicia el gestor de inactividad.
        lvgl_port_unlock();
    }
    ESP_LOGI(TAG, "Interfaz de Usuario principal inicializada.");

    // 5. Decide el siguiente paso basado en el estado de la SD.
    if (!is_sd_ok) {
        // Si la SD falla, se invoca la acción de modo configuración.
        ESP_LOGW(TAG, "Fallo en la SD. Entrando automáticamente en modo de configuración WiFi...");
        vTaskDelay(pdMS_TO_TICKS(500));
        execute_diymon_action(ACTION_ID_ACTIVATE_CONFIG_MODE);
    } else {
        // Si todo está bien, inicia la tarea de telemetría en segundo plano.
        telemetry_task_start();
        ESP_LOGI(TAG, "¡Firmware DIYMON en marcha!");
    }
}

--- END OF FILE: .\main\main.c ---

