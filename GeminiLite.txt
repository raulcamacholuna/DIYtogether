--- START OF FILE: .\CMakeLists.txt ---
# Fecha: 17/08/2025 - 04:03 
# Fichero: ./CMakeLists.txt
# √öltimo cambio: Reestructurados y mejorados los comentarios para mayor claridad.
# Descripci√≥n: Fichero ra√≠z de configuraci√≥n de CMake para el proyecto. Define la versi√≥n m√≠nima de CMake,
#              el nombre del proyecto, y rutas adicionales para componentes de terceros. El error 'Permission denied'
#              del sistema de compilaci√≥n (Ninja) no se origina en este fichero, sino en un problema externo
#              como un antivirus o permisos del sistema de ficheros. Se mejora este fichero como acci√≥n proactiva.

# Versi√≥n m√≠nima de CMake requerida por ESP-IDF.
cmake_minimum_required(VERSION 3.16)

# A√±ade el directorio 'components_dependencies' a la ruta de b√∫squeda de componentes.
# Esto permite que el sistema de compilaci√≥n encuentre librer√≠as de terceros (ej. esp_lvgl_port)
# que no forman parte de los componentes est√°ndar ni del propio proyecto.
set(EXTRA_COMPONENT_DIRS components_dependencies)

# Define una macro de preprocesador global para todo el proyecto.
# En este caso, se usa para informar a los componentes que se est√° utilizando LVGL v9.
add_compile_definitions(LVGL_VERSION_MAJOR=9)

# Incluye el script principal de ESP-IDF que gestiona toda la l√≥gica de compilaci√≥n de proyectos.
# Esta l√≠nea es fundamental y debe ir despu√©s de las configuraciones iniciales.
include($ENV{IDF_PATH}/tools/cmake/project.cmake)

# Declara el nombre del proyecto.
project(DIYTOGETHER)

--- END OF FILE: .\CMakeLists.txt ---

--- START OF FILE: .\partitions.csv ---
# Name,   Type, SubType, Offset,  Size, Flags
nvs,      data, nvs,     0x9000,  0x6000,
phy_init, data, phy,     0xf000,  0x1000,
factory,  app,  factory, 0x10000, 6M,
--- END OF FILE: .\partitions.csv ---

--- START OF FILE: .\platformio.ini ---
# Fecha: 15/08/2025 - 03:54 
# Fichero: Z:\DIYTOGETHER\DIYtogether\platformio.ini
# √öltimo cambio: Eliminada la dependencia 'lvgl' de lib_deps para resolver conflictos de redefinici√≥n de macros.
# Descripci√≥n: Este fichero configura el entorno de PlatformIO. Se ha eliminado la dependencia de `lvgl` de la secci√≥n `lib_deps` porque el proyecto ya gestiona LVGL como un componente local de ESP-IDF. Esto evita que PlatformIO descargue una segunda copia de la librer√≠a y resuelve los warnings de macros redefinidas (`CONFIG_LV_...`) durante la compilaci√≥n.

# PlatformIO Project Configuration File
#
# NOTA DE MIGRACI√ìN:
# Este fichero est√° configurado para usar la estructura de directorios de ESP-IDF.
# El c√≥digo fuente principal est√° en la carpeta 'main', y los componentes adicionales
# en la carpeta 'components'.

[platformio]
default_envs = esp32-c6-devkitc-1
src_dir = main

[env:esp32-c6-devkitc-1]
# -- Configuraci√≥n General --
platform = espressif32
board = esp32-c6-devkitc-1
framework = espidf

# -- Opciones de Compilaci√≥n y Subida (extra√≠das de sdkconfig y CMakeLists.txt) --
board_build.flash_mode = dio
board_build.flash_freq = 80m
board_build.partitions = partitions.csv

# Esta l√≠nea es CRUCIAL. Le dice a PlatformIO que use tu 'sdkconfig' existente,
# manteniendo todas tus configuraciones detalladas (tama√±o de stack, etc.).
board_build.sdkconfig_path = sdkconfig

# -- Opciones del Monitor Serie --
monitor_speed = 115200

# -- Dependencias de Librer√≠as y Componentes --
# PlatformIO encuentra autom√°ticamente los componentes locales en la carpeta 'components'.
lib_deps =
    # [CORRECCI√ìN] Se elimina esta l√≠nea. Tu proyecto ya incluye LVGL como un componente de ESP-IDF,
    # y esta dependencia externa causa conflictos de configuraci√≥n.

# -- Banderas de Compilaci√≥n --
# Definiciones personalizadas extra√≠das de tu CMakeLists.txt ra√≠z.
build_flags = -D LVGL_VERSION_MAJOR=9

--- END OF FILE: .\platformio.ini ---

--- START OF FILE: .\README.md ---
/* Fecha: 17/08/2025 - 03:39  */
/* Fichero: .\README.md */
/* √öltimo cambio: Actualizada la nota de compilaci√≥n para reflejar la arquitectura de UI refactorizada y corregido el escapado de caracteres para PowerShell. */
/* Descripci√≥n: Documentaci√≥n principal del proyecto. La nota sobre la estructura del componente 'ui' ahora detalla la nueva organizaci√≥n modular en subdirectorios (assets, core, screens, etc.) para reflejar la reciente refactorizaci√≥n. Se han escapado los caracteres de acento grave (backticks) para evitar errores de parser en PowerShell. */

# DIYTogether - Tu Mascota Virtual DIY

![Ilustraci√≥n de DIYTogether en acci√≥n]([Link a git3.png])

**DIYTogether** no es solo un gadget. Es una aventura de aprendizaje, una puerta a la creatividad y una excusa para construir algo incre√≠ble con las personas que te importan.

## La Historia detr√°s de DIYTogether

Constantemente sue√±o despierto.

Fantaseo con ser *`ese t√≠o guay`* para mis sobrinos, el que les ense√±a a crear, a entender la tecnolog√≠a, a jugar con la electr√≥nica y la dom√≥tica. Quer√≠a construir algo que nos uniera, un juego que les apasionara y despertara su curiosidad por dentro. Una excusa perfecta para aprender divirti√©ndose y pasar tiempo de calidad juntos.

De esa idea nace **DIYTogether**.

Un proyecto que empez√≥ con mis mejores amigos y que ahora abro al mundo, invitando a todo aquel que quiera unirse a crear una tecnolog√≠a con alma.

---

## ¬øQu√© es DIYTogether?

DIYTogether es un proyecto de mascota virtual open-source basada en hardware ESP32. Es un **`Tamagotchi para Hackers`** dise√±ado desde cero para ser:

*   üé® **Personalizable**: Crea y carga tus propios "Skins" (gr√°ficos, animaciones y sonidos) sin necesidad de reprogramar nada. ¬°Haz tu DIYTogether verdaderamente tuyo!
*   üß† **Educativo**: Aprende electr√≥nica, programaci√≥n (C++/ESP-IDF) y conectividad IoT de una forma pr√°ctica y progresiva. Cada paso es una lecci√≥n, y los errores son parte del viaje.
*   üåç **Interactivo**: Utiliza sensores como el aceler√≥metro y la conectividad Bluetooth para interactuar con tu criatura de formas nuevas y creativas.
*   ‚ù§Ô∏è **Abierto y Comunitario**: Todo el proyecto (firmware, hardware, dise√±os 3D) es libre. Queremos que lo copies, lo modifiques, lo mejores y lo compartas.

![Variedad de colores y criaturas DIYTogether]([Link a git2.png])

---

## Caracter√≠sticas Principales

*   **Hardware**: Basado en la placa Waveshare ESP32-C6-Touch-LCD-1.9 o hardware similar.
*   **Firmware**: Escrito en C/C++ con el framework ESP-IDF.
*   **Sistema de Evoluci√≥n Modular**: Las criaturas evolucionan seg√∫n tus cuidados, el entorno e interacciones.
*   **Licencias**:
    *   **C√≥digo**: GPLv3 - ¬°Libre para siempre!
    *   **Dise√±os de la carcasa**: CC BY-NC - ¬°Comp√°rtela, pero no para uso comercial sin permiso!

![Prototipo de DIYTogether con interfaz hologr√°fica]([Link a git1.png])

---

### Estado Actual del Proyecto
> *Nota: Esta secci√≥n se actualizar√° con los avances.*

*   ‚úÖ Prototipo funcional con interacciones b√°sicas (alimentar, entrenar, limpiar).
*   ‚úÖ Sistema de skins din√°micas implementado.
*   üöß Trabajando en la conectividad Bluetooth con la App de soporte (FIYNDEX).
*   üí° Planeando una campa√±a de Kickstarter para ofrecer kits DIY asequibles.

---

## ¬øC√≥mo puedes empezar?

### 1. Requisitos
*   **Hardware**: Waveshare ESP32-C6-Touch-LCD-1.9.
*   **Software**: [Visual Studio Code](https://code.visualstudio.com/) con la extensi√≥n [PlatformIO IDE](https://platformio.org/platformio-ide).

### 2. Compilaci√≥n y Subida del Firmware
Este proyecto est√° configurado para ser compilado y subido f√°cilmente con PlatformIO.

*(Nota: La arquitectura del componente `ui` ha sido completamente refactorizada para seguir principios de dise√±o modular y de responsabilidad √∫nica. La l√≥gica ahora est√° organizada en subdirectorios bien definidos:*
*   ***`assets/`***: *Contiene todos los recursos est√°ticos (im√°genes, fuentes).*
*   ***`core/`***: *Orquesta la UI, gestiona el estado y la telemetr√≠a.*
*   ***`screens/`***: *Define y controla las diferentes pantallas de la aplicaci√≥n.*
*   ***`actions/`***: *Encapsula la l√≥gica de cada acci√≥n del usuario (comer, reiniciar, etc.).*
*   ***`buttons/`***: *M√≥dulos individuales para cada bot√≥n, encapsulando su creaci√≥n y eventos.*
*A pesar de esta estructura interna avanzada, el proceso de compilaci√≥n con PlatformIO sigue siendo el mismo y es el m√©todo recomendado.)*

1.  **Clona el repositorio**:
    `ash
    git clone [URL de tu repositorio]
    cd DIYtogether
    `
2.  **Abre el proyecto en VS Code**:
    *   Abre VS Code.
    *   Ve a File > Open Folder... y selecciona la carpeta DIYtogether que acabas de clonar.
    *   PlatformIO deber√≠a detectar autom√°ticamente el fichero platformio.ini y configurar el entorno.

3.  **Compila y Sube**:
    *   Conecta tu placa ESP32-C6 al ordenador por USB.
    *   En la barra de estado de PlatformIO (generalmente en la parte inferior de VS Code), busca y haz clic en el icono de la flecha (->) que corresponde a **Upload**.
    *   PlatformIO compilar√° el c√≥digo, generar√° los binarios y los subir√° autom√°ticamente a tu placa.

4.  **Monitor Serie**:
    *   Para ver los logs de depuraci√≥n, haz clic en el icono del enchufe (üîå) que corresponde a **Monitor** en la barra de estado de PlatformIO.

*(Aqu√≠ puedes poner un GIF animado de tu prototipo funcionando. ¬°Esto es s√∫per efectivo!)*
![alt text](ruta/a/tu/gif/animado.gif)

---

## ¬°√önete a la Comunidad!

Este proyecto vive gracias a gente como t√∫. Si te gusta la idea, ¬°invol√∫crate!

*   ‚≠ê **Dale una estrella a este repositorio**: ¬°Nos ayuda a ganar visibilidad!
*   üí¨ **√önete a nuestro canal de Discord/Telegram**: El mejor lugar para charlar, pedir ayuda y compartir tus creaciones.
*   üí° **Aporta ideas o reporta bugs**: Abre un `Issue` aqu√≠ en GitHub.
*   üöÄ **Contribuye con c√≥digo o dise√±os**: ¬°Los Pull Requests son bienvenidos! Revisa nuestra [gu√≠a de contribuci√≥n].

Gracias por tu apoyo y por creer en un proyecto hecho con cari√±o y curiosidad.

--- END OF FILE: .\README.md ---

--- START OF FILE: .\sdkconfig ---
#
# Automatically generated file. DO NOT EDIT.
# Espressif IoT Development Framework (ESP-IDF) 5.5.0 Project Configuration
#
CONFIG_SOC_ADC_SUPPORTED=y
CONFIG_SOC_DEDICATED_GPIO_SUPPORTED=y
CONFIG_SOC_UART_SUPPORTED=y
CONFIG_SOC_UHCI_SUPPORTED=y
CONFIG_SOC_GDMA_SUPPORTED=y
CONFIG_SOC_AHB_GDMA_SUPPORTED=y
CONFIG_SOC_GPTIMER_SUPPORTED=y
CONFIG_SOC_PCNT_SUPPORTED=y
CONFIG_SOC_MCPWM_SUPPORTED=y
CONFIG_SOC_TWAI_SUPPORTED=y
CONFIG_SOC_ETM_SUPPORTED=y
CONFIG_SOC_PARLIO_SUPPORTED=y
CONFIG_SOC_BT_SUPPORTED=y
CONFIG_SOC_IEEE802154_SUPPORTED=y
CONFIG_SOC_ASYNC_MEMCPY_SUPPORTED=y
CONFIG_SOC_USB_SERIAL_JTAG_SUPPORTED=y
CONFIG_SOC_TEMP_SENSOR_SUPPORTED=y
CONFIG_SOC_PHY_SUPPORTED=y
CONFIG_SOC_WIFI_SUPPORTED=y
CONFIG_SOC_SUPPORTS_SECURE_DL_MODE=y
CONFIG_SOC_ULP_SUPPORTED=y
CONFIG_SOC_LP_CORE_SUPPORTED=y
CONFIG_SOC_EFUSE_KEY_PURPOSE_FIELD=y
CONFIG_SOC_EFUSE_SUPPORTED=y
CONFIG_SOC_RTC_FAST_MEM_SUPPORTED=y
CONFIG_SOC_RTC_MEM_SUPPORTED=y
CONFIG_SOC_I2S_SUPPORTED=y
CONFIG_SOC_RMT_SUPPORTED=y
CONFIG_SOC_SDM_SUPPORTED=y
CONFIG_SOC_GPSPI_SUPPORTED=y
CONFIG_SOC_LEDC_SUPPORTED=y
CONFIG_SOC_I2C_SUPPORTED=y
CONFIG_SOC_SYSTIMER_SUPPORTED=y
CONFIG_SOC_SUPPORT_COEXISTENCE=y
CONFIG_SOC_AES_SUPPORTED=y
CONFIG_SOC_MPI_SUPPORTED=y
CONFIG_SOC_SHA_SUPPORTED=y
CONFIG_SOC_HMAC_SUPPORTED=y
CONFIG_SOC_DIG_SIGN_SUPPORTED=y
CONFIG_SOC_ECC_SUPPORTED=y
CONFIG_SOC_FLASH_ENC_SUPPORTED=y
CONFIG_SOC_SECURE_BOOT_SUPPORTED=y
CONFIG_SOC_SDIO_SLAVE_SUPPORTED=y
CONFIG_SOC_BOD_SUPPORTED=y
CONFIG_SOC_APM_SUPPORTED=y
CONFIG_SOC_PMU_SUPPORTED=y
CONFIG_SOC_PAU_SUPPORTED=y
CONFIG_SOC_LP_TIMER_SUPPORTED=y
CONFIG_SOC_LP_AON_SUPPORTED=y
CONFIG_SOC_LP_PERIPHERALS_SUPPORTED=y
CONFIG_SOC_LP_I2C_SUPPORTED=y
CONFIG_SOC_ULP_LP_UART_SUPPORTED=y
CONFIG_SOC_CLK_TREE_SUPPORTED=y
CONFIG_SOC_ASSIST_DEBUG_SUPPORTED=y
CONFIG_SOC_WDT_SUPPORTED=y
CONFIG_SOC_SPI_FLASH_SUPPORTED=y
CONFIG_SOC_RNG_SUPPORTED=y
CONFIG_SOC_LIGHT_SLEEP_SUPPORTED=y
CONFIG_SOC_DEEP_SLEEP_SUPPORTED=y
CONFIG_SOC_MODEM_CLOCK_SUPPORTED=y
CONFIG_SOC_PM_SUPPORTED=y
CONFIG_SOC_XTAL_SUPPORT_40M=y
CONFIG_SOC_XTAL_CLOCK_PATH_DEPENDS_ON_TOP_DOMAIN=y
CONFIG_SOC_AES_SUPPORT_DMA=y
CONFIG_SOC_AES_GDMA=y
CONFIG_SOC_AES_SUPPORT_AES_128=y
CONFIG_SOC_AES_SUPPORT_AES_256=y
CONFIG_SOC_ADC_DIG_CTRL_SUPPORTED=y
CONFIG_SOC_ADC_DIG_IIR_FILTER_SUPPORTED=y
CONFIG_SOC_ADC_MONITOR_SUPPORTED=y
CONFIG_SOC_ADC_DMA_SUPPORTED=y
CONFIG_SOC_ADC_PERIPH_NUM=1
CONFIG_SOC_ADC_MAX_CHANNEL_NUM=7
CONFIG_SOC_ADC_ATTEN_NUM=4
CONFIG_SOC_ADC_DIGI_CONTROLLER_NUM=1
CONFIG_SOC_ADC_PATT_LEN_MAX=8
CONFIG_SOC_ADC_DIGI_MAX_BITWIDTH=12
CONFIG_SOC_ADC_DIGI_MIN_BITWIDTH=12
CONFIG_SOC_ADC_DIGI_IIR_FILTER_NUM=2
CONFIG_SOC_ADC_DIGI_MONITOR_NUM=2
CONFIG_SOC_ADC_DIGI_RESULT_BYTES=4
CONFIG_SOC_ADC_DIGI_DATA_BYTES_PER_CONV=4
CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_HIGH=83333
CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_LOW=611
CONFIG_SOC_ADC_RTC_MIN_BITWIDTH=12
CONFIG_SOC_ADC_RTC_MAX_BITWIDTH=12
CONFIG_SOC_ADC_CALIBRATION_V1_SUPPORTED=y
CONFIG_SOC_ADC_SELF_HW_CALI_SUPPORTED=y
CONFIG_SOC_ADC_CALIB_CHAN_COMPENS_SUPPORTED=y
CONFIG_SOC_ADC_TEMPERATURE_SHARE_INTR=y
CONFIG_SOC_ADC_SHARED_POWER=y
CONFIG_SOC_BROWNOUT_RESET_SUPPORTED=y
CONFIG_SOC_SHARED_IDCACHE_SUPPORTED=y
CONFIG_SOC_CACHE_FREEZE_SUPPORTED=y
CONFIG_SOC_CPU_CORES_NUM=1
CONFIG_SOC_CPU_INTR_NUM=32
CONFIG_SOC_CPU_HAS_FLEXIBLE_INTC=y
CONFIG_SOC_INT_PLIC_SUPPORTED=y
CONFIG_SOC_CPU_HAS_CSR_PC=y
CONFIG_SOC_CPU_BREAKPOINTS_NUM=4
CONFIG_SOC_CPU_WATCHPOINTS_NUM=4
CONFIG_SOC_CPU_WATCHPOINT_MAX_REGION_SIZE=0x80000000
CONFIG_SOC_CPU_HAS_PMA=y
CONFIG_SOC_CPU_IDRAM_SPLIT_USING_PMP=y
CONFIG_SOC_CPU_PMP_REGION_GRANULARITY=4
CONFIG_SOC_DS_SIGNATURE_MAX_BIT_LEN=3072
CONFIG_SOC_DS_KEY_PARAM_MD_IV_LENGTH=16
CONFIG_SOC_DS_KEY_CHECK_MAX_WAIT_US=1100
CONFIG_SOC_AHB_GDMA_VERSION=1
CONFIG_SOC_GDMA_NUM_GROUPS_MAX=1
CONFIG_SOC_GDMA_PAIRS_PER_GROUP_MAX=3
CONFIG_SOC_GDMA_SUPPORT_ETM=y
CONFIG_SOC_GDMA_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_ETM_GROUPS=1
CONFIG_SOC_ETM_CHANNELS_PER_GROUP=50
CONFIG_SOC_ETM_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_GPIO_PORT=1
CONFIG_SOC_GPIO_PIN_COUNT=31
CONFIG_SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER=y
CONFIG_SOC_GPIO_FLEX_GLITCH_FILTER_NUM=8
CONFIG_SOC_GPIO_SUPPORT_ETM=y
CONFIG_SOC_GPIO_SUPPORT_RTC_INDEPENDENT=y
CONFIG_SOC_GPIO_SUPPORT_DEEPSLEEP_WAKEUP=y
CONFIG_SOC_LP_IO_CLOCK_IS_INDEPENDENT=y
CONFIG_SOC_GPIO_IN_RANGE_MAX=30
CONFIG_SOC_GPIO_OUT_RANGE_MAX=30
CONFIG_SOC_GPIO_DEEP_SLEEP_WAKE_VALID_GPIO_MASK=0
CONFIG_SOC_GPIO_DEEP_SLEEP_WAKE_SUPPORTED_PIN_CNT=8
CONFIG_SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK=0x000000007FFFFF00
CONFIG_SOC_GPIO_SUPPORT_FORCE_HOLD=y
CONFIG_SOC_GPIO_SUPPORT_HOLD_IO_IN_DSLP=y
CONFIG_SOC_GPIO_SUPPORT_HOLD_SINGLE_IO_IN_DSLP=y
CONFIG_SOC_GPIO_CLOCKOUT_BY_GPIO_MATRIX=y
CONFIG_SOC_CLOCKOUT_HAS_SOURCE_GATE=y
CONFIG_SOC_GPIO_CLOCKOUT_CHANNEL_NUM=3
CONFIG_SOC_RTCIO_PIN_COUNT=8
CONFIG_SOC_RTCIO_INPUT_OUTPUT_SUPPORTED=y
CONFIG_SOC_RTCIO_HOLD_SUPPORTED=y
CONFIG_SOC_RTCIO_WAKE_SUPPORTED=y
CONFIG_SOC_RTCIO_EDGE_WAKE_SUPPORTED=y
CONFIG_SOC_DEDIC_GPIO_OUT_CHANNELS_NUM=8
CONFIG_SOC_DEDIC_GPIO_IN_CHANNELS_NUM=8
CONFIG_SOC_DEDIC_PERIPH_ALWAYS_ENABLE=y
CONFIG_SOC_I2C_NUM=2
CONFIG_SOC_HP_I2C_NUM=1
CONFIG_SOC_I2C_FIFO_LEN=32
CONFIG_SOC_I2C_CMD_REG_NUM=8
CONFIG_SOC_I2C_SUPPORT_SLAVE=y
CONFIG_SOC_I2C_SUPPORT_HW_FSM_RST=y
CONFIG_SOC_I2C_SUPPORT_HW_CLR_BUS=y
CONFIG_SOC_I2C_SUPPORT_XTAL=y
CONFIG_SOC_I2C_SUPPORT_RTC=y
CONFIG_SOC_I2C_SUPPORT_10BIT_ADDR=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_BROADCAST=y
CONFIG_SOC_I2C_SLAVE_CAN_GET_STRETCH_CAUSE=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_I2CRAM_ACCESS=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_SLAVE_UNMATCH=y
CONFIG_SOC_I2C_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_LP_I2C_NUM=1
CONFIG_SOC_LP_I2C_FIFO_LEN=16
CONFIG_SOC_I2S_NUM=1
CONFIG_SOC_I2S_HW_VERSION_2=y
CONFIG_SOC_I2S_SUPPORTS_ETM=y
CONFIG_SOC_I2S_SUPPORTS_XTAL=y
CONFIG_SOC_I2S_SUPPORTS_PLL_F160M=y
CONFIG_SOC_I2S_SUPPORTS_PCM=y
CONFIG_SOC_I2S_SUPPORTS_PDM=y
CONFIG_SOC_I2S_SUPPORTS_PDM_TX=y
CONFIG_SOC_I2S_SUPPORTS_PCM2PDM=y
CONFIG_SOC_I2S_SUPPORTS_PDM_RX=y
CONFIG_SOC_I2S_PDM_MAX_TX_LINES=2
CONFIG_SOC_I2S_PDM_MAX_RX_LINES=1
CONFIG_SOC_I2S_SUPPORTS_TDM=y
CONFIG_SOC_I2S_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_LEDC_SUPPORT_PLL_DIV_CLOCK=y
CONFIG_SOC_LEDC_SUPPORT_XTAL_CLOCK=y
CONFIG_SOC_LEDC_TIMER_NUM=4
CONFIG_SOC_LEDC_CHANNEL_NUM=6
CONFIG_SOC_LEDC_TIMER_BIT_WIDTH=20
CONFIG_SOC_LEDC_SUPPORT_FADE_STOP=y
CONFIG_SOC_LEDC_GAMMA_CURVE_FADE_SUPPORTED=y
CONFIG_SOC_LEDC_GAMMA_CURVE_FADE_RANGE_MAX=16
CONFIG_SOC_LEDC_FADE_PARAMS_BIT_WIDTH=10
CONFIG_SOC_LEDC_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MMU_PAGE_SIZE_CONFIGURABLE=y
CONFIG_SOC_MMU_PAGE_SIZE_8KB_SUPPORTED=y
CONFIG_SOC_MMU_PERIPH_NUM=1
CONFIG_SOC_MMU_LINEAR_ADDRESS_REGION_NUM=1
CONFIG_SOC_MMU_DI_VADDR_SHARED=y
CONFIG_SOC_MPU_MIN_REGION_SIZE=0x20000000
CONFIG_SOC_MPU_REGIONS_MAX_NUM=8
CONFIG_SOC_PCNT_GROUPS=1
CONFIG_SOC_PCNT_UNITS_PER_GROUP=4
CONFIG_SOC_PCNT_CHANNELS_PER_UNIT=2
CONFIG_SOC_PCNT_THRES_POINT_PER_UNIT=2
CONFIG_SOC_PCNT_SUPPORT_RUNTIME_THRES_UPDATE=y
CONFIG_SOC_PCNT_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_RMT_GROUPS=1
CONFIG_SOC_RMT_TX_CANDIDATES_PER_GROUP=2
CONFIG_SOC_RMT_RX_CANDIDATES_PER_GROUP=2
CONFIG_SOC_RMT_CHANNELS_PER_GROUP=4
CONFIG_SOC_RMT_MEM_WORDS_PER_CHANNEL=48
CONFIG_SOC_RMT_SUPPORT_RX_PINGPONG=y
CONFIG_SOC_RMT_SUPPORT_RX_DEMODULATION=y
CONFIG_SOC_RMT_SUPPORT_TX_ASYNC_STOP=y
CONFIG_SOC_RMT_SUPPORT_TX_LOOP_COUNT=y
CONFIG_SOC_RMT_SUPPORT_TX_LOOP_AUTO_STOP=y
CONFIG_SOC_RMT_SUPPORT_TX_SYNCHRO=y
CONFIG_SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY=y
CONFIG_SOC_RMT_SUPPORT_XTAL=y
CONFIG_SOC_RMT_SUPPORT_RC_FAST=y
CONFIG_SOC_RMT_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MCPWM_GROUPS=1
CONFIG_SOC_MCPWM_TIMERS_PER_GROUP=3
CONFIG_SOC_MCPWM_OPERATORS_PER_GROUP=3
CONFIG_SOC_MCPWM_COMPARATORS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_GENERATORS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_TRIGGERS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_GPIO_FAULTS_PER_GROUP=3
CONFIG_SOC_MCPWM_CAPTURE_TIMERS_PER_GROUP=y
CONFIG_SOC_MCPWM_CAPTURE_CHANNELS_PER_TIMER=3
CONFIG_SOC_MCPWM_GPIO_SYNCHROS_PER_GROUP=3
CONFIG_SOC_MCPWM_SWSYNC_CAN_PROPAGATE=y
CONFIG_SOC_MCPWM_SUPPORT_ETM=y
CONFIG_SOC_MCPWM_CAPTURE_CLK_FROM_GROUP=y
CONFIG_SOC_MCPWM_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_PARLIO_GROUPS=1
CONFIG_SOC_PARLIO_TX_UNITS_PER_GROUP=1
CONFIG_SOC_PARLIO_RX_UNITS_PER_GROUP=1
CONFIG_SOC_PARLIO_TX_UNIT_MAX_DATA_WIDTH=16
CONFIG_SOC_PARLIO_RX_UNIT_MAX_DATA_WIDTH=16
CONFIG_SOC_PARLIO_TX_RX_SHARE_INTERRUPT=y
CONFIG_SOC_PARLIO_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MPI_MEM_BLOCKS_NUM=4
CONFIG_SOC_MPI_OPERATIONS_NUM=3
CONFIG_SOC_RSA_MAX_BIT_LEN=3072
CONFIG_SOC_SHA_DMA_MAX_BUFFER_SIZE=3968
CONFIG_SOC_SHA_SUPPORT_DMA=y
CONFIG_SOC_SHA_SUPPORT_RESUME=y
CONFIG_SOC_SHA_GDMA=y
CONFIG_SOC_SHA_SUPPORT_SHA1=y
CONFIG_SOC_SHA_SUPPORT_SHA224=y
CONFIG_SOC_SHA_SUPPORT_SHA256=y
CONFIG_SOC_SDM_GROUPS=1
CONFIG_SOC_SDM_CHANNELS_PER_GROUP=4
CONFIG_SOC_SDM_CLK_SUPPORT_PLL_F80M=y
CONFIG_SOC_SDM_CLK_SUPPORT_XTAL=y
CONFIG_SOC_SPI_PERIPH_NUM=2
CONFIG_SOC_SPI_MAX_CS_NUM=6
CONFIG_SOC_SPI_MAXIMUM_BUFFER_SIZE=64
CONFIG_SOC_SPI_SUPPORT_DDRCLK=y
CONFIG_SOC_SPI_SLAVE_SUPPORT_SEG_TRANS=y
CONFIG_SOC_SPI_SUPPORT_CD_SIG=y
CONFIG_SOC_SPI_SUPPORT_CONTINUOUS_TRANS=y
CONFIG_SOC_SPI_SUPPORT_SLAVE_HD_VER2=y
CONFIG_SOC_SPI_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_SPI_SUPPORT_CLK_XTAL=y
CONFIG_SOC_SPI_SUPPORT_CLK_PLL_F80M=y
CONFIG_SOC_SPI_SUPPORT_CLK_RC_FAST=y
CONFIG_SOC_SPI_SCT_SUPPORTED=y
CONFIG_SOC_SPI_SCT_REG_NUM=14
CONFIG_SOC_SPI_SCT_BUFFER_NUM_MAX=y
CONFIG_SOC_SPI_SCT_CONF_BITLEN_MAX=0x3FFFA
CONFIG_SOC_MEMSPI_IS_INDEPENDENT=y
CONFIG_SOC_SPI_MAX_PRE_DIVIDER=16
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE=y
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND=y
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_RESUME=y
CONFIG_SOC_SPI_MEM_SUPPORT_IDLE_INTR=y
CONFIG_SOC_SPI_MEM_SUPPORT_SW_SUSPEND=y
CONFIG_SOC_SPI_MEM_SUPPORT_CHECK_SUS=y
CONFIG_SOC_SPI_MEM_SUPPORT_WRAP=y
CONFIG_SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED=y
CONFIG_SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED=y
CONFIG_SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED=y
CONFIG_SOC_SYSTIMER_COUNTER_NUM=2
CONFIG_SOC_SYSTIMER_ALARM_NUM=3
CONFIG_SOC_SYSTIMER_BIT_WIDTH_LO=32
CONFIG_SOC_SYSTIMER_BIT_WIDTH_HI=20
CONFIG_SOC_SYSTIMER_FIXED_DIVIDER=y
CONFIG_SOC_SYSTIMER_SUPPORT_RC_FAST=y
CONFIG_SOC_SYSTIMER_INT_LEVEL=y
CONFIG_SOC_SYSTIMER_ALARM_MISS_COMPENSATE=y
CONFIG_SOC_SYSTIMER_SUPPORT_ETM=y
CONFIG_SOC_LP_TIMER_BIT_WIDTH_LO=32
CONFIG_SOC_LP_TIMER_BIT_WIDTH_HI=16
CONFIG_SOC_TIMER_GROUPS=2
CONFIG_SOC_TIMER_GROUP_TIMERS_PER_GROUP=1
CONFIG_SOC_TIMER_GROUP_COUNTER_BIT_WIDTH=54
CONFIG_SOC_TIMER_GROUP_SUPPORT_XTAL=y
CONFIG_SOC_TIMER_GROUP_SUPPORT_RC_FAST=y
CONFIG_SOC_TIMER_GROUP_TOTAL_TIMERS=2
CONFIG_SOC_TIMER_SUPPORT_ETM=y
CONFIG_SOC_TIMER_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MWDT_SUPPORT_XTAL=y
CONFIG_SOC_MWDT_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_TWAI_CONTROLLER_NUM=2
CONFIG_SOC_TWAI_MASK_FILTER_NUM=1
CONFIG_SOC_TWAI_CLK_SUPPORT_XTAL=y
CONFIG_SOC_TWAI_BRP_MIN=2
CONFIG_SOC_TWAI_BRP_MAX=32768
CONFIG_SOC_TWAI_SUPPORTS_RX_STATUS=y
CONFIG_SOC_TWAI_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_EFUSE_DIS_DOWNLOAD_ICACHE=y
CONFIG_SOC_EFUSE_DIS_PAD_JTAG=y
CONFIG_SOC_EFUSE_DIS_USB_JTAG=y
CONFIG_SOC_EFUSE_DIS_DIRECT_BOOT=y
CONFIG_SOC_EFUSE_SOFT_DIS_JTAG=y
CONFIG_SOC_EFUSE_DIS_ICACHE=y
CONFIG_SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK=y
CONFIG_SOC_SECURE_BOOT_V2_RSA=y
CONFIG_SOC_SECURE_BOOT_V2_ECC=y
CONFIG_SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS=3
CONFIG_SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS=y
CONFIG_SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY=y
CONFIG_SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX=64
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES=y
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_128=y
CONFIG_SOC_APM_CTRL_FILTER_SUPPORTED=y
CONFIG_SOC_APM_LP_APM0_SUPPORTED=y
CONFIG_SOC_CRYPTO_DPA_PROTECTION_SUPPORTED=y
CONFIG_SOC_UART_NUM=3
CONFIG_SOC_UART_HP_NUM=2
CONFIG_SOC_UART_LP_NUM=1
CONFIG_SOC_UART_FIFO_LEN=128
CONFIG_SOC_LP_UART_FIFO_LEN=16
CONFIG_SOC_UART_BITRATE_MAX=5000000
CONFIG_SOC_UART_SUPPORT_PLL_F80M_CLK=y
CONFIG_SOC_UART_SUPPORT_RTC_CLK=y
CONFIG_SOC_UART_SUPPORT_XTAL_CLK=y
CONFIG_SOC_UART_SUPPORT_WAKEUP_INT=y
CONFIG_SOC_UART_HAS_LP_UART=y
CONFIG_SOC_UART_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_UART_SUPPORT_FSM_TX_WAIT_SEND=y
CONFIG_SOC_UART_WAKEUP_CHARS_SEQ_MAX_LEN=5
CONFIG_SOC_UART_WAKEUP_SUPPORT_ACTIVE_THRESH_MODE=y
CONFIG_SOC_UART_WAKEUP_SUPPORT_FIFO_THRESH_MODE=y
CONFIG_SOC_UART_WAKEUP_SUPPORT_START_BIT_MODE=y
CONFIG_SOC_UART_WAKEUP_SUPPORT_CHAR_SEQ_MODE=y
CONFIG_SOC_UHCI_NUM=1
CONFIG_SOC_COEX_HW_PTI=y
CONFIG_SOC_EXTERNAL_COEX_ADVANCE=y
CONFIG_SOC_PHY_DIG_REGS_MEM_SIZE=21
CONFIG_SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH=12
CONFIG_SOC_RTC_MEM_SUPPORT_SPEED_MODE_SWITCH=y
CONFIG_SOC_PM_SUPPORT_WIFI_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_BEACON_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_BT_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP_MODE_PER_PIN=y
CONFIG_SOC_PM_SUPPORT_CPU_PD=y
CONFIG_SOC_PM_SUPPORT_MODEM_PD=y
CONFIG_SOC_PM_SUPPORT_XTAL32K_PD=y
CONFIG_SOC_PM_SUPPORT_RC32K_PD=y
CONFIG_SOC_PM_SUPPORT_RC_FAST_PD=y
CONFIG_SOC_PM_SUPPORT_VDDSDIO_PD=y
CONFIG_SOC_PM_SUPPORT_TOP_PD=y
CONFIG_SOC_PM_SUPPORT_HP_AON_PD=y
CONFIG_SOC_PM_SUPPORT_MAC_BB_PD=y
CONFIG_SOC_PM_SUPPORT_RTC_PERIPH_PD=y
CONFIG_SOC_PM_SUPPORT_PMU_MODEM_STATE=y
CONFIG_SOC_PM_SUPPORT_PMU_CLK_ICG=y
CONFIG_SOC_PM_SUPPORT_DEEPSLEEP_CHECK_STUB_ONLY=y
CONFIG_SOC_PM_CPU_RETENTION_BY_SW=y
CONFIG_SOC_PM_MODEM_RETENTION_BY_REGDMA=y
CONFIG_SOC_PM_RETENTION_HAS_CLOCK_BUG=y
CONFIG_SOC_EXT_MEM_CACHE_TAG_IN_CPU_DOMAIN=y
CONFIG_SOC_PM_PAU_LINK_NUM=4
CONFIG_SOC_PM_PAU_REGDMA_LINK_MULTI_ADDR=y
CONFIG_SOC_PM_PAU_REGDMA_LINK_WIFIMAC=y
CONFIG_SOC_PM_PAU_REGDMA_UPDATE_CACHE_BEFORE_WAIT_COMPARE=y
CONFIG_SOC_PM_PMU_MIN_SLP_SLOW_CLK_CYCLE_FIXED=y
CONFIG_SOC_PM_RETENTION_MODULE_NUM=32
CONFIG_SOC_CLK_RC_FAST_SUPPORT_CALIBRATION=y
CONFIG_SOC_MODEM_CLOCK_IS_INDEPENDENT=y
CONFIG_SOC_CLK_XTAL32K_SUPPORTED=y
CONFIG_SOC_CLK_OSC_SLOW_SUPPORTED=y
CONFIG_SOC_CLK_RC32K_SUPPORTED=y
CONFIG_SOC_CLK_LP_FAST_SUPPORT_XTAL_D2=y
CONFIG_SOC_RCC_IS_INDEPENDENT=y
CONFIG_SOC_CLK_ANA_I2C_MST_HAS_ROOT_GATE=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_XTAL=y
CONFIG_SOC_TEMPERATURE_SENSOR_INTR_SUPPORT=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_ETM=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_TEMPERATURE_SENSOR_UNDER_PD_TOP_DOMAIN=y
CONFIG_SOC_RNG_CLOCK_IS_INDEPENDENT=y
CONFIG_SOC_WIFI_HW_TSF=y
CONFIG_SOC_WIFI_FTM_SUPPORT=y
CONFIG_SOC_WIFI_GCMP_SUPPORT=y
CONFIG_SOC_WIFI_WAPI_SUPPORT=y
CONFIG_SOC_WIFI_CSI_SUPPORT=y
CONFIG_SOC_WIFI_MESH_SUPPORT=y
CONFIG_SOC_WIFI_HE_SUPPORT=y
CONFIG_SOC_WIFI_MAC_VERSION_NUM=2
CONFIG_SOC_BLE_SUPPORTED=y
CONFIG_SOC_BLE_MESH_SUPPORTED=y
CONFIG_SOC_ESP_NIMBLE_CONTROLLER=y
CONFIG_SOC_BLE_50_SUPPORTED=y
CONFIG_SOC_BLE_DEVICE_PRIVACY_SUPPORTED=y
CONFIG_SOC_BLE_POWER_CONTROL_SUPPORTED=y
CONFIG_SOC_BLE_PERIODIC_ADV_ENH_SUPPORTED=y
CONFIG_SOC_BLUFI_SUPPORTED=y
CONFIG_SOC_BLE_MULTI_CONN_OPTIMIZATION=y
CONFIG_SOC_BLE_USE_WIFI_PWR_CLK_WORKAROUND=y
CONFIG_SOC_PHY_COMBO_MODULE=y
CONFIG_SOC_CAPS_NO_RESET_BY_ANA_BOD=y
CONFIG_SOC_LP_CORE_SINGLE_INTERRUPT_VECTOR=y
CONFIG_SOC_LP_CORE_SUPPORT_ETM=y
CONFIG_SOC_DEBUG_HAVE_OCD_STUB_BINS=y
CONFIG_IDF_CMAKE=y
CONFIG_IDF_TOOLCHAIN="gcc"
CONFIG_IDF_TOOLCHAIN_GCC=y
CONFIG_IDF_TARGET_ARCH_RISCV=y
CONFIG_IDF_TARGET_ARCH="riscv"
CONFIG_IDF_TARGET="esp32c6"
CONFIG_IDF_INIT_VERSION="5.5.0"
CONFIG_IDF_TARGET_ESP32C6=y
CONFIG_IDF_FIRMWARE_CHIP_ID=0x000D

#
# Build type
#
CONFIG_APP_BUILD_TYPE_APP_2NDBOOT=y
# CONFIG_APP_BUILD_TYPE_RAM is not set
CONFIG_APP_BUILD_GENERATE_BINARIES=y
CONFIG_APP_BUILD_BOOTLOADER=y
CONFIG_APP_BUILD_USE_FLASH_SECTIONS=y
# CONFIG_APP_REPRODUCIBLE_BUILD is not set
# CONFIG_APP_NO_BLOBS is not set
# end of Build type

#
# Bootloader config
#

#
# Bootloader manager
#
CONFIG_BOOTLOADER_COMPILE_TIME_DATE=y
CONFIG_BOOTLOADER_PROJECT_VER=1
# end of Bootloader manager

#
# Application Rollback
#
# CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE is not set
# end of Application Rollback

#
# Bootloader Rollback
#
# end of Bootloader Rollback

CONFIG_BOOTLOADER_OFFSET_IN_FLASH=0x0
CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE=y
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_DEBUG is not set
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_PERF is not set

#
# Log
#
CONFIG_BOOTLOADER_LOG_VERSION_1=y
CONFIG_BOOTLOADER_LOG_VERSION=1
# CONFIG_BOOTLOADER_LOG_LEVEL_NONE is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_ERROR is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_WARN is not set
CONFIG_BOOTLOADER_LOG_LEVEL_INFO=y
# CONFIG_BOOTLOADER_LOG_LEVEL_DEBUG is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_VERBOSE is not set
CONFIG_BOOTLOADER_LOG_LEVEL=3

#
# Format
#
# CONFIG_BOOTLOADER_LOG_COLORS is not set
CONFIG_BOOTLOADER_LOG_TIMESTAMP_SOURCE_CPU_TICKS=y
# end of Format

#
# Settings
#
CONFIG_BOOTLOADER_LOG_MODE_TEXT_EN=y
CONFIG_BOOTLOADER_LOG_MODE_TEXT=y
# end of Settings
# end of Log

#
# Serial Flash Configurations
#
# CONFIG_BOOTLOADER_FLASH_DC_AWARE is not set
CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT=y
# end of Serial Flash Configurations

# CONFIG_BOOTLOADER_FACTORY_RESET is not set
# CONFIG_BOOTLOADER_APP_TEST is not set
CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE=y
CONFIG_BOOTLOADER_WDT_ENABLE=y
# CONFIG_BOOTLOADER_WDT_DISABLE_IN_USER_CODE is not set
CONFIG_BOOTLOADER_WDT_TIME_MS=9000
# CONFIG_BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP is not set
# CONFIG_BOOTLOADER_SKIP_VALIDATE_ON_POWER_ON is not set
# CONFIG_BOOTLOADER_SKIP_VALIDATE_ALWAYS is not set
CONFIG_BOOTLOADER_RESERVE_RTC_SIZE=0
# CONFIG_BOOTLOADER_CUSTOM_RESERVE_RTC is not set
# end of Bootloader config

#
# Security features
#
CONFIG_SECURE_BOOT_V2_RSA_SUPPORTED=y
CONFIG_SECURE_BOOT_V2_ECC_SUPPORTED=y
CONFIG_SECURE_BOOT_V2_PREFERRED=y
# CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT is not set
# CONFIG_SECURE_BOOT is not set
# CONFIG_SECURE_FLASH_ENC_ENABLED is not set
CONFIG_SECURE_ROM_DL_MODE_ENABLED=y
# end of Security features

#
# Application manager
#
CONFIG_APP_COMPILE_TIME_DATE=y
# CONFIG_APP_EXCLUDE_PROJECT_VER_VAR is not set
# CONFIG_APP_EXCLUDE_PROJECT_NAME_VAR is not set
# CONFIG_APP_PROJECT_VER_FROM_CONFIG is not set
CONFIG_APP_RETRIEVE_LEN_ELF_SHA=9
# end of Application manager

CONFIG_ESP_ROM_HAS_CRC_LE=y
CONFIG_ESP_ROM_HAS_CRC_BE=y
CONFIG_ESP_ROM_HAS_JPEG_DECODE=y
CONFIG_ESP_ROM_UART_CLK_IS_XTAL=y
CONFIG_ESP_ROM_USB_SERIAL_DEVICE_NUM=3
CONFIG_ESP_ROM_HAS_RETARGETABLE_LOCKING=y
CONFIG_ESP_ROM_GET_CLK_FREQ=y
CONFIG_ESP_ROM_HAS_RVFPLIB=y
CONFIG_ESP_ROM_HAS_HAL_WDT=y
CONFIG_ESP_ROM_HAS_HAL_SYSTIMER=y
CONFIG_ESP_ROM_HAS_HEAP_TLSF=y
CONFIG_ESP_ROM_TLSF_CHECK_PATCH=y
CONFIG_ESP_ROM_MULTI_HEAP_WALK_PATCH=y
CONFIG_ESP_ROM_HAS_LAYOUT_TABLE=y
CONFIG_ESP_ROM_HAS_SPI_FLASH=y
CONFIG_ESP_ROM_HAS_SPI_FLASH_MMAP=y
CONFIG_ESP_ROM_HAS_REGI2C_BUG=y
CONFIG_ESP_ROM_HAS_NEWLIB=y
CONFIG_ESP_ROM_HAS_NEWLIB_NORMAL_FORMAT=y
CONFIG_ESP_ROM_REV0_HAS_NO_ECDSA_INTERFACE=y
CONFIG_ESP_ROM_WDT_INIT_PATCH=y
CONFIG_ESP_ROM_NEEDS_SET_CACHE_MMU_SIZE=y
CONFIG_ESP_ROM_RAM_APP_NEEDS_MMU_INIT=y
CONFIG_ESP_ROM_HAS_SW_FLOAT=y
CONFIG_ESP_ROM_USB_OTG_NUM=-1
CONFIG_ESP_ROM_HAS_VERSION=y
CONFIG_ESP_ROM_SUPPORT_DEEP_SLEEP_WAKEUP_STUB=y
CONFIG_ESP_ROM_HAS_OUTPUT_PUTC_FUNC=y
CONFIG_ESP_ROM_NO_USB_SERIAL_OUTPUT_API=y
CONFIG_ESP_ROM_HAS_SUBOPTIMAL_NEWLIB_ON_MISALIGNED_MEMORY=y

#
# Boot ROM Behavior
#
CONFIG_BOOT_ROM_LOG_ALWAYS_ON=y
# CONFIG_BOOT_ROM_LOG_ALWAYS_OFF is not set
# CONFIG_BOOT_ROM_LOG_ON_GPIO_HIGH is not set
# CONFIG_BOOT_ROM_LOG_ON_GPIO_LOW is not set
# end of Boot ROM Behavior

#
# ESP-TEE (Trusted Execution Environment)
#
# CONFIG_SECURE_ENABLE_TEE is not set
CONFIG_SECURE_TEE_LOG_LEVEL=0
# end of ESP-TEE (Trusted Execution Environment)

#
# Serial flasher config
#
# CONFIG_ESPTOOLPY_NO_STUB is not set
# CONFIG_ESPTOOLPY_FLASHMODE_QIO is not set
# CONFIG_ESPTOOLPY_FLASHMODE_QOUT is not set
CONFIG_ESPTOOLPY_FLASHMODE_DIO=y
# CONFIG_ESPTOOLPY_FLASHMODE_DOUT is not set
CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_STR=y
CONFIG_ESPTOOLPY_FLASHMODE="dio"
CONFIG_ESPTOOLPY_FLASHFREQ_80M=y
# CONFIG_ESPTOOLPY_FLASHFREQ_40M is not set
# CONFIG_ESPTOOLPY_FLASHFREQ_20M is not set
CONFIG_ESPTOOLPY_FLASHFREQ="80m"
# CONFIG_ESPTOOLPY_FLASHSIZE_1MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_2MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_4MB is not set
CONFIG_ESPTOOLPY_FLASHSIZE_8MB=y
# CONFIG_ESPTOOLPY_FLASHSIZE_16MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_32MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_64MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_128MB is not set
CONFIG_ESPTOOLPY_FLASHSIZE="8MB"
# CONFIG_ESPTOOLPY_HEADER_FLASHSIZE_UPDATE is not set
CONFIG_ESPTOOLPY_BEFORE_RESET=y
# CONFIG_ESPTOOLPY_BEFORE_NORESET is not set
CONFIG_ESPTOOLPY_BEFORE="default_reset"
CONFIG_ESPTOOLPY_AFTER_RESET=y
# CONFIG_ESPTOOLPY_AFTER_NORESET is not set
CONFIG_ESPTOOLPY_AFTER="hard_reset"
CONFIG_ESPTOOLPY_MONITOR_BAUD=115200
# end of Serial flasher config

#
# Partition Table
#
# CONFIG_PARTITION_TABLE_SINGLE_APP is not set
# CONFIG_PARTITION_TABLE_SINGLE_APP_LARGE is not set
# CONFIG_PARTITION_TABLE_TWO_OTA is not set
# CONFIG_PARTITION_TABLE_TWO_OTA_LARGE is not set
CONFIG_PARTITION_TABLE_CUSTOM=y
CONFIG_PARTITION_TABLE_CUSTOM_FILENAME="partitions.csv"
CONFIG_PARTITION_TABLE_FILENAME="partitions.csv"
CONFIG_PARTITION_TABLE_OFFSET=0x8000
CONFIG_PARTITION_TABLE_MD5=y
# end of Partition Table

#
# Example Configuration
#
CONFIG_ESP_WIFI_SSID="myssid"
CONFIG_ESP_WIFI_PASSWORD="mypassword"
# end of Example Configuration

#
# DIYMON Board Support Package
#
# CONFIG_DIYMON_BOARD_ORIGINAL is not set
CONFIG_DIYMON_BOARD_WAVESHARE_C6=y
# end of DIYMON Board Support Package

#
# Compiler options
#
CONFIG_COMPILER_OPTIMIZATION_DEBUG=y
# CONFIG_COMPILER_OPTIMIZATION_SIZE is not set
# CONFIG_COMPILER_OPTIMIZATION_PERF is not set
# CONFIG_COMPILER_OPTIMIZATION_NONE is not set
CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE=y
# CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT is not set
# CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_DISABLE is not set
CONFIG_COMPILER_ASSERT_NDEBUG_EVALUATE=y
# CONFIG_COMPILER_FLOAT_LIB_FROM_GCCLIB is not set
CONFIG_COMPILER_FLOAT_LIB_FROM_RVFPLIB=y
CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL=2
# CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT is not set
CONFIG_COMPILER_HIDE_PATHS_MACROS=y
# CONFIG_COMPILER_CXX_EXCEPTIONS is not set
# CONFIG_COMPILER_CXX_RTTI is not set
CONFIG_COMPILER_STACK_CHECK_MODE_NONE=y
# CONFIG_COMPILER_STACK_CHECK_MODE_NORM is not set
# CONFIG_COMPILER_STACK_CHECK_MODE_STRONG is not set
# CONFIG_COMPILER_STACK_CHECK_MODE_ALL is not set
# CONFIG_COMPILER_NO_MERGE_CONSTANTS is not set
# CONFIG_COMPILER_WARN_WRITE_STRINGS is not set
# CONFIG_COMPILER_SAVE_RESTORE_LIBCALLS is not set
CONFIG_COMPILER_DISABLE_DEFAULT_ERRORS=y
# CONFIG_COMPILER_DISABLE_GCC12_WARNINGS is not set
# CONFIG_COMPILER_DISABLE_GCC13_WARNINGS is not set
# CONFIG_COMPILER_DISABLE_GCC14_WARNINGS is not set
# CONFIG_COMPILER_DUMP_RTL_FILES is not set
CONFIG_COMPILER_RT_LIB_GCCLIB=y
CONFIG_COMPILER_RT_LIB_NAME="gcc"
CONFIG_COMPILER_ORPHAN_SECTIONS_WARNING=y
# CONFIG_COMPILER_ORPHAN_SECTIONS_PLACE is not set
# CONFIG_COMPILER_STATIC_ANALYZER is not set
# end of Compiler options

#
# Component config
#

#
# Application Level Tracing
#
# CONFIG_APPTRACE_DEST_JTAG is not set
CONFIG_APPTRACE_DEST_NONE=y
# CONFIG_APPTRACE_DEST_UART1 is not set
# CONFIG_APPTRACE_DEST_UART2 is not set
CONFIG_APPTRACE_DEST_UART_NONE=y
CONFIG_APPTRACE_UART_TASK_PRIO=1
CONFIG_APPTRACE_LOCK_ENABLE=y
# end of Application Level Tracing

#
# Bluetooth
#
# CONFIG_BT_ENABLED is not set

#
# Common Options
#
# CONFIG_BT_BLE_LOG_SPI_OUT_ENABLED is not set
# end of Common Options
# end of Bluetooth

#
# Console Library
#
CONFIG_CONSOLE_SORTED_HELP=y
# end of Console Library

#
# Driver Configurations
#

#
# Legacy TWAI Driver Configurations
#
# CONFIG_TWAI_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy TWAI Driver Configurations

#
# Legacy ADC Driver Configuration
#
# CONFIG_ADC_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_ADC_SKIP_LEGACY_CONFLICT_CHECK is not set

#
# Legacy ADC Calibration Configuration
#
# CONFIG_ADC_CALI_SUPPRESS_DEPRECATE_WARN is not set
# end of Legacy ADC Calibration Configuration
# end of Legacy ADC Driver Configuration

#
# Legacy MCPWM Driver Configurations
#
# CONFIG_MCPWM_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_MCPWM_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy MCPWM Driver Configurations

#
# Legacy Timer Group Driver Configurations
#
# CONFIG_GPTIMER_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_GPTIMER_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy Timer Group Driver Configurations

#
# Legacy RMT Driver Configurations
#
# CONFIG_RMT_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_RMT_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy RMT Driver Configurations

#
# Legacy I2S Driver Configurations
#
# CONFIG_I2S_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_I2S_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy I2S Driver Configurations

#
# Legacy I2C Driver Configurations
#
# CONFIG_I2C_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy I2C Driver Configurations

#
# Legacy PCNT Driver Configurations
#
# CONFIG_PCNT_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_PCNT_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy PCNT Driver Configurations

#
# Legacy SDM Driver Configurations
#
# CONFIG_SDM_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_SDM_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy SDM Driver Configurations

#
# Legacy Temperature Sensor Driver Configurations
#
# CONFIG_TEMP_SENSOR_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_TEMP_SENSOR_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy Temperature Sensor Driver Configurations
# end of Driver Configurations

#
# eFuse Bit Manager
#
# CONFIG_EFUSE_CUSTOM_TABLE is not set
# CONFIG_EFUSE_VIRTUAL is not set
CONFIG_EFUSE_MAX_BLK_LEN=256
# end of eFuse Bit Manager

#
# ESP-TLS
#
CONFIG_ESP_TLS_USING_MBEDTLS=y
# CONFIG_ESP_TLS_USE_SECURE_ELEMENT is not set
CONFIG_ESP_TLS_USE_DS_PERIPHERAL=y
# CONFIG_ESP_TLS_CLIENT_SESSION_TICKETS is not set
# CONFIG_ESP_TLS_SERVER_SESSION_TICKETS is not set
# CONFIG_ESP_TLS_SERVER_CERT_SELECT_HOOK is not set
# CONFIG_ESP_TLS_SERVER_MIN_AUTH_MODE_OPTIONAL is not set
# CONFIG_ESP_TLS_PSK_VERIFICATION is not set
# CONFIG_ESP_TLS_INSECURE is not set
# end of ESP-TLS

#
# ADC and ADC Calibration
#
# CONFIG_ADC_ONESHOT_CTRL_FUNC_IN_IRAM is not set
# CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE is not set
# CONFIG_ADC_ENABLE_DEBUG_LOG is not set
# end of ADC and ADC Calibration

#
# Wireless Coexistence
#
CONFIG_ESP_COEX_ENABLED=y
CONFIG_ESP_COEX_SW_COEXIST_ENABLE=y
# CONFIG_ESP_COEX_EXTERNAL_COEXIST_ENABLE is not set
# CONFIG_ESP_COEX_POWER_MANAGEMENT is not set
# CONFIG_ESP_COEX_GPIO_DEBUG is not set
# end of Wireless Coexistence

#
# Common ESP-related
#
CONFIG_ESP_ERR_TO_NAME_LOOKUP=y
# end of Common ESP-related

#
# ESP-Driver:GPIO Configurations
#
# CONFIG_GPIO_CTRL_FUNC_IN_IRAM is not set
# end of ESP-Driver:GPIO Configurations

#
# ESP-Driver:GPTimer Configurations
#
CONFIG_GPTIMER_ISR_HANDLER_IN_IRAM=y
# CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM is not set
# CONFIG_GPTIMER_ISR_CACHE_SAFE is not set
CONFIG_GPTIMER_OBJ_CACHE_SAFE=y
# CONFIG_GPTIMER_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:GPTimer Configurations

#
# ESP-Driver:I2C Configurations
#
# CONFIG_I2C_ISR_IRAM_SAFE is not set
# CONFIG_I2C_ENABLE_DEBUG_LOG is not set
# CONFIG_I2C_ENABLE_SLAVE_DRIVER_VERSION_2 is not set
CONFIG_I2C_MASTER_ISR_HANDLER_IN_IRAM=y
# end of ESP-Driver:I2C Configurations

#
# ESP-Driver:I2S Configurations
#
# CONFIG_I2S_ISR_IRAM_SAFE is not set
# CONFIG_I2S_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:I2S Configurations

#
# ESP-Driver:LEDC Configurations
#
# CONFIG_LEDC_CTRL_FUNC_IN_IRAM is not set
# end of ESP-Driver:LEDC Configurations

#
# ESP-Driver:MCPWM Configurations
#
CONFIG_MCPWM_ISR_HANDLER_IN_IRAM=y
# CONFIG_MCPWM_ISR_CACHE_SAFE is not set
# CONFIG_MCPWM_CTRL_FUNC_IN_IRAM is not set
CONFIG_MCPWM_OBJ_CACHE_SAFE=y
# CONFIG_MCPWM_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:MCPWM Configurations

#
# ESP-Driver:Parallel IO Configurations
#
CONFIG_PARLIO_TX_ISR_HANDLER_IN_IRAM=y
CONFIG_PARLIO_RX_ISR_HANDLER_IN_IRAM=y
# CONFIG_PARLIO_TX_ISR_CACHE_SAFE is not set
# CONFIG_PARLIO_RX_ISR_CACHE_SAFE is not set
CONFIG_PARLIO_OBJ_CACHE_SAFE=y
# CONFIG_PARLIO_ENABLE_DEBUG_LOG is not set
# CONFIG_PARLIO_ISR_IRAM_SAFE is not set
# end of ESP-Driver:Parallel IO Configurations

#
# ESP-Driver:PCNT Configurations
#
# CONFIG_PCNT_CTRL_FUNC_IN_IRAM is not set
# CONFIG_PCNT_ISR_IRAM_SAFE is not set
# CONFIG_PCNT_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:PCNT Configurations

#
# ESP-Driver:RMT Configurations
#
CONFIG_RMT_ENCODER_FUNC_IN_IRAM=y
CONFIG_RMT_TX_ISR_HANDLER_IN_IRAM=y
CONFIG_RMT_RX_ISR_HANDLER_IN_IRAM=y
# CONFIG_RMT_RECV_FUNC_IN_IRAM is not set
# CONFIG_RMT_TX_ISR_CACHE_SAFE is not set
# CONFIG_RMT_RX_ISR_CACHE_SAFE is not set
CONFIG_RMT_OBJ_CACHE_SAFE=y
# CONFIG_RMT_ENABLE_DEBUG_LOG is not set
# CONFIG_RMT_ISR_IRAM_SAFE is not set
# end of ESP-Driver:RMT Configurations

#
# ESP-Driver:Sigma Delta Modulator Configurations
#
# CONFIG_SDM_CTRL_FUNC_IN_IRAM is not set
# CONFIG_SDM_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:Sigma Delta Modulator Configurations

#
# ESP-Driver:SPI Configurations
#
# CONFIG_SPI_MASTER_IN_IRAM is not set
CONFIG_SPI_MASTER_ISR_IN_IRAM=y
# CONFIG_SPI_SLAVE_IN_IRAM is not set
CONFIG_SPI_SLAVE_ISR_IN_IRAM=y
# end of ESP-Driver:SPI Configurations

#
# ESP-Driver:Temperature Sensor Configurations
#
# CONFIG_TEMP_SENSOR_ENABLE_DEBUG_LOG is not set
# CONFIG_TEMP_SENSOR_ISR_IRAM_SAFE is not set
# end of ESP-Driver:Temperature Sensor Configurations

#
# ESP-Driver:TWAI Configurations
#
# CONFIG_TWAI_ISR_IN_IRAM is not set
# CONFIG_TWAI_ISR_CACHE_SAFE is not set
# CONFIG_TWAI_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:TWAI Configurations

#
# ESP-Driver:UART Configurations
#
# CONFIG_UART_ISR_IN_IRAM is not set
# end of ESP-Driver:UART Configurations

#
# ESP-Driver:UHCI Configurations
#
# CONFIG_UHCI_ISR_HANDLER_IN_IRAM is not set
# CONFIG_UHCI_ISR_CACHE_SAFE is not set
# CONFIG_UHCI_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:UHCI Configurations

#
# ESP-Driver:USB Serial/JTAG Configuration
#
CONFIG_USJ_ENABLE_USB_SERIAL_JTAG=y
# end of ESP-Driver:USB Serial/JTAG Configuration

#
# Ethernet
#
CONFIG_ETH_ENABLED=y
CONFIG_ETH_USE_SPI_ETHERNET=y
# CONFIG_ETH_SPI_ETHERNET_DM9051 is not set
# CONFIG_ETH_SPI_ETHERNET_W5500 is not set
# CONFIG_ETH_SPI_ETHERNET_KSZ8851SNL is not set
# CONFIG_ETH_USE_OPENETH is not set
# CONFIG_ETH_TRANSMIT_MUTEX is not set
# end of Ethernet

#
# Event Loop Library
#
# CONFIG_ESP_EVENT_LOOP_PROFILING is not set
CONFIG_ESP_EVENT_POST_FROM_ISR=y
CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR=y
# end of Event Loop Library

#
# GDB Stub
#
CONFIG_ESP_GDBSTUB_ENABLED=y
# CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME is not set
CONFIG_ESP_GDBSTUB_SUPPORT_TASKS=y
CONFIG_ESP_GDBSTUB_MAX_TASKS=32
# end of GDB Stub

#
# ESP HID
#
CONFIG_ESPHID_TASK_SIZE_BT=2048
CONFIG_ESPHID_TASK_SIZE_BLE=4096
# end of ESP HID

#
# ESP HTTP client
#
CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS=y
# CONFIG_ESP_HTTP_CLIENT_ENABLE_BASIC_AUTH is not set
# CONFIG_ESP_HTTP_CLIENT_ENABLE_DIGEST_AUTH is not set
# CONFIG_ESP_HTTP_CLIENT_ENABLE_CUSTOM_TRANSPORT is not set
CONFIG_ESP_HTTP_CLIENT_EVENT_POST_TIMEOUT=2000
# end of ESP HTTP client

#
# HTTP Server
#
CONFIG_HTTPD_MAX_REQ_HDR_LEN=1024
CONFIG_HTTPD_MAX_URI_LEN=512
CONFIG_HTTPD_ERR_RESP_NO_DELAY=y
CONFIG_HTTPD_PURGE_BUF_LEN=32
# CONFIG_HTTPD_LOG_PURGE_DATA is not set
# CONFIG_HTTPD_WS_SUPPORT is not set
# CONFIG_HTTPD_QUEUE_WORK_BLOCKING is not set
CONFIG_HTTPD_SERVER_EVENT_POST_TIMEOUT=2000
# end of HTTP Server

#
# ESP HTTPS OTA
#
# CONFIG_ESP_HTTPS_OTA_DECRYPT_CB is not set
# CONFIG_ESP_HTTPS_OTA_ALLOW_HTTP is not set
CONFIG_ESP_HTTPS_OTA_EVENT_POST_TIMEOUT=2000
# end of ESP HTTPS OTA

#
# ESP HTTPS server
#
# CONFIG_ESP_HTTPS_SERVER_ENABLE is not set
CONFIG_ESP_HTTPS_SERVER_EVENT_POST_TIMEOUT=2000
# CONFIG_ESP_HTTPS_SERVER_CERT_SELECT_HOOK is not set
# end of ESP HTTPS server

#
# Hardware Settings
#

#
# Chip revision
#
CONFIG_ESP32C6_REV_MIN_0=y
# CONFIG_ESP32C6_REV_MIN_1 is not set
# CONFIG_ESP32C6_REV_MIN_2 is not set
CONFIG_ESP32C6_REV_MIN_FULL=0
CONFIG_ESP_REV_MIN_FULL=0

#
# Maximum Supported ESP32-C6 Revision (Rev v0.99)
#
CONFIG_ESP32C6_REV_MAX_FULL=99
CONFIG_ESP_REV_MAX_FULL=99
CONFIG_ESP_EFUSE_BLOCK_REV_MIN_FULL=0
CONFIG_ESP_EFUSE_BLOCK_REV_MAX_FULL=99

#
# Maximum Supported ESP32-C6 eFuse Block Revision (eFuse Block Rev v0.99)
#
# end of Chip revision

#
# MAC Config
#
CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_BT=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_ETH=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_IEEE802154=y
CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES_FOUR=y
CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES=4
# CONFIG_ESP32C6_UNIVERSAL_MAC_ADDRESSES_TWO is not set
CONFIG_ESP32C6_UNIVERSAL_MAC_ADDRESSES_FOUR=y
CONFIG_ESP32C6_UNIVERSAL_MAC_ADDRESSES=4
# CONFIG_ESP_MAC_USE_CUSTOM_MAC_AS_BASE_MAC is not set
# end of MAC Config

#
# Sleep Config
#
# CONFIG_ESP_SLEEP_POWER_DOWN_FLASH is not set
CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND=y
# CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU is not set
CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND=y
CONFIG_ESP_SLEEP_WAIT_FLASH_READY_EXTRA_DELAY=0
# CONFIG_ESP_SLEEP_CACHE_SAFE_ASSERTION is not set
# CONFIG_ESP_SLEEP_DEBUG is not set
CONFIG_ESP_SLEEP_GPIO_ENABLE_INTERNAL_RESISTORS=y
# end of Sleep Config

#
# RTC Clock Config
#
CONFIG_RTC_CLK_SRC_INT_RC=y
# CONFIG_RTC_CLK_SRC_EXT_CRYS is not set
# CONFIG_RTC_CLK_SRC_EXT_OSC is not set
# CONFIG_RTC_CLK_SRC_USE_DANGEROUS_RC32K_ALLOWED is not set
CONFIG_RTC_CLK_CAL_CYCLES=1024
# end of RTC Clock Config

#
# Peripheral Control
#
CONFIG_ESP_PERIPH_CTRL_FUNC_IN_IRAM=y
CONFIG_ESP_REGI2C_CTRL_FUNC_IN_IRAM=y
# end of Peripheral Control

#
# ETM Configuration
#
# CONFIG_ETM_ENABLE_DEBUG_LOG is not set
# end of ETM Configuration

#
# GDMA Configurations
#
CONFIG_GDMA_CTRL_FUNC_IN_IRAM=y
CONFIG_GDMA_ISR_HANDLER_IN_IRAM=y
CONFIG_GDMA_OBJ_DRAM_SAFE=y
# CONFIG_GDMA_ENABLE_DEBUG_LOG is not set
# CONFIG_GDMA_ISR_IRAM_SAFE is not set
# end of GDMA Configurations

#
# Main XTAL Config
#
CONFIG_XTAL_FREQ_40=y
CONFIG_XTAL_FREQ=40
# end of Main XTAL Config

#
# Power Supplier
#

#
# Brownout Detector
#
CONFIG_ESP_BROWNOUT_DET=y
CONFIG_ESP_BROWNOUT_DET_LVL_SEL_7=y
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_2 is not set
CONFIG_ESP_BROWNOUT_DET_LVL=7
CONFIG_ESP_BROWNOUT_USE_INTR=y
# end of Brownout Detector
# end of Power Supplier

CONFIG_ESP_SPI_BUS_LOCK_ISR_FUNCS_IN_IRAM=y
CONFIG_ESP_INTR_IN_IRAM=y
# end of Hardware Settings

#
# ESP-Driver:LCD Controller Configurations
#
# CONFIG_LCD_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:LCD Controller Configurations

#
# ESP-MM: Memory Management Configurations
#
# end of ESP-MM: Memory Management Configurations

#
# ESP NETIF Adapter
#
CONFIG_ESP_NETIF_IP_LOST_TIMER_INTERVAL=120
# CONFIG_ESP_NETIF_PROVIDE_CUSTOM_IMPLEMENTATION is not set
CONFIG_ESP_NETIF_TCPIP_LWIP=y
# CONFIG_ESP_NETIF_LOOPBACK is not set
CONFIG_ESP_NETIF_USES_TCPIP_WITH_BSD_API=y
CONFIG_ESP_NETIF_REPORT_DATA_TRAFFIC=y
# CONFIG_ESP_NETIF_RECEIVE_REPORT_ERRORS is not set
# CONFIG_ESP_NETIF_L2_TAP is not set
# CONFIG_ESP_NETIF_BRIDGE_EN is not set
# CONFIG_ESP_NETIF_SET_DNS_PER_DEFAULT_NETIF is not set
# end of ESP NETIF Adapter

#
# Partition API Configuration
#
# end of Partition API Configuration

#
# PHY
#
CONFIG_ESP_PHY_ENABLED=y
CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE=y
# CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION is not set
CONFIG_ESP_PHY_MAX_WIFI_TX_POWER=20
CONFIG_ESP_PHY_MAX_TX_POWER=20
# CONFIG_ESP_PHY_REDUCE_TX_POWER is not set
# CONFIG_ESP_PHY_ENABLE_CERT_TEST is not set
CONFIG_ESP_PHY_RF_CAL_PARTIAL=y
# CONFIG_ESP_PHY_RF_CAL_NONE is not set
# CONFIG_ESP_PHY_RF_CAL_FULL is not set
CONFIG_ESP_PHY_CALIBRATION_MODE=0
# CONFIG_ESP_PHY_PLL_TRACK_DEBUG is not set
# CONFIG_ESP_PHY_RECORD_USED_TIME is not set
CONFIG_ESP_PHY_IRAM_OPT=y
# end of PHY

#
# Power Management
#
CONFIG_PM_SLEEP_FUNC_IN_IRAM=y
# CONFIG_PM_ENABLE is not set
CONFIG_PM_SLP_IRAM_OPT=y
CONFIG_PM_SLP_DEFAULT_PARAMS_OPT=y
CONFIG_PM_POWER_DOWN_CPU_IN_LIGHT_SLEEP=y
# CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP is not set
# end of Power Management

#
# ESP PSRAM
#

#
# ESP Ringbuf
#
# CONFIG_RINGBUF_PLACE_FUNCTIONS_INTO_FLASH is not set
# end of ESP Ringbuf

#
# ESP-ROM
#
CONFIG_ESP_ROM_PRINT_IN_IRAM=y
# end of ESP-ROM

#
# ESP Security Specific
#

#
# Crypto DPA Protection
#
CONFIG_ESP_CRYPTO_DPA_PROTECTION_AT_STARTUP=y
CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL_LOW=y
# CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL_MEDIUM is not set
# CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL_HIGH is not set
CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL=1
# end of Crypto DPA Protection
# end of ESP Security Specific

#
# ESP System Settings
#
# CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_80 is not set
# CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_120 is not set
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_160=y
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ=160
# CONFIG_ESP_SYSTEM_PANIC_PRINT_HALT is not set
CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT=y
# CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT is not set
# CONFIG_ESP_SYSTEM_PANIC_GDBSTUB is not set
CONFIG_ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS=0
CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE=y
CONFIG_ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK=y
CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP=y
CONFIG_ESP_SYSTEM_NO_BACKTRACE=y
# CONFIG_ESP_SYSTEM_USE_EH_FRAME is not set
# CONFIG_ESP_SYSTEM_USE_FRAME_POINTER is not set

#
# Memory protection
#
CONFIG_ESP_SYSTEM_PMP_IDRAM_SPLIT=y
# CONFIG_ESP_SYSTEM_PMP_LP_CORE_RESERVE_MEM_EXECUTABLE is not set
# end of Memory protection

CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE=32
CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE=2304
CONFIG_ESP_MAIN_TASK_STACK_SIZE=16384
CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0=y
# CONFIG_ESP_MAIN_TASK_AFFINITY_NO_AFFINITY is not set
CONFIG_ESP_MAIN_TASK_AFFINITY=0x0
CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE=2048
CONFIG_ESP_CONSOLE_UART_DEFAULT=y
# CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG is not set
# CONFIG_ESP_CONSOLE_UART_CUSTOM is not set
# CONFIG_ESP_CONSOLE_NONE is not set
# CONFIG_ESP_CONSOLE_SECONDARY_NONE is not set
CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG=y
CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG_ENABLED=y
CONFIG_ESP_CONSOLE_UART=y
CONFIG_ESP_CONSOLE_UART_NUM=0
CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM=0
CONFIG_ESP_CONSOLE_UART_BAUDRATE=115200
CONFIG_ESP_INT_WDT=y
CONFIG_ESP_INT_WDT_TIMEOUT_MS=300
CONFIG_ESP_TASK_WDT_EN=y
CONFIG_ESP_TASK_WDT_INIT=y
# CONFIG_ESP_TASK_WDT_PANIC is not set
CONFIG_ESP_TASK_WDT_TIMEOUT_S=5
CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0=y
# CONFIG_ESP_PANIC_HANDLER_IRAM is not set
# CONFIG_ESP_DEBUG_STUBS_ENABLE is not set
# CONFIG_ESP_DEBUG_INCLUDE_OCD_STUB_BINS is not set
CONFIG_ESP_DEBUG_OCDAWARE=y
CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4=y
CONFIG_ESP_SYSTEM_HW_STACK_GUARD=y
CONFIG_ESP_SYSTEM_BBPLL_RECALIB=y
CONFIG_ESP_SYSTEM_HW_PC_RECORD=y
# end of ESP System Settings

#
# IPC (Inter-Processor Call)
#
CONFIG_ESP_IPC_TASK_STACK_SIZE=1024
# end of IPC (Inter-Processor Call)

#
# ESP Timer (High Resolution Timer)
#
CONFIG_ESP_TIMER_IN_IRAM=y
# CONFIG_ESP_TIMER_PROFILING is not set
CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER=y
CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER=y
CONFIG_ESP_TIMER_TASK_STACK_SIZE=3584
CONFIG_ESP_TIMER_INTERRUPT_LEVEL=1
# CONFIG_ESP_TIMER_SHOW_EXPERIMENTAL is not set
CONFIG_ESP_TIMER_TASK_AFFINITY=0x0
CONFIG_ESP_TIMER_TASK_AFFINITY_CPU0=y
CONFIG_ESP_TIMER_ISR_AFFINITY_CPU0=y
# CONFIG_ESP_TIMER_SUPPORTS_ISR_DISPATCH_METHOD is not set
CONFIG_ESP_TIMER_IMPL_SYSTIMER=y
# end of ESP Timer (High Resolution Timer)

#
# Wi-Fi
#
CONFIG_ESP_WIFI_ENABLED=y
CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM=10
CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM=32
# CONFIG_ESP_WIFI_STATIC_TX_BUFFER is not set
CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER=y
CONFIG_ESP_WIFI_TX_BUFFER_TYPE=1
CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM=32
CONFIG_ESP_WIFI_STATIC_RX_MGMT_BUFFER=y
# CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUFFER is not set
CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUF=0
CONFIG_ESP_WIFI_RX_MGMT_BUF_NUM_DEF=5
# CONFIG_ESP_WIFI_CSI_ENABLED is not set
CONFIG_ESP_WIFI_AMPDU_TX_ENABLED=y
CONFIG_ESP_WIFI_TX_BA_WIN=6
CONFIG_ESP_WIFI_AMPDU_RX_ENABLED=y
CONFIG_ESP_WIFI_RX_BA_WIN=6
CONFIG_ESP_WIFI_NVS_ENABLED=y
CONFIG_ESP_WIFI_SOFTAP_BEACON_MAX_LEN=752
CONFIG_ESP_WIFI_MGMT_SBUF_NUM=32
CONFIG_ESP_WIFI_IRAM_OPT=y
CONFIG_ESP_WIFI_EXTRA_IRAM_OPT=y
CONFIG_ESP_WIFI_RX_IRAM_OPT=y
CONFIG_ESP_WIFI_ENABLE_WPA3_SAE=y
CONFIG_ESP_WIFI_ENABLE_SAE_PK=y
CONFIG_ESP_WIFI_ENABLE_SAE_H2E=y
CONFIG_ESP_WIFI_SOFTAP_SAE_SUPPORT=y
CONFIG_ESP_WIFI_ENABLE_WPA3_OWE_STA=y
CONFIG_ESP_WIFI_SLP_IRAM_OPT=y
CONFIG_ESP_WIFI_SLP_DEFAULT_MIN_ACTIVE_TIME=50
CONFIG_ESP_WIFI_BSS_MAX_IDLE_SUPPORT=y
CONFIG_ESP_WIFI_SLP_DEFAULT_MAX_ACTIVE_TIME=10
CONFIG_ESP_WIFI_SLP_DEFAULT_WAIT_BROADCAST_DATA_TIME=15
# CONFIG_ESP_WIFI_FTM_ENABLE is not set
CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE=y
# CONFIG_ESP_WIFI_GCMP_SUPPORT is not set
CONFIG_ESP_WIFI_GMAC_SUPPORT=y
CONFIG_ESP_WIFI_SOFTAP_SUPPORT=y
# CONFIG_ESP_WIFI_SLP_BEACON_LOST_OPT is not set
CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM=7
CONFIG_ESP_WIFI_MBEDTLS_CRYPTO=y
CONFIG_ESP_WIFI_MBEDTLS_TLS_CLIENT=y
# CONFIG_ESP_WIFI_WAPI_PSK is not set
# CONFIG_ESP_WIFI_SUITE_B_192 is not set
# CONFIG_ESP_WIFI_11KV_SUPPORT is not set
# CONFIG_ESP_WIFI_MBO_SUPPORT is not set
# CONFIG_ESP_WIFI_DPP_SUPPORT is not set
# CONFIG_ESP_WIFI_11R_SUPPORT is not set
# CONFIG_ESP_WIFI_WPS_SOFTAP_REGISTRAR is not set
# CONFIG_ESP_WIFI_ENABLE_WIFI_TX_STATS is not set
# CONFIG_ESP_WIFI_ENABLE_WIFI_RX_STATS is not set
CONFIG_ESP_WIFI_TX_HETB_QUEUE_NUM=3

#
# WPS Configuration Options
#
# CONFIG_ESP_WIFI_WPS_STRICT is not set
# CONFIG_ESP_WIFI_WPS_PASSPHRASE is not set
# end of WPS Configuration Options

# CONFIG_ESP_WIFI_DEBUG_PRINT is not set
# CONFIG_ESP_WIFI_TESTING_OPTIONS is not set
CONFIG_ESP_WIFI_ENTERPRISE_SUPPORT=y
# CONFIG_ESP_WIFI_ENT_FREE_DYNAMIC_BUFFER is not set
# end of Wi-Fi

#
# Core dump
#
# CONFIG_ESP_COREDUMP_ENABLE_TO_FLASH is not set
# CONFIG_ESP_COREDUMP_ENABLE_TO_UART is not set
CONFIG_ESP_COREDUMP_ENABLE_TO_NONE=y
# end of Core dump

#
# FAT Filesystem support
#
CONFIG_FATFS_VOLUME_COUNT=2
# CONFIG_FATFS_LFN_NONE is not set
CONFIG_FATFS_LFN_HEAP=y
# CONFIG_FATFS_LFN_STACK is not set
# CONFIG_FATFS_SECTOR_512 is not set
CONFIG_FATFS_SECTOR_4096=y
# CONFIG_FATFS_CODEPAGE_DYNAMIC is not set
CONFIG_FATFS_CODEPAGE_437=y
# CONFIG_FATFS_CODEPAGE_720 is not set
# CONFIG_FATFS_CODEPAGE_737 is not set
# CONFIG_FATFS_CODEPAGE_771 is not set
# CONFIG_FATFS_CODEPAGE_775 is not set
# CONFIG_FATFS_CODEPAGE_850 is not set
# CONFIG_FATFS_CODEPAGE_852 is not set
# CONFIG_FATFS_CODEPAGE_855 is not set
# CONFIG_FATFS_CODEPAGE_857 is not set
# CONFIG_FATFS_CODEPAGE_860 is not set
# CONFIG_FATFS_CODEPAGE_861 is not set
# CONFIG_FATFS_CODEPAGE_862 is not set
# CONFIG_FATFS_CODEPAGE_863 is not set
# CONFIG_FATFS_CODEPAGE_864 is not set
# CONFIG_FATFS_CODEPAGE_865 is not set
# CONFIG_FATFS_CODEPAGE_866 is not set
# CONFIG_FATFS_CODEPAGE_869 is not set
# CONFIG_FATFS_CODEPAGE_932 is not set
# CONFIG_FATFS_CODEPAGE_936 is not set
# CONFIG_FATFS_CODEPAGE_949 is not set
# CONFIG_FATFS_CODEPAGE_950 is not set
CONFIG_FATFS_CODEPAGE=437
CONFIG_FATFS_MAX_LFN=255
CONFIG_FATFS_API_ENCODING_ANSI_OEM=y
# CONFIG_FATFS_API_ENCODING_UTF_8 is not set
CONFIG_FATFS_FS_LOCK=0
CONFIG_FATFS_TIMEOUT_MS=10000
CONFIG_FATFS_PER_FILE_CACHE=y
# CONFIG_FATFS_USE_FASTSEEK is not set
CONFIG_FATFS_USE_STRFUNC_NONE=y
# CONFIG_FATFS_USE_STRFUNC_WITHOUT_CRLF_CONV is not set
# CONFIG_FATFS_USE_STRFUNC_WITH_CRLF_CONV is not set
CONFIG_FATFS_VFS_FSTAT_BLKSIZE=0
# CONFIG_FATFS_IMMEDIATE_FSYNC is not set
# CONFIG_FATFS_USE_LABEL is not set
CONFIG_FATFS_LINK_LOCK=y
# CONFIG_FATFS_USE_DYN_BUFFERS is not set

#
# File system free space calculation behavior
#
CONFIG_FATFS_DONT_TRUST_FREE_CLUSTER_CNT=0
CONFIG_FATFS_DONT_TRUST_LAST_ALLOC=0
# end of File system free space calculation behavior
# end of FAT Filesystem support

#
# FreeRTOS
#

#
# Kernel
#
# CONFIG_FREERTOS_SMP is not set
CONFIG_FREERTOS_UNICORE=y
CONFIG_FREERTOS_HZ=100
CONFIG_FREERTOS_OPTIMIZED_SCHEDULER=y
# CONFIG_FREERTOS_CHECK_STACKOVERFLOW_NONE is not set
# CONFIG_FREERTOS_CHECK_STACKOVERFLOW_PTRVAL is not set
CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY=y
CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS=1
CONFIG_FREERTOS_IDLE_TASK_STACKSIZE=1536
# CONFIG_FREERTOS_USE_IDLE_HOOK is not set
# CONFIG_FREERTOS_USE_TICK_HOOK is not set
CONFIG_FREERTOS_MAX_TASK_NAME_LEN=16
# CONFIG_FREERTOS_ENABLE_BACKWARD_COMPATIBILITY is not set
CONFIG_FREERTOS_USE_TIMERS=y
CONFIG_FREERTOS_TIMER_SERVICE_TASK_NAME="Tmr Svc"
# CONFIG_FREERTOS_TIMER_TASK_AFFINITY_CPU0 is not set
CONFIG_FREERTOS_TIMER_TASK_NO_AFFINITY=y
CONFIG_FREERTOS_TIMER_SERVICE_TASK_CORE_AFFINITY=0x7FFFFFFF
CONFIG_FREERTOS_TIMER_TASK_PRIORITY=1
CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH=2048
CONFIG_FREERTOS_TIMER_QUEUE_LENGTH=10
CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE=0
CONFIG_FREERTOS_TASK_NOTIFICATION_ARRAY_ENTRIES=1
# CONFIG_FREERTOS_USE_TRACE_FACILITY is not set
# CONFIG_FREERTOS_USE_LIST_DATA_INTEGRITY_CHECK_BYTES is not set
# CONFIG_FREERTOS_GENERATE_RUN_TIME_STATS is not set
# CONFIG_FREERTOS_USE_APPLICATION_TASK_TAG is not set
# end of Kernel

#
# Port
#
CONFIG_FREERTOS_TASK_FUNCTION_WRAPPER=y
# CONFIG_FREERTOS_WATCHPOINT_END_OF_STACK is not set
CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS=y
# CONFIG_FREERTOS_TASK_PRE_DELETION_HOOK is not set
# CONFIG_FREERTOS_ENABLE_STATIC_TASK_CLEAN_UP is not set
CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER=y
CONFIG_FREERTOS_ISR_STACKSIZE=1536
CONFIG_FREERTOS_INTERRUPT_BACKTRACE=y
CONFIG_FREERTOS_TICK_SUPPORT_SYSTIMER=y
CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL1=y
# CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL3 is not set
CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER=y
# CONFIG_FREERTOS_PLACE_FUNCTIONS_INTO_FLASH is not set
# CONFIG_FREERTOS_CHECK_PORT_CRITICAL_COMPLIANCE is not set
# end of Port

#
# Extra
#
# end of Extra

CONFIG_FREERTOS_PORT=y
CONFIG_FREERTOS_NO_AFFINITY=0x7FFFFFFF
CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION=y
CONFIG_FREERTOS_DEBUG_OCDAWARE=y
CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT=y
CONFIG_FREERTOS_PLACE_SNAPSHOT_FUNS_INTO_FLASH=y
CONFIG_FREERTOS_NUMBER_OF_CORES=1
CONFIG_FREERTOS_IN_IRAM=y
# end of FreeRTOS

#
# Hardware Abstraction Layer (HAL) and Low Level (LL)
#
CONFIG_HAL_ASSERTION_EQUALS_SYSTEM=y
# CONFIG_HAL_ASSERTION_DISABLE is not set
# CONFIG_HAL_ASSERTION_SILENT is not set
# CONFIG_HAL_ASSERTION_ENABLE is not set
CONFIG_HAL_DEFAULT_ASSERTION_LEVEL=2
CONFIG_HAL_SYSTIMER_USE_ROM_IMPL=y
CONFIG_HAL_WDT_USE_ROM_IMPL=y
# end of Hardware Abstraction Layer (HAL) and Low Level (LL)

#
# Heap memory debugging
#
CONFIG_HEAP_POISONING_DISABLED=y
# CONFIG_HEAP_POISONING_LIGHT is not set
# CONFIG_HEAP_POISONING_COMPREHENSIVE is not set
CONFIG_HEAP_TRACING_OFF=y
# CONFIG_HEAP_TRACING_STANDALONE is not set
# CONFIG_HEAP_TRACING_TOHOST is not set
# CONFIG_HEAP_USE_HOOKS is not set
# CONFIG_HEAP_TASK_TRACKING is not set
# CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS is not set
CONFIG_HEAP_TLSF_USE_ROM_IMPL=y
# CONFIG_HEAP_PLACE_FUNCTION_INTO_FLASH is not set
# end of Heap memory debugging

#
# IEEE 802.15.4
#
CONFIG_IEEE802154_ENABLED=y
CONFIG_IEEE802154_RX_BUFFER_SIZE=20
# CONFIG_IEEE802154_CCA_CARRIER is not set
CONFIG_IEEE802154_CCA_ED=y
# CONFIG_IEEE802154_CCA_CARRIER_OR_ED is not set
# CONFIG_IEEE802154_CCA_CARRIER_AND_ED is not set
CONFIG_IEEE802154_CCA_MODE=1
CONFIG_IEEE802154_CCA_THRESHOLD=-60
CONFIG_IEEE802154_PENDING_TABLE_SIZE=20
# CONFIG_IEEE802154_MULTI_PAN_ENABLE is not set
CONFIG_IEEE802154_TIMING_OPTIMIZATION=y
# CONFIG_IEEE802154_DEBUG is not set
# CONFIG_IEEE802154_DEBUG_ASSERT_MONITOR is not set
# end of IEEE 802.15.4

#
# Log
#
CONFIG_LOG_VERSION_1=y
# CONFIG_LOG_VERSION_2 is not set
CONFIG_LOG_VERSION=1

#
# Log Level
#
# CONFIG_LOG_DEFAULT_LEVEL_NONE is not set
# CONFIG_LOG_DEFAULT_LEVEL_ERROR is not set
# CONFIG_LOG_DEFAULT_LEVEL_WARN is not set
CONFIG_LOG_DEFAULT_LEVEL_INFO=y
# CONFIG_LOG_DEFAULT_LEVEL_DEBUG is not set
# CONFIG_LOG_DEFAULT_LEVEL_VERBOSE is not set
CONFIG_LOG_DEFAULT_LEVEL=3
CONFIG_LOG_MAXIMUM_EQUALS_DEFAULT=y
# CONFIG_LOG_MAXIMUM_LEVEL_DEBUG is not set
# CONFIG_LOG_MAXIMUM_LEVEL_VERBOSE is not set
CONFIG_LOG_MAXIMUM_LEVEL=3

#
# Level Settings
#
# CONFIG_LOG_MASTER_LEVEL is not set
CONFIG_LOG_DYNAMIC_LEVEL_CONTROL=y
# CONFIG_LOG_TAG_LEVEL_IMPL_NONE is not set
# CONFIG_LOG_TAG_LEVEL_IMPL_LINKED_LIST is not set
CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_AND_LINKED_LIST=y
# CONFIG_LOG_TAG_LEVEL_CACHE_ARRAY is not set
CONFIG_LOG_TAG_LEVEL_CACHE_BINARY_MIN_HEAP=y
CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_SIZE=31
# end of Level Settings
# end of Log Level

#
# Format
#
# CONFIG_LOG_COLORS is not set
CONFIG_LOG_TIMESTAMP_SOURCE_RTOS=y
# CONFIG_LOG_TIMESTAMP_SOURCE_SYSTEM is not set
# end of Format

#
# Settings
#
CONFIG_LOG_MODE_TEXT_EN=y
CONFIG_LOG_MODE_TEXT=y
# end of Settings

CONFIG_LOG_IN_IRAM=y
# end of Log

#
# LWIP
#
CONFIG_LWIP_ENABLE=y
CONFIG_LWIP_LOCAL_HOSTNAME="espressif"
CONFIG_LWIP_TCPIP_TASK_PRIO=2
# CONFIG_LWIP_TCPIP_CORE_LOCKING is not set
# CONFIG_LWIP_CHECK_THREAD_SAFETY is not set
CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES=y
# CONFIG_LWIP_L2_TO_L3_COPY is not set
# CONFIG_LWIP_IRAM_OPTIMIZATION is not set
# CONFIG_LWIP_EXTRA_IRAM_OPTIMIZATION is not set
CONFIG_LWIP_TIMERS_ONDEMAND=y
CONFIG_LWIP_ND6=y
# CONFIG_LWIP_FORCE_ROUTER_FORWARDING is not set
CONFIG_LWIP_MAX_SOCKETS=10
# CONFIG_LWIP_USE_ONLY_LWIP_SELECT is not set
# CONFIG_LWIP_SO_LINGER is not set
CONFIG_LWIP_SO_REUSE=y
CONFIG_LWIP_SO_REUSE_RXTOALL=y
# CONFIG_LWIP_SO_RCVBUF is not set
# CONFIG_LWIP_NETBUF_RECVINFO is not set
CONFIG_LWIP_IP_DEFAULT_TTL=64
CONFIG_LWIP_IP4_FRAG=y
CONFIG_LWIP_IP6_FRAG=y
# CONFIG_LWIP_IP4_REASSEMBLY is not set
# CONFIG_LWIP_IP6_REASSEMBLY is not set
CONFIG_LWIP_IP_REASS_MAX_PBUFS=10
# CONFIG_LWIP_IP_FORWARD is not set
# CONFIG_LWIP_STATS is not set
CONFIG_LWIP_ESP_GRATUITOUS_ARP=y
CONFIG_LWIP_GARP_TMR_INTERVAL=60
CONFIG_LWIP_ESP_MLDV6_REPORT=y
CONFIG_LWIP_MLDV6_TMR_INTERVAL=40
CONFIG_LWIP_TCPIP_RECVMBOX_SIZE=32
CONFIG_LWIP_DHCP_DOES_ARP_CHECK=y
# CONFIG_LWIP_DHCP_DOES_ACD_CHECK is not set
# CONFIG_LWIP_DHCP_DOES_NOT_CHECK_OFFERED_IP is not set
# CONFIG_LWIP_DHCP_DISABLE_CLIENT_ID is not set
CONFIG_LWIP_DHCP_DISABLE_VENDOR_CLASS_ID=y
# CONFIG_LWIP_DHCP_RESTORE_LAST_IP is not set
CONFIG_LWIP_DHCP_OPTIONS_LEN=68
CONFIG_LWIP_NUM_NETIF_CLIENT_DATA=0
CONFIG_LWIP_DHCP_COARSE_TIMER_SECS=1

#
# DHCP server
#
CONFIG_LWIP_DHCPS=y
CONFIG_LWIP_DHCPS_LEASE_UNIT=60
CONFIG_LWIP_DHCPS_MAX_STATION_NUM=8
CONFIG_LWIP_DHCPS_STATIC_ENTRIES=y
CONFIG_LWIP_DHCPS_ADD_DNS=y
# end of DHCP server

# CONFIG_LWIP_AUTOIP is not set
CONFIG_LWIP_IPV4=y
CONFIG_LWIP_IPV6=y
# CONFIG_LWIP_IPV6_AUTOCONFIG is not set
CONFIG_LWIP_IPV6_NUM_ADDRESSES=3
# CONFIG_LWIP_IPV6_FORWARD is not set
# CONFIG_LWIP_NETIF_STATUS_CALLBACK is not set
CONFIG_LWIP_NETIF_LOOPBACK=y
CONFIG_LWIP_LOOPBACK_MAX_PBUFS=8

#
# TCP
#
CONFIG_LWIP_MAX_ACTIVE_TCP=16
CONFIG_LWIP_MAX_LISTENING_TCP=16
CONFIG_LWIP_TCP_HIGH_SPEED_RETRANSMISSION=y
CONFIG_LWIP_TCP_MAXRTX=12
CONFIG_LWIP_TCP_SYNMAXRTX=12
CONFIG_LWIP_TCP_MSS=1440
CONFIG_LWIP_TCP_TMR_INTERVAL=250
CONFIG_LWIP_TCP_MSL=60000
CONFIG_LWIP_TCP_FIN_WAIT_TIMEOUT=20000
CONFIG_LWIP_TCP_SND_BUF_DEFAULT=5760
CONFIG_LWIP_TCP_WND_DEFAULT=5760
CONFIG_LWIP_TCP_RECVMBOX_SIZE=6
CONFIG_LWIP_TCP_ACCEPTMBOX_SIZE=6
CONFIG_LWIP_TCP_QUEUE_OOSEQ=y
CONFIG_LWIP_TCP_OOSEQ_TIMEOUT=6
CONFIG_LWIP_TCP_OOSEQ_MAX_PBUFS=4
# CONFIG_LWIP_TCP_SACK_OUT is not set
CONFIG_LWIP_TCP_OVERSIZE_MSS=y
# CONFIG_LWIP_TCP_OVERSIZE_QUARTER_MSS is not set
# CONFIG_LWIP_TCP_OVERSIZE_DISABLE is not set
CONFIG_LWIP_TCP_RTO_TIME=1500
# end of TCP

#
# UDP
#
CONFIG_LWIP_MAX_UDP_PCBS=16
CONFIG_LWIP_UDP_RECVMBOX_SIZE=6
# end of UDP

#
# Checksums
#
# CONFIG_LWIP_CHECKSUM_CHECK_IP is not set
# CONFIG_LWIP_CHECKSUM_CHECK_UDP is not set
CONFIG_LWIP_CHECKSUM_CHECK_ICMP=y
# end of Checksums

CONFIG_LWIP_TCPIP_TASK_STACK_SIZE=3072
CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY=y
# CONFIG_LWIP_TCPIP_TASK_AFFINITY_CPU0 is not set
CONFIG_LWIP_TCPIP_TASK_AFFINITY=0x7FFFFFFF
CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE=3
CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS=5
CONFIG_LWIP_IPV6_ND6_NUM_PREFIXES=5
CONFIG_LWIP_IPV6_ND6_NUM_ROUTERS=3
CONFIG_LWIP_IPV6_ND6_NUM_DESTINATIONS=10
# CONFIG_LWIP_PPP_SUPPORT is not set
# CONFIG_LWIP_SLIP_SUPPORT is not set

#
# ICMP
#
CONFIG_LWIP_ICMP=y
# CONFIG_LWIP_MULTICAST_PING is not set
# CONFIG_LWIP_BROADCAST_PING is not set
# end of ICMP

#
# LWIP RAW API
#
CONFIG_LWIP_MAX_RAW_PCBS=16
# end of LWIP RAW API

#
# SNTP
#
CONFIG_LWIP_SNTP_MAX_SERVERS=1
# CONFIG_LWIP_DHCP_GET_NTP_SRV is not set
CONFIG_LWIP_SNTP_UPDATE_DELAY=3600000
CONFIG_LWIP_SNTP_STARTUP_DELAY=y
CONFIG_LWIP_SNTP_MAXIMUM_STARTUP_DELAY=5000
# end of SNTP

#
# DNS
#
CONFIG_LWIP_DNS_MAX_HOST_IP=1
CONFIG_LWIP_DNS_MAX_SERVERS=3
# CONFIG_LWIP_FALLBACK_DNS_SERVER_SUPPORT is not set
# CONFIG_LWIP_DNS_SETSERVER_WITH_NETIF is not set
# CONFIG_LWIP_USE_ESP_GETADDRINFO is not set
# end of DNS

CONFIG_LWIP_BRIDGEIF_MAX_PORTS=7
CONFIG_LWIP_ESP_LWIP_ASSERT=y

#
# Hooks
#
# CONFIG_LWIP_HOOK_TCP_ISN_NONE is not set
CONFIG_LWIP_HOOK_TCP_ISN_DEFAULT=y
# CONFIG_LWIP_HOOK_TCP_ISN_CUSTOM is not set
CONFIG_LWIP_HOOK_IP6_ROUTE_NONE=y
# CONFIG_LWIP_HOOK_IP6_ROUTE_DEFAULT is not set
# CONFIG_LWIP_HOOK_IP6_ROUTE_CUSTOM is not set
CONFIG_LWIP_HOOK_ND6_GET_GW_NONE=y
# CONFIG_LWIP_HOOK_ND6_GET_GW_DEFAULT is not set
# CONFIG_LWIP_HOOK_ND6_GET_GW_CUSTOM is not set
CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_NONE=y
# CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_DEFAULT is not set
# CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_CUSTOM is not set
CONFIG_LWIP_HOOK_DHCP_EXTRA_OPTION_NONE=y
# CONFIG_LWIP_HOOK_DHCP_EXTRA_OPTION_DEFAULT is not set
# CONFIG_LWIP_HOOK_DHCP_EXTRA_OPTION_CUSTOM is not set
CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_NONE=y
# CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_DEFAULT is not set
# CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_CUSTOM is not set
CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_NONE=y
# CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_CUSTOM is not set
# CONFIG_LWIP_HOOK_IP6_INPUT_NONE is not set
CONFIG_LWIP_HOOK_IP6_INPUT_DEFAULT=y
# CONFIG_LWIP_HOOK_IP6_INPUT_CUSTOM is not set
# end of Hooks

# CONFIG_LWIP_DEBUG is not set
# end of LWIP

#
# mbedTLS
#
CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC=y
# CONFIG_MBEDTLS_DEFAULT_MEM_ALLOC is not set
# CONFIG_MBEDTLS_CUSTOM_MEM_ALLOC is not set
CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN=y
CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN=16384
CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN=4096
# CONFIG_MBEDTLS_DYNAMIC_BUFFER is not set
# CONFIG_MBEDTLS_DEBUG is not set

#
# mbedTLS v3.x related
#
# CONFIG_MBEDTLS_SSL_PROTO_TLS1_3 is not set
# CONFIG_MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH is not set
# CONFIG_MBEDTLS_X509_TRUSTED_CERT_CALLBACK is not set
# CONFIG_MBEDTLS_SSL_CONTEXT_SERIALIZATION is not set
CONFIG_MBEDTLS_SSL_KEEP_PEER_CERTIFICATE=y
CONFIG_MBEDTLS_PKCS7_C=y
# end of mbedTLS v3.x related

#
# Certificate Bundle
#
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE=y
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL=y
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_CMN is not set
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_NONE is not set
# CONFIG_MBEDTLS_CUSTOM_CERTIFICATE_BUNDLE is not set
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEPRECATED_LIST is not set
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_MAX_CERTS=200
# end of Certificate Bundle

# CONFIG_MBEDTLS_ECP_RESTARTABLE is not set
CONFIG_MBEDTLS_CMAC_C=y
CONFIG_MBEDTLS_HARDWARE_AES=y
CONFIG_MBEDTLS_AES_USE_INTERRUPT=y
CONFIG_MBEDTLS_AES_INTERRUPT_LEVEL=0
CONFIG_MBEDTLS_GCM_SUPPORT_NON_AES_CIPHER=y
CONFIG_MBEDTLS_HARDWARE_MPI=y
CONFIG_MBEDTLS_LARGE_KEY_SOFTWARE_MPI=y
CONFIG_MBEDTLS_MPI_USE_INTERRUPT=y
CONFIG_MBEDTLS_MPI_INTERRUPT_LEVEL=0
CONFIG_MBEDTLS_HARDWARE_SHA=y
CONFIG_MBEDTLS_HARDWARE_ECC=y
CONFIG_MBEDTLS_ECC_OTHER_CURVES_SOFT_FALLBACK=y
CONFIG_MBEDTLS_ROM_MD5=y
# CONFIG_MBEDTLS_ATCA_HW_ECDSA_SIGN is not set
# CONFIG_MBEDTLS_ATCA_HW_ECDSA_VERIFY is not set
CONFIG_MBEDTLS_HAVE_TIME=y
# CONFIG_MBEDTLS_PLATFORM_TIME_ALT is not set
# CONFIG_MBEDTLS_HAVE_TIME_DATE is not set
CONFIG_MBEDTLS_ECDSA_DETERMINISTIC=y
CONFIG_MBEDTLS_SHA1_C=y
CONFIG_MBEDTLS_SHA512_C=y
# CONFIG_MBEDTLS_SHA3_C is not set
CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT=y
# CONFIG_MBEDTLS_TLS_SERVER_ONLY is not set
# CONFIG_MBEDTLS_TLS_CLIENT_ONLY is not set
# CONFIG_MBEDTLS_TLS_DISABLED is not set
CONFIG_MBEDTLS_TLS_SERVER=y
CONFIG_MBEDTLS_TLS_CLIENT=y
CONFIG_MBEDTLS_TLS_ENABLED=y

#
# TLS Key Exchange Methods
#
# CONFIG_MBEDTLS_PSK_MODES is not set
CONFIG_MBEDTLS_KEY_EXCHANGE_RSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA=y
# end of TLS Key Exchange Methods

CONFIG_MBEDTLS_SSL_RENEGOTIATION=y
CONFIG_MBEDTLS_SSL_PROTO_TLS1_2=y
# CONFIG_MBEDTLS_SSL_PROTO_GMTSSL1_1 is not set
# CONFIG_MBEDTLS_SSL_PROTO_DTLS is not set
CONFIG_MBEDTLS_SSL_ALPN=y
CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS=y
CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS=y

#
# Symmetric Ciphers
#
CONFIG_MBEDTLS_AES_C=y
# CONFIG_MBEDTLS_CAMELLIA_C is not set
# CONFIG_MBEDTLS_DES_C is not set
# CONFIG_MBEDTLS_BLOWFISH_C is not set
# CONFIG_MBEDTLS_XTEA_C is not set
CONFIG_MBEDTLS_CCM_C=y
CONFIG_MBEDTLS_GCM_C=y
# CONFIG_MBEDTLS_NIST_KW_C is not set
# end of Symmetric Ciphers

# CONFIG_MBEDTLS_RIPEMD160_C is not set

#
# Certificates
#
CONFIG_MBEDTLS_PEM_PARSE_C=y
CONFIG_MBEDTLS_PEM_WRITE_C=y
CONFIG_MBEDTLS_X509_CRL_PARSE_C=y
CONFIG_MBEDTLS_X509_CSR_PARSE_C=y
# end of Certificates

CONFIG_MBEDTLS_ECP_C=y
CONFIG_MBEDTLS_PK_PARSE_EC_EXTENDED=y
CONFIG_MBEDTLS_PK_PARSE_EC_COMPRESSED=y
# CONFIG_MBEDTLS_DHM_C is not set
CONFIG_MBEDTLS_ECDH_C=y
CONFIG_MBEDTLS_ECDSA_C=y
# CONFIG_MBEDTLS_ECJPAKE_C is not set
CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED=y
CONFIG_MBEDTLS_ECP_NIST_OPTIM=y
# CONFIG_MBEDTLS_ECP_FIXED_POINT_OPTIM is not set
# CONFIG_MBEDTLS_POLY1305_C is not set
# CONFIG_MBEDTLS_CHACHA20_C is not set
# CONFIG_MBEDTLS_HKDF_C is not set
# CONFIG_MBEDTLS_THREADING_C is not set
CONFIG_MBEDTLS_ERROR_STRINGS=y
CONFIG_MBEDTLS_FS_IO=y
# CONFIG_MBEDTLS_ALLOW_WEAK_CERTIFICATE_VERIFICATION is not set
# end of mbedTLS

#
# ESP-MQTT Configurations
#
CONFIG_MQTT_PROTOCOL_311=y
# CONFIG_MQTT_PROTOCOL_5 is not set
CONFIG_MQTT_TRANSPORT_SSL=y
CONFIG_MQTT_TRANSPORT_WEBSOCKET=y
CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE=y
# CONFIG_MQTT_MSG_ID_INCREMENTAL is not set
# CONFIG_MQTT_SKIP_PUBLISH_IF_DISCONNECTED is not set
# CONFIG_MQTT_REPORT_DELETED_MESSAGES is not set
# CONFIG_MQTT_USE_CUSTOM_CONFIG is not set
# CONFIG_MQTT_TASK_CORE_SELECTION_ENABLED is not set
# CONFIG_MQTT_CUSTOM_OUTBOX is not set
# end of ESP-MQTT Configurations

#
# LibC
#
CONFIG_LIBC_NEWLIB=y
CONFIG_LIBC_MISC_IN_IRAM=y
CONFIG_LIBC_LOCKS_PLACE_IN_IRAM=y
CONFIG_LIBC_STDOUT_LINE_ENDING_CRLF=y
# CONFIG_LIBC_STDOUT_LINE_ENDING_LF is not set
# CONFIG_LIBC_STDOUT_LINE_ENDING_CR is not set
# CONFIG_LIBC_STDIN_LINE_ENDING_CRLF is not set
# CONFIG_LIBC_STDIN_LINE_ENDING_LF is not set
CONFIG_LIBC_STDIN_LINE_ENDING_CR=y
# CONFIG_LIBC_NEWLIB_NANO_FORMAT is not set
CONFIG_LIBC_TIME_SYSCALL_USE_RTC_HRT=y
# CONFIG_LIBC_TIME_SYSCALL_USE_RTC is not set
# CONFIG_LIBC_TIME_SYSCALL_USE_HRT is not set
# CONFIG_LIBC_TIME_SYSCALL_USE_NONE is not set
# CONFIG_LIBC_OPTIMIZED_MISALIGNED_ACCESS is not set
# end of LibC

#
# NVS
#
# CONFIG_NVS_ENCRYPTION is not set
# CONFIG_NVS_ASSERT_ERROR_CHECK is not set
# CONFIG_NVS_LEGACY_DUP_KEYS_COMPATIBILITY is not set
# end of NVS

#
# OpenThread
#
# CONFIG_OPENTHREAD_ENABLED is not set

#
# OpenThread Spinel
#
# CONFIG_OPENTHREAD_SPINEL_ONLY is not set
# end of OpenThread Spinel
# end of OpenThread

#
# Protocomm
#
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_0=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_1=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_2=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_PATCH_VERSION=y
# end of Protocomm

#
# PThreads
#
CONFIG_PTHREAD_TASK_PRIO_DEFAULT=5
CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT=3072
CONFIG_PTHREAD_STACK_MIN=768
CONFIG_PTHREAD_TASK_CORE_DEFAULT=-1
CONFIG_PTHREAD_TASK_NAME_DEFAULT="pthread"
# end of PThreads

#
# MMU Config
#
CONFIG_MMU_PAGE_SIZE_64KB=y
CONFIG_MMU_PAGE_MODE="64KB"
CONFIG_MMU_PAGE_SIZE=0x10000
# end of MMU Config

#
# Main Flash configuration
#

#
# SPI Flash behavior when brownout
#
CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC=y
CONFIG_SPI_FLASH_BROWNOUT_RESET=y
# end of SPI Flash behavior when brownout

#
# Optional and Experimental Features (READ DOCS FIRST)
#

#
# Features here require specific hardware (READ DOCS FIRST!)
#
# CONFIG_SPI_FLASH_AUTO_SUSPEND is not set
CONFIG_SPI_FLASH_SUSPEND_TSUS_VAL_US=50
# CONFIG_SPI_FLASH_FORCE_ENABLE_XMC_C_SUSPEND is not set
# CONFIG_SPI_FLASH_FORCE_ENABLE_C6_H2_SUSPEND is not set
CONFIG_SPI_FLASH_PLACE_FUNCTIONS_IN_IRAM=y
# end of Optional and Experimental Features (READ DOCS FIRST)
# end of Main Flash configuration

#
# SPI Flash driver
#
# CONFIG_SPI_FLASH_VERIFY_WRITE is not set
# CONFIG_SPI_FLASH_ENABLE_COUNTERS is not set
CONFIG_SPI_FLASH_ROM_DRIVER_PATCH=y
# CONFIG_SPI_FLASH_ROM_IMPL is not set
CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS=y
# CONFIG_SPI_FLASH_DANGEROUS_WRITE_FAILS is not set
# CONFIG_SPI_FLASH_DANGEROUS_WRITE_ALLOWED is not set
# CONFIG_SPI_FLASH_BYPASS_BLOCK_ERASE is not set
CONFIG_SPI_FLASH_YIELD_DURING_ERASE=y
CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS=20
CONFIG_SPI_FLASH_ERASE_YIELD_TICKS=1
CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE=8192
# CONFIG_SPI_FLASH_SIZE_OVERRIDE is not set
# CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED is not set
# CONFIG_SPI_FLASH_OVERRIDE_CHIP_DRIVER_LIST is not set

#
# Auto-detect flash chips
#
CONFIG_SPI_FLASH_VENDOR_XMC_SUPPORTED=y
# CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_MXIC_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_GD_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_WINBOND_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_BOYA_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_TH_CHIP is not set
# end of Auto-detect flash chips

CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE=y
# end of SPI Flash driver

#
# SPIFFS Configuration
#
CONFIG_SPIFFS_MAX_PARTITIONS=3

#
# SPIFFS Cache Configuration
#
CONFIG_SPIFFS_CACHE=y
CONFIG_SPIFFS_CACHE_WR=y
# CONFIG_SPIFFS_CACHE_STATS is not set
# end of SPIFFS Cache Configuration

CONFIG_SPIFFS_PAGE_CHECK=y
CONFIG_SPIFFS_GC_MAX_RUNS=10
# CONFIG_SPIFFS_GC_STATS is not set
CONFIG_SPIFFS_PAGE_SIZE=256
CONFIG_SPIFFS_OBJ_NAME_LEN=32
# CONFIG_SPIFFS_FOLLOW_SYMLINKS is not set
CONFIG_SPIFFS_USE_MAGIC=y
CONFIG_SPIFFS_USE_MAGIC_LENGTH=y
CONFIG_SPIFFS_META_LENGTH=4
CONFIG_SPIFFS_USE_MTIME=y

#
# Debug Configuration
#
# CONFIG_SPIFFS_DBG is not set
# CONFIG_SPIFFS_API_DBG is not set
# CONFIG_SPIFFS_GC_DBG is not set
# CONFIG_SPIFFS_CACHE_DBG is not set
# CONFIG_SPIFFS_CHECK_DBG is not set
# CONFIG_SPIFFS_TEST_VISUALISATION is not set
# end of Debug Configuration
# end of SPIFFS Configuration

#
# TCP Transport
#

#
# Websocket
#
CONFIG_WS_TRANSPORT=y
CONFIG_WS_BUFFER_SIZE=1024
# CONFIG_WS_DYNAMIC_BUFFER is not set
# end of Websocket
# end of TCP Transport

#
# Ultra Low Power (ULP) Co-processor
#
# CONFIG_ULP_COPROC_ENABLED is not set

#
# ULP Debugging Options
#
# end of ULP Debugging Options
# end of Ultra Low Power (ULP) Co-processor

#
# Unity unit testing library
#
CONFIG_UNITY_ENABLE_FLOAT=y
CONFIG_UNITY_ENABLE_DOUBLE=y
# CONFIG_UNITY_ENABLE_64BIT is not set
# CONFIG_UNITY_ENABLE_COLOR is not set
CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER=y
# CONFIG_UNITY_ENABLE_FIXTURE is not set
# CONFIG_UNITY_ENABLE_BACKTRACE_ON_FAIL is not set
# CONFIG_UNITY_TEST_ORDER_BY_FILE_PATH_AND_LINE is not set
# end of Unity unit testing library

#
# Virtual file system
#
CONFIG_VFS_SUPPORT_IO=y
CONFIG_VFS_SUPPORT_DIR=y
CONFIG_VFS_SUPPORT_SELECT=y
CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT=y
# CONFIG_VFS_SELECT_IN_RAM is not set
CONFIG_VFS_SUPPORT_TERMIOS=y
CONFIG_VFS_MAX_COUNT=8

#
# Host File System I/O (Semihosting)
#
CONFIG_VFS_SEMIHOSTFS_MAX_MOUNT_POINTS=1
# end of Host File System I/O (Semihosting)

CONFIG_VFS_INITIALIZE_DEV_NULL=y
# end of Virtual file system

#
# Wear Levelling
#
# CONFIG_WL_SECTOR_SIZE_512 is not set
CONFIG_WL_SECTOR_SIZE_4096=y
CONFIG_WL_SECTOR_SIZE=4096
# end of Wear Levelling

#
# Wi-Fi Provisioning Manager
#
CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES=16
CONFIG_WIFI_PROV_AUTOSTOP_TIMEOUT=30
CONFIG_WIFI_PROV_STA_ALL_CHANNEL_SCAN=y
# CONFIG_WIFI_PROV_STA_FAST_SCAN is not set
# end of Wi-Fi Provisioning Manager

#
# ESP LCD TOUCH
#
CONFIG_ESP_LCD_TOUCH_MAX_POINTS=5
CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS=1
# end of ESP LCD TOUCH

#
# ESP LVGL PORT
#
# end of ESP LVGL PORT

#
# CMake Utilities
#
# CONFIG_CU_RELINKER_ENABLE is not set
# CONFIG_CU_DIAGNOSTICS_COLOR_NEVER is not set
CONFIG_CU_DIAGNOSTICS_COLOR_ALWAYS=y
# CONFIG_CU_DIAGNOSTICS_COLOR_AUTO is not set
# CONFIG_CU_GCC_LTO_ENABLE is not set
# CONFIG_CU_GCC_STRING_1BYTE_ALIGN is not set
# end of CMake Utilities

#
# LVGL configuration
#
CONFIG_LV_CONF_SKIP=y
# CONFIG_LV_CONF_MINIMAL is not set

#
# Color Settings
#
# CONFIG_LV_COLOR_DEPTH_32 is not set
# CONFIG_LV_COLOR_DEPTH_24 is not set
CONFIG_LV_COLOR_DEPTH_16=y
# CONFIG_LV_COLOR_DEPTH_8 is not set
# CONFIG_LV_COLOR_DEPTH_1 is not set
CONFIG_LV_COLOR_DEPTH=16
# end of Color Settings

#
# Memory Settings
#
CONFIG_LV_USE_BUILTIN_MALLOC=y
# CONFIG_LV_USE_CLIB_MALLOC is not set
# CONFIG_LV_USE_MICROPYTHON_MALLOC is not set
# CONFIG_LV_USE_RTTHREAD_MALLOC is not set
# CONFIG_LV_USE_CUSTOM_MALLOC is not set
CONFIG_LV_USE_BUILTIN_STRING=y
# CONFIG_LV_USE_CLIB_STRING is not set
# CONFIG_LV_USE_CUSTOM_STRING is not set
CONFIG_LV_USE_BUILTIN_SPRINTF=y
# CONFIG_LV_USE_CLIB_SPRINTF is not set
# CONFIG_LV_USE_CUSTOM_SPRINTF is not set
CONFIG_LV_MEM_SIZE_KILOBYTES=64
CONFIG_LV_MEM_POOL_EXPAND_SIZE_KILOBYTES=0
CONFIG_LV_MEM_ADR=0x0
# end of Memory Settings

#
# HAL Settings
#
CONFIG_LV_DEF_REFR_PERIOD=33
CONFIG_LV_DPI_DEF=130
# end of HAL Settings

#
# Operating System (OS)
#
CONFIG_LV_OS_NONE=y
# CONFIG_LV_OS_PTHREAD is not set
# CONFIG_LV_OS_FREERTOS is not set
# CONFIG_LV_OS_CMSIS_RTOS2 is not set
# CONFIG_LV_OS_RTTHREAD is not set
# CONFIG_LV_OS_WINDOWS is not set
# CONFIG_LV_OS_CUSTOM is not set
CONFIG_LV_USE_OS=0
# end of Operating System (OS)

#
# Rendering Configuration
#
CONFIG_LV_DRAW_BUF_STRIDE_ALIGN=1
CONFIG_LV_DRAW_BUF_ALIGN=4
CONFIG_LV_DRAW_LAYER_SIMPLE_BUF_SIZE=24576
CONFIG_LV_USE_DRAW_SW=y
CONFIG_LV_DRAW_SW_DRAW_UNIT_CNT=1
# CONFIG_LV_USE_DRAW_ARM2D_SYNC is not set
CONFIG_LV_USE_NATIVE_HELIUM_ASM=y
CONFIG_LV_DRAW_SW_COMPLEX=y
CONFIG_LV_DRAW_SW_SHADOW_CACHE_SIZE=0
CONFIG_LV_DRAW_SW_CIRCLE_CACHE_SIZE=4
CONFIG_LV_DRAW_SW_ASM_NONE=y
# CONFIG_LV_DRAW_SW_ASM_NEON is not set
# CONFIG_LV_DRAW_SW_ASM_HELIUM is not set
# CONFIG_LV_DRAW_SW_ASM_CUSTOM is not set
CONFIG_LV_USE_DRAW_SW_ASM=0
# CONFIG_LV_USE_DRAW_VGLITE is not set
# CONFIG_LV_USE_DRAW_PXP is not set
# CONFIG_LV_USE_DRAW_DAVE2D is not set
# CONFIG_LV_USE_DRAW_SDL is not set
# CONFIG_LV_USE_DRAW_VG_LITE is not set
# CONFIG_LV_USE_VECTOR_GRAPHIC is not set
# end of Rendering Configuration

#
# Feature Configuration
#

#
# Logging
#
# CONFIG_LV_USE_LOG is not set
# end of Logging

#
# Asserts
#
CONFIG_LV_USE_ASSERT_NULL=y
CONFIG_LV_USE_ASSERT_MALLOC=y
# CONFIG_LV_USE_ASSERT_STYLE is not set
# CONFIG_LV_USE_ASSERT_MEM_INTEGRITY is not set
# CONFIG_LV_USE_ASSERT_OBJ is not set
CONFIG_LV_ASSERT_HANDLER_INCLUDE="assert.h"
# end of Asserts

#
# Debug
#
# CONFIG_LV_USE_REFR_DEBUG is not set
# CONFIG_LV_USE_LAYER_DEBUG is not set
# CONFIG_LV_USE_PARALLEL_DRAW_DEBUG is not set
# end of Debug

#
# Others
#
# CONFIG_LV_ENABLE_GLOBAL_CUSTOM is not set
CONFIG_LV_CACHE_DEF_SIZE=0
CONFIG_LV_IMAGE_HEADER_CACHE_DEF_CNT=0
CONFIG_LV_GRADIENT_MAX_STOPS=2
CONFIG_LV_COLOR_MIX_ROUND_OFS=128
# CONFIG_LV_OBJ_STYLE_CACHE is not set
# CONFIG_LV_USE_OBJ_ID is not set
# CONFIG_LV_USE_OBJ_ID_BUILTIN is not set
# CONFIG_LV_USE_OBJ_PROPERTY is not set
# end of Others
# end of Feature Configuration

#
# Compiler Settings
#
# CONFIG_LV_BIG_ENDIAN_SYSTEM is not set
CONFIG_LV_ATTRIBUTE_MEM_ALIGN_SIZE=1
# CONFIG_LV_ATTRIBUTE_FAST_MEM_USE_IRAM is not set
# CONFIG_LV_USE_FLOAT is not set
# end of Compiler Settings

#
# Font Usage
#

#
# Enable built-in fonts
#
# CONFIG_LV_FONT_MONTSERRAT_8 is not set
# CONFIG_LV_FONT_MONTSERRAT_10 is not set
# CONFIG_LV_FONT_MONTSERRAT_12 is not set
CONFIG_LV_FONT_MONTSERRAT_14=y
# CONFIG_LV_FONT_MONTSERRAT_16 is not set
# CONFIG_LV_FONT_MONTSERRAT_18 is not set
# CONFIG_LV_FONT_MONTSERRAT_20 is not set
# CONFIG_LV_FONT_MONTSERRAT_22 is not set
# CONFIG_LV_FONT_MONTSERRAT_24 is not set
# CONFIG_LV_FONT_MONTSERRAT_26 is not set
# CONFIG_LV_FONT_MONTSERRAT_28 is not set
# CONFIG_LV_FONT_MONTSERRAT_30 is not set
# CONFIG_LV_FONT_MONTSERRAT_32 is not set
# CONFIG_LV_FONT_MONTSERRAT_34 is not set
# CONFIG_LV_FONT_MONTSERRAT_36 is not set
# CONFIG_LV_FONT_MONTSERRAT_38 is not set
# CONFIG_LV_FONT_MONTSERRAT_40 is not set
# CONFIG_LV_FONT_MONTSERRAT_42 is not set
# CONFIG_LV_FONT_MONTSERRAT_44 is not set
# CONFIG_LV_FONT_MONTSERRAT_46 is not set
# CONFIG_LV_FONT_MONTSERRAT_48 is not set
# CONFIG_LV_FONT_MONTSERRAT_28_COMPRESSED is not set
# CONFIG_LV_FONT_DEJAVU_16_PERSIAN_HEBREW is not set
# CONFIG_LV_FONT_SIMSUN_16_CJK is not set
# CONFIG_LV_FONT_UNSCII_8 is not set
# CONFIG_LV_FONT_UNSCII_16 is not set
# end of Enable built-in fonts

# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_8 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_12 is not set
CONFIG_LV_FONT_DEFAULT_MONTSERRAT_14=y
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_16 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_18 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_20 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_22 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_24 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_26 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_28 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_30 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_32 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_34 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_36 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_38 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_40 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_42 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_44 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_46 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_48 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_28_COMPRESSED is not set
# CONFIG_LV_FONT_DEFAULT_DEJAVU_16_PERSIAN_HEBREW is not set
# CONFIG_LV_FONT_DEFAULT_SIMSUN_16_CJK is not set
# CONFIG_LV_FONT_DEFAULT_UNSCII_8 is not set
# CONFIG_LV_FONT_DEFAULT_UNSCII_16 is not set
# CONFIG_LV_FONT_FMT_TXT_LARGE is not set
# CONFIG_LV_USE_FONT_COMPRESSED is not set
CONFIG_LV_USE_FONT_PLACEHOLDER=y
# end of Font Usage

#
# Text Settings
#
CONFIG_LV_TXT_ENC_UTF8=y
# CONFIG_LV_TXT_ENC_ASCII is not set
CONFIG_LV_TXT_BREAK_CHARS=" ,.;:-_)]}"
CONFIG_LV_TXT_LINE_BREAK_LONG_LEN=0
# CONFIG_LV_USE_BIDI is not set
# CONFIG_LV_USE_ARABIC_PERSIAN_CHARS is not set
# end of Text Settings

#
# Widget Usage
#
CONFIG_LV_WIDGETS_HAS_DEFAULT_VALUE=y
CONFIG_LV_USE_ANIMIMG=y
CONFIG_LV_USE_ARC=y
CONFIG_LV_USE_BAR=y
CONFIG_LV_USE_BUTTON=y
CONFIG_LV_USE_BUTTONMATRIX=y
CONFIG_LV_USE_CALENDAR=y
# CONFIG_LV_CALENDAR_WEEK_STARTS_MONDAY is not set
CONFIG_LV_USE_CALENDAR_HEADER_ARROW=y
CONFIG_LV_USE_CALENDAR_HEADER_DROPDOWN=y
CONFIG_LV_USE_CANVAS=y
CONFIG_LV_USE_CHART=y
CONFIG_LV_USE_CHECKBOX=y
CONFIG_LV_USE_DROPDOWN=y
CONFIG_LV_USE_IMAGE=y
CONFIG_LV_USE_IMAGEBUTTON=y
CONFIG_LV_USE_KEYBOARD=y
CONFIG_LV_USE_LABEL=y
CONFIG_LV_LABEL_TEXT_SELECTION=y
CONFIG_LV_LABEL_LONG_TXT_HINT=y
CONFIG_LV_LABEL_WAIT_CHAR_COUNT=3
CONFIG_LV_USE_LED=y
CONFIG_LV_USE_LINE=y
CONFIG_LV_USE_LIST=y
CONFIG_LV_USE_MENU=y
CONFIG_LV_USE_MSGBOX=y
# CONFIG_LV_USE_OBSERVER is not set
CONFIG_LV_USE_ROLLER=y
CONFIG_LV_USE_SCALE=y
CONFIG_LV_USE_SLIDER=y
CONFIG_LV_USE_SPAN=y
CONFIG_LV_SPAN_SNIPPET_STACK_SIZE=64
CONFIG_LV_USE_SPINBOX=y
CONFIG_LV_USE_SPINNER=y
CONFIG_LV_USE_SWITCH=y
CONFIG_LV_USE_TEXTAREA=y
CONFIG_LV_TEXTAREA_DEF_PWD_SHOW_TIME=1500
CONFIG_LV_USE_TABLE=y
CONFIG_LV_USE_TABVIEW=y
CONFIG_LV_USE_TILEVIEW=y
CONFIG_LV_USE_WIN=y
# end of Widget Usage

#
# Themes
#
CONFIG_LV_USE_THEME_DEFAULT=y
# CONFIG_LV_THEME_DEFAULT_DARK is not set
CONFIG_LV_THEME_DEFAULT_GROW=y
CONFIG_LV_THEME_DEFAULT_TRANSITION_TIME=80
CONFIG_LV_USE_THEME_SIMPLE=y
# CONFIG_LV_USE_THEME_MONO is not set
# end of Themes

#
# Layouts
#
CONFIG_LV_USE_FLEX=y
CONFIG_LV_USE_GRID=y
# end of Layouts

#
# 3rd Party Libraries
#
# CONFIG_LV_USE_FS_STDIO is not set
# CONFIG_LV_USE_FS_POSIX is not set
# CONFIG_LV_USE_FS_WIN32 is not set
# CONFIG_LV_USE_FS_FATFS is not set
# CONFIG_LV_USE_FS_MEMFS is not set
# CONFIG_LV_USE_FS_LITTLEFS is not set
# CONFIG_LV_USE_LODEPNG is not set
# CONFIG_LV_USE_LIBPNG is not set
# CONFIG_LV_USE_BMP is not set
# CONFIG_LV_USE_TJPGD is not set
# CONFIG_LV_USE_LIBJPEG_TURBO is not set
# CONFIG_LV_USE_GIF is not set
# CONFIG_LV_BIN_DECODER_RAM_LOAD is not set
# CONFIG_LV_USE_RLE is not set
# CONFIG_LV_USE_QRCODE is not set
# CONFIG_LV_USE_BARCODE is not set
# CONFIG_LV_USE_FREETYPE is not set
# CONFIG_LV_USE_TINY_TTF is not set
# CONFIG_LV_USE_RLOTTIE is not set
# CONFIG_LV_USE_THORVG is not set
# CONFIG_LV_USE_LZ4 is not set
# CONFIG_LV_USE_FFMPEG is not set
# end of 3rd Party Libraries

#
# Others
#
# CONFIG_LV_USE_SNAPSHOT is not set
# CONFIG_LV_USE_SYSMON is not set
# CONFIG_LV_USE_MONKEY is not set
# CONFIG_LV_USE_PROFILER is not set
# CONFIG_LV_USE_GRIDNAV is not set
# CONFIG_LV_USE_FRAGMENT is not set
# CONFIG_LV_USE_IMGFONT is not set
# CONFIG_LV_USE_IME_PINYIN is not set
# CONFIG_LV_USE_FILE_EXPLORER is not set
# end of Others

#
# Devices
#
# CONFIG_LV_USE_SDL is not set
# CONFIG_LV_USE_X11 is not set
# CONFIG_LV_USE_LINUX_FBDEV is not set
# CONFIG_LV_USE_NUTTX is not set
# CONFIG_LV_USE_LINUX_DRM is not set
# CONFIG_LV_USE_TFT_ESPI is not set
# CONFIG_LV_USE_EVDEV is not set
# CONFIG_LV_USE_LIBINPUT is not set
# CONFIG_LV_USE_ST7735 is not set
# CONFIG_LV_USE_ST7789 is not set
# CONFIG_LV_USE_ST7796 is not set
# CONFIG_LV_USE_ILI9341 is not set
# CONFIG_LV_USE_GENERIC_MIPI is not set
# CONFIG_LV_USE_WINDOWS is not set
# end of Devices

#
# Examples
#
CONFIG_LV_BUILD_EXAMPLES=y
# end of Examples

#
# Demos
#
# CONFIG_LV_USE_DEMO_WIDGETS is not set
# CONFIG_LV_USE_DEMO_KEYPAD_AND_ENCODER is not set
# CONFIG_LV_USE_DEMO_RENDER is not set
# CONFIG_LV_USE_DEMO_SCROLL is not set
# CONFIG_LV_USE_DEMO_STRESS is not set
# CONFIG_LV_USE_DEMO_MUSIC is not set
# CONFIG_LV_USE_DEMO_FLEX_LAYOUT is not set
# CONFIG_LV_USE_DEMO_MULTILANG is not set
# end of Demos
# end of LVGL configuration

#
# DIYMON Board Options
#
CONFIG_BSP_SD_CARD_ENABLED=y
# end of DIYMON Board Options

#
# IoT Button
#
CONFIG_BUTTON_PERIOD_TIME_MS=5
CONFIG_BUTTON_DEBOUNCE_TICKS=2
CONFIG_BUTTON_SHORT_PRESS_TIME_MS=180
CONFIG_BUTTON_LONG_PRESS_TIME_MS=1500
CONFIG_BUTTON_LONG_PRESS_HOLD_SERIAL_TIME_MS=20
CONFIG_ADC_BUTTON_MAX_CHANNEL=3
CONFIG_ADC_BUTTON_MAX_BUTTON_PER_CHANNEL=8
CONFIG_ADC_BUTTON_SAMPLE_TIMES=1
# end of IoT Button

#
# ESP LCD TOUCH - CST816S
#
# CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID is not set
# end of ESP LCD TOUCH - CST816S
# end of Component config

# CONFIG_IDF_EXPERIMENTAL_FEATURES is not set

# Deprecated options for backward compatibility
# CONFIG_APP_BUILD_TYPE_ELF_RAM is not set
# CONFIG_NO_BLOBS is not set
# CONFIG_APP_ROLLBACK_ENABLE is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_NONE is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_ERROR is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_WARN is not set
CONFIG_LOG_BOOTLOADER_LEVEL_INFO=y
# CONFIG_LOG_BOOTLOADER_LEVEL_DEBUG is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_VERBOSE is not set
CONFIG_LOG_BOOTLOADER_LEVEL=3
# CONFIG_FLASH_ENCRYPTION_ENABLED is not set
# CONFIG_FLASHMODE_QIO is not set
# CONFIG_FLASHMODE_QOUT is not set
CONFIG_FLASHMODE_DIO=y
# CONFIG_FLASHMODE_DOUT is not set
CONFIG_MONITOR_BAUD=115200
CONFIG_OPTIMIZATION_LEVEL_DEBUG=y
CONFIG_COMPILER_OPTIMIZATION_LEVEL_DEBUG=y
CONFIG_COMPILER_OPTIMIZATION_DEFAULT=y
# CONFIG_OPTIMIZATION_LEVEL_RELEASE is not set
# CONFIG_COMPILER_OPTIMIZATION_LEVEL_RELEASE is not set
CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED=y
# CONFIG_OPTIMIZATION_ASSERTIONS_SILENT is not set
# CONFIG_OPTIMIZATION_ASSERTIONS_DISABLED is not set
CONFIG_OPTIMIZATION_ASSERTION_LEVEL=2
# CONFIG_CXX_EXCEPTIONS is not set
CONFIG_STACK_CHECK_NONE=y
# CONFIG_STACK_CHECK_NORM is not set
# CONFIG_STACK_CHECK_STRONG is not set
# CONFIG_STACK_CHECK_ALL is not set
# CONFIG_WARN_WRITE_STRINGS is not set
# CONFIG_ESP32_APPTRACE_DEST_TRAX is not set
CONFIG_ESP32_APPTRACE_DEST_NONE=y
CONFIG_ESP32_APPTRACE_LOCK_ENABLE=y
CONFIG_SW_COEXIST_ENABLE=y
CONFIG_ESP32_WIFI_SW_COEXIST_ENABLE=y
CONFIG_ESP_WIFI_SW_COEXIST_ENABLE=y
# CONFIG_EXTERNAL_COEX_ENABLE is not set
# CONFIG_ESP_WIFI_EXTERNAL_COEXIST_ENABLE is not set
# CONFIG_GPTIMER_ISR_IRAM_SAFE is not set
# CONFIG_MCPWM_ISR_IRAM_SAFE is not set
# CONFIG_EVENT_LOOP_PROFILING is not set
CONFIG_POST_EVENTS_FROM_ISR=y
CONFIG_POST_EVENTS_FROM_IRAM_ISR=y
CONFIG_GDBSTUB_SUPPORT_TASKS=y
CONFIG_GDBSTUB_MAX_TASKS=32
# CONFIG_OTA_ALLOW_HTTP is not set
# CONFIG_ESP_SYSTEM_PD_FLASH is not set
CONFIG_PERIPH_CTRL_FUNC_IN_IRAM=y
CONFIG_BROWNOUT_DET=y
CONFIG_BROWNOUT_DET_LVL_SEL_7=y
# CONFIG_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_2 is not set
CONFIG_BROWNOUT_DET_LVL=7
CONFIG_ESP_SYSTEM_BROWNOUT_INTR=y
CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE=y
# CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION is not set
CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER=20
CONFIG_ESP32_PHY_MAX_TX_POWER=20
# CONFIG_REDUCE_PHY_TX_POWER is not set
# CONFIG_ESP32_REDUCE_PHY_TX_POWER is not set
CONFIG_ESP_SYSTEM_PM_POWER_DOWN_CPU=y
CONFIG_SYSTEM_EVENT_QUEUE_SIZE=32
CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE=2304
CONFIG_MAIN_TASK_STACK_SIZE=16384
CONFIG_CONSOLE_UART_DEFAULT=y
# CONFIG_CONSOLE_UART_CUSTOM is not set
# CONFIG_CONSOLE_UART_NONE is not set
# CONFIG_ESP_CONSOLE_UART_NONE is not set
CONFIG_CONSOLE_UART=y
CONFIG_CONSOLE_UART_NUM=0
CONFIG_CONSOLE_UART_BAUDRATE=115200
CONFIG_INT_WDT=y
CONFIG_INT_WDT_TIMEOUT_MS=300
CONFIG_TASK_WDT=y
CONFIG_ESP_TASK_WDT=y
# CONFIG_TASK_WDT_PANIC is not set
CONFIG_TASK_WDT_TIMEOUT_S=5
CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0=y
# CONFIG_ESP32_DEBUG_STUBS_ENABLE is not set
CONFIG_IPC_TASK_STACK_SIZE=1024
CONFIG_TIMER_TASK_STACK_SIZE=3584
CONFIG_ESP32_WIFI_ENABLED=y
CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM=10
CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM=32
# CONFIG_ESP32_WIFI_STATIC_TX_BUFFER is not set
CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER=y
CONFIG_ESP32_WIFI_TX_BUFFER_TYPE=1
CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM=32
# CONFIG_ESP32_WIFI_CSI_ENABLED is not set
CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED=y
CONFIG_ESP32_WIFI_TX_BA_WIN=6
CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED=y
CONFIG_ESP32_WIFI_RX_BA_WIN=6
CONFIG_ESP32_WIFI_NVS_ENABLED=y
CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN=752
CONFIG_ESP32_WIFI_MGMT_SBUF_NUM=32
CONFIG_ESP32_WIFI_IRAM_OPT=y
CONFIG_ESP32_WIFI_RX_IRAM_OPT=y
CONFIG_ESP32_WIFI_ENABLE_WPA3_SAE=y
CONFIG_ESP32_WIFI_ENABLE_WPA3_OWE_STA=y
CONFIG_WPA_MBEDTLS_CRYPTO=y
CONFIG_WPA_MBEDTLS_TLS_CLIENT=y
# CONFIG_WPA_WAPI_PSK is not set
# CONFIG_WPA_SUITE_B_192 is not set
# CONFIG_WPA_11KV_SUPPORT is not set
# CONFIG_WPA_MBO_SUPPORT is not set
# CONFIG_WPA_DPP_SUPPORT is not set
# CONFIG_WPA_11R_SUPPORT is not set
# CONFIG_WPA_WPS_SOFTAP_REGISTRAR is not set
# CONFIG_WPA_WPS_STRICT is not set
# CONFIG_WPA_DEBUG_PRINT is not set
# CONFIG_WPA_TESTING_OPTIONS is not set
# CONFIG_ESP32_ENABLE_COREDUMP_TO_FLASH is not set
# CONFIG_ESP32_ENABLE_COREDUMP_TO_UART is not set
CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE=y
CONFIG_TIMER_TASK_PRIORITY=1
CONFIG_TIMER_TASK_STACK_DEPTH=2048
CONFIG_TIMER_QUEUE_LENGTH=10
# CONFIG_ENABLE_STATIC_TASK_CLEAN_UP_HOOK is not set
# CONFIG_HAL_ASSERTION_SILIENT is not set
# CONFIG_L2_TO_L3_COPY is not set
CONFIG_ESP_GRATUITOUS_ARP=y
CONFIG_GARP_TMR_INTERVAL=60
CONFIG_TCPIP_RECVMBOX_SIZE=32
CONFIG_TCP_MAXRTX=12
CONFIG_TCP_SYNMAXRTX=12
CONFIG_TCP_MSS=1440
CONFIG_TCP_MSL=60000
CONFIG_TCP_SND_BUF_DEFAULT=5760
CONFIG_TCP_WND_DEFAULT=5760
CONFIG_TCP_RECVMBOX_SIZE=6
CONFIG_TCP_QUEUE_OOSEQ=y
CONFIG_TCP_OVERSIZE_MSS=y
# CONFIG_TCP_OVERSIZE_QUARTER_MSS is not set
# CONFIG_TCP_OVERSIZE_DISABLE is not set
CONFIG_UDP_RECVMBOX_SIZE=6
CONFIG_TCPIP_TASK_STACK_SIZE=3072
CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY=y
# CONFIG_TCPIP_TASK_AFFINITY_CPU0 is not set
CONFIG_TCPIP_TASK_AFFINITY=0x7FFFFFFF
# CONFIG_PPP_SUPPORT is not set
CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF=y
# CONFIG_NEWLIB_STDOUT_LINE_ENDING_LF is not set
# CONFIG_NEWLIB_STDOUT_LINE_ENDING_CR is not set
# CONFIG_NEWLIB_STDIN_LINE_ENDING_CRLF is not set
# CONFIG_NEWLIB_STDIN_LINE_ENDING_LF is not set
CONFIG_NEWLIB_STDIN_LINE_ENDING_CR=y
# CONFIG_NEWLIB_NANO_FORMAT is not set
CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT=y
# CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC is not set
# CONFIG_NEWLIB_TIME_SYSCALL_USE_HRT is not set
# CONFIG_NEWLIB_TIME_SYSCALL_USE_NONE is not set
CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT=5
CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT=3072
CONFIG_ESP32_PTHREAD_STACK_MIN=768
CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT=-1
CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT="pthread"
CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS=y
# CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_FAILS is not set
# CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ALLOWED is not set
CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT=y
CONFIG_SUPPORT_TERMIOS=y
CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS=1
# End of deprecated options

--- END OF FILE: .\sdkconfig ---

--- START OF FILE: .\components\bsp\include\bsp_api.h ---
/* Fecha: 18/08/2025 - 09:01  */
/* Fichero: components/bsp/include/bsp_api.h */
/* √öltimo cambio: A√±adida la declaraci√≥n de bsp_wifi_deinit para la limpieza de recursos. */
/* Descripci√≥n: Interfaz p√∫blica del BSP. Se a√±ade la funci√≥n `bsp_wifi_deinit` para permitir una desinicializaci√≥n completa y segura del stack WiFi. Esto es crucial para liberar memoria y recursos al salir de modos de operaci√≥n que usan la red, como el modo de configuraci√≥n, evitando as√≠ fugas y fallos de asignaci√≥n al reiniciar servicios. */

#ifndef BSP_API_H
#define BSP_API_H

#include "esp_err.h"
#include "esp_lcd_panel_ops.h"
#include "esp_lcd_touch.h"
#include "driver/i2c_master.h"
#include "driver/gpio.h"
#include "esp_wifi.h"
#include <stdint.h> // Para uint16_t

// --- INICIALIZADORES DE HARDWARE ---
esp_err_t bsp_init(void);
esp_err_t bsp_init_service_mode(void);
esp_err_t bsp_init_minimal_headless(void);

// --- INICIALIZADORES DE PERIF√âRICOS INDIVIDUALES ---
esp_err_t bsp_i2c_init(void);
esp_err_t bsp_spi_init(void);
esp_err_t bsp_display_init(void);
esp_err_t bsp_touch_init(void);
esp_err_t bsp_sdcard_init(void);
esp_err_t bsp_imu_init(void);
esp_err_t bsp_battery_init(void);

// --- FUNCIONES DE WIFI ---
void bsp_wifi_init_stack(void);
void bsp_wifi_init_sta(const char *ssid, const char *pass);
void bsp_wifi_start_ap(void);
void bsp_wifi_init_sta_from_nvs(void);
void bsp_wifi_deinit(void); // <-- NUEVA FUNCI√ìN
bool bsp_wifi_wait_for_ip(uint32_t timeout_ms);
void bsp_wifi_get_ip(char *ip);
void bsp_wifi_erase_credentials(void);

// --- FUNCIONES DE CONTROL ---
void bsp_display_set_brightness(int percentage);
void bsp_display_turn_on(void);
void bsp_display_turn_off(void);

// --- FUNCIONES DEL IMU (SENSOR DE MOVIMIENTO) ---
void bsp_imu_read(float acc[3], float gyro[3]);

// --- FUNCIONES DE BATER√çA ---
void bsp_battery_get_voltage(float *voltage, uint16_t *adc_value);

// --- GETTERS DE HANDLES Y CONFIGURACI√ìN ---
i2c_master_bus_handle_t bsp_get_i2c_bus_handle(void);
esp_lcd_panel_io_handle_t bsp_get_panel_io_handle(void);
esp_lcd_panel_handle_t bsp_get_display_handle(void);
esp_lcd_touch_handle_t bsp_get_touch_handle(void);
int bsp_get_display_hres(void);
int bsp_get_display_vres(void);
size_t bsp_get_display_buffer_size(void);

#endif // BSP_API_H

--- END OF FILE: .\components\bsp\include\bsp_api.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\include\esp_lcd_touch_cst816s.h ---
/*
 * SPDX-FileCopyrightText: 2023-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @file
 * @brief ESP LCD touch: CST816S
 */

#pragma once

#include "esp_idf_version.h"
#include "esp_lcd_touch.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Create a new CST816S touch driver
 *
 * @note  The I2C communication should be initialized before use this function.
 *
 * @param io LCD panel IO handle, it should be created by `esp_lcd_new_panel_io_i2c()`
 * @param config Touch panel configuration
 * @param tp Touch panel handle
 * @return
 *      - ESP_OK: on success
 */
esp_err_t esp_lcd_touch_new_i2c_cst816s(const esp_lcd_panel_io_handle_t io, const esp_lcd_touch_config_t *config, esp_lcd_touch_handle_t *tp);

/**
 * @brief I2C address of the CST816S controller
 *
 */
#define ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS    (0x15)

/**
 * @brief Touch IO configuration structure
 *
 */
#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(5, 2, 0)
#define ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG()             \
    {                                                     \
        .dev_addr = ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS, \
        .on_color_trans_done = 0,                         \
        .user_ctx = 0,                                    \
        .control_phase_bytes = 1,                         \
        .dc_bit_offset = 0,                               \
        .lcd_cmd_bits = 8,                                \
        .lcd_param_bits = 0,                              \
        .flags =                                          \
        {                                                 \
            .dc_low_on_data = 0,                          \
            .disable_control_phase = 1,                   \
        }                                                 \
    }
#else
#define ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG()             \
    {                                                     \
        .dev_addr = ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS, \
        .on_color_trans_done = 0,                         \
        .user_ctx = 0,                                    \
        .control_phase_bytes = 1,                         \
        .dc_bit_offset = 0,                               \
        .lcd_cmd_bits = 8,                                \
        .lcd_param_bits = 0,                              \
        .flags =                                          \
        {                                                 \
            .dc_low_on_data = 0,                          \
            .disable_control_phase = 1,                   \
        },                                                \
        .scl_speed_hz = 100000                            \
    }
#endif

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\include\esp_lcd_touch_cst816s.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\main\CMakeLists.txt ---
idf_component_register(SRCS "test_esp_lcd_touch_cst816s.c")

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\main\CMakeLists.txt ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\main\test_esp_lcd_touch_cst816s.c ---
/*
 * SPDX-FileCopyrightText: 2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: CC0-1.0
 */

#include <inttypes.h>
#include "driver/i2c.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "unity.h"
#include "unity_test_runner.h"

#include "esp_lcd_touch_cst816s.h"

#define TEST_TOUCH_I2C_NUM       (0)
#define TEST_TOUCH_I2C_CLK_HZ    (400000)

#define TEST_LCD_H_RES              (240)
#define TEST_LCD_V_RES              (240)

/* LCD touch pins */
#define TEST_TOUCH_I2C_SCL       (GPIO_NUM_18)
#define TEST_TOUCH_I2C_SDA       (GPIO_NUM_8)
#define TEST_TOUCH_GPIO_INT      (GPIO_NUM_3)

TEST_CASE("test cst816s to initialize touch", "[cst816s][i2c]")
{
    /* Initilize I2C */
    const i2c_config_t i2c_conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = TEST_TOUCH_I2C_SDA,
        .sda_pullup_en = GPIO_PULLUP_DISABLE,
        .scl_io_num = TEST_TOUCH_I2C_SCL,
        .scl_pullup_en = GPIO_PULLUP_DISABLE,
        .master.clk_speed = TEST_TOUCH_I2C_CLK_HZ
    };
    TEST_ESP_OK(i2c_param_config(TEST_TOUCH_I2C_NUM, &i2c_conf));
    TEST_ESP_OK(i2c_driver_install(TEST_TOUCH_I2C_NUM, i2c_conf.mode, 0, 0, 0));

    /* Initialize touch HW */
    const esp_lcd_touch_config_t tp_cfg = {
        .x_max = TEST_LCD_H_RES,
        .y_max = TEST_LCD_V_RES,
        .rst_gpio_num = GPIO_NUM_NC, // Shared with LCD reset
        .int_gpio_num = TEST_TOUCH_GPIO_INT,
        .levels = {
            .reset = 0,
            .interrupt = 0,
        },
        .flags = {
            .swap_xy = 0,
            .mirror_x = 1,
            .mirror_y = 0,
        },
    };

    esp_lcd_touch_handle_t touch_handle;
    esp_lcd_panel_io_handle_t tp_io_handle = NULL;
    const esp_lcd_panel_io_i2c_config_t tp_io_config = ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG();
    TEST_ESP_OK(esp_lcd_new_panel_io_i2c((esp_lcd_i2c_bus_handle_t)TEST_TOUCH_I2C_NUM, &tp_io_config, &tp_io_handle));
    TEST_ESP_OK(esp_lcd_touch_new_i2c_cst816s(tp_io_handle, &tp_cfg, &touch_handle));
}

void app_main(void)
{
    printf("CST816S Test\r\n");
    unity_run_menu();
}

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\main\test_esp_lcd_touch_cst816s.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\CMakeLists.txt ---
# The following lines of boilerplate have to be in your project's CMakeLists
# in this exact order for cmake to work correctly
cmake_minimum_required(VERSION 3.5)
set(EXTRA_COMPONENT_DIRS "$ENV{IDF_PATH}/tools/unit-test-app/components")
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(test_esp_lcd_touch_cst816s)

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\CMakeLists.txt ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\CMakeLists.txt ---
idf_component_register(SRCS "esp_lcd_touch_cst816s.c" INCLUDE_DIRS "include" REQUIRES "esp_lcd")

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\CMakeLists.txt ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\esp_lcd_touch_cst816s.c ---
/*
 * SPDX-FileCopyrightText: 2015-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_system.h"
#include "esp_err.h"
#include "esp_log.h"
#include "esp_check.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_touch.h"

#define POINT_NUM_MAX       (1)

#define DATA_START_REG      (0x02)
#define CHIP_ID_REG         (0xA7)

static const char *TAG = "CST816S";

static esp_err_t read_data(esp_lcd_touch_handle_t tp);
static bool get_xy(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num);
static esp_err_t del(esp_lcd_touch_handle_t tp);

static esp_err_t i2c_read_bytes(esp_lcd_touch_handle_t tp, uint16_t reg, uint8_t *data, uint8_t len);

static esp_err_t reset(esp_lcd_touch_handle_t tp);
static esp_err_t read_id(esp_lcd_touch_handle_t tp);

esp_err_t esp_lcd_touch_new_i2c_cst816s(const esp_lcd_panel_io_handle_t io, const esp_lcd_touch_config_t *config, esp_lcd_touch_handle_t *tp)
{
    ESP_RETURN_ON_FALSE(io, ESP_ERR_INVALID_ARG, TAG, "Invalid io");
    ESP_RETURN_ON_FALSE(config, ESP_ERR_INVALID_ARG, TAG, "Invalid config");
    ESP_RETURN_ON_FALSE(tp, ESP_ERR_INVALID_ARG, TAG, "Invalid touch handle");

    /* Prepare main structure */
    esp_err_t ret = ESP_OK;
    esp_lcd_touch_handle_t cst816s = calloc(1, sizeof(esp_lcd_touch_t));
    ESP_GOTO_ON_FALSE(cst816s, ESP_ERR_NO_MEM, err, TAG, "Touch handle malloc failed");

    /* Communication interface */
    cst816s->io = io;
    /* Only supported callbacks are set */
    cst816s->read_data = read_data;
    cst816s->get_xy = get_xy;
    cst816s->del = del;
    /* Mutex */
    cst816s->data.lock.owner = portMUX_FREE_VAL;
    /* Save config */
    memcpy(&cst816s->config, config, sizeof(esp_lcd_touch_config_t));

    /* Prepare pin for touch interrupt */
    if (cst816s->config.int_gpio_num != GPIO_NUM_NC) {
        const gpio_config_t int_gpio_config = {
            .mode = GPIO_MODE_INPUT,
            .intr_type = (cst816s->config.levels.interrupt ? GPIO_INTR_POSEDGE : GPIO_INTR_NEGEDGE),
            .pin_bit_mask = BIT64(cst816s->config.int_gpio_num)
        };
        ESP_GOTO_ON_ERROR(gpio_config(&int_gpio_config), err, TAG, "GPIO intr config failed");

        /* Register interrupt callback */
        if (cst816s->config.interrupt_callback) {
            esp_lcd_touch_register_interrupt_callback(cst816s, cst816s->config.interrupt_callback);
        }
    }
    /* Prepare pin for touch controller reset */
    if (cst816s->config.rst_gpio_num != GPIO_NUM_NC) {
        const gpio_config_t rst_gpio_config = {
            .mode = GPIO_MODE_OUTPUT,
            .pin_bit_mask = BIT64(cst816s->config.rst_gpio_num)
        };
        ESP_GOTO_ON_ERROR(gpio_config(&rst_gpio_config), err, TAG, "GPIO reset config failed");
    }
    /* Reset controller */
    ESP_GOTO_ON_ERROR(reset(cst816s), err, TAG, "Reset failed");
    /* Read product id */
#ifdef CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID
    ESP_LOGI(TAG, "Read ID disabled");
#else
    ESP_GOTO_ON_ERROR(read_id(cst816s), err, TAG, "Read ID failed");
#endif
    *tp = cst816s;

    return ESP_OK;
err:
    if (cst816s) {
        del(cst816s);
    }
    ESP_LOGE(TAG, "Initialization failed!");
    return ret;
}

static esp_err_t read_data(esp_lcd_touch_handle_t tp)
{
    typedef struct {
        uint8_t num;
        uint8_t x_h : 4;
        uint8_t : 4;
        uint8_t x_l;
        uint8_t y_h : 4;
        uint8_t : 4;
        uint8_t y_l;
    } data_t;

    data_t point;
    ESP_RETURN_ON_ERROR(i2c_read_bytes(tp, DATA_START_REG, (uint8_t *)&point, sizeof(data_t)), TAG, "I2C read failed");

    portENTER_CRITICAL(&tp->data.lock);
    point.num = (point.num > POINT_NUM_MAX ? POINT_NUM_MAX : point.num);
    tp->data.points = point.num;
    /* Fill all coordinates */
    for (int i = 0; i < point.num; i++) {
        tp->data.coords[i].x = point.x_h << 8 | point.x_l;
        tp->data.coords[i].y = point.y_h << 8 | point.y_l;
    }
    portEXIT_CRITICAL(&tp->data.lock);

    return ESP_OK;
}

static bool get_xy(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num)
{
    portENTER_CRITICAL(&tp->data.lock);
    /* Count of points */
    *point_num = (tp->data.points > max_point_num ? max_point_num : tp->data.points);
    for (size_t i = 0; i < *point_num; i++) {
        x[i] = tp->data.coords[i].x;
        y[i] = tp->data.coords[i].y;

        if (strength) {
            strength[i] = tp->data.coords[i].strength;
        }
    }
    /* Invalidate */
    tp->data.points = 0;
    portEXIT_CRITICAL(&tp->data.lock);

    return (*point_num > 0);
}

static esp_err_t del(esp_lcd_touch_handle_t tp)
{
    /* Reset GPIO pin settings */
    if (tp->config.int_gpio_num != GPIO_NUM_NC) {
        gpio_reset_pin(tp->config.int_gpio_num);
        if (tp->config.interrupt_callback) {
            gpio_isr_handler_remove(tp->config.int_gpio_num);
        }
    }
    if (tp->config.rst_gpio_num != GPIO_NUM_NC) {
        gpio_reset_pin(tp->config.rst_gpio_num);
    }
    /* Release memory */
    free(tp);

    return ESP_OK;
}

static esp_err_t reset(esp_lcd_touch_handle_t tp)
{
    if (tp->config.rst_gpio_num != GPIO_NUM_NC) {
        ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, tp->config.levels.reset), TAG, "GPIO set level failed");
        vTaskDelay(pdMS_TO_TICKS(200));
        ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, !tp->config.levels.reset), TAG, "GPIO set level failed");
        vTaskDelay(pdMS_TO_TICKS(200));
    }

    return ESP_OK;
}

#ifndef CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID
static esp_err_t read_id(esp_lcd_touch_handle_t tp)
{
    uint8_t id;
    ESP_RETURN_ON_ERROR(i2c_read_bytes(tp, CHIP_ID_REG, &id, 1), TAG, "I2C read failed");
    ESP_LOGI(TAG, "IC id: %d", id);
    return ESP_OK;
}
#endif

static esp_err_t i2c_read_bytes(esp_lcd_touch_handle_t tp, uint16_t reg, uint8_t *data, uint8_t len)
{
    ESP_RETURN_ON_FALSE(data, ESP_ERR_INVALID_ARG, TAG, "Invalid data");

    return esp_lcd_panel_io_rx_param(tp->io, reg, data, len);
}

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\esp_lcd_touch_cst816s.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\Kconfig ---
menu "ESP LCD TOUCH - CST816S"

    config ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID
        bool "Disable reading ID during initialization"
        default n
        help
            For some CST816 series chips, reading ID may cause initialization failure.

endmenu

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\Kconfig ---

--- START OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\README.md ---
# ESP LCD Touch CST816S Controller

[![Component Registry](https://components.espressif.com/components/espressif/esp_lcd_touch_cst816s/badge.svg)](https://components.espressif.com/components/espressif/esp_lcd_touch_cst816s)

Implementation of the CST816S touch controller with esp_lcd_touch component.

| Touch controller | Communication interface |    Component name     |                             Link to datasheet                              |
| :--------------: | :---------------------: | :-------------------: | :------------------------------------------------------------------------: |
|     CST816S      |           I2C           | esp_lcd_touch_cst816s | [datasheet](https://www.buydisplay.com/download/ic/DS-CST816S_DS_V1.3.pdf) |

> [!NOTE]
> * There are two things about the driver are noteworthy (from [document](https://doc.riot-os.org/group__drivers__cst816s.html)):
>   * It only responds to I2C commands after an event, such as a touch detection. Do not expect it to respond on init. Instead after a touch event, it will assert the IRQ and respond to I2C reads for a short time.
>   * While it should be able to detect multiple finger events, this version of the chip always returns only a single finger event and a gesture. Reading the display data multiple times during a single event will return the last sampled finger position.
> * For some chips, reading ID may cause initialization failure. Disable reading ID by setting `CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID` to `y` in `menuconfig`.

## Add to project

Packages from this repository are uploaded to [Espressif's component service](https://components.espressif.com/).
You can add them to your project via `idf.py add-dependancy`, e.g.
```
    idf.py add-dependency esp_lcd_touch_cst816s==1.0.0
```

Alternatively, you can create `idf_component.yml`. More is in [Espressif's documentation](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/tools/idf-component-manager.html).

## Example use

Define a mutex for the touch and create it before initialize the touch:

```
static SemaphoreHandle_t touch_mux;

touch_mux = xSemaphoreCreateBinary();
```

Define a callback function used by ISR:

```
static void touch_callback(esp_lcd_touch_handle_t tp)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(touch_mux, &xHigherPriorityTaskWoken);

    if (xHigherPriorityTaskWoken) {
        portYIELD_FROM_ISR();
    }
}
```

Initialization of the touch component.

```
    esp_lcd_panel_io_i2c_config_t io_config = ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG();

    esp_lcd_touch_config_t tp_cfg = {
        .x_max = CONFIG_LCD_HRES,
        .y_max = CONFIG_LCD_VRES,
        .rst_gpio_num = CONFIG_LCD_TOUCH_RST,
        .int_gpio_num = CONFIG_LCD_TOUCH_INT,
        .levels = {
            .reset = 0,
            .interrupt = 0,
        },
        .flags = {
            .swap_xy = 0,
            .mirror_x = 0,
            .mirror_y = 0,
        },
        .interrupt_callback = touch_callback,
    };

    esp_lcd_touch_handle_t tp;
    esp_lcd_touch_new_i2c_cst816s(io_handle, &tp_cfg, &tp);
```

Read data from the touch controller and store it in RAM memory. It should be called regularly in poll.

```
    if (xSemaphoreTake(touch_mux, 0) == pdTRUE) {
        esp_lcd_touch_read_data(tp); // read only when ISR was triggled
    }
```

Get one X and Y coordinates with strength of touch.

```
    uint16_t touch_x[1];
    uint16_t touch_y[1];
    uint16_t touch_strength[1];
    uint8_t touch_cnt = 0;

    bool touchpad_pressed = esp_lcd_touch_get_coordinates(tp, touch_x, touch_y, touch_strength, &touch_cnt, 1);
```

--- END OF FILE: .\components\bsp\WS1.9TS\esp_lcd_touch_cst816s\README.md ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_battery.c ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_battery.c
 * Fecha: 13/08/2025 - 12:06 
 * √öltimo cambio: Corregido el tipo de retorno de la funci√≥n de inicializaci√≥n.
 * Descripci√≥n: Se ha corregido la firma de la funci√≥n sp_battery_init de oid a sp_err_t
 *              para que coincida con su declaraci√≥n en la API p√∫blica. Esto resuelve un error
 *              cr√≠tico de compilaci√≥n (ESP_ERROR_CHECK sobre una funci√≥n void) que causaba
 *              un reinicio del dispositivo durante el arranque.
 */
#include "bsp_battery.h"

#include "esp_adc/adc_oneshot.h"
#include "esp_adc/adc_cali.h"
#include "esp_adc/adc_cali_scheme.h"


#include "esp_log.h"

static char *TAG = "bsp_battery";


static adc_oneshot_unit_handle_t adc1_handle;
static adc_cali_handle_t adc1_cali_chan0_handle = NULL;
static bool do_calibration1_chan0;


static bool example_adc_calibration_init(adc_unit_t unit, adc_channel_t channel, adc_atten_t atten, adc_cali_handle_t *out_handle)
{
    adc_cali_handle_t handle = NULL;
    esp_err_t ret = ESP_FAIL;
    bool calibrated = false;

#if ADC_CALI_SCHEME_CURVE_FITTING_SUPPORTED
    if (!calibrated)
    {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Curve Fitting");
        adc_cali_curve_fitting_config_t cali_config = {
            .unit_id = unit,
            .chan = channel,
            .atten = atten,
            .bitwidth = ADC_BITWIDTH_DEFAULT,
        };
        ret = adc_cali_create_scheme_curve_fitting(&cali_config, &handle);
        if (ret == ESP_OK)
        {
            calibrated = true;
        }
    }
#endif

#if ADC_CALI_SCHEME_LINE_FITTING_SUPPORTED
    if (!calibrated)
    {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Line Fitting");
        adc_cali_line_fitting_config_t cali_config = {
            .unit_id = unit,
            .atten = atten,
            .bitwidth = ADC_BITWIDTH_DEFAULT,
        };
        ret = adc_cali_create_scheme_line_fitting(&cali_config, &handle);
        if (ret == ESP_OK)
        {
            calibrated = true;
        }
    }
#endif

    *out_handle = handle;
    if (ret == ESP_OK)
    {
        ESP_LOGI(TAG, "Calibration Success");
    }
    else if (ret == ESP_ERR_NOT_SUPPORTED || !calibrated)
    {
        ESP_LOGW(TAG, "eFuse not burnt, skip software calibration");
    }
    else
    {
        ESP_LOGE(TAG, "Invalid arg or no memory");
    }

    return calibrated;
}


esp_err_t bsp_battery_init(void)
{

    adc_oneshot_unit_init_cfg_t init_config1 = {
        .unit_id = EXAMPLE_ADC_UNIT,
    };
    ESP_ERROR_CHECK(adc_oneshot_new_unit(&init_config1, &adc1_handle));
    //-------------ADC1 Config---------------//
    adc_oneshot_chan_cfg_t config = {
        .bitwidth = ADC_BITWIDTH_DEFAULT,
        .atten = EXAMPLE_ADC_ATTEN,
    };
    ESP_ERROR_CHECK(adc_oneshot_config_channel(adc1_handle, EXAMPLE_BATTERY_ADC_CHANNEL, &config));

    //-------------ADC1 Calibration Init---------------//

    do_calibration1_chan0 = example_adc_calibration_init(EXAMPLE_ADC_UNIT, EXAMPLE_BATTERY_ADC_CHANNEL, EXAMPLE_ADC_ATTEN, &adc1_cali_chan0_handle);
    return ESP_OK;
}


void bsp_battery_get_voltage(float *voltage, uint16_t *adc_value)
{
    int adc_raw;
    int voltage_int;
    
    ESP_ERROR_CHECK(adc_oneshot_read(adc1_handle, EXAMPLE_BATTERY_ADC_CHANNEL, &adc_raw));
    
    // ESP_LOGI(TAG, "ADC%d Channel[%d] Raw Data: %d", ADC_UNIT_1 + 1, EXAMPLE_BATTERY_ADC_CHANNEL, adc_raw);
    if (do_calibration1_chan0)
    {
        ESP_ERROR_CHECK(adc_cali_raw_to_voltage(adc1_cali_chan0_handle, adc_raw, &voltage_int));
        *voltage = (voltage_int / 1000.0f) * 3.0; 

        if (adc_value)
        {
            *adc_value = adc_raw;
        }   
    }
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_battery.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_battery.h ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_battery.h
 * Fecha: 13/08/2025 - 12:06 
 * √öltimo cambio: Corregido el tipo de retorno de la funci√≥n de inicializaci√≥n.
 * Descripci√≥n: Cabecera privada para el driver de la bater√≠a. Se ha corregido la firma
 *              de sp_battery_init a sp_err_t para que sea consistente con la
 *              API p√∫blica y evitar un crash en tiempo de ejecuci√≥n.
 */
#ifndef __BSP_BATTERY_H__
#define __BSP_BATTERY_H__
#include <stdio.h>
#include "esp_err.h"
#include <stdint.h>

#define EXAMPLE_ADC_UNIT ADC_UNIT_1
#define EXAMPLE_BATTERY_ADC_CHANNEL ADC_CHANNEL_0
#define EXAMPLE_ADC_ATTEN ADC_ATTEN_DB_12


#ifdef __cplusplus
extern "C" {
#endif

esp_err_t bsp_battery_init(void);
void bsp_battery_get_voltage(float *voltage, uint16_t *adc_value);

#ifdef __cplusplus
}
#endif


#endif

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_battery.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_display.c ---
/*
Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_display.c
Fecha: $timestamp
√öltimo cambio: Modificada la l√≥gica de `bsp_display_set_brightness` para no guardar el estado de atenuaci√≥n (10%) en NVS.
Descripci√≥n: Driver del display. Se ha modificado la funci√≥n de ajuste de brillo para que los cambios autom√°ticos de atenuaci√≥n (al 10%) no sobrescriban el brillo configurado por el usuario en la NVS ni el √∫ltimo nivel de brillo conocido. Esto asegura que al reactivar la pantalla, esta vuelva al estado deseado por el usuario y no al 10%.
*/
#include "bsp_api.h"
#include "esp_log.h"
#include "driver/spi_master.h"
#include "driver/ledc.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_ops.h"
#include "esp_lcd_panel_vendor.h"
#include "nvs_flash.h"
#include "nvs.h"

static const char *TAG = "bsp_display";

#define BSP_SPI_HOST            SPI2_HOST
#define PIN_NUM_LCD_SCLK        5
#define PIN_NUM_LCD_MOSI        4
#define PIN_NUM_LCD_CS          7
#define PIN_NUM_LCD_DC          6
#define PIN_NUM_LCD_RST         14
#define PIN_NUM_LCD_BL          15
#define PIN_NUM_SD_MISO         19
#define BSP_LCD_H_RES           170
#define BSP_LCD_V_RES           320

static esp_lcd_panel_handle_t g_panel_handle = NULL;
static esp_lcd_panel_io_handle_t g_io_handle = NULL;

// Variable est√°tica para guardar el √∫ltimo nivel de brillo
static int s_last_brightness_percentage = 100;

esp_err_t bsp_display_init(void) {
    ESP_LOGI(TAG, "Initializing display...");

    ledc_timer_config_t bl_timer_conf = {
        .speed_mode = LEDC_LOW_SPEED_MODE, .duty_resolution = LEDC_TIMER_8_BIT,
        .timer_num = LEDC_TIMER_0, .freq_hz = 5000, .clk_cfg = LEDC_AUTO_CLK
    };
    ESP_ERROR_CHECK(ledc_timer_config(&bl_timer_conf));
    ledc_channel_config_t bl_channel_conf = {
        .gpio_num = PIN_NUM_LCD_BL, .speed_mode = LEDC_LOW_SPEED_MODE,
        .channel = LEDC_CHANNEL_0, .timer_sel = LEDC_TIMER_0, .duty = 0, .hpoint = 0
    };
    ESP_ERROR_CHECK(ledc_channel_config(&bl_channel_conf));

    // Carga el √∫ltimo nivel de brillo guardado en NVS.
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READONLY, &nvs_handle);
    int32_t saved_brightness = 100; // Valor por defecto si no se encuentra nada.
    if (err == ESP_OK) {
        err = nvs_get_i32(nvs_handle, "brightness", &saved_brightness);
        if (err != ESP_OK) {
            ESP_LOGW(TAG, "No se encontr√≥ brillo en NVS, usando valor por defecto (100).");
            saved_brightness = 100;
        } else {
            ESP_LOGI(TAG, "Brillo cargado desde NVS: %d%%", (int)saved_brightness);
        }
        nvs_close(nvs_handle);
    } else {
        ESP_LOGE(TAG, "Error al abrir NVS para leer brillo: %s", esp_err_to_name(err));
    }
    bsp_display_set_brightness((int)saved_brightness);

    esp_lcd_panel_io_spi_config_t io_config = {
        .cs_gpio_num = PIN_NUM_LCD_CS, .dc_gpio_num = PIN_NUM_LCD_DC,
        .spi_mode = 0, .pclk_hz = 40 * 1000 * 1000, .trans_queue_depth = 10,
        .lcd_cmd_bits = 8, .lcd_param_bits = 8
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi((esp_lcd_spi_bus_handle_t)BSP_SPI_HOST, &io_config, &g_io_handle));

    esp_lcd_panel_dev_config_t panel_config = {
        .reset_gpio_num = PIN_NUM_LCD_RST, .bits_per_pixel = 16,
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_st7789(g_io_handle, &panel_config, &g_panel_handle));
    
    esp_lcd_panel_reset(g_panel_handle);
    esp_lcd_panel_init(g_panel_handle);
    
    esp_lcd_panel_swap_xy(g_panel_handle, true);
    esp_lcd_panel_mirror(g_panel_handle, false, true);
    esp_lcd_panel_set_gap(g_panel_handle, 35, 0); 
    esp_lcd_panel_invert_color(g_panel_handle, true);

    esp_lcd_panel_disp_on_off(g_panel_handle, true);
    
    ESP_LOGI(TAG, "Display initialized and rotated by driver to 170x320.");
    return ESP_OK;
}

void bsp_display_set_brightness(int percentage) {
    if (percentage > 100) percentage = 100;
    if (percentage < 0) percentage = 0;

    // Calcula y establece el ciclo de trabajo del PWM para el backlight.
    uint32_t duty = 255 - ((255 * percentage) / 100);
    ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);

    // El valor 10% es el nivel de atenuaci√≥n autom√°tica por inactividad.
    // No se debe guardar en NVS ni como √∫ltimo brillo conocido del usuario.
    if (percentage == 10) {
        ESP_LOGD(TAG, "Atenuando pantalla temporalmente a 10%%. No se guarda el estado.");
        return;
    }

    // Guarda el √∫ltimo nivel de brillo (si es > 0) para la funci√≥n de re-encendido.
    if (percentage > 0) {
        s_last_brightness_percentage = percentage;
    }

    // Guarda el nuevo nivel de brillo en la memoria no vol√°til (NVS).
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err == ESP_OK) {
        err = nvs_set_i32(nvs_handle, "brightness", (int32_t)percentage);
        if (err == ESP_OK) {
            nvs_commit(nvs_handle);
            ESP_LOGD(TAG, "Brillo de usuario (%d%%) guardado en NVS.", percentage);
        } else {
            ESP_LOGE(TAG, "Error al guardar brillo en NVS: %s", esp_err_to_name(err));
        }
        nvs_close(nvs_handle);
    } else {
        ESP_LOGE(TAG, "Error al abrir NVS para guardar brillo: %s", esp_err_to_name(err));
    }
}

void bsp_display_turn_on(void) {
    ESP_LOGI(TAG, "Turning display ON and restoring brightness to %d%%", s_last_brightness_percentage);
    // 1. Restaurar el brillo (sin guardar estado, ya que se restaura uno existente)
    uint32_t duty = 255 - ((255 * s_last_brightness_percentage) / 100);
    ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);
    // 2. Encender el panel
    esp_lcd_panel_disp_on_off(g_panel_handle, true);
}

void bsp_display_turn_off(void) {
    ESP_LOGI(TAG, "Turning display and backlight OFF");
    // 1. Apagar el panel
    esp_lcd_panel_disp_on_off(g_panel_handle, false);
    // 2. Apagar el backlight directamente para no llamar a set_brightness
    uint32_t duty = 255; // Duty 255 es 0% de brillo en mi configuraci√≥n invertida
    ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);
}

esp_lcd_panel_handle_t bsp_get_display_handle(void) { return g_panel_handle; }
esp_lcd_panel_io_handle_t bsp_get_panel_io_handle(void) { return g_io_handle; }
int bsp_get_display_hres(void) { return BSP_LCD_H_RES; }
int bsp_get_display_vres(void) { return BSP_LCD_V_RES; }
size_t bsp_get_display_buffer_size(void) { return BSP_LCD_H_RES * 20; }

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_display.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_display.h ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_display.h
 * Fecha: 12/08/2025 - 11:46
 * √öltimo cambio: A√±adidas las declaraciones para encendido/apagado del display.
 * Descripci√≥n: Cabecera privada para el driver del display. Se a√±aden las declaraciones de las funciones que controlan el estado de encendido del panel.
 */
#ifndef BSP_DISPLAY_H
#define BSP_DISPLAY_H

#include "esp_err.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_ops.h"

#ifdef __cplusplus
extern "C" {
#endif

// Constantes de la pantalla
#define BSP_LCD_H_RES           170
#define BSP_LCD_V_RES           320

// Funciones exportadas por bsp_display.c
esp_err_t bsp_display_init(void);
void bsp_display_set_brightness(int percentage);
void bsp_display_turn_on(void);
void bsp_display_turn_off(void);
esp_lcd_panel_handle_t bsp_get_display_handle(void);
esp_lcd_panel_io_handle_t bsp_get_panel_io_handle(void);
int bsp_get_display_hres(void);
int bsp_get_display_vres(void);
size_t bsp_get_display_buffer_size(void);

#ifdef __cplusplus
}
#endif

#endif // BSP_DISPLAY_H
--- END OF FILE: .\components\bsp\WS1.9TS\bsp_display.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_i2c.c ---
/*
 * Fichero: ./diymon_bsp/WS1.9TS/bsp_i2c.c
 * Fecha: 12/08/2025 - 05:05 pm
 * √öltimo cambio: Implementada la inicializaci√≥n idempotente.
 * Descripci√≥n: Centraliza la inicializaci√≥n del bus I2C. La funci√≥n sp_i2c_init es ahora idempotente, lo que significa que puede ser llamada m√∫ltiples veces de forma segura, pero solo ejecutar√° la inicializaci√≥n del bus la primera vez, evitando errores de reinicializaci√≥n.
 */
#include "bsp_api.h"
#include "esp_log.h"
#include "driver/i2c_master.h"

static const char *TAG = "bsp_i2c";

// Pines definidos para el bus I2C
#define PIN_I2C_SCL      8
#define PIN_I2C_SDA      18
#define I2C_PORT_NUM     I2C_NUM_0
#define I2C_CLK_SPEED_HZ 400000

// Variable est√°tica para almacenar el manejador del bus I2C
static i2c_master_bus_handle_t g_bus_handle = NULL;
// Bandera para asegurar la inicializaci√≥n √∫nica (idempotencia)
static bool g_i2c_bus_initialized = false;

esp_err_t bsp_i2c_init(void)
{
    if (g_i2c_bus_initialized) {
        ESP_LOGD(TAG, "I2C master bus ya est√° inicializado.");
        return ESP_OK;
    }

    ESP_LOGI(TAG, "Initializing I2C master bus (Modern API)...");

    i2c_master_bus_config_t i2c_bus_config = {
        .i2c_port = I2C_PORT_NUM,
        .sda_io_num = PIN_I2C_SDA,
        .scl_io_num = PIN_I2C_SCL,
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .glitch_ignore_cnt = 7,
        .flags.enable_internal_pullup = true,
    };
    
    ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_config, &g_bus_handle));

    g_i2c_bus_initialized = true;
    ESP_LOGI(TAG, "I2C bus initialized successfully.");
    return ESP_OK;
}

i2c_master_bus_handle_t bsp_get_i2c_bus_handle(void)
{
    return g_bus_handle;
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_i2c.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_i2c.h ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_i2c.h
 * Fecha: 13/08/2025 - 05:00 
 * √öltimo cambio: Corregido el contenido del fichero.
 * Descripci√≥n: Cabecera privada para el m√≥dulo I2C del BSP. Se ha corregido un error de copiado y pegado que conten√≠a declaraciones incorrectas.
 */
#ifndef BSP_I2C_H__
#define BSP_I2C_H__

// Este es un header privado. Las declaraciones p√∫blicas est√°n en bsp_api.h.

#endif // BSP_I2C_H__

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_i2c.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_qmi8658.c ---
/*
  Fichero: ./components/diymon_bsp/WS1.9TS/bsp_qmi8658.c
  Fecha: 13/08/2025 - 12:03 
  √öltimo cambio: Eliminadas las funciones de interrupci√≥n no utilizadas.
  Descripci√≥n: Driver del IMU. Se han eliminado las implementaciones de las funciones
               de interrupci√≥n (bsp_imu_interrupt_init, bsp_imu_enable_motion_interrupt,
               bsp_imu_clear_interrupt) para limpiar el c√≥digo, ya que la detecci√≥n
               de 'shake' ahora se realiza por sondeo en la capa de la UI.
*/
#include "bsp_api.h"
#include "bsp_qmi8658.h"
#include "esp_log.h"
#include "driver/i2c_master.h"
#include "driver/gpio.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static const char *TAG = "bsp_qmi8658";

#define IMU_I2C_ADDRESS  0x6B
#define I2C_CLK_SPEED_HZ 400000

static i2c_master_dev_handle_t g_imu_dev_handle = NULL;

// --- Funciones de ayuda est√°ticas ---
static void qmi8658_on_demand_cali(void) {
    ESP_LOGI(TAG, "Performing on-demand calibration...");
    
    uint8_t reset_buf[] = {QMI8658_RESET, 0xb0};
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, reset_buf, sizeof(reset_buf), pdMS_TO_TICKS(100)));
    vTaskDelay(pdMS_TO_TICKS(20));

    uint8_t cali_cmd_buf[] = {QMI8658_CTRL9, QMI8658_CTRL9_CMD_ON_DEMAND_CALI};
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, cali_cmd_buf, sizeof(cali_cmd_buf), pdMS_TO_TICKS(100)));
    
    vTaskDelay(pdMS_TO_TICKS(2200));

    uint8_t nop_cmd_buf[] = {QMI8658_CTRL9, QMI8658_CTRL9_CMD_NOP};
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, nop_cmd_buf, sizeof(nop_cmd_buf), pdMS_TO_TICKS(100)));
    vTaskDelay(pdMS_TO_TICKS(100));

    ESP_LOGI(TAG, "On-demand calibration finished.");
}


// --- Funciones p√∫blicas ---

esp_err_t bsp_imu_init(void)
{
    ESP_LOGI(TAG, "Initializing IMU QMI8658 with Modern I2C API...");
    
    i2c_master_bus_handle_t bus_handle = bsp_get_i2c_bus_handle();
    if (bus_handle == NULL) {
        ESP_LOGE(TAG, "I2C bus handle is not initialized!");
        return ESP_FAIL;
    }

    i2c_device_config_t dev_cfg = {
        .device_address = IMU_I2C_ADDRESS,
        .scl_speed_hz = I2C_CLK_SPEED_HZ,
    };
    
    ESP_ERROR_CHECK(i2c_master_bus_add_device(bus_handle, &dev_cfg, &g_imu_dev_handle));
    ESP_LOGI(TAG, "IMU device added to I2C bus successfully.");

    uint8_t who_am_i = 0;
    ESP_ERROR_CHECK(i2c_master_transmit_receive(g_imu_dev_handle, 
                                                (uint8_t[]){QMI8658_WHO_AM_I}, 1, 
                                                &who_am_i, 1, 
                                                pdMS_TO_TICKS(100)));

    if (who_am_i != 0x05) {
        ESP_LOGE(TAG, "QMI8658 not found! WhoAmI check failed. Read value: 0x%02X", who_am_i);
        return ESP_FAIL;
    }
    ESP_LOGI(TAG, "QMI8658 found successfully! WhoAmI: 0x%02X", who_am_i);

    qmi8658_on_demand_cali();
    
    uint8_t ctrl1_buf[] = {QMI8658_CTRL1, 0x60}; // Habilitar Address Auto-Increment
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, ctrl1_buf, sizeof(ctrl1_buf), pdMS_TO_TICKS(100)));

    uint8_t ctrl_regs_data[][2] = {
        {QMI8658_CTRL7, 0x03}, // Habilitar Accel y Gyro
        {QMI8658_CTRL2, 0x23}, // Accel: +-8g, 250Hz ODR
        {QMI8658_CTRL3, 0x53}  // Gyro:  +-1024dps, 250Hz ODR
    };

    for (int i = 0; i < sizeof(ctrl_regs_data) / sizeof(ctrl_regs_data[0]); i++) {
        ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, ctrl_regs_data[i], 2, pdMS_TO_TICKS(100)));
    }
    
    ESP_LOGI(TAG, "IMU initialized.");
    return ESP_OK;
}

void bsp_imu_read(float acc[3], float gyro[3])
{
    if (g_imu_dev_handle == NULL) {
        ESP_LOGE(TAG, "IMU device handle not initialized, cannot read.");
        acc[0] = acc[1] = acc[2] = 0;
        gyro[0] = gyro[1] = gyro[2] = 0;
        return;
    }

    uint8_t buf_reg[12];
    short raw_acc_xyz[3];
    short raw_gyro_xyz[3];

    esp_err_t ret = i2c_master_transmit_receive(g_imu_dev_handle,
                                (uint8_t[]){QMI8658_AX_L}, 1,
                                buf_reg, 12,
                                pdMS_TO_TICKS(100));

    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to read IMU data via I2C");
        acc[0] = acc[1] = acc[2] = 0;
        gyro[0] = gyro[1] = gyro[2] = 0;
        return;
    }

    raw_acc_xyz[0] = (int16_t)((buf_reg[1] << 8) | buf_reg[0]);
    raw_acc_xyz[1] = (int16_t)((buf_reg[3] << 8) | buf_reg[2]);
    raw_acc_xyz[2] = (int16_t)((buf_reg[5] << 8) | buf_reg[4]);
    raw_gyro_xyz[0] = (int16_t)((buf_reg[7] << 8) | buf_reg[6]);
    raw_gyro_xyz[1] = (int16_t)((buf_reg[9] << 8) | buf_reg[8]);
    raw_gyro_xyz[2] = (int16_t)((buf_reg[11] << 8) | buf_reg[10]);

    // Conversi√≥n a m/s^2 (+-8g)
    acc[0] = ((float)raw_acc_xyz[0] / 4096.0f) * 9.81f;
    acc[1] = ((float)raw_acc_xyz[1] / 4096.0f) * 9.81f;
    acc[2] = ((float)raw_acc_xyz[2] / 4096.0f) * 9.81f;
    
    // Conversi√≥n a dps (+-1024dps)
    gyro[0] = (float)raw_gyro_xyz[0] / 32.0f;
    gyro[1] = (float)raw_gyro_xyz[1] / 32.0f;
    gyro[2] = (float)raw_gyro_xyz[2] / 32.0f;
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_qmi8658.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_qmi8658.h ---
/*
 * Fichero: ./diymon_bsp/WS1.9TS/bsp_qmi8658.h
 * Fecha: 12/08/2025 - 09:25 pm
 * √öltimo cambio: Corregidos los valores de los registros y a√±adidos los de calibraci√≥n.
 * Descripci√≥n: Cabecera privada para el sensor QMI8658. Se han corregido las direcciones
 *              de los registros de datos (temperatura, aceler√≥metro, etc.) para que coincidan
 *              con la hoja de datos oficial y se han a√±adido los registros y comandos
 *              necesarios para la calibraci√≥n y configuraci√≥n avanzada del sensor.
 */
#ifndef BSP_QMI8658_H
#define BSP_QMI8658_H

#include <stdint.h>

// Definici√≥n de los registros del sensor QMI8658 (corregidos seg√∫n datasheet)
typedef enum
{
    QMI8658_WHO_AM_I        = 0x00,
    QMI8658_REVISION_ID     = 0x01,
    QMI8658_CTRL1           = 0x02,
    QMI8658_CTRL2           = 0x03,
    QMI8658_CTRL3           = 0x04,
    QMI8658_CTRL4           = 0x05,
    QMI8658_CTRL5           = 0x06,
    QMI8658_CTRL6           = 0x07,
    QMI8658_CTRL7           = 0x08,
    QMI8658_CTRL9           = 0x0A,
    QMI8658_CAL1_L          = 0x0B,
    QMI8658_STATUS_INT      = 0x2D,
    QMI8658_TEMP_L          = 0x33,
    QMI8658_TEMP_H          = 0x34,
    QMI8658_AX_L            = 0x35,
    QMI8658_AX_H            = 0x36,
    QMI8658_AY_L            = 0x37,
    QMI8658_AY_H            = 0x38,
    QMI8658_AZ_L            = 0x39,
    QMI8658_AZ_H            = 0x3A,
    QMI8658_GX_L            = 0x3B,
    QMI8658_GX_H            = 0x3C,
    QMI8658_GY_L            = 0x3D,
    QMI8658_GY_H            = 0x3E,
    QMI8658_GZ_L            = 0x3F,
    QMI8658_GZ_H            = 0x40,
    QMI8658_RESET           = 0x60
} qmi8658_reg_t;

// Comandos para el registro CTRL9
typedef enum {
    QMI8658_CTRL9_CMD_NOP = 0x00,
    QMI8658_CTRL9_CMD_ON_DEMAND_CALI = 0xA2,
} qmi8658_ctrl9_cmd_t;

#endif // BSP_QMI8658_H

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_qmi8658.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_sdcard.c ---
/*
 * Archivo: components/diymon_bsp/WS1.9TS/bsp_sdcard.c
 * Versi√≥n: Final (con max_files aumentado)
 */
#include "bsp_api.h"
#include "esp_log.h"
#include "esp_vfs_fat.h"
#include "sdmmc_cmd.h"
#include "driver/sdspi_host.h"
#include "driver/spi_common.h"
#include "bsp_sdcard.h" 

static const char *TAG = "bsp_sdcard";

// --- CONFIGURACI√ìN PRIVADA ---
#define PIN_NUM_MISO  (GPIO_NUM_19)
#define PIN_NUM_MOSI  (GPIO_NUM_4)
#define PIN_NUM_CLK   (GPIO_NUM_5)
#define PIN_NUM_CS    (GPIO_NUM_20)
#define MOUNT_POINT   "/sdcard"

static sdmmc_card_t *g_card = NULL;
static sdmmc_host_t g_host = SDSPI_HOST_DEFAULT();

// --- IMPLEMENTACI√ìN DE LA FUNCI√ìN P√öBLICA ---
esp_err_t bsp_sdcard_init(void)
{
    ESP_LOGI(TAG, "Initializing SD card...");
    esp_err_t ret;

    // 1. Configurar el sistema de ficheros FAT que se va a montar
    esp_vfs_fat_sdmmc_mount_config_t mount_config = {
        .format_if_mount_failed = false,
        // [CAMBIO CLAVE] Aumentamos el l√≠mite para permitir la navegaci√≥n por subdirectorios.
        .max_files = 10,  // <-- El √∫nico cambio est√° aqu√≠. Antes era 5.
        .allocation_unit_size = 16 * 1024
    };

    g_host.slot = SPI2_HOST;

    sdspi_device_config_t slot_config = SDSPI_DEVICE_CONFIG_DEFAULT();
    slot_config.gpio_cs = PIN_NUM_CS;
    slot_config.host_id = SPI2_HOST;

    ret = esp_vfs_fat_sdspi_mount(MOUNT_POINT, &g_host, &slot_config, &mount_config, &g_card);

    if (ret != ESP_OK) {
        if (ret == ESP_FAIL) {
            ESP_LOGE(TAG, "Failed to mount filesystem.");
        } else {
            ESP_LOGE(TAG, "Failed to initialize the card (%s).", esp_err_to_name(ret));
        }
        return ret;
    }
    
    sdmmc_card_print_info(stdout, g_card);
    ESP_LOGI(TAG, "SD card initialized successfully!");
    
    return ESP_OK;
}
--- END OF FILE: .\components\bsp\WS1.9TS\bsp_sdcard.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_sdcard.h ---
/*
 * Fichero: bsp_sdcard.h
 * Fecha: 08/08/2025
 * √öltimo cambio: A√±adida la declaraci√≥n de bsp_sdcard_init.
 * Descripci√≥n: Interfaz p√∫blica para el controlador de la tarjeta SD.
 */
#ifndef __BSP_SDCARD_H_
#define __BSP_SDCARD_H_

#include "esp_err.h"
#include <stdint.h> // Para uint64_t

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el bus SPI y monta el sistema de ficheros FAT en la tarjeta SD.
 * 
 * @return esp_err_t 
 *         - ESP_OK si la inicializaci√≥n y el montaje son exitosos.
 *         - ESP_FAIL u otros c√≥digos de error si algo falla.
 */
esp_err_t bsp_sdcard_init(void);

/**
 * @brief Obtiene el tama√±o total de la tarjeta SD en bytes.
 * 
 * @note Esta funci√≥n debe ser llamada despu√©s de una inicializaci√≥n exitosa.
 * @return uint64_t Tama√±o de la tarjeta en bytes.
 */
uint64_t bsp_sdcard_get_size(void);


#ifdef __cplusplus
}
#endif

#endif // __BSP_SDCARD_H_
--- END OF FILE: .\components\bsp\WS1.9TS\bsp_sdcard.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_spi.c ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_spi.c
 * Fecha: 12/08/2025 - 05:05 pm
 * √öltimo cambio: Implementada la inicializaci√≥n idempotente.
 * Descripci√≥n: Driver para la inicializaci√≥n del bus SPI. La funci√≥n sp_spi_init es ahora idempotente, asegurando que el bus SPI solo se inicializa una vez, previniendo crashes por m√∫ltiples llamadas.
 */
#include "bsp_api.h"
#include "esp_log.h"
#include "driver/spi_master.h"
#include "bsp_display.h" 

static const char *TAG = "bsp_spi";

#define BSP_SPI_HOST            SPI2_HOST
#define PIN_NUM_SPI_SCLK        5
#define PIN_NUM_SPI_MOSI        4
#define PIN_NUM_SPI_MISO        19 

// Bandera para asegurar la inicializaci√≥n √∫nica (idempotencia)
static bool g_spi_bus_initialized = false;

esp_err_t bsp_spi_init(void) {
    if (g_spi_bus_initialized) {
        ESP_LOGD(TAG, "SPI bus (Host: %d) ya est√° inicializado.", BSP_SPI_HOST);
        return ESP_OK;
    }

    ESP_LOGI(TAG, "Initializing main SPI bus (Host: %d)...", BSP_SPI_HOST);

    spi_bus_config_t buscfg = {
        .sclk_io_num = PIN_NUM_SPI_SCLK, 
        .mosi_io_num = PIN_NUM_SPI_MOSI,
        .miso_io_num = PIN_NUM_SPI_MISO, 
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = BSP_LCD_H_RES * 100 * sizeof(uint16_t)
    };
    
    esp_err_t ret = spi_bus_initialize(BSP_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize SPI bus!");
    } else {
        g_spi_bus_initialized = true;
        ESP_LOGI(TAG, "SPI bus initialized successfully.");
    }

    return ret;
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_spi.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_touch.c ---
/*
  Fichero: ./components/diymon_bsp/WS1.9TS/bsp_touch.c
  Fecha: 12/08/2025 - 09:00
  √öltimo cambio: Corregido para usar el bus I2C global en lugar de pasarlo.
  Descripci√≥n: Driver del panel t√°ctil CST816S. Ahora utiliza la funci√≥n p√∫blica
               `bsp_get_i2c_bus_handle` para obtener el manejador del bus I2C.
*/
#include "bsp_api.h"
#include "esp_log.h"
#include "esp_lcd_touch_cst816s.h"

static const char *TAG = "bsp_touch";
static esp_lcd_touch_handle_t g_touch_handle = NULL;

esp_err_t bsp_touch_init(void)
{
    ESP_LOGI(TAG, "Initializing touch controller CST816S (Modern API)...");

    i2c_master_bus_handle_t bus_handle = bsp_get_i2c_bus_handle();
    if (bus_handle == NULL) {
        ESP_LOGE(TAG, "I2C bus handle is not initialized!");
        return ESP_FAIL;
    }

    esp_lcd_panel_io_handle_t tp_io_handle = NULL;
    const esp_lcd_panel_io_i2c_config_t tp_io_config = {
        .dev_addr = ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS,
        .control_phase_bytes = 1,
        .lcd_cmd_bits = 8,
        .lcd_param_bits = 8,
        .scl_speed_hz = 400000,
        .flags = {
            .dc_low_on_data = 0,
            .disable_control_phase = 1,
        }
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_io_i2c(bus_handle, &tp_io_config, &tp_io_handle));

    const esp_lcd_touch_config_t tp_cfg = {
        .x_max = 170,
        .y_max = 320,
        .rst_gpio_num = GPIO_NUM_NC,
        .int_gpio_num = GPIO_NUM_NC,
    };
    ESP_ERROR_CHECK(esp_lcd_touch_new_i2c_cst816s(tp_io_handle, &tp_cfg, &g_touch_handle));
    
    ESP_LOGI(TAG, "Touch driver initialized successfully.");
    return ESP_OK;
}

esp_lcd_touch_handle_t bsp_get_touch_handle(void)
{
    return g_touch_handle;
}
--- END OF FILE: .\components\bsp\WS1.9TS\bsp_touch.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_touch.h ---
/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_touch.h
 * Fecha: 13/08/2025 - 05:00 
 * √öltimo cambio: Corregido el header del driver de touch.
 * Descripci√≥n: Cabecera privada para el m√≥dulo t√°ctil. Se ha corregido la inclusi√≥n de la cabecera del driver para que apunte a cst816s en lugar de axs5106 y se han eliminado defines no utilizados.
 */
#ifndef BSP_TOUCH_H__
#define BSP_TOUCH_H__

#include "driver/i2c_master.h"
#include "esp_lcd_touch_cst816s.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif

#endif // BSP_TOUCH_H__

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_touch.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_wifi.c ---
/* Fecha: 18/08/2025 - 09:01  */
/* Fichero: components/bsp/WS1.9TS/bsp_wifi.c */
/* √öltimo cambio: A√±adida la funci√≥n bsp_wifi_deinit para una limpieza completa de recursos. */
/* Descripci√≥n: Se ha implementado `bsp_wifi_deinit` para desregistrar los manejadores de eventos y liberar la memoria del sem√°foro. Esto resuelve un problema de fuga de recursos que ocurr√≠a al salir del modo de configuraci√≥n y asegura que el sistema WiFi pueda reinicializarse de forma limpia, evitando el fallo de asignaci√≥n del buffer de animaci√≥n. */

#include "bsp_api.h"
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "freertos/semphr.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "lwip/err.h"
#include "lwip/sys.h"
#include <assert.h>

#define PORTAL_AP_SSID          "DIYTogether"
#define PORTAL_AP_PASS          "MakeItYours"
#define PORTAL_AP_CHANNEL       1
#define PORTAL_AP_MAX_CONN      4

static const char *TAG = "bsp_wifi";
static SemaphoreHandle_t s_ip_acquired_sem = NULL;
static bool g_network_stack_initialized = false;
static esp_event_handler_instance_t s_wifi_event_instance;
static esp_event_handler_instance_t s_ip_event_instance;

static void event_handler(void* arg, esp_event_base_t event_base,
                                int32_t event_id, void* event_data)
{
    if (event_base == WIFI_EVENT) {
        switch(event_id) {
            case WIFI_EVENT_STA_START:
                esp_wifi_connect();
                break;
            case WIFI_EVENT_STA_CONNECTED:
                ESP_LOGI(TAG, "Conectado al AP, esperando IP.");
                break;
            case WIFI_EVENT_STA_DISCONNECTED: {
                vTaskDelay(pdMS_TO_TICKS(1000));
                ESP_LOGI(TAG, "Reintentando conexi√≥n...");
                esp_wifi_connect();
                break;
            }
            default:
                break;
        }
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "¬°IP Obtenida!: " IPSTR, IP2STR(&event->ip_info.ip));
        if (s_ip_acquired_sem) {
            xSemaphoreGive(s_ip_acquired_sem);
        }
    }
}

void bsp_wifi_init_stack(void) {
    if (g_network_stack_initialized) {
        ESP_LOGD(TAG, "El stack de red ya ha sido inicializado.");
        return;
    }
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    g_network_stack_initialized = true;
    ESP_LOGI(TAG, "Stack de red (netif, event loop) inicializado por primera vez.");
}

void bsp_wifi_start_ap(void) {
    esp_netif_create_default_wifi_ap();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    wifi_config_t wifi_config = {
        .ap = {
            .ssid = PORTAL_AP_SSID, .ssid_len = strlen(PORTAL_AP_SSID),
            .channel = PORTAL_AP_CHANNEL, .password = PORTAL_AP_PASS,
            .max_connection = PORTAL_AP_MAX_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK
        },
    };
    if (strlen(PORTAL_AP_PASS) == 0) {
        wifi_config.ap.authmode = WIFI_AUTH_OPEN;
    }

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());
}

void bsp_wifi_init_sta_from_nvs(void) {
    esp_netif_create_default_wifi_sta();
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &event_handler, NULL, &s_wifi_event_instance));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &event_handler, NULL, &s_ip_event_instance));

    s_ip_acquired_sem = xSemaphoreCreateBinary();

    char ssid[32] = {0}, pass[64] = {0};
    size_t len_ssid = sizeof(ssid), len_pass = sizeof(pass);

    nvs_handle_t nvs_handle;
    if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
        nvs_get_str(nvs_handle, "wifi_ssid", ssid, &len_ssid);
        nvs_get_str(nvs_handle, "wifi_pass", pass, &len_pass);
        nvs_close(nvs_handle);
    }

    if (len_ssid > 1) {
        wifi_config_t wifi_config = {0};
        strcpy((char *)wifi_config.sta.ssid, ssid);
        strcpy((char *)wifi_config.sta.password, pass);
        wifi_config.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;
        
        ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
        ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
        ESP_ERROR_CHECK(esp_wifi_start());
    }
}

bool bsp_wifi_wait_for_ip(uint32_t timeout_ms) {
    if (!s_ip_acquired_sem) return false;
    return (xSemaphoreTake(s_ip_acquired_sem, pdMS_TO_TICKS(timeout_ms)) == pdTRUE);
}

void bsp_wifi_get_ip(char *ip) {
    esp_netif_t* netif = esp_netif_get_handle_from_ifkey("WIFI_STA_DEF");
    if(netif) {
        esp_netif_ip_info_t ip_info;
        esp_netif_get_ip_info(netif, &ip_info);
        sprintf(ip, IPSTR, IP2STR(&ip_info.ip));
    }
}

void bsp_wifi_init_sta(const char *ssid, const char *pass) {
    esp_netif_create_default_wifi_sta();
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &event_handler, NULL, &s_wifi_event_instance));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &event_handler, NULL, &s_ip_event_instance));

    s_ip_acquired_sem = xSemaphoreCreateBinary();

    if (ssid && strlen(ssid) > 0) {
        wifi_config_t wifi_config = {0};
        strcpy((char *)wifi_config.sta.ssid, ssid);
        if (pass) { strcpy((char *)wifi_config.sta.password, pass); }
        wifi_config.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;

        ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
        ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
        ESP_ERROR_CHECK(esp_wifi_start());
    }
}

void bsp_wifi_deinit(void) {
    ESP_LOGI(TAG, "Desinicializando WiFi y liberando recursos...");
    // Detener WiFi
    esp_wifi_stop();
    
    // Desregistrar manejadores de eventos
    if (s_wifi_event_instance) {
        esp_event_handler_instance_unregister(WIFI_EVENT, ESP_EVENT_ANY_ID, s_wifi_event_instance);
        s_wifi_event_instance = NULL;
    }
    if (s_ip_event_instance) {
        esp_event_handler_instance_unregister(IP_EVENT, IP_EVENT_STA_GOT_IP, s_ip_event_instance);
        s_ip_event_instance = NULL;
    }
    
    // Liberar recursos de WiFi
    esp_wifi_deinit();
    
    // Liberar sem√°foro
    if (s_ip_acquired_sem) {
        vSemaphoreDelete(s_ip_acquired_sem);
        s_ip_acquired_sem = NULL;
    }

    // Destruir interfaces de red
    esp_netif_t* sta_netif = esp_netif_get_handle_from_ifkey("WIFI_STA_DEF");
    if (sta_netif) {
        esp_netif_destroy(sta_netif);
    }
    esp_netif_t* ap_netif = esp_netif_get_handle_from_ifkey("WIFI_AP_DEF");
    if (ap_netif) {
        esp_netif_destroy(ap_netif);
    }

    ESP_LOGI(TAG, "WiFi desinicializado y recursos liberados.");
}

void bsp_wifi_erase_credentials(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) abriendo NVS para borrar credenciales.", esp_err_to_name(err));
        return;
    }
    nvs_erase_key(nvs_handle, "wifi_ssid");
    nvs_erase_key(nvs_handle, "wifi_pass");
    nvs_erase_key(nvs_handle, "wifi_authmode");
    nvs_commit(nvs_handle);
    nvs_close(nvs_handle);
    ESP_LOGI(TAG, "Credenciales WiFi borradas de NVS.");
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_wifi.c ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp_wifi.h ---
/*
  Fichero: ./components/diymon_bsp/WS1.9TS/bsp_wifi.h
  Fecha: 12/08/2025 - 05:05 pm
  √öltimo cambio: Actualizadas las declaraciones de funciones para reflejar la implementaci√≥n.
  Descripci√≥n: Interfaz p√∫blica del gestor WiFi del BSP. Se han corregido las declaraciones para que coincidan con las funciones realmente exportadas por sp_wifi.c, resolviendo posibles errores de 'implicit declaration'.
*/
#ifndef __BSP_WIFI_H__
#define __BSP_WIFI_H__

#include "esp_err.h"
#include "esp_wifi.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el stack de red (netif y event loop).
 */
void bsp_wifi_init_stack(void);

/**
 * @brief Escanea redes WiFi disponibles y las muestra en el log.
 * @return ESP_OK si el escaneo fue exitoso.
 */
esp_err_t bsp_wifi_scan(void);

/**
 * @brief Inicia el dispositivo en modo Punto de Acceso (AP).
 */
void bsp_wifi_start_ap(void);

/**
 * @brief Inicia el dispositivo en modo Estaci√≥n (STA) usando credenciales de NVS.
 */
void bsp_wifi_init_sta_from_nvs(void);

/**
 * @brief Espera de forma bloqueante hasta obtener una direcci√≥n IP.
 * @param timeout_ms Tiempo m√°ximo de espera en milisegundos.
 * @return true si se obtuvo IP, false en caso de timeout.
 */
bool bsp_wifi_wait_for_ip(uint32_t timeout_ms);

/**
 * @brief Obtiene la direcci√≥n IP actual del dispositivo en modo STA.
 * @param ip Puntero a un buffer de caracteres donde se escribir√° la IP.
 */
void bsp_wifi_get_ip(char *ip);

#ifdef __cplusplus
}
#endif

#endif // __BSP_WIFI_H__

--- END OF FILE: .\components\bsp\WS1.9TS\bsp_wifi.h ---

--- START OF FILE: .\components\bsp\WS1.9TS\bsp.c ---
/* Fecha: 16/08/2025 - 08:17  */
/* Fichero: components/diymon_bsp/WS1.9TS/bsp.c */
/* √öltimo cambio: Modificado para manejar el fallo de inicializaci√≥n de la tarjeta SD sin abortar. */
/* Descripci√≥n: Orquestador del BSP. Ahora trata el fallo de la tarjeta SD como un error no fatal, permitiendo que el dispositivo arranque sin la SD. Esto es crucial para los modos de configuraci√≥n que no dependen de los assets de la tarjeta y para la robustez general del sistema. */

#include "bsp_api.h"
#include "esp_err.h"
#include "esp_log.h" 
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static const char *TAG = "bsp";

// Inicializaci√≥n completa para la aplicaci√≥n principal
esp_err_t bsp_init(void) {
    ESP_LOGI(TAG, "Inicializando TODO el hardware para la aplicaci√≥n principal...");
    ESP_ERROR_CHECK(bsp_i2c_init());
    ESP_ERROR_CHECK(bsp_spi_init());
    ESP_ERROR_CHECK(bsp_display_init());
    ESP_ERROR_CHECK(bsp_touch_init());
    ESP_ERROR_CHECK(bsp_imu_init());
    
    // [CORRECCI√ìN] Manejar fallo de SD sin abortar.
    if (bsp_sdcard_init() != ESP_OK) {
        ESP_LOGE(TAG, "Fallo al inicializar la tarjeta SD, pero se contin√∫a el arranque. Las animaciones no funcionar√°n.");
    }
    
    ESP_ERROR_CHECK(bsp_battery_init());
    return ESP_OK;
}

// Inicializaci√≥n para modos de servicio que necesitan mostrar una imagen
esp_err_t bsp_init_service_mode(void) {
    ESP_LOGI(TAG, "Inicializando hardware para modo de servicio con pantalla...");
    ESP_ERROR_CHECK(bsp_i2c_init());
    ESP_ERROR_CHECK(bsp_spi_init());
    
    // [CORRECCI√ìN] Manejar fallo de SD sin abortar.
    if (bsp_sdcard_init() != ESP_OK) {
        ESP_LOGE(TAG, "Fallo al inicializar la tarjeta SD en modo servicio. El servidor de ficheros no funcionar√°.");
    }

    ESP_ERROR_CHECK(bsp_display_init());
    ESP_ERROR_CHECK(bsp_touch_init());
    bsp_display_set_brightness(100);
    return ESP_OK;
}

// Inicializaci√≥n m√≠nima para modos de servicio que no usan pantalla
esp_err_t bsp_init_minimal_headless(void) {
    ESP_LOGI(TAG, "Inicializando hardware M√çNIMO para modo headless (SPI + SD)...");
    ESP_ERROR_CHECK(bsp_spi_init());
    
    // [CORRECCI√ìN] Manejar fallo de SD sin abortar.
    if (bsp_sdcard_init() != ESP_OK) {
        ESP_LOGE(TAG, "Fallo al inicializar la tarjeta SD en modo headless.");
    }

    return ESP_OK;
}

--- END OF FILE: .\components\bsp\WS1.9TS\bsp.c ---

--- START OF FILE: .\components\bsp\CMakeLists.txt ---
# Fecha: 17/08/2025 - 02:55 
# Fichero: components/bsp/CMakeLists.txt
# √öltimo cambio: Eliminada la dependencia expl√≠cita de 'esp_driver_i2c' para resolver un conflicto de compilaci√≥n.
# Descripci√≥n: Se ha eliminado la dependencia 'esp_driver_i2c' de la lista REQUIRES. Requerir sub-componentes de 'driver' individualmente es una pr√°ctica no est√°ndar que puede corromper el √°rbol de dependencias del build system. El componente 'driver' ya se incluye y proporciona acceso a todas las APIs de controladores necesarias (I2C, SPI, etc.), solucionando el fallo de compilaci√≥n en el componente 'esp_twai'.

set(BOARD_SUBDIR "WS1.9TS")

file(GLOB component_sources "${BOARD_SUBDIR}/*.c")

idf_component_register(
    SRCS ${component_sources}
    
    INCLUDE_DIRS "include"
    PRIV_INCLUDE_DIRS "${BOARD_SUBDIR}"
    
    REQUIRES 
        driver
        esp_lcd
        sdmmc
        fatfs
        esp_adc
        esp_wifi
        nvs_flash
        lvgl
        esp_lvgl_port
        esp_lcd_touch_cst816s
        esp_lcd_sh8601
)

--- END OF FILE: .\components\bsp\CMakeLists.txt ---

--- START OF FILE: .\components\bsp\Kconfig ---
# Fichero: ./components/diymon_bsp/Kconfig
# Fecha: 12/08/2025 - 07:45 pm
# √öltimo cambio: A√±adida opci√≥n para habilitar/deshabilitar la tarjeta SD.
# Descripci√≥n: Fichero de configuraci√≥n para el BSP. Se a√±ade una opci√≥n booleana
#              que permite compilar con o sin el soporte para la tarjeta SD.
#              Esto es crucial para resolver un conflicto de hardware en la placa,
#              donde el pin de la SD (GPIO20) interfiere con el monitor serie USB.

menu "DIYMON Board Options"

    config BSP_SD_CARD_ENABLED
        bool "Enable SD Card Support"
        default y
        help
            Enable this option to initialize and use the onboard SD card reader.

            WARNING: On the Waveshare ESP32-C6 Touch LCD board, the SD Card's
            Chip Select (CS) pin is connected to GPIO20. This pin is also used
            by the internal USB-JTAG interface for the serial monitor output.

            If you enable this option, YOU WILL LOSE THE SERIAL MONITOR LOGS
            as soon as the SD card is initialized.

            Disable this option during development and debugging if you need to
            see log output via the USB port. Re-enable it for final deployment.

endmenu

--- END OF FILE: .\components\bsp\Kconfig ---

--- START OF FILE: .\components\bsp\Kconfig.projbuild ---
menu "DIYMON Board Support Package"
    choice DIYMON_TARGET_BOARD
        prompt "Target DIYMON Hardware"
        default DIYMON_BOARD_ORIGINAL
        help
            Select the specific hardware board you are compiling for.

        config DIYMON_BOARD_ORIGINAL
            bool "Placa Original (ESP32-S3)"

        config DIYMON_BOARD_WAVESHARE_C6
            bool "Waveshare ESP32-C6 LCD 1.9"

    endchoice
endmenu
--- END OF FILE: .\components\bsp\Kconfig.projbuild ---

--- START OF FILE: .\components\core\include\diymon_evolution.h ---
/*
 * Fichero: ./components/diymon_core/include/diymon_evolution.h
 * Fecha: 13/08/2025 - 19:45
 * √öltimo cambio: A√±adida la declaraci√≥n para resetear el estado.
 * Descripci√≥n: Cabecera del motor de evoluci√≥n. Expone las funciones para gestionar el estado y la secuencia de evoluci√≥n del DIYMON, incluyendo la involuci√≥n y el reseteo de estado.
 */
#ifndef DIYMON_EVOLUTION_H
#define DIYMON_EVOLUTION_H

#include <stdint.h> // Para usar tipos como uint8_t

// Estructura para almacenar las estad√≠sticas de una forma can√≥nica
typedef struct {
    uint8_t fue;
    uint8_t res;
    uint8_t vel;
    uint8_t intel;
} diymon_stats_t;

/**
 * @brief Inicializa el motor de evoluci√≥n.
 */
void diymon_evolution_init(void);

/**
 * @brief Obtiene las estad√≠sticas base para un C√≥digo Evolutivo dado.
 * @param evo_code El c√≥digo a buscar (ej: "1.2.3").
 * @return Un puntero a las estad√≠sticas (solo lectura) o NULL si no se encuentra.
 */
const diymon_stats_t* diymon_get_stats_for_code(const char* evo_code);

/**
 * @brief Establece el c√≥digo evolutivo del DIYMON activo.
 * @param new_code El nuevo c√≥digo a establecer.
 */
void diymon_set_current_code(const char* new_code);

/**
 * @brief Obtiene el c√≥digo evolutivo del DIYMON activo.
 * @return Un puntero al c√≥digo actual.
 */
const char* diymon_get_current_code(void);

/**
 * @brief Obtiene el siguiente c√≥digo en la secuencia de evoluci√≥n predefinida.
 * @param current_code El c√≥digo actual.
 * @return El siguiente c√≥digo en la secuencia, o NULL si es la evoluci√≥n final.
 */
const char* diymon_get_next_evolution_in_sequence(const char* current_code);

/**
 * @brief Obtiene el c√≥digo anterior en la secuencia de evoluci√≥n predefinida.
 * @param current_code El c√≥digo actual.
 * @return El c√≥digo anterior en la secuencia, o NULL si es la forma inicial.
 */
const char* diymon_get_previous_evolution_in_sequence(const char* current_code);

/**
 * @brief Construye un c√≥digo de evoluci√≥n ramificado y comprueba si existe.
 * @param current_code El c√≥digo de evoluci√≥n actual.
 * @param branch_id El identificador de la rama elemental (1-4).
 * @return El nuevo c√≥digo de evoluci√≥n si es v√°lido, o NULL si no existe.
 */
const char* diymon_get_branched_evolution(const char* current_code, int branch_id);

/**
 * @brief Borra el estado de evoluci√≥n guardado en la NVS.
 */
void diymon_evolution_reset_state(void);


#endif // DIYMON_EVOLUTION_H

--- END OF FILE: .\components\core\include\diymon_evolution.h ---

--- START OF FILE: .\components\core\CMakeLists.txt ---
idf_component_register(SRCS "diymon_evolution.c"
                    INCLUDE_DIRS "include"
                    # Le damos permiso para usar tanto los logs como la memoria flash
                    REQUIRES "log" "nvs_flash"
                    )
--- END OF FILE: .\components\core\CMakeLists.txt ---

--- START OF FILE: .\components\core\diymon_evolution.c ---
/* Fecha: 15/08/2025 - 09:54  */
/* Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_core\diymon_evolution.c */
/* √öltimo cambio: A√±adidas las evoluciones de la Etapa 3 para resolver el error de "evoluci√≥n no v√°lida". */
/* Descripci√≥n: Se ha expandido la tabla maestra de evoluciones (`G_MASTER_TABLE`) para incluir las ramificaciones de la Etapa 3 que faltaban (ej: desde "3.3" a "3.3.1"). Esto corrige el error reportado por el usuario y permite que el DIYMON contin√∫e evolucionando. */

#include "diymon_evolution.h"
#include <string.h>
#include <stdlib.h>
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"

static const char* TAG = "DIYMON_CORE";

// --- LA TABLA MAESTRA DE ESTAD√çSTICAS ---
static const struct {
    const char* evo_code;
    const diymon_stats_t stats;
} G_MASTER_TABLE[] = {
    // Base
    {"0",       {5, 5, 5, 5}},
    // Etapa 1
    {"1",       {8, 5, 6, 5}}, // Fuego
    {"2",       {5, 8, 5, 6}}, // Agua
    {"3",       {6, 5, 8, 5}}, // Tierra
    {"4",       {5, 6, 5, 8}}, // Aire
    // Etapa 2 (ramas de "1" - Fuego)
    {"1.1",     {10, 5, 7, 7}}, // Fuego+Fuego
    {"1.2",     {7, 8, 7, 7}}, // Fuego+Agua
    {"1.3",     {8, 7, 8, 6}}, // Fuego+Tierra
    {"1.4",     {7, 7, 6, 8}}, // Fuego+Aire
    // Etapa 2 (ramas de "2" - Agua)
    {"2.1",     {8, 7, 7, 7}}, // Agua+Fuego
    {"2.2",     {5, 10, 7, 7}}, // Agua+Agua
    // Etapa 2 (ramas de "3" - Tierra)
    {"3.1",     {8, 6, 8, 7}}, // Tierra+Fuego
    {"3.3",     {7, 7, 10, 5}}, // Tierra+Tierra
    // Etapa 2 (ramas de "4" - Aire)
    {"4.1",     {8, 7, 6, 8}}, // Aire+Fuego
    {"4.4",     {6, 7, 5, 10}}, // Aire+Aire
    // Etapa 3 (ramas de "1.1")
    {"1.1.1",   {12, 5, 8, 8}},
    {"1.1.2",   {10, 8, 7, 8}},
    // Etapa 3 (ramas de "2.2")
    {"2.2.1",   {8, 11, 8, 8}},
    {"2.2.2",   {5, 13, 8, 9}},
    // Etapa 3 (ramas de "3.3")
    {"3.3.1",   {10, 8, 11, 6}},
    {"3.3.2",   {8, 10, 11, 6}},
    {"3.3.3",   {9, 8, 13, 5}},
    {"3.3.4",   {8, 8, 11, 8}},
    // Etapa 3 (ramas de "4.4")
    {"4.4.1",   {9, 8, 6, 11}},
    {"4.4.4",   {6, 8, 5, 13}},
};

static char G_CURRENT_DIYMON_CODE[16] = "0";
// B√∫fer est√°tico para construir c√≥digos de evoluci√≥n candidatos.
static char G_EVO_CODE_BUFFER[16];


// ----- Funciones para interactuar con la memoria FLASH (NVS) -----

static void diymon_core_save_state(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("diymon_storage", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) abriendo NVS para escribir!", esp_err_to_name(err));
        return;
    }
    err = nvs_set_str(nvs_handle, "evo_code", G_CURRENT_DIYMON_CODE);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) guardando 'evo_code' en NVS!", esp_err_to_name(err));
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) haciendo commit en NVS!", esp_err_to_name(err));
    }
    nvs_close(nvs_handle);
    ESP_LOGI(TAG, "Estado guardado en memoria flash: %s", G_CURRENT_DIYMON_CODE);
}

static void diymon_core_load_state(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("diymon_storage", NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGI(TAG, "NVS: No se encontr√≥ partici√≥n, empezando de cero.");
        strcpy(G_CURRENT_DIYMON_CODE, "0"); // Asegurar estado inicial si no hay NVS
        return;
    }
    size_t required_size = sizeof(G_CURRENT_DIYMON_CODE);
    err = nvs_get_str(nvs_handle, "evo_code", G_CURRENT_DIYMON_CODE, &required_size);
    switch (err) {
        case ESP_OK:
            ESP_LOGI(TAG, "Estado cargado de memoria flash: %s", G_CURRENT_DIYMON_CODE);
            break;
        case ESP_ERR_NVS_NOT_FOUND:
            ESP_LOGI(TAG, "NVS: Clave 'evo_code' no encontrada. Es la primera ejecuci√≥n.");
            strcpy(G_CURRENT_DIYMON_CODE, "0"); // Estado inicial
            break;
        default:
            ESP_LOGE(TAG, "Error (%s) cargando 'evo_code' desde NVS!", esp_err_to_name(err));
    }
    nvs_close(nvs_handle);
}

// ----- Funciones p√∫blicas -----

void diymon_evolution_init(void) {
    ESP_LOGI(TAG, "Motor de evoluci√≥n inicializado.");
    diymon_core_load_state();
}

void diymon_set_current_code(const char* new_code) {
    strncpy(G_CURRENT_DIYMON_CODE, new_code, sizeof(G_CURRENT_DIYMON_CODE) - 1);
    diymon_core_save_state();
}

const diymon_stats_t* diymon_get_stats_for_code(const char* evo_code) {
    for (int i = 0; i < sizeof(G_MASTER_TABLE) / sizeof(G_MASTER_TABLE[0]); ++i) {
        if (strcmp(G_MASTER_TABLE[i].evo_code, evo_code) == 0) {
            return &G_MASTER_TABLE[i].stats;
        }
    }
    return NULL;
}

const char* diymon_get_current_code(void) {
    return G_CURRENT_DIYMON_CODE;
}

const char* diymon_get_next_evolution_in_sequence(const char* current_code) {
    if (strcmp(current_code, "0") == 0) return "1";
    if (strcmp(current_code, "1") == 0) return "1.1";
    if (strcmp(current_code, "1.1") == 0) return "1.1.1";
    return NULL;
}

const char* diymon_get_previous_evolution_in_sequence(const char* current_code) {
    if (strcmp(current_code, "0") == 0) {
        return NULL; // Ya est√° en la forma base.
    }

    const char* last_dot = strrchr(current_code, '.');
    
    // Si no hay punto (ej: "1", "2", "3", "4"), la involuci√≥n es hacia "0".
    if (!last_dot) {
        return "0";
    }

    // Si hay un punto, se trunca el c√≥digo para obtener el padre.
    size_t parent_len = last_dot - current_code;
    strncpy(G_EVO_CODE_BUFFER, current_code, parent_len);
    G_EVO_CODE_BUFFER[parent_len] = '\0';

    // Se busca el c√≥digo padre en la tabla para devolver un puntero v√°lido.
    for (int i = 0; i < sizeof(G_MASTER_TABLE) / sizeof(G_MASTER_TABLE[0]); ++i) {
        if (strcmp(G_MASTER_TABLE[i].evo_code, G_EVO_CODE_BUFFER) == 0) {
            return G_MASTER_TABLE[i].evo_code;
        }
    }

    return NULL; // El padre no existe en la tabla.
}

const char* diymon_get_branched_evolution(const char* current_code, int branch_id) {
    // Si el c√≥digo actual es "0", la evoluci√≥n es directamente a la rama, sin prefijo.
    if (strcmp(current_code, "0") == 0) {
        snprintf(G_EVO_CODE_BUFFER, sizeof(G_EVO_CODE_BUFFER), "%d", branch_id);
    } else {
        // Para cualquier otro estado, la evoluci√≥n es una sub-rama.
        snprintf(G_EVO_CODE_BUFFER, sizeof(G_EVO_CODE_BUFFER), "%s.%d", current_code, branch_id);
    }

    // Buscar si el c√≥digo generado existe en la tabla de evoluciones
    for (int i = 0; i < sizeof(G_MASTER_TABLE) / sizeof(G_MASTER_TABLE[0]); ++i) {
        if (strcmp(G_MASTER_TABLE[i].evo_code, G_EVO_CODE_BUFFER) == 0) {
            return G_MASTER_TABLE[i].evo_code; // Devuelve el puntero de la tabla
        }
    }

    return NULL; // La evoluci√≥n no es v√°lida
}

void diymon_evolution_reset_state(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("diymon_storage", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) abriendo NVS para borrar estado de evoluci√≥n.", esp_err_to_name(err));
        return;
    }
    err = nvs_erase_key(nvs_handle, "evo_code");
    if (err == ESP_OK) {
        ESP_LOGI(TAG, "Clave 'evo_code' borrada de NVS.");
    } else {
        ESP_LOGE(TAG, "Error al borrar 'evo_code': %s", esp_err_to_name(err));
    }
    nvs_commit(nvs_handle);
    nvs_close(nvs_handle);
}

--- END OF FILE: .\components\core\diymon_evolution.c ---

--- START OF FILE: .\components\iot_button\include\button_adc.h ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once

#include "driver/gpio.h"
#include "esp_adc/adc_oneshot.h"
#include "button_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief adc button configuration
 *
 */
typedef struct {
    adc_oneshot_unit_handle_t *adc_handle;           /**< handle of adc unit, if NULL will create new one internal, else will use the handle */
    adc_unit_t unit_id;                              /**< ADC unit */
    uint8_t adc_channel;                             /**< Channel of ADC */
    uint8_t button_index;                            /**< button index on the channel */
    uint16_t min;                                    /**< min voltage in mv corresponding to the button */
    uint16_t max;                                    /**< max voltage in mv corresponding to the button */
} button_adc_config_t;

/**
 * @brief Create a new ADC button device
 *
 * This function initializes and configures a new ADC button device using the given configuration parameters.
 * It manages the ADC unit, channels, and button-specific parameters, and ensures proper resource allocation
 * for the ADC button object.
 *
 * @param[in] button_config Configuration for the button device, including callbacks and debounce parameters.
 * @param[in] adc_config Configuration for the ADC channel and button, including the ADC unit, channel,
 *                        button index, and voltage range (min and max).
 * @param[out] ret_button Handle to the newly created button device.
 *
 * @return
 *     - ESP_OK: Successfully created the ADC button device.
 *     - ESP_ERR_INVALID_ARG: Invalid argument provided.
 *     - ESP_ERR_NO_MEM: Memory allocation failed.
 *     - ESP_ERR_INVALID_STATE: The requested button index or channel is already in use, or no channels are available.
 *     - ESP_FAIL: Failed to initialize or configure the ADC or button device.
 *
 * @note
 * - If the ADC unit is not already configured, it will be initialized with the provided or default settings.
 * - If the ADC channel is not initialized, it will be configured for the specified unit and calibrated.
 * - This function ensures that ADC resources are reused whenever possible to optimize resource allocation.
 */
esp_err_t iot_button_new_adc_device(const button_config_t *button_config, const button_adc_config_t *adc_config, button_handle_t *ret_button);

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\include\button_adc.h ---

--- START OF FILE: .\components\iot_button\include\button_gpio.h ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once

#include "esp_err.h"
#include "button_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief gpio button configuration
 *
 */
typedef struct {
    int32_t gpio_num;              /**< num of gpio */
    uint8_t active_level;          /**< gpio level when press down */
    bool enable_power_save;        /**< enable power save mode */
    bool disable_pull;             /**< disable internal pull up or down */
} button_gpio_config_t;

/**
 * @brief Create a new GPIO button device
 *
 * This function initializes and configures a GPIO-based button device using the given configuration parameters.
 * It sets up the GPIO pin, configures its input mode, and optionally enables power-saving features or wake-up functionality.
 *
 * @param[in] button_config Configuration for the button device, including callbacks and debounce parameters.
 * @param[in] gpio_cfg Configuration for the GPIO, including the pin number, active level, and power-save options.
 * @param[out] ret_button Handle to the newly created GPIO button device.
 *
 * @return
 *     - ESP_OK: Successfully created the GPIO button device.
 *     - ESP_ERR_INVALID_ARG: Invalid argument provided, such as an invalid GPIO number.
 *     - ESP_ERR_NO_MEM: Memory allocation failed.
 *     - ESP_ERR_INVALID_STATE: Failed to configure GPIO wake-up or interrupt settings.
 *     - ESP_FAIL: General failure, such as unsupported wake-up configuration on the target.
 *
 * @note
 * - If power-saving is enabled, the GPIO will be configured as a wake-up source for light sleep.
 * - Pull-up or pull-down resistors are configured based on the `active_level` and the `disable_pull` flag.
 * - This function checks for the validity of the GPIO as a wake-up source when power-saving is enabled.
 * - If power-saving is not supported by the hardware or configuration, the function will return an error.
 */
esp_err_t iot_button_new_gpio_device(const button_config_t *button_config, const button_gpio_config_t *gpio_config, button_handle_t *ret_button);

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\include\button_gpio.h ---

--- START OF FILE: .\components\iot_button\include\button_matrix.h ---
/*
 * SPDX-FileCopyrightText: 2023-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#pragma once

#include "esp_err.h"
#include "button_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Button matrix key configuration.
 *        Just need to configure the GPIO associated with this GPIO in the matrix keyboard.
 *
 *        Matrix Keyboard Layout (3x3):
 *        ----------------------------------------
 *        |  Button 1  |  Button 2  |  Button 3  |
 *        |  (R1-C1)   |  (R1-C2)   |  (R1-C3)   |
 *        |--------------------------------------|
 *        |  Button 4  |  Button 5  |  Button 6  |
 *        |  (R2-C1)   |  (R2-C2)   |  (R2-C3)   |
 *        |--------------------------------------|
 *        |  Button 7  |  Button 8  |  Button 9  |
 *        |  (R3-C1)   |  (R3-C2)   |  (R3-C3)   |
 *        ----------------------------------------
 *
 *        - Button matrix key is driven using row scanning.
 *        - Buttons within the same column cannot be detected simultaneously,
 *          but buttons within the same row can be detected without conflicts.
 */
typedef struct {
    int32_t *row_gpios;        /**< GPIO number list for the row */
    int32_t *col_gpios;        /**< GPIO number list for the column */
    uint32_t row_gpio_num;     /**< Number of GPIOs associated with the row */
    uint32_t col_gpio_num;     /**< Number of GPIOs associated with the column */
} button_matrix_config_t;

/**
 * @brief Create a new button matrix device
 *
 * This function initializes and configures a button matrix device using the specified row and column GPIOs.
 * Each button in the matrix is represented as an independent button object, and its handle is returned in the `ret_button` array.
 *
 * @param[in] button_config Configuration for the button device, including callbacks and debounce parameters.
 * @param[in] matrix_config Configuration for the matrix, including row and column GPIOs and their counts.
 * @param[out] ret_button Array of handles for the buttons in the matrix.
 * @param[inout] size Pointer to the total number of buttons in the matrix. Must match the product of row and column GPIO counts.
 *                    On success, this value is updated to reflect the size of the button matrix.
 *
 * @return
 *     - ESP_OK: Successfully created the button matrix device.
 *     - ESP_ERR_INVALID_ARG: Invalid argument provided, such as null pointers or mismatched matrix dimensions.
 *     - ESP_ERR_NO_MEM: Memory allocation failed.
 *     - ESP_FAIL: General failure, such as button creation failure for one or more buttons.
 *
 * @note
 * - Each row GPIO is configured as an output, while each column GPIO is configured as an input.
 * - The total number of buttons in the matrix must equal the product of the row and column GPIO counts.
 * - The `ret_button` array must be large enough to store handles for all buttons in the matrix.
 * - If any button creation fails, the function will free all allocated resources and return an error.
 */
esp_err_t iot_button_new_matrix_device(const button_config_t *button_config, const button_matrix_config_t *matrix_config, button_handle_t *ret_button, size_t *size);

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\include\button_matrix.h ---

--- START OF FILE: .\components\iot_button\include\button_types.h ---
/*
 * SPDX-FileCopyrightText: 2024-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#pragma once

#include <stdint.h>
#include "esp_err.h"
#include "button_interface.h"

#ifdef __cplusplus
extern "C" {
#endif

enum {
    BUTTON_INACTIVE = 0,
    BUTTON_ACTIVE,
};

typedef struct button_dev_t *button_handle_t;

/**
 * @brief Button configuration
 *
 */
typedef struct {
    uint16_t long_press_time;                         /**< Trigger time(ms) for long press, if 0 default to BUTTON_LONG_PRESS_TIME_MS */
    uint16_t short_press_time;                        /**< Trigger time(ms) for short press, if 0 default to BUTTON_SHORT_PRESS_TIME_MS */
} button_config_t;

/**
 * @brief Create a new IoT button instance
 *
 * This function initializes a new button instance with the specified configuration
 * and driver. It also sets up internal resources such as the button timer if not
 * already initialized.
 *
 * @param[in] config        Pointer to the button configuration structure
 * @param[in] driver        Pointer to the button driver structure
 * @param[out] ret_button   Pointer to where the handle of the created button will be stored
 *
 * @return
 *      - ESP_OK: Successfully created the button
 *      - ESP_ERR_INVALID_ARG: Invalid arguments passed to the function
 *      - ESP_ERR_NO_MEM: Memory allocation failed
 *
 * @note
 * - The first call to this function logs the IoT Button version.
 * - The function initializes a global button timer if it is not already running.
 * - Timer is started only if the driver does not enable power-saving mode.
 */
esp_err_t iot_button_create(const button_config_t *config, const button_driver_t *driver, button_handle_t *ret_button);

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\include\button_types.h ---

--- START OF FILE: .\components\iot_button\include\iot_button.h ---
/* SPDX-FileCopyrightText: 2022-2024 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#pragma once

#include "sdkconfig.h"
#include "esp_err.h"
#include "button_types.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef void (* button_cb_t)(void *button_handle, void *usr_data);

typedef void (* button_power_save_cb_t)(void *usr_data);

/**
 * @brief Structs to store power save callback info
 *
 */
typedef struct {
    button_power_save_cb_t enter_power_save_cb;  /**< Callback function when entering power save mode */
    void *usr_data;                              /**< User data for the callback */
} button_power_save_config_t;

/**
 * @brief Button events
 *
 */
typedef enum {
    BUTTON_PRESS_DOWN = 0,
    BUTTON_PRESS_UP,
    BUTTON_PRESS_REPEAT,
    BUTTON_PRESS_REPEAT_DONE,
    BUTTON_SINGLE_CLICK,
    BUTTON_DOUBLE_CLICK,
    BUTTON_MULTIPLE_CLICK,
    BUTTON_LONG_PRESS_START,
    BUTTON_LONG_PRESS_HOLD,
    BUTTON_LONG_PRESS_UP,
    BUTTON_PRESS_END,
    BUTTON_EVENT_MAX,
    BUTTON_NONE_PRESS,
} button_event_t;

/**
 * @brief Button events arg
 *
 */
typedef union {
    /**
     * @brief Long press time event data
     *
     */
    struct long_press_t {
        uint16_t press_time;    /**< press time(ms) for the corresponding callback to trigger */
    } long_press;               /**< long press struct, for event BUTTON_LONG_PRESS_START and BUTTON_LONG_PRESS_UP */

    /**
     * @brief Multiple clicks event data
     *
     */
    struct multiple_clicks_t {
        uint16_t clicks;        /**< number of clicks, to trigger the callback */
    } multiple_clicks;          /**< multiple clicks struct, for event BUTTON_MULTIPLE_CLICK */
} button_event_args_t;

/**
 * @brief Button parameter
 *
 */
typedef enum {
    BUTTON_LONG_PRESS_TIME_MS = 0,
    BUTTON_SHORT_PRESS_TIME_MS,
    BUTTON_PARAM_MAX,
} button_param_t;

/**
 * @brief Delete a button
 *
 * @param btn_handle A button handle to delete
 *
 * @return
 *      - ESP_OK  Success
 *      - ESP_FAIL Failure
 */
esp_err_t iot_button_delete(button_handle_t btn_handle);

/**
 * @brief Register the button event callback function.
 *
 * @param btn_handle A button handle to register
 * @param event Button event
 * @param event_args Button event arguments
 * @param cb Callback function.
 * @param usr_data user data
 *
 * @return
 *      - ESP_OK on success
 *      - ESP_ERR_INVALID_ARG   Arguments is invalid.
 *      - ESP_ERR_INVALID_STATE The Callback is already registered. No free Space for another Callback.
 *      - ESP_ERR_NO_MEM        No more memory allocation for the event
 */
esp_err_t iot_button_register_cb(button_handle_t btn_handle, button_event_t event, button_event_args_t *event_args, button_cb_t cb, void *usr_data);

/**
 * @brief Unregister all the callbacks associated with the event.
 *
 * @param btn_handle A button handle to unregister
 * @param event Button event
 * @param event_args Used for unregistering a specific callback.
 *
 * @return
 *      - ESP_OK on success
 *      - ESP_ERR_INVALID_ARG   Arguments is invalid.
 *      - ESP_ERR_INVALID_STATE No callbacks registered for the event
 */
esp_err_t iot_button_unregister_cb(button_handle_t btn_handle, button_event_t event, button_event_args_t *event_args);

/**
 * @brief counts total callbacks registered
 *
 * @param btn_handle A button handle to the button
 *
 * @return
 *      - 0 if no callbacks registered, or 1 .. (BUTTON_EVENT_MAX-1) for the number of Registered Buttons.
 *      - ESP_ERR_INVALID_ARG if btn_handle is invalid
 */
size_t iot_button_count_cb(button_handle_t btn_handle);

/**
 * @brief how many callbacks are registered for the event
 *
 * @param btn_handle A button handle to the button
 *
 * @param event Button event
 *
 * @return
 *      - 0 if no callbacks registered, or 1 .. (BUTTON_EVENT_MAX-1) for the number of Registered Buttons.
 *      - ESP_ERR_INVALID_ARG if btn_handle is invalid
 */
size_t iot_button_count_event_cb(button_handle_t btn_handle, button_event_t event);

/**
 * @brief Get button event
 *
 * @param btn_handle Button handle
 *
 * @return Current button event. See button_event_t
 */
button_event_t iot_button_get_event(button_handle_t btn_handle);

/**
 * @brief Get the string representation of a button event.
 *
 * This function returns the corresponding string for a given button event.
 * If the event value is outside the valid range, the function returns error string "event value is invalid".
 *
 * @param[in] event The button event to be converted to a string.
 *
 * @return
 *      - Pointer to the event string if the event is valid.
 *      - "invalid event" if the event value is invalid.
 */
const char *iot_button_get_event_str(button_event_t event);

/**
 * @brief Log the current button event as a string.
 *
 * This function prints the string representation of the current event associated with the button.
 *
 * @param[in] btn_handle Handle to the button object.
 *
 * @return
 *      - ESP_OK: Successfully logged the event string.
 *      - ESP_FAIL: Invalid button handle.
 */
esp_err_t iot_button_print_event(button_handle_t btn_handle);

/**
 * @brief Get button repeat times
 *
 * @param btn_handle Button handle
 *
 * @return button pressed times. For example, double-click return 2, triple-click return 3, etc.
 */
uint8_t iot_button_get_repeat(button_handle_t btn_handle);

/**
 * @brief Get button ticks time
 *
 * @param btn_handle Button handle
 *
 * @return Actual time from press down to up (ms).
 */
uint32_t iot_button_get_ticks_time(button_handle_t btn_handle);

/**
 * @brief Get button long press hold count
 *
 * @param btn_handle Button handle
 *
 * @return Count of trigger cb(BUTTON_LONG_PRESS_HOLD)
 */
uint16_t iot_button_get_long_press_hold_cnt(button_handle_t btn_handle);

/**
 * @brief Dynamically change the parameters of the iot button
 *
 * @param btn_handle Button handle
 * @param param Button parameter
 * @param value new value
 * @return
 *      - ESP_OK on success
 *      - ESP_ERR_INVALID_ARG   Arguments is invalid.
 */
esp_err_t iot_button_set_param(button_handle_t btn_handle, button_param_t param, void *value);

/**
 * @brief Get button key level
 *
 * @param btn_handle Button handle
 * @return
 *      - 1 if key is pressed
 *      - 0 if key is released or invalid button handle
 */
uint8_t iot_button_get_key_level(button_handle_t btn_handle);

/**
 * @brief resume button timer, if button timer is stopped. Make sure iot_button_create() is called before calling this API.
 *
 * @return
 *     - ESP_OK on success
 *     - ESP_ERR_INVALID_STATE   timer state is invalid.
 */
esp_err_t iot_button_resume(void);

/**
 * @brief stop button timer, if button timer is running. Make sure iot_button_create() is called before calling this API.
 *
 * @return
 *     - ESP_OK on success
 *     - ESP_ERR_INVALID_STATE   timer state is invalid
 */
esp_err_t iot_button_stop(void);

/**
 * @brief Register a callback function for power saving.
 *        The config->enter_power_save_cb function will be called when all keys stop working.
 *
 * @param config Button power save config
 * @return
 *     - ESP_OK                  on success
 *     - ESP_ERR_INVALID_STATE   No button registered
 *     - ESP_ERR_INVALID_ARG     Arguments is invalid
 *     - ESP_ERR_NO_MEM          Not enough memory
 */
esp_err_t iot_button_register_power_save_cb(const button_power_save_config_t *config);

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\include\iot_button.h ---

--- START OF FILE: .\components\iot_button\interface\button_interface.h ---
/*
 * SPDX-FileCopyrightText: 2024 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */
#pragma once

#include <stdbool.h>
#include <stdint.h>
#include "esp_err.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct button_driver_t button_driver_t; /*!< Type of button object */

struct button_driver_t {
    /*!< (optional) Need Support Power Save */
    bool enable_power_save;

    /*!< (necessary) Get key level */
    uint8_t (*get_key_level)(button_driver_t *button_driver);

    /*!< (optional) Enter Power Save cb */
    esp_err_t (*enter_power_save)(button_driver_t *button_driver);

    /*!< (optional) Del the hardware driver and cleanup */
    esp_err_t (*del)(button_driver_t *button_driver);
};

#ifdef __cplusplus
}
#endif

--- END OF FILE: .\components\iot_button\interface\button_interface.h ---

--- START OF FILE: .\components\iot_button\test_apps\main\adc_button_test.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/timers.h"
#include "freertos/semphr.h"
#include "freertos/event_groups.h"
#include "esp_idf_version.h"
#include "esp_log.h"
#include "unity.h"
#include "iot_button.h"
#include "button_adc.h"

static const char *TAG = "ADC BUTTON TEST";

static void button_event_cb(void *arg, void *data)
{
    button_event_t event = iot_button_get_event(arg);
    ESP_LOGI(TAG, "BTN[%d] %s", (int)data, iot_button_get_event_str(event));
    if (BUTTON_PRESS_REPEAT == event || BUTTON_PRESS_REPEAT_DONE == event) {
        ESP_LOGI(TAG, "\tREPEAT[%d]", iot_button_get_repeat(arg));
    }

    if (BUTTON_PRESS_UP == event || BUTTON_LONG_PRESS_HOLD == event || BUTTON_LONG_PRESS_UP == event) {
        ESP_LOGI(TAG, "\tTICKS[%"PRIu32"]", iot_button_get_ticks_time(arg));
    }

    if (BUTTON_MULTIPLE_CLICK == event) {
        ESP_LOGI(TAG, "\tMULTIPLE[%d]", (int)data);
    }
}

TEST_CASE("adc button test", "[button][adc]")
{
    /** ESP32-S3-Korvo2 board */
    const button_config_t btn_cfg = {0};
    button_adc_config_t btn_adc_cfg = {
        .unit_id = ADC_UNIT_1,
        .adc_channel = 4,
    };

    button_handle_t btns[6] = {NULL};

    const uint16_t vol[6] = {380, 820, 1180, 1570, 1980, 2410};
    for (size_t i = 0; i < 6; i++) {
        btn_adc_cfg.button_index = i;
        if (i == 0) {
            btn_adc_cfg.min = (0 + vol[i]) / 2;
        } else {
            btn_adc_cfg.min = (vol[i - 1] + vol[i]) / 2;
        }

        if (i == 5) {
            btn_adc_cfg.max = (vol[i] + 3000) / 2;
        } else {
            btn_adc_cfg.max = (vol[i] + vol[i + 1]) / 2;
        }

        esp_err_t ret = iot_button_new_adc_device(&btn_cfg, &btn_adc_cfg, &btns[i]);
        TEST_ASSERT(ret == ESP_OK);
        TEST_ASSERT_NOT_NULL(btns[i]);
        iot_button_register_cb(btns[i], BUTTON_PRESS_DOWN, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_UP, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_REPEAT, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_SINGLE_CLICK, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_DOUBLE_CLICK, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_START, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_UP, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_END, NULL, button_event_cb, (void *)i);
    }

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    for (size_t i = 0; i < 6; i++) {
        iot_button_delete(btns[i]);
    }
}

TEST_CASE("adc button test memory leak", "[button][adc][memory leak]")
{
    /** ESP32-S3-Korvo2 board */
    const button_config_t btn_cfg = {0};
    button_adc_config_t btn_adc_cfg = {
        .unit_id = ADC_UNIT_1,
        .adc_channel = 4,
    };

    button_handle_t btns[6] = {NULL};

    const uint16_t vol[6] = {380, 820, 1180, 1570, 1980, 2410};
    for (size_t i = 0; i < 6; i++) {
        btn_adc_cfg.button_index = i;
        if (i == 0) {
            btn_adc_cfg.min = (0 + vol[i]) / 2;
        } else {
            btn_adc_cfg.min = (vol[i - 1] + vol[i]) / 2;
        }

        if (i == 5) {
            btn_adc_cfg.max = (vol[i] + 3000) / 2;
        } else {
            btn_adc_cfg.max = (vol[i] + vol[i + 1]) / 2;
        }

        esp_err_t ret = iot_button_new_adc_device(&btn_cfg, &btn_adc_cfg, &btns[i]);
        TEST_ASSERT(ret == ESP_OK);

        TEST_ASSERT_NOT_NULL(btns[i]);
        iot_button_register_cb(btns[i], BUTTON_PRESS_DOWN, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_UP, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_REPEAT, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_SINGLE_CLICK, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_DOUBLE_CLICK, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_START, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_LONG_PRESS_UP, NULL, button_event_cb, (void *)i);
        iot_button_register_cb(btns[i], BUTTON_PRESS_END, NULL, button_event_cb, (void *)i);
    }

    for (size_t i = 0; i < 6; i++) {
        iot_button_delete(btns[i]);
    }
}

--- END OF FILE: .\components\iot_button\test_apps\main\adc_button_test.c ---

--- START OF FILE: .\components\iot_button\test_apps\main\auto_test.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "freertos/event_groups.h"
#include "esp_log.h"
#include "unity.h"
#include "iot_button.h"
#include "button_gpio.h"
#include "driver/gpio.h"

static const char *TAG = "BUTTON AUTO TEST";

#define GPIO_OUTPUT_IO_45 45
#define BUTTON_IO_NUM  0
#define BUTTON_ACTIVE_LEVEL   0

static EventGroupHandle_t g_check = NULL;
static SemaphoreHandle_t g_auto_check_pass = NULL;

static button_event_t state = BUTTON_PRESS_DOWN;

static void button_auto_press_test_task(void *arg)
{
    // test BUTTON_PRESS_DOWN
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));

    // // test BUTTON_PRESS_UP
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(200));

    // test BUTTON_PRESS_REPEAT
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));

    // test BUTTON_PRESS_REPEAT_DONE
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(200));

    // test BUTTON_SINGLE_CLICK
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(200));

    // test BUTTON_DOUBLE_CLICK
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    vTaskDelay(pdMS_TO_TICKS(200));

    // test BUTTON_MULTIPLE_CLICK
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    for (int i = 0; i < 4; i++) {
        gpio_set_level(GPIO_OUTPUT_IO_45, 0);
        vTaskDelay(pdMS_TO_TICKS(100));
        gpio_set_level(GPIO_OUTPUT_IO_45, 1);
        vTaskDelay(pdMS_TO_TICKS(100));
    }
    vTaskDelay(pdMS_TO_TICKS(100));

    // test BUTTON_LONG_PRESS_START
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 0);
    vTaskDelay(pdMS_TO_TICKS(1600));

    // test BUTTON_LONG_PRESS_HOLD and BUTTON_LONG_PRESS_UP
    xEventGroupWaitBits(g_check, BIT(0) | BIT(1), pdTRUE, pdTRUE, portMAX_DELAY);
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);

    ESP_LOGI(TAG, "Auto Press Success!");
    vTaskDelete(NULL);
}
static void button_auto_check_cb_1(void *arg, void *data)
{
    if (iot_button_get_event(arg) == state) {
        xEventGroupSetBits(g_check, BIT(1));
    }
}
static void button_auto_check_cb(void *arg, void *data)
{
    if (iot_button_get_event(arg) == state) {
        ESP_LOGI(TAG, "Auto check: button event %s pass", iot_button_get_event_str(state));
        xEventGroupSetBits(g_check, BIT(0));
        if (++state >= BUTTON_EVENT_MAX) {
            xSemaphoreGive(g_auto_check_pass);
            return;
        }
    }
}

TEST_CASE("gpio button auto-test", "[button][iot][auto]")
{
    state = BUTTON_PRESS_DOWN;
    g_check = xEventGroupCreate();
    g_auto_check_pass = xSemaphoreCreateBinary();
    xEventGroupSetBits(g_check, BIT(0) | BIT(1));
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);

    /* register iot_button callback for all the button_event */
    for (uint8_t i = 0; i < BUTTON_EVENT_MAX; i++) {
        if (i == BUTTON_MULTIPLE_CLICK) {
            button_event_args_t args = {
                .multiple_clicks.clicks = 4,
            };
            iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_auto_check_cb_1, NULL);
            iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_auto_check_cb, NULL);
        } else {
            iot_button_register_cb(btn, i, NULL, button_auto_check_cb_1, NULL);
            iot_button_register_cb(btn, i, NULL, button_auto_check_cb, NULL);
        }
    }

    TEST_ASSERT_EQUAL(ESP_OK, iot_button_set_param(btn, BUTTON_LONG_PRESS_TIME_MS, (void *)1500));

    gpio_config_t io_conf = {
        .intr_type = GPIO_INTR_DISABLE,
        .mode = GPIO_MODE_OUTPUT,
        .pin_bit_mask = (1ULL << GPIO_OUTPUT_IO_45),
        .pull_down_en = 0,
        .pull_up_en = 0,
    };
    gpio_config(&io_conf);
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);

    xTaskCreate(button_auto_press_test_task, "button_auto_press_test_task", 1024 * 4, NULL, 10, NULL);

    TEST_ASSERT_EQUAL(pdTRUE, xSemaphoreTake(g_auto_check_pass, pdMS_TO_TICKS(6000)));

    for (uint8_t i = 0; i < BUTTON_EVENT_MAX; i++) {
        button_event_args_t args;

        if (i == BUTTON_MULTIPLE_CLICK) {
            args.multiple_clicks.clicks = 4;
            iot_button_unregister_cb(btn, i, &args);
        } else if (i == BUTTON_LONG_PRESS_UP || i == BUTTON_LONG_PRESS_START) {
            args.long_press.press_time = 1500;
            iot_button_unregister_cb(btn, i, &args);
        } else {
            iot_button_unregister_cb(btn, i, NULL);
        }
    }

    TEST_ASSERT_EQUAL(ESP_OK, iot_button_delete(btn));
    vEventGroupDelete(g_check);
    vSemaphoreDelete(g_auto_check_pass);
    vTaskDelay(pdMS_TO_TICKS(100));
}

#define TOLERANCE (CONFIG_BUTTON_PERIOD_TIME_MS * 4)

uint16_t long_press_time[5] = {2000, 2500, 3000, 3500, 4000};
static SemaphoreHandle_t long_press_check = NULL;
static SemaphoreHandle_t long_press_auto_check_pass = NULL;
unsigned int status = 0;

static void button_auto_long_press_test_task(void *arg)
{
    // Test for BUTTON_LONG_PRESS_START
    for (int i = 0; i < 5; i++) {
        xSemaphoreTake(long_press_check, portMAX_DELAY);
        gpio_set_level(GPIO_OUTPUT_IO_45, 0);
        status = (BUTTON_LONG_PRESS_START << 16) | long_press_time[i];
        if (i > 0) {
            vTaskDelay(pdMS_TO_TICKS(long_press_time[i] - long_press_time[i - 1]));
        } else {
            vTaskDelay(pdMS_TO_TICKS(long_press_time[i]));
        }
    }
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    xSemaphoreGive(long_press_auto_check_pass);
    vTaskDelay(pdMS_TO_TICKS(100));
    // Test for BUTTON_LONG_PRESS_UP
    for (int i = 0; i < 5; i++) {
        xSemaphoreTake(long_press_check, portMAX_DELAY);
        status = (BUTTON_LONG_PRESS_UP << 16) | long_press_time[i];
        gpio_set_level(GPIO_OUTPUT_IO_45, 0);
        vTaskDelay(pdMS_TO_TICKS(long_press_time[i] + 10));
        gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    }

    ESP_LOGI(TAG, "Auto Long Press Success!");
    vTaskDelete(NULL);
}

static void button_long_press_auto_check_cb(void *arg, void *data)
{
    uint32_t value = (uint32_t)data;
    uint16_t event = (0xffff0000 & value) >> 16;
    uint16_t time = 0xffff & value;
    uint32_t ticks_time = iot_button_get_ticks_time(arg);
    int32_t diff = ticks_time - time;
    if (status == value && abs(diff) <= TOLERANCE) {
        ESP_LOGI(TAG, "Auto check: button event: %s and time: %d pass", iot_button_get_event_str(event), time);

        if (event == BUTTON_LONG_PRESS_UP && time == long_press_time[4]) {
            xSemaphoreGive(long_press_auto_check_pass);
        }

        xSemaphoreGive(long_press_check);
    }
}

TEST_CASE("gpio button long_press auto-test", "[button][long_press][auto]")
{
    ESP_LOGI(TAG, "Starting the test");
    long_press_check = xSemaphoreCreateBinary();
    long_press_auto_check_pass = xSemaphoreCreateBinary();
    xSemaphoreGive(long_press_check);
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);

    for (int i = 0; i < 5; i++) {
        button_event_args_t args = {
            .long_press.press_time = long_press_time[i],
        };

        uint32_t data = (BUTTON_LONG_PRESS_START << 16) | long_press_time[i];
        iot_button_register_cb(btn, BUTTON_LONG_PRESS_START, &args, button_long_press_auto_check_cb, (void*)data);
    }

    gpio_config_t io_conf = {
        .intr_type = GPIO_INTR_DISABLE,
        .mode = GPIO_MODE_OUTPUT,
        .pin_bit_mask = (1ULL << GPIO_OUTPUT_IO_45),
        .pull_down_en = 0,
        .pull_up_en = 0,
    };
    gpio_config(&io_conf);
    gpio_set_level(GPIO_OUTPUT_IO_45, 1);
    xTaskCreate(button_auto_long_press_test_task, "button_auto_long_press_test_task", 1024 * 4, NULL, 10, NULL);

    xSemaphoreTake(long_press_auto_check_pass, portMAX_DELAY);
    iot_button_unregister_cb(btn, BUTTON_LONG_PRESS_START, NULL);

    for (int i = 0; i < 5; i++) {
        button_event_args_t args = {
            .long_press.press_time = long_press_time[i]
        };

        uint32_t data = (BUTTON_LONG_PRESS_UP << 16) | long_press_time[i];
        iot_button_register_cb(btn, BUTTON_LONG_PRESS_UP, &args, button_long_press_auto_check_cb, (void*)data);
    }
    TEST_ASSERT_EQUAL(pdTRUE, xSemaphoreTake(long_press_auto_check_pass, pdMS_TO_TICKS(17000)));
    TEST_ASSERT_EQUAL(ESP_OK, iot_button_delete(btn));
    vSemaphoreDelete(long_press_check);
    vSemaphoreDelete(long_press_auto_check_pass);
    vTaskDelay(pdMS_TO_TICKS(100));
}

--- END OF FILE: .\components\iot_button\test_apps\main\auto_test.c ---

--- START OF FILE: .\components\iot_button\test_apps\main\button_test_main.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include "unity.h"
#include "unity_test_runner.h"
#include "unity_test_utils_memory.h"
#include "esp_heap_caps.h"
#include "sdkconfig.h"

#define LEAKS (400)

void setUp(void)
{
    unity_utils_record_free_mem();
}

void tearDown(void)
{
    unity_utils_evaluate_leaks_direct(LEAKS);
}

void app_main(void)
{
    /*
    * ____          _    _                  _______          _
    *|  _ \        | |  | |                |__   __|        | |
    *| |_) | _   _ | |_ | |_  ___   _ __      | |  ___  ___ | |_
    *|  _ < | | | || __|| __|/ _ \ | '_ \     | | / _ \/ __|| __|
    *| |_) || |_| || |_ | |_| (_) || | | |    | ||  __/\__ \| |_
    *|____/  \__,_| \__| \__|\___/ |_| |_|    |_| \___||___/ \__|
    */
    printf("  ____          _    _                  _______          _   \n");
    printf(" |  _ \\        | |  | |                |__   __|        | |  \n");
    printf(" | |_) | _   _ | |_ | |_  ___   _ __      | |  ___  ___ | |_ \n");
    printf(" |  _ < | | | || __|| __|/ _ \\ | '_ \\     | | / _ \\/ __|| __|\n");
    printf(" | |_) || |_| || |_ | |_| (_) || | | |    | ||  __/\\__ \\| |_ \n");
    printf(" |____/  \\__,_| \\__| \\__|\\___/ |_| |_|    |_| \\___||___/ \\__|\n");
    unity_run_menu();
}

--- END OF FILE: .\components\iot_button\test_apps\main\button_test_main.c ---

--- START OF FILE: .\components\iot_button\test_apps\main\CMakeLists.txt ---
if("${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}" VERSION_GREATER_EQUAL "5.0")
    list(APPEND PRIVREQ esp_adc)
endif()

idf_component_register(SRC_DIRS "."
                       PRIV_INCLUDE_DIRS "."
                       PRIV_REQUIRES esp_event unity test_utils button ${PRIVREQ}
                       WHOLE_ARCHIVE)

--- END OF FILE: .\components\iot_button\test_apps\main\CMakeLists.txt ---

--- START OF FILE: .\components\iot_button\test_apps\main\custom_button_test.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "unity.h"
#include "iot_button.h"
#include "driver/gpio.h"

static const char *TAG = "CUSTOM BUTTON TEST";

#define BUTTON_IO_NUM  0
#define BUTTON_ACTIVE_LEVEL   0

static void button_event_cb(void *arg, void *data)
{
    button_event_t event = iot_button_get_event(arg);
    ESP_LOGI(TAG, "%s", iot_button_get_event_str(event));
    if (BUTTON_PRESS_REPEAT == event || BUTTON_PRESS_REPEAT_DONE == event) {
        ESP_LOGI(TAG, "\tREPEAT[%d]", iot_button_get_repeat(arg));
    }

    if (BUTTON_PRESS_UP == event || BUTTON_LONG_PRESS_HOLD == event || BUTTON_LONG_PRESS_UP == event) {
        ESP_LOGI(TAG, "\tTICKS[%"PRIu32"]", iot_button_get_ticks_time(arg));
    }

    if (BUTTON_MULTIPLE_CLICK == event) {
        ESP_LOGI(TAG, "\tMULTIPLE[%d]", (int)data);
    }
}

typedef struct {
    button_driver_t base;
    int32_t gpio_num;              /**< num of gpio */
    uint8_t active_level;          /**< gpio level when press down */
} custom_gpio_obj;

static uint8_t button_get_key_level(button_driver_t *button_driver)
{
    custom_gpio_obj *custom_btn = __containerof(button_driver, custom_gpio_obj, base);
    int level = gpio_get_level(custom_btn->gpio_num);
    return level == custom_btn->active_level ? 1 : 0;
}

static esp_err_t button_del(button_driver_t *button_driver)
{
    return ESP_OK;
}

TEST_CASE("custom button test", "[button][custom]")
{
    gpio_config_t gpio_conf = {
        .pin_bit_mask = 1ULL << BUTTON_IO_NUM,
                             .mode = GPIO_MODE_INPUT,
                             .pull_up_en = 1,
                             .pull_down_en = 0,
                             .intr_type = GPIO_INTR_DISABLE,
    };
    gpio_config(&gpio_conf);

    custom_gpio_obj *custom_btn = (custom_gpio_obj *)calloc(1, sizeof(custom_gpio_obj));
    TEST_ASSERT_NOT_NULL(custom_btn);
    custom_btn->active_level = BUTTON_ACTIVE_LEVEL;
    custom_btn->gpio_num = BUTTON_IO_NUM;

    button_handle_t btn = NULL;
    const button_config_t btn_cfg = {0};
    custom_btn->base.get_key_level = button_get_key_level;
    custom_btn->base.del = button_del;
    esp_err_t ret = iot_button_create(&btn_cfg, &custom_btn->base, &btn);
    TEST_ASSERT(ESP_OK == ret);
    TEST_ASSERT_NOT_NULL(btn);
    iot_button_register_cb(btn, BUTTON_PRESS_DOWN, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_SINGLE_CLICK, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_DOUBLE_CLICK, NULL, button_event_cb, NULL);

    /*!< Multiple Click must provide button_event_args_t */
    /*!< Double Click */
    button_event_args_t args = {
        .multiple_clicks.clicks = 2,
    };
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)2);
    /*!< Triple Click */
    args.multiple_clicks.clicks = 3;
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)3);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_START, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_END, NULL, button_event_cb, NULL);

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    iot_button_delete(btn);
}

--- END OF FILE: .\components\iot_button\test_apps\main\custom_button_test.c ---

--- START OF FILE: .\components\iot_button\test_apps\main\gpio_button_test.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "unity.h"
#include "iot_button.h"
#include "button_gpio.h"

static const char *TAG = "GPIO BUTTON TEST";

#define BUTTON_IO_NUM  0
#define BUTTON_ACTIVE_LEVEL   0

static void button_event_cb(void *arg, void *data)
{
    button_event_t event = iot_button_get_event(arg);
    ESP_LOGI(TAG, "%s", iot_button_get_event_str(event));
    if (BUTTON_PRESS_REPEAT == event || BUTTON_PRESS_REPEAT_DONE == event) {
        ESP_LOGI(TAG, "\tREPEAT[%d]", iot_button_get_repeat(arg));
    }

    if (BUTTON_PRESS_UP == event || BUTTON_LONG_PRESS_HOLD == event || BUTTON_LONG_PRESS_UP == event) {
        ESP_LOGI(TAG, "\tTICKS[%"PRIu32"]", iot_button_get_ticks_time(arg));
    }

    if (BUTTON_MULTIPLE_CLICK == event) {
        ESP_LOGI(TAG, "\tMULTIPLE[%d]", (int)data);
    }
}

TEST_CASE("gpio button test", "[button][gpio]")
{
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);
    iot_button_register_cb(btn, BUTTON_PRESS_DOWN, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_SINGLE_CLICK, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_DOUBLE_CLICK, NULL, button_event_cb, NULL);

    /*!< Multiple Click must provide button_event_args_t */
    /*!< Double Click */
    button_event_args_t args = {
        .multiple_clicks.clicks = 2,
    };
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)2);
    /*!< Triple Click */
    args.multiple_clicks.clicks = 3;
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)3);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_START, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_END, NULL, button_event_cb, NULL);

    uint8_t level = 0;
    level = iot_button_get_key_level(btn);
    ESP_LOGI(TAG, "button level is %d", level);

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    iot_button_delete(btn);
}

TEST_CASE("gpio button get event test", "[button][gpio][event test]")
{
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);

    uint8_t level = 0;
    level = iot_button_get_key_level(btn);
    ESP_LOGI(TAG, "button level is %d", level);

    while (1) {
        button_event_t event = iot_button_get_event(btn);
        if (event != BUTTON_NONE_PRESS) {
            ESP_LOGI(TAG, "event is %s", iot_button_get_event_str(event));
        }
        vTaskDelay(pdMS_TO_TICKS(1));
    }

    iot_button_delete(btn);
}

TEST_CASE("gpio button test power save", "[button][gpio][power save]")
{
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
        .enable_power_save = true,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);

    iot_button_register_cb(btn, BUTTON_PRESS_DOWN, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_SINGLE_CLICK, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_DOUBLE_CLICK, NULL, button_event_cb, NULL);

    /*!< Multiple Click must provide button_event_args_t */
    /*!< Double Click */
    button_event_args_t args = {
        .multiple_clicks.clicks = 2,
    };
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)2);
    /*!< Triple Click */
    args.multiple_clicks.clicks = 3;
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)3);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_START, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_END, NULL, button_event_cb, NULL);

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    iot_button_delete(btn);
}

TEST_CASE("gpio button test memory leak", "[button][gpio][memory leak]")
{
    const button_config_t btn_cfg = {0};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = BUTTON_IO_NUM,
        .active_level = BUTTON_ACTIVE_LEVEL,
    };

    button_handle_t btn = NULL;
    esp_err_t ret = iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn);
    TEST_ASSERT(ret == ESP_OK);
    TEST_ASSERT_NOT_NULL(btn);

    iot_button_register_cb(btn, BUTTON_PRESS_DOWN, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_SINGLE_CLICK, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_DOUBLE_CLICK, NULL, button_event_cb, NULL);

    /*!< Multiple Click must provide button_event_args_t */
    /*!< Double Click */
    button_event_args_t args = {
        .multiple_clicks.clicks = 2,
    };
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)2);
    /*!< Triple Click */
    args.multiple_clicks.clicks = 3;
    iot_button_register_cb(btn, BUTTON_MULTIPLE_CLICK, &args, button_event_cb, (void *)3);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_START, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_LONG_PRESS_UP, NULL, button_event_cb, NULL);
    iot_button_register_cb(btn, BUTTON_PRESS_END, NULL, button_event_cb, NULL);

    iot_button_delete(btn);
}

--- END OF FILE: .\components\iot_button\test_apps\main\gpio_button_test.c ---

--- START OF FILE: .\components\iot_button\test_apps\main\matrix_button_test.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "unity.h"
#include "iot_button.h"
#include "button_matrix.h"

static const char *TAG = "MATRIX BUTTON TEST";

static void button_event_cb(void *arg, void *data)
{
    button_event_t event = iot_button_get_event(arg);
    ESP_LOGI(TAG, "BUTTON[%d] %s", (int)data, iot_button_get_event_str(event));
    if (BUTTON_PRESS_REPEAT == event || BUTTON_PRESS_REPEAT_DONE == event) {
        ESP_LOGI(TAG, "\tREPEAT[%d]", iot_button_get_repeat(arg));
    }

    if (BUTTON_PRESS_UP == event || BUTTON_LONG_PRESS_HOLD == event || BUTTON_LONG_PRESS_UP == event) {
        ESP_LOGI(TAG, "\tTICKS[%"PRIu32"]", iot_button_get_ticks_time(arg));
    }

    if (BUTTON_MULTIPLE_CLICK == event) {
        ESP_LOGI(TAG, "\tMULTIPLE[%d]", (int)data);
    }
}

TEST_CASE("matrix keyboard button test", "[button][matrix key]")
{
    const button_config_t btn_cfg = {0};
    const button_matrix_config_t matrix_cfg = {
        .row_gpios = (int32_t[]){4, 5, 6, 7},
        .col_gpios = (int32_t[]){3, 8, 16, 15},
        .row_gpio_num = 4,
        .col_gpio_num = 4,
    };

    button_handle_t btns[16] = {0};
    size_t btn_num = 16;
    esp_err_t ret = iot_button_new_matrix_device(&btn_cfg, &matrix_cfg, btns, &btn_num);
    TEST_ASSERT(ret == ESP_OK);

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            int index = i * 4 + j;
            TEST_ASSERT_NOT_NULL(btns[index]);
            iot_button_register_cb(btns[index], BUTTON_PRESS_DOWN, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_PRESS_UP, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_PRESS_REPEAT, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_PRESS_REPEAT_DONE, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_SINGLE_CLICK, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_DOUBLE_CLICK, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_LONG_PRESS_START, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_LONG_PRESS_UP, NULL, button_event_cb, (void *)index);
            iot_button_register_cb(btns[index], BUTTON_PRESS_END, NULL, button_event_cb, (void *)index);
        }
    }

    while (1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            iot_button_delete(btns[i * 4 + j]);
        }
    }
}

--- END OF FILE: .\components\iot_button\test_apps\main\matrix_button_test.c ---

--- START OF FILE: .\components\iot_button\test_apps\CMakeLists.txt ---

# The following lines of boilerplate have to be in your project's CMakeLists
# in this exact order for cmake to work correctly
cmake_minimum_required(VERSION 3.5)

set(EXTRA_COMPONENT_DIRS "$ENV{IDF_PATH}/tools/unit-test-app/components"
                         "../../button")
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(button_test)

--- END OF FILE: .\components\iot_button\test_apps\CMakeLists.txt ---

--- START OF FILE: .\components\iot_button\button_adc.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <string.h>
#include <inttypes.h>
#include "esp_log.h"
#include "esp_check.h"
#include "esp_timer.h"
#include "esp_idf_version.h"
#include "soc/soc_caps.h"
#include "esp_adc/adc_oneshot.h"
#include "esp_adc/adc_cali.h"
#include "esp_adc/adc_cali_scheme.h"
#include "button_adc.h"
#include "button_interface.h"

static const char *TAG = "adc_button";

#define DEFAULT_VREF    1100
#define NO_OF_SAMPLES   CONFIG_ADC_BUTTON_SAMPLE_TIMES     //Multisampling

/*!< Using atten bigger than 6db by default, it will be 11db or 12db in different target */
#define DEFAULT_ADC_ATTEN         (ADC_ATTEN_DB_6 + 1)

#define ADC_BUTTON_WIDTH          SOC_ADC_RTC_MAX_BITWIDTH
#define ADC_BUTTON_CHANNEL_MAX    SOC_ADC_MAX_CHANNEL_NUM
#define ADC_BUTTON_ATTEN          DEFAULT_ADC_ATTEN

#define ADC_BUTTON_MAX_CHANNEL  CONFIG_ADC_BUTTON_MAX_CHANNEL
#define ADC_BUTTON_MAX_BUTTON   CONFIG_ADC_BUTTON_MAX_BUTTON_PER_CHANNEL

// ESP32C3 ADC2 it has been deprecated.
#if (SOC_ADC_PERIPH_NUM >= 2) && !CONFIG_IDF_TARGET_ESP32C3
#define ADC_UNIT_NUM 2
#else
#define ADC_UNIT_NUM 1
#endif

typedef struct {
    uint16_t min;
    uint16_t max;
} button_data_t;

typedef struct {
    uint8_t channel;
    uint8_t is_init;
    button_data_t btns[ADC_BUTTON_MAX_BUTTON];  /* all button on the channel */
    uint64_t last_time;  /* the last time of adc sample */
} btn_adc_channel_t;

typedef enum {
    ADC_NONE_INIT = 0,
    ADC_INIT_BY_ADC_BUTTON,
    ADC_INIT_BY_USER,
} adc_init_info_t;

typedef struct {
    adc_init_info_t is_configured;
    adc_cali_handle_t adc_cali_handle;
    adc_oneshot_unit_handle_t adc_handle;
    btn_adc_channel_t ch[ADC_BUTTON_MAX_CHANNEL];
    uint8_t ch_num;
} btn_adc_unit_t;

typedef struct {
    btn_adc_unit_t unit[ADC_UNIT_NUM];
} button_adc_t;
typedef struct {
    button_driver_t base;
    adc_unit_t unit_id;
    uint32_t ch;
    uint32_t index;
} button_adc_obj;

static button_adc_t g_button = {0};

static int find_unused_channel(adc_unit_t unit_id)
{
    for (size_t i = 0; i < ADC_BUTTON_MAX_CHANNEL; i++) {
        if (0 == g_button.unit[unit_id].ch[i].is_init) {
            return i;
        }
    }
    return -1;
}

static int find_channel(adc_unit_t unit_id, uint8_t channel)
{
    for (size_t i = 0; i < ADC_BUTTON_MAX_CHANNEL; i++) {
        if (channel == g_button.unit[unit_id].ch[i].channel) {
            return i;
        }
    }
    return -1;
}

static bool adc_calibration_init(adc_unit_t unit, adc_atten_t atten, adc_cali_handle_t *out_handle)
{
    adc_cali_handle_t handle = NULL;
    esp_err_t ret = ESP_ERR_NOT_SUPPORTED;
    bool calibrated = false;

#if ADC_CALI_SCHEME_CURVE_FITTING_SUPPORTED
    if (!calibrated) {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Curve Fitting");
        adc_cali_curve_fitting_config_t cali_config = {
            .unit_id = unit,
            .atten = atten,
            .bitwidth = ADC_BUTTON_WIDTH,
        };
        ret = adc_cali_create_scheme_curve_fitting(&cali_config, &handle);
        if (ret == ESP_OK) {
            calibrated = true;
        }
    }
#endif

#if ADC_CALI_SCHEME_LINE_FITTING_SUPPORTED
    if (!calibrated) {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Line Fitting");
        adc_cali_line_fitting_config_t cali_config = {
            .unit_id = unit,
            .atten = atten,
            .bitwidth = ADC_BUTTON_WIDTH,
        };
        ret = adc_cali_create_scheme_line_fitting(&cali_config, &handle);
        if (ret == ESP_OK) {
            calibrated = true;
        }
    }
#endif

    *out_handle = handle;
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "Calibration Success");
    } else if (ret == ESP_ERR_NOT_SUPPORTED || !calibrated) {
        ESP_LOGW(TAG, "eFuse not burnt, skip software calibration");
    } else if (ret == ESP_ERR_NOT_SUPPORTED) {
        ESP_LOGW(TAG, "Calibration not supported");
    } else {
        ESP_LOGE(TAG, "Invalid arg or no memory");
    }

    return calibrated;
}

static bool adc_calibration_deinit(adc_cali_handle_t handle)
{
#if ADC_CALI_SCHEME_CURVE_FITTING_SUPPORTED
    if (adc_cali_delete_scheme_curve_fitting(handle) == ESP_OK) {
        return true;
    }
#endif

#if ADC_CALI_SCHEME_LINE_FITTING_SUPPORTED
    if (adc_cali_delete_scheme_line_fitting(handle) == ESP_OK) {
        return true;
    }
#endif

    return false;
}

esp_err_t button_adc_del(button_driver_t *button_driver)
{
    button_adc_obj *adc_btn = __containerof(button_driver, button_adc_obj, base);
    ESP_RETURN_ON_FALSE(adc_btn->ch < ADC_BUTTON_CHANNEL_MAX, ESP_ERR_INVALID_ARG, TAG, "channel out of range");
    ESP_RETURN_ON_FALSE(adc_btn->index < ADC_BUTTON_MAX_BUTTON, ESP_ERR_INVALID_ARG, TAG, "button_index out of range");

    int ch_index = find_channel(adc_btn->unit_id, adc_btn->ch);
    ESP_RETURN_ON_FALSE(ch_index >= 0, ESP_ERR_INVALID_ARG, TAG, "can't find the channel");

    g_button.unit[adc_btn->unit_id].ch[ch_index].btns[adc_btn->index].max = 0;
    g_button.unit[adc_btn->unit_id].ch[ch_index].btns[adc_btn->index].min = 0;

    /** check button usage on the channel*/
    uint8_t unused_button = 0;
    for (size_t i = 0; i < ADC_BUTTON_MAX_BUTTON; i++) {
        if (0 == g_button.unit[adc_btn->unit_id].ch[ch_index].btns[i].max) {
            unused_button++;
        }
    }
    if (unused_button == ADC_BUTTON_MAX_BUTTON && g_button.unit[adc_btn->unit_id].ch[ch_index].is_init) {  /**< if all button is unused, deinit the channel */
        g_button.unit[adc_btn->unit_id].ch[ch_index].is_init = 0;
        g_button.unit[adc_btn->unit_id].ch[ch_index].channel = ADC_BUTTON_CHANNEL_MAX;
        ESP_LOGD(TAG, "all button is unused on channel%d, deinit the channel", g_button.unit[adc_btn->unit_id].ch[ch_index].channel);
    }

    /** check channel usage on the adc*/
    uint8_t unused_ch = 0;
    for (size_t i = 0; i < ADC_BUTTON_MAX_CHANNEL; i++) {
        if (0 == g_button.unit[adc_btn->unit_id].ch[i].is_init) {
            unused_ch++;
        }
    }
    if (unused_ch == ADC_BUTTON_MAX_CHANNEL && g_button.unit[adc_btn->unit_id].is_configured) { /**< if all channel is unused, deinit the adc */
        if (g_button.unit[adc_btn->unit_id].is_configured == ADC_INIT_BY_ADC_BUTTON) {
            esp_err_t ret = adc_oneshot_del_unit(g_button.unit[adc_btn->unit_id].adc_handle);
            ESP_RETURN_ON_FALSE(ret == ESP_OK, ret, TAG, "adc oneshot del unit fail");
            adc_calibration_deinit(g_button.unit[adc_btn->unit_id].adc_cali_handle);
        }

        g_button.unit[adc_btn->unit_id].is_configured = ADC_NONE_INIT;
        memset(&g_button.unit[adc_btn->unit_id], 0, sizeof(btn_adc_unit_t));
        ESP_LOGD(TAG, "all channel is unused, , deinit adc");
    }
    free(adc_btn);

    return ESP_OK;
}

static uint32_t get_adc_volatge(adc_unit_t unit_id, uint8_t channel)
{
    uint32_t adc_reading = 0;
    int adc_raw = 0;
    for (int i = 0; i < NO_OF_SAMPLES; i++) {
        adc_oneshot_read(g_button.unit[unit_id].adc_handle, channel, &adc_raw);
        adc_reading += adc_raw;
    }
    adc_reading /= NO_OF_SAMPLES;
    //Convert adc_reading to voltage in mV
    int voltage = 0;
    adc_cali_raw_to_voltage(g_button.unit[unit_id].adc_cali_handle, adc_reading, &voltage);
    ESP_LOGV(TAG, "Raw: %"PRIu32"\tVoltage: %dmV", adc_reading, voltage);
    return voltage;
}

uint8_t button_adc_get_key_level(button_driver_t *button_driver)
{
    button_adc_obj *adc_btn = __containerof(button_driver, button_adc_obj, base);
    static uint16_t vol = 0;
    uint32_t ch = adc_btn->ch;
    uint32_t index = adc_btn->index;
    ESP_RETURN_ON_FALSE(ch < ADC_BUTTON_CHANNEL_MAX, 0, TAG, "channel out of range");
    ESP_RETURN_ON_FALSE(index < ADC_BUTTON_MAX_BUTTON, 0, TAG, "button_index out of range");

    int ch_index = find_channel(adc_btn->unit_id, ch);
    ESP_RETURN_ON_FALSE(ch_index >= 0, 0, TAG, "The button_index is not init");

    /** It starts only when the elapsed time is more than 1ms */
    if ((esp_timer_get_time() - g_button.unit[adc_btn->unit_id].ch[ch_index].last_time) > 1000) {
        vol = get_adc_volatge(adc_btn->unit_id, ch);
        g_button.unit[adc_btn->unit_id].ch[ch_index].last_time = esp_timer_get_time();
    }

    if (vol <= g_button.unit[adc_btn->unit_id].ch[ch_index].btns[index].max &&
            vol >= g_button.unit[adc_btn->unit_id].ch[ch_index].btns[index].min) {
        return BUTTON_ACTIVE;
    }
    return BUTTON_INACTIVE;
}

esp_err_t iot_button_new_adc_device(const button_config_t *button_config, const button_adc_config_t *adc_config, button_handle_t *ret_button)
{
    esp_err_t ret = ESP_OK;
    ESP_RETURN_ON_FALSE(button_config && adc_config && ret_button, ESP_ERR_INVALID_ARG, TAG, "Invalid argument");
    ESP_RETURN_ON_FALSE(adc_config->unit_id < ADC_UNIT_NUM, ESP_ERR_INVALID_ARG, TAG, "adc_handle out of range");
    ESP_RETURN_ON_FALSE(adc_config->adc_channel < ADC_BUTTON_CHANNEL_MAX, ESP_ERR_INVALID_ARG, TAG, "channel out of range");
    ESP_RETURN_ON_FALSE(adc_config->button_index < ADC_BUTTON_MAX_BUTTON, ESP_ERR_INVALID_ARG, TAG, "button_index out of range");
    ESP_RETURN_ON_FALSE(adc_config->max > 0, ESP_ERR_INVALID_ARG, TAG, "key max voltage invalid");
    button_adc_obj *adc_btn = calloc(1, sizeof(button_adc_obj));
    ESP_RETURN_ON_FALSE(adc_btn, ESP_ERR_NO_MEM, TAG, "calloc fail");
    adc_btn->unit_id = adc_config->unit_id;

    int ch_index = find_channel(adc_btn->unit_id, adc_config->adc_channel);
    if (ch_index >= 0) { /**< the channel has been initialized */
        ESP_GOTO_ON_FALSE(g_button.unit[adc_btn->unit_id].ch[ch_index].btns[adc_config->button_index].max == 0, ESP_ERR_INVALID_STATE, err, TAG, "The button_index has been used");
    } else { /**< this is a new channel */
        int unused_ch_index = find_unused_channel(adc_config->unit_id);
        ESP_GOTO_ON_FALSE(unused_ch_index >= 0, ESP_ERR_INVALID_STATE, err, TAG, "exceed max channel number, can't create a new channel");
        ch_index = unused_ch_index;
    }

    /** initialize adc */
    if (0 == g_button.unit[adc_btn->unit_id].is_configured) {
        esp_err_t ret;
        if (NULL == adc_config->adc_handle) {
            //ADC1 Init
            adc_oneshot_unit_init_cfg_t init_config = {
                .unit_id = adc_btn->unit_id,
            };
            ret = adc_oneshot_new_unit(&init_config, &g_button.unit[adc_btn->unit_id].adc_handle);
            ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "adc oneshot new unit fail!");
            g_button.unit[adc_btn->unit_id].is_configured = ADC_INIT_BY_ADC_BUTTON;
        } else {
            g_button.unit[adc_btn->unit_id].adc_handle = *adc_config->adc_handle;
            ESP_LOGI(TAG, "ADC1 has been initialized");
            g_button.unit[adc_btn->unit_id].is_configured = ADC_INIT_BY_USER;
        }

    }

    /** initialize adc channel */
    if (0 == g_button.unit[adc_btn->unit_id].ch[ch_index].is_init) {
        //ADC1 Config
        adc_oneshot_chan_cfg_t oneshot_config = {
            .bitwidth = ADC_BUTTON_WIDTH,
            .atten = ADC_BUTTON_ATTEN,
        };
        esp_err_t ret = adc_oneshot_config_channel(g_button.unit[adc_btn->unit_id].adc_handle, adc_config->adc_channel, &oneshot_config);
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "adc oneshot config channel fail!");
        //-------------ADC1 Calibration Init---------------//
        adc_calibration_init(adc_btn->unit_id, ADC_BUTTON_ATTEN, &g_button.unit[adc_btn->unit_id].adc_cali_handle);
        g_button.unit[adc_btn->unit_id].ch[ch_index].channel = adc_config->adc_channel;
        g_button.unit[adc_btn->unit_id].ch[ch_index].is_init = 1;
        g_button.unit[adc_btn->unit_id].ch[ch_index].last_time = 0;
    }
    g_button.unit[adc_btn->unit_id].ch[ch_index].btns[adc_config->button_index].max = adc_config->max;
    g_button.unit[adc_btn->unit_id].ch[ch_index].btns[adc_config->button_index].min = adc_config->min;
    g_button.unit[adc_btn->unit_id].ch_num++;

    adc_btn->ch = adc_config->adc_channel;
    adc_btn->index = adc_config->button_index;
    adc_btn->base.get_key_level = button_adc_get_key_level;
    adc_btn->base.del = button_adc_del;
    ret = iot_button_create(button_config, &adc_btn->base, ret_button);
    ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Create button failed");

    return ESP_OK;
err:
    if (adc_btn) {
        free(adc_btn);
    }
    return ret;
}

--- END OF FILE: .\components\iot_button\button_adc.c ---

--- START OF FILE: .\components\iot_button\button_gpio.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include "esp_log.h"
#include "esp_err.h"
#include "esp_check.h"
#include "driver/gpio.h"
#include "button_gpio.h"
#include "esp_sleep.h"
#include "button_interface.h"
#include "iot_button.h"

static const char *TAG = "gpio_button";

typedef struct {
    button_driver_t base;          /**< button driver */
    int32_t gpio_num;              /**< num of gpio */
    uint8_t active_level;          /**< gpio level when press down */
    bool enable_power_save;        /**< enable power save */
} button_gpio_obj;

static esp_err_t button_gpio_del(button_driver_t *button_driver)
{
    button_gpio_obj *gpio_btn = __containerof(button_driver, button_gpio_obj, base);
    esp_err_t ret = gpio_reset_pin(gpio_btn->gpio_num);
    free(gpio_btn);
    return ret;
}

static uint8_t button_gpio_get_key_level(button_driver_t *button_driver)
{
    button_gpio_obj *gpio_btn = __containerof(button_driver, button_gpio_obj, base);
    int level = gpio_get_level(gpio_btn->gpio_num);
    return level == gpio_btn->active_level ? 1 : 0;
}

static esp_err_t button_gpio_enable_gpio_wakeup(uint32_t gpio_num, uint8_t active_level, bool enable)
{
    esp_err_t ret;
    if (enable) {
        gpio_intr_enable(gpio_num);
        ret = gpio_wakeup_enable(gpio_num, active_level == 0 ? GPIO_INTR_LOW_LEVEL : GPIO_INTR_HIGH_LEVEL);
    } else {
        gpio_intr_disable(gpio_num);
        ret = gpio_wakeup_disable(gpio_num);
    }
    return ret;
}

static esp_err_t button_gpio_set_intr(int gpio_num, gpio_int_type_t intr_type, gpio_isr_t isr_handler)
{
    static bool isr_service_installed = false;
    gpio_set_intr_type(gpio_num, intr_type);
    if (!isr_service_installed) {
        gpio_install_isr_service(ESP_INTR_FLAG_IRAM);
        isr_service_installed = true;
    }
    gpio_isr_handler_add(gpio_num, isr_handler, (void *)gpio_num);
    return ESP_OK;
}

static void button_power_save_isr_handler(void* arg)
{
    /*!< resume the button */
    iot_button_resume();
    /*!< disable gpio wakeup not need active level*/
    button_gpio_enable_gpio_wakeup((uint32_t)arg, 0, false);
}

static esp_err_t button_enter_power_save(button_driver_t *button_driver)
{
    button_gpio_obj *gpio_btn = __containerof(button_driver, button_gpio_obj, base);
    return button_gpio_enable_gpio_wakeup(gpio_btn->gpio_num, gpio_btn->active_level, true);
}

esp_err_t iot_button_new_gpio_device(const button_config_t *button_config, const button_gpio_config_t *gpio_cfg, button_handle_t *ret_button)
{
    button_gpio_obj *gpio_btn = NULL;
    esp_err_t ret = ESP_OK;
    ESP_GOTO_ON_FALSE(button_config && gpio_cfg && ret_button, ESP_ERR_INVALID_ARG, err, TAG, "Invalid argument");
    ESP_GOTO_ON_FALSE(GPIO_IS_VALID_GPIO(gpio_cfg->gpio_num), ESP_ERR_INVALID_ARG, err, TAG, "GPIO number error");

    gpio_btn = (button_gpio_obj *)calloc(1, sizeof(button_gpio_obj));
    ESP_GOTO_ON_FALSE(gpio_btn, ESP_ERR_NO_MEM, err, TAG, "No memory for gpio button");
    gpio_btn->gpio_num = gpio_cfg->gpio_num;
    gpio_btn->active_level = gpio_cfg->active_level;
    gpio_btn->enable_power_save = gpio_cfg->enable_power_save;

    gpio_config_t gpio_conf = {0};
    gpio_conf.intr_type = GPIO_INTR_DISABLE;
    gpio_conf.mode = GPIO_MODE_INPUT;
    gpio_conf.pin_bit_mask = (1ULL << gpio_cfg->gpio_num);
    if (!gpio_cfg->disable_pull) {
        if (gpio_cfg->active_level) {
            gpio_conf.pull_down_en = GPIO_PULLDOWN_ENABLE;
            gpio_conf.pull_up_en = GPIO_PULLUP_DISABLE;
        } else {
            gpio_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
            gpio_conf.pull_up_en = GPIO_PULLUP_ENABLE;
        }
    }
    gpio_config(&gpio_conf);

    if (gpio_cfg->enable_power_save) {
#if CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP
        if (!esp_sleep_is_valid_wakeup_gpio(gpio_cfg->gpio_num)) {
            ESP_LOGE(TAG, "GPIO %ld is not a valid wakeup source under CONFIG_GPIO_BUTTON_SUPPORT_POWER_SAVE", gpio_cfg->gpio_num);
            return ESP_FAIL;
        }
        gpio_hold_en(gpio_cfg->gpio_num);
#endif
        /* Enable wake up from GPIO */
        esp_err_t ret = gpio_wakeup_enable(gpio_cfg->gpio_num, gpio_cfg->active_level == 0 ? GPIO_INTR_LOW_LEVEL : GPIO_INTR_HIGH_LEVEL);
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_ERR_INVALID_STATE, err, TAG, "Enable gpio wakeup failed");
#if CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP
#if SOC_PM_SUPPORT_EXT1_WAKEUP
        ret = esp_sleep_enable_ext1_wakeup_io((1ULL << gpio_cfg->gpio_num), gpio_cfg->active_level == 0 ? ESP_EXT1_WAKEUP_ANY_LOW : ESP_EXT1_WAKEUP_ANY_HIGH);
#else
        /*!< Not support etc: esp32c2, esp32c3. Target must support ext1 wakeup */
        ret = ESP_FAIL;
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Target must support ext1 wakeup");
#endif
#else
        ret = esp_sleep_enable_gpio_wakeup();
#endif
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Configure gpio as wakeup source failed");

        ret = button_gpio_set_intr(gpio_btn->gpio_num, gpio_cfg->active_level == 0 ? GPIO_INTR_LOW_LEVEL : GPIO_INTR_HIGH_LEVEL, button_power_save_isr_handler);
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Set gpio interrupt failed");

        gpio_btn->base.enable_power_save = true;
        gpio_btn->base.enter_power_save = button_enter_power_save;
    }

    gpio_btn->base.get_key_level = button_gpio_get_key_level;
    gpio_btn->base.del = button_gpio_del;

    ret = iot_button_create(button_config, &gpio_btn->base, ret_button);
    ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Create button failed");

    return ESP_OK;
err:
    if (gpio_btn) {
        free(gpio_btn);
    }
    return ret;
}

--- END OF FILE: .\components\iot_button\button_gpio.c ---

--- START OF FILE: .\components\iot_button\button_matrix.c ---
/*
 * SPDX-FileCopyrightText: 2023-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <inttypes.h>
#include "esp_log.h"
#include "esp_check.h"
#include "driver/gpio.h"
#include "button_matrix.h"
#include "button_interface.h"

static const char *TAG = "matrix_button";

typedef struct {
    button_driver_t base;          /**< base button driver */
    int32_t row_gpio_num;          /**< row gpio */
    int32_t col_gpio_num;          /**< col gpio */
} button_matrix_obj;

static esp_err_t button_matrix_gpio_init(int32_t gpio_num, gpio_mode_t mode)
{
    ESP_RETURN_ON_FALSE(GPIO_IS_VALID_GPIO(gpio_num), ESP_ERR_INVALID_ARG, TAG, "gpio_num error");
    gpio_config_t gpio_conf = {0};
    gpio_conf.intr_type = GPIO_INTR_DISABLE;
    gpio_conf.pull_down_en = GPIO_PULLDOWN_ENABLE;
    gpio_conf.pin_bit_mask = (1ULL << gpio_num);
    gpio_conf.mode = mode;
    gpio_config(&gpio_conf);
    return ESP_OK;
}

esp_err_t button_matrix_del(button_driver_t *button_driver)
{
    button_matrix_obj *matrix_btn = __containerof(button_driver, button_matrix_obj, base);
    //Reset an gpio to default state (select gpio function, enable pullup and disable input and output).
    gpio_reset_pin(matrix_btn->row_gpio_num);
    gpio_reset_pin(matrix_btn->col_gpio_num);
    free(matrix_btn);
    return ESP_OK;
}

uint8_t button_matrix_get_key_level(button_driver_t *button_driver)
{
    button_matrix_obj *matrix_btn = __containerof(button_driver, button_matrix_obj, base);
    gpio_set_level(matrix_btn->row_gpio_num, 1);
    uint8_t level = gpio_get_level(matrix_btn->col_gpio_num);
    gpio_set_level(matrix_btn->row_gpio_num, 0);
    return level;
}

esp_err_t iot_button_new_matrix_device(const button_config_t *button_config, const button_matrix_config_t *matrix_config, button_handle_t *ret_button, size_t *size)
{
    esp_err_t ret = ESP_OK;
    ESP_RETURN_ON_FALSE(button_config && matrix_config && ret_button, ESP_ERR_INVALID_ARG, TAG, "Invalid argument");
    ESP_RETURN_ON_FALSE(matrix_config->col_gpios && matrix_config->row_gpios, ESP_ERR_INVALID_ARG, TAG, "Invalid matrix config");
    ESP_RETURN_ON_FALSE(matrix_config->col_gpio_num > 0 && matrix_config->row_gpio_num > 0, ESP_ERR_INVALID_ARG, TAG, "Invalid matrix config");
    ESP_RETURN_ON_FALSE(*size == matrix_config->row_gpio_num * matrix_config->col_gpio_num, ESP_ERR_INVALID_ARG, TAG, "Invalid size");

    button_matrix_obj *matrix_btn = calloc(*size, sizeof(button_matrix_obj));
    for (int i = 0; i < matrix_config->row_gpio_num; i++) {
        button_matrix_gpio_init(matrix_config->row_gpios[i], GPIO_MODE_OUTPUT);
    }

    for (int i = 0; i < matrix_config->col_gpio_num; i++) {
        button_matrix_gpio_init(matrix_config->col_gpios[i], GPIO_MODE_INPUT);
    }

    for (int i = 0; i < *size; i++) {
        matrix_btn[i].base.get_key_level = button_matrix_get_key_level;
        matrix_btn[i].base.del = button_matrix_del;
        matrix_btn[i].row_gpio_num = matrix_config->row_gpios[i / matrix_config->col_gpio_num];
        matrix_btn[i].col_gpio_num = matrix_config->col_gpios[i % matrix_config->col_gpio_num];
        ESP_LOGD(TAG, "row_gpio_num: %"PRId32", col_gpio_num: %"PRId32"", matrix_btn[i].row_gpio_num, matrix_btn[i].col_gpio_num);
        ret = iot_button_create(button_config, &matrix_btn[i].base, &ret_button[i]);
        ESP_GOTO_ON_FALSE(ret == ESP_OK, ESP_FAIL, err, TAG, "Create button failed");
    }
    *size = matrix_config->row_gpio_num * matrix_config->col_gpio_num;
    return ESP_OK;

err:
    if (matrix_btn) {
        free(matrix_btn);
    }

    return ret;
}

--- END OF FILE: .\components\iot_button\button_matrix.c ---

--- START OF FILE: .\components\iot_button\CMakeLists.txt ---
# Fecha: 15/08/2025 - 03:42 
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\iot_button\CMakeLists.txt
# √öltimo cambio: Eliminadas las llamadas a 'package_manager' y 'cu_pkg_define_version' para resolver el error de compilaci√≥n en PlatformIO.
# Descripci√≥n: Registro del componente 'iot_button'. Se han eliminado las funciones de gesti√≥n de paquetes que requer√≠an un fichero 'idf_component.yml' inexistente, causando el fallo de CMake. El componente ahora se registra de forma est√°ndar, permitiendo que PlatformIO lo compile correctamente.

set(PRIVREQ esp_timer)
set(REQ driver)
set(SRC_FILES "button_gpio.c" "iot_button.c" "button_matrix.c")

if("${IDF_VERSION_MAJOR}.${IDF_VERSION_MINOR}" VERSION_GREATER_EQUAL "5.0")
    list(APPEND REQ esp_adc)
    if(CONFIG_SOC_ADC_SUPPORTED)
        list(APPEND SRC_FILES "button_adc.c")
    endif()
endif()

idf_component_register(SRCS ${SRC_FILES}
                        INCLUDE_DIRS include interface
                        REQUIRES ${REQ}
                        PRIV_REQUIRES ${PRIVREQ})

# [CORRECCI√ìN] Se eliminaron las siguientes l√≠neas que causaban el error de CMake,
# ya que este componente es local y no necesita gestionar su versi√≥n a trav√©s
# del registro de componentes de Espressif.
# include(package_manager)
# cu_pkg_define_version(${CMAKE_CURRENT_LIST_DIR})

--- END OF FILE: .\components\iot_button\CMakeLists.txt ---

--- START OF FILE: .\components\iot_button\iot_button.c ---
/* SPDX-FileCopyrightText: 2022-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/timers.h"
#include "driver/gpio.h"
#include "esp_timer.h"
#include "esp_log.h"
#include "esp_check.h"
#include "iot_button.h"
#include "sdkconfig.h"
#include "button_interface.h"

static const char *TAG = "button";
static portMUX_TYPE s_button_lock = portMUX_INITIALIZER_UNLOCKED;
#define BUTTON_ENTER_CRITICAL()           portENTER_CRITICAL(&s_button_lock)
#define BUTTON_EXIT_CRITICAL()            portEXIT_CRITICAL(&s_button_lock)

#define BTN_CHECK(a, str, ret_val)                                \
    if (!(a)) {                                                   \
        ESP_LOGE(TAG, "%s(%d): %s", __FUNCTION__, __LINE__, str); \
        return (ret_val);                                         \
    }

#define IOT_BUTTON_VER_MAJOR 1
#define IOT_BUTTON_VER_MINOR 0
#define IOT_BUTTON_VER_PATCH 0

static const char *button_event_str[] = {
    "BUTTON_PRESS_DOWN",
    "BUTTON_PRESS_UP",
    "BUTTON_PRESS_REPEAT",
    "BUTTON_PRESS_REPEAT_DONE",
    "BUTTON_SINGLE_CLICK",
    "BUTTON_DOUBLE_CLICK",
    "BUTTON_MULTIPLE_CLICK",
    "BUTTON_LONG_PRESS_START",
    "BUTTON_LONG_PRESS_HOLD",
    "BUTTON_LONG_PRESS_UP",
    "BUTTON_PRESS_END",
    "BUTTON_EVENT_MAX",
    "BUTTON_NONE_PRESS",
};

enum {
    PRESS_DOWN_CHECK = 0,
    PRESS_UP_CHECK,
    PRESS_REPEAT_DOWN_CHECK,
    PRESS_REPEAT_UP_CHECK,
    PRESS_LONG_PRESS_UP_CHECK,
};

/**
 * @brief Structs to store callback info
 *
 */
typedef struct {
    button_cb_t cb;
    void *usr_data;
    button_event_args_t event_args;
} button_cb_info_t;

/**
 * @brief Structs to record individual key parameters
 *
 */
typedef struct button_dev_t {
    uint32_t              ticks;                    /*!< Count for the current button state. */
    uint32_t              long_press_ticks;         /*!< Trigger ticks for long press,  */
    uint32_t              short_press_ticks;        /*!< Trigger ticks for repeat press */
    uint32_t              long_press_hold_cnt;      /*!< Record long press hold count */
    uint8_t               repeat;
    uint8_t               state: 3;
    uint8_t               debounce_cnt: 4;          /*!< Max 15 */
    uint8_t               button_level: 1;
    button_event_t        event;
    button_driver_t       *driver;
    button_cb_info_t      *cb_info[BUTTON_EVENT_MAX];
    size_t                size[BUTTON_EVENT_MAX];
    int                   count[2];
    struct button_dev_t   *next;
} button_dev_t;

//button handle list head.
static button_dev_t *g_head_handle = NULL;
static esp_timer_handle_t g_button_timer_handle = NULL;
static bool g_is_timer_running = false;
static button_power_save_config_t power_save_usr_cfg = {0};

#define TICKS_INTERVAL    CONFIG_BUTTON_PERIOD_TIME_MS
#define DEBOUNCE_TICKS    CONFIG_BUTTON_DEBOUNCE_TICKS //MAX 8
#define SHORT_TICKS       (CONFIG_BUTTON_SHORT_PRESS_TIME_MS /TICKS_INTERVAL)
#define LONG_TICKS        (CONFIG_BUTTON_LONG_PRESS_TIME_MS /TICKS_INTERVAL)
#define SERIAL_TICKS      (CONFIG_BUTTON_LONG_PRESS_HOLD_SERIAL_TIME_MS /TICKS_INTERVAL)
#define TOLERANCE         (CONFIG_BUTTON_PERIOD_TIME_MS*4)

#define CALL_EVENT_CB(ev)                                                   \
    if (btn->cb_info[ev]) {                                                 \
        for (int i = 0; i < btn->size[ev]; i++) {                           \
            btn->cb_info[ev][i].cb(btn, btn->cb_info[ev][i].usr_data);      \
        }                                                                   \
    }                                                                       \

#define TIME_TO_TICKS(time, congfig_time)  (0 == (time))?congfig_time:(((time) / TICKS_INTERVAL))?((time) / TICKS_INTERVAL):1

/**
  * @brief  Button driver core function, driver state machine.
  */
static void button_handler(button_dev_t *btn)
{
    uint8_t read_gpio_level = btn->driver->get_key_level(btn->driver);

    /** ticks counter working.. */
    if ((btn->state) > 0) {
        btn->ticks++;
    }

    /**< button debounce handle */
    if (read_gpio_level != btn->button_level) {
        if (++(btn->debounce_cnt) >= DEBOUNCE_TICKS) {
            btn->button_level = read_gpio_level;
            btn->debounce_cnt = 0;
        }
    } else {
        btn->debounce_cnt = 0;
    }

    /** State machine */
    switch (btn->state) {
    case PRESS_DOWN_CHECK:
        if (btn->button_level == BUTTON_ACTIVE) {
            btn->event = (uint8_t)BUTTON_PRESS_DOWN;
            CALL_EVENT_CB(BUTTON_PRESS_DOWN);
            btn->ticks = 0;
            btn->repeat = 1;
            btn->state = PRESS_UP_CHECK;
        } else {
            btn->event = (uint8_t)BUTTON_NONE_PRESS;
        }
        break;

    case PRESS_UP_CHECK:
        if (btn->button_level != BUTTON_ACTIVE) {
            btn->event = (uint8_t)BUTTON_PRESS_UP;
            CALL_EVENT_CB(BUTTON_PRESS_UP);
            btn->ticks = 0;
            btn->state = PRESS_REPEAT_DOWN_CHECK;

        } else if (btn->ticks >= btn->long_press_ticks) {
            btn->event = (uint8_t)BUTTON_LONG_PRESS_START;
            btn->state = PRESS_LONG_PRESS_UP_CHECK;
            /** Calling callbacks for BUTTON_LONG_PRESS_START */
            uint32_t ticks_time = iot_button_get_ticks_time(btn);
            int32_t diff = ticks_time - btn->long_press_ticks * TICKS_INTERVAL;
            if (btn->cb_info[btn->event] && btn->count[0] == 0) {
                if (abs(diff) <= TOLERANCE && btn->cb_info[btn->event][btn->count[0]].event_args.long_press.press_time == (btn->long_press_ticks * TICKS_INTERVAL)) {
                    do {
                        btn->cb_info[btn->event][btn->count[0]].cb(btn, btn->cb_info[btn->event][btn->count[0]].usr_data);
                        btn->count[0]++;
                        if (btn->count[0] >= btn->size[btn->event]) {
                            break;
                        }
                    } while (btn->cb_info[btn->event][btn->count[0]].event_args.long_press.press_time == btn->long_press_ticks * TICKS_INTERVAL);
                }
            }
        }
        break;

    case PRESS_REPEAT_DOWN_CHECK:
        if (btn->button_level == BUTTON_ACTIVE) {
            btn->event = (uint8_t)BUTTON_PRESS_DOWN;
            CALL_EVENT_CB(BUTTON_PRESS_DOWN);
            btn->event = (uint8_t)BUTTON_PRESS_REPEAT;
            btn->repeat++;
            CALL_EVENT_CB(BUTTON_PRESS_REPEAT); // repeat hit
            btn->ticks = 0;
            btn->state = PRESS_REPEAT_UP_CHECK;
        } else if (btn->ticks > btn->short_press_ticks) {
            if (btn->repeat == 1) {
                btn->event = (uint8_t)BUTTON_SINGLE_CLICK;
                CALL_EVENT_CB(BUTTON_SINGLE_CLICK);
            } else if (btn->repeat == 2) {
                btn->event = (uint8_t)BUTTON_DOUBLE_CLICK;
                CALL_EVENT_CB(BUTTON_DOUBLE_CLICK); // repeat hit
            }

            btn->event = (uint8_t)BUTTON_MULTIPLE_CLICK;

            /** Calling the callbacks for MULTIPLE BUTTON CLICKS */
            for (int i = 0; i < btn->size[btn->event]; i++) {
                if (btn->repeat == btn->cb_info[btn->event][i].event_args.multiple_clicks.clicks) {
                    do {
                        btn->cb_info[btn->event][i].cb(btn, btn->cb_info[btn->event][i].usr_data);
                        i++;
                        if (i >= btn->size[btn->event]) {
                            break;
                        }
                    } while (btn->cb_info[btn->event][i].event_args.multiple_clicks.clicks == btn->repeat);
                }
            }

            btn->event = (uint8_t)BUTTON_PRESS_REPEAT_DONE;
            CALL_EVENT_CB(BUTTON_PRESS_REPEAT_DONE); // repeat hit
            btn->repeat = 0;
            btn->state = 0;
            btn->event = (uint8_t)BUTTON_PRESS_END;
            CALL_EVENT_CB(BUTTON_PRESS_END);
        }
        break;

    case 3:
        if (btn->button_level != BUTTON_ACTIVE) {
            btn->event = (uint8_t)BUTTON_PRESS_UP;
            CALL_EVENT_CB(BUTTON_PRESS_UP);
            if (btn->ticks < btn->short_press_ticks) {
                btn->ticks = 0;
                btn->state = PRESS_REPEAT_DOWN_CHECK; //repeat press
            } else {
                btn->state = PRESS_DOWN_CHECK;
                btn->event = (uint8_t)BUTTON_PRESS_END;
                CALL_EVENT_CB(BUTTON_PRESS_END);
            }
        }
        break;

    case PRESS_LONG_PRESS_UP_CHECK:
        if (btn->button_level == BUTTON_ACTIVE) {
            //continue hold trigger
            if (btn->ticks >= (btn->long_press_hold_cnt + 1) * SERIAL_TICKS + btn->long_press_ticks) {
                btn->event = (uint8_t)BUTTON_LONG_PRESS_HOLD;
                btn->long_press_hold_cnt++;
                CALL_EVENT_CB(BUTTON_LONG_PRESS_HOLD);
            }

            /** Calling callbacks for BUTTON_LONG_PRESS_START based on press_time */
            uint32_t ticks_time = iot_button_get_ticks_time(btn);
            if (btn->cb_info[BUTTON_LONG_PRESS_START]) {
                button_cb_info_t *cb_info = btn->cb_info[BUTTON_LONG_PRESS_START];
                uint16_t time = cb_info[btn->count[0]].event_args.long_press.press_time;
                if (btn->long_press_ticks * TICKS_INTERVAL > time) {
                    for (int i = btn->count[0] + 1; i < btn->size[BUTTON_LONG_PRESS_START]; i++) {
                        time = cb_info[i].event_args.long_press.press_time;
                        if (btn->long_press_ticks * TICKS_INTERVAL <= time) {
                            btn->count[0] = i;
                            break;
                        }
                    }
                }
                if (btn->count[0] < btn->size[BUTTON_LONG_PRESS_START] && abs((int)ticks_time - (int)time) <= TOLERANCE) {
                    btn->event = (uint8_t)BUTTON_LONG_PRESS_START;
                    do {
                        cb_info[btn->count[0]].cb(btn, cb_info[btn->count[0]].usr_data);
                        btn->count[0]++;
                        if (btn->count[0] >= btn->size[BUTTON_LONG_PRESS_START]) {
                            break;
                        }
                    } while (time == cb_info[btn->count[0]].event_args.long_press.press_time);
                }
            }

            /** Updating counter for BUTTON_LONG_PRESS_UP press_time */
            if (btn->cb_info[BUTTON_LONG_PRESS_UP]) {
                button_cb_info_t *cb_info = btn->cb_info[BUTTON_LONG_PRESS_UP];
                uint16_t time = cb_info[btn->count[1] + 1].event_args.long_press.press_time;
                if (btn->long_press_ticks * TICKS_INTERVAL > time) {
                    for (int i = btn->count[1] + 1; i < btn->size[BUTTON_LONG_PRESS_UP]; i++) {
                        time = cb_info[i].event_args.long_press.press_time;
                        if (btn->long_press_ticks * TICKS_INTERVAL <= time) {
                            btn->count[1] = i;
                            break;
                        }
                    }
                }
                if (btn->count[1] + 1 < btn->size[BUTTON_LONG_PRESS_UP] && abs((int)ticks_time - (int)time) <= TOLERANCE) {
                    do {
                        btn->count[1]++;
                        if (btn->count[1] + 1 >= btn->size[BUTTON_LONG_PRESS_UP]) {
                            break;
                        }
                    } while (time == cb_info[btn->count[1] + 1].event_args.long_press.press_time);
                }
            }
        } else { //releasd

            btn->event = BUTTON_LONG_PRESS_UP;

            /** calling callbacks for BUTTON_LONG_PRESS_UP press_time */
            if (btn->cb_info[btn->event] && btn->count[1] >= 0) {
                button_cb_info_t *cb_info = btn->cb_info[btn->event];
                do {
                    cb_info[btn->count[1]].cb(btn, cb_info[btn->count[1]].usr_data);
                    if (!btn->count[1]) {
                        break;
                    }
                    btn->count[1]--;
                } while (cb_info[btn->count[1]].event_args.long_press.press_time == cb_info[btn->count[1] + 1].event_args.long_press.press_time);

                /** Reset the counter */
                btn->count[1] = -1;
            }
            /** Reset counter */
            if (btn->cb_info[BUTTON_LONG_PRESS_START]) {
                btn->count[0] = 0;
            }

            btn->event = (uint8_t)BUTTON_PRESS_UP;
            CALL_EVENT_CB(BUTTON_PRESS_UP);
            btn->state = PRESS_DOWN_CHECK; //reset
            btn->long_press_hold_cnt = 0;
            btn->event = (uint8_t)BUTTON_PRESS_END;
            CALL_EVENT_CB(BUTTON_PRESS_END);
        }
        break;
    }
}

static void button_cb(void *args)
{
    button_dev_t *target;
    /*!< When all buttons enter the BUTTON_NONE_PRESS state, the system enters low-power mode */
    bool enter_power_save_flag = true;
    for (target = g_head_handle; target; target = target->next) {
        button_handler(target);
        if (!(target->driver->enable_power_save && target->debounce_cnt == 0 && target->event == BUTTON_NONE_PRESS)) {
            enter_power_save_flag = false;
        }
    }
    if (enter_power_save_flag) {
        /*!< Stop esp timer for power save */
        if (g_is_timer_running) {
            esp_timer_stop(g_button_timer_handle);
            g_is_timer_running = false;
        }
        for (target = g_head_handle; target; target = target->next) {
            if (target->driver->enable_power_save && target->driver->enter_power_save) {
                target->driver->enter_power_save(target->driver);
            }
        }
        /*!< Notify the user that the Button has entered power save mode by calling this callback function. */
        if (power_save_usr_cfg.enter_power_save_cb) {
            power_save_usr_cfg.enter_power_save_cb(power_save_usr_cfg.usr_data);
        }
    }
}

esp_err_t iot_button_register_cb(button_handle_t btn_handle, button_event_t event, button_event_args_t *event_args, button_cb_t cb, void *usr_data)
{
    ESP_RETURN_ON_FALSE(NULL != btn_handle, ESP_ERR_INVALID_ARG, TAG, "Pointer of handle is invalid");
    button_dev_t *btn = (button_dev_t *) btn_handle;
    ESP_RETURN_ON_FALSE(event < BUTTON_EVENT_MAX, ESP_ERR_INVALID_ARG, TAG, "event is invalid");
    ESP_RETURN_ON_FALSE(NULL != cb, ESP_ERR_INVALID_ARG, TAG, "Pointer of cb is invalid");
    ESP_RETURN_ON_FALSE(event != BUTTON_MULTIPLE_CLICK || event_args, ESP_ERR_INVALID_ARG, TAG, "event is invalid");

    if (event_args) {
        ESP_RETURN_ON_FALSE(!(event == BUTTON_LONG_PRESS_START || event == BUTTON_LONG_PRESS_UP) || event_args->long_press.press_time > btn->short_press_ticks * TICKS_INTERVAL, ESP_ERR_INVALID_ARG, TAG, "event_args is invalid");
        ESP_RETURN_ON_FALSE(event != BUTTON_MULTIPLE_CLICK || event_args->multiple_clicks.clicks, ESP_ERR_INVALID_ARG, TAG, "event_args is invalid");
    }

    if (!btn->cb_info[event]) {
        btn->cb_info[event] = calloc(1, sizeof(button_cb_info_t));
        BTN_CHECK(NULL != btn->cb_info[event], "calloc cb_info failed", ESP_ERR_NO_MEM);
        if (event == BUTTON_LONG_PRESS_START) {
            btn->count[0] = 0;
        } else if (event == BUTTON_LONG_PRESS_UP) {
            btn->count[1] = -1;
        }
    } else {
        button_cb_info_t *p = realloc(btn->cb_info[event], sizeof(button_cb_info_t) * (btn->size[event] + 1));
        BTN_CHECK(NULL != p, "realloc cb_info failed", ESP_ERR_NO_MEM);
        btn->cb_info[event] = p;
    }

    btn->cb_info[event][btn->size[event]].cb = cb;
    btn->cb_info[event][btn->size[event]].usr_data = usr_data;
    btn->size[event]++;

    /** Inserting the event_args in sorted manner */
    if (event == BUTTON_LONG_PRESS_START || event == BUTTON_LONG_PRESS_UP) {
        uint16_t press_time = btn->long_press_ticks * TICKS_INTERVAL;
        if (event_args) {
            press_time = event_args->long_press.press_time;
        }
        BTN_CHECK(press_time / TICKS_INTERVAL > btn->short_press_ticks, "press_time event_args is less than short_press_ticks", ESP_ERR_INVALID_ARG);
        if (btn->size[event] >= 2) {
            for (int i = btn->size[event] - 2; i >= 0; i--) {
                if (btn->cb_info[event][i].event_args.long_press.press_time > press_time) {
                    btn->cb_info[event][i + 1] = btn->cb_info[event][i];

                    btn->cb_info[event][i].event_args.long_press.press_time = press_time;
                    btn->cb_info[event][i].cb = cb;
                    btn->cb_info[event][i].usr_data = usr_data;
                } else {
                    btn->cb_info[event][i + 1].event_args.long_press.press_time = press_time;
                    btn->cb_info[event][i + 1].cb = cb;
                    btn->cb_info[event][i + 1].usr_data = usr_data;
                    break;
                }
            }
        } else {
            btn->cb_info[event][btn->size[event] - 1].event_args.long_press.press_time = press_time;
        }

        int32_t press_ticks = press_time / TICKS_INTERVAL;
        if (btn->short_press_ticks < press_ticks && press_ticks < btn->long_press_ticks) {
            iot_button_set_param(btn, BUTTON_LONG_PRESS_TIME_MS, (void*)(intptr_t)press_time);
        }
    }

    if (event == BUTTON_MULTIPLE_CLICK) {
        uint16_t clicks = btn->long_press_ticks * TICKS_INTERVAL;
        if (event_args) {
            clicks = event_args->multiple_clicks.clicks;
        }
        if (btn->size[event] >= 2) {
            for (int i = btn->size[event] - 2; i >= 0; i--) {
                if (btn->cb_info[event][i].event_args.multiple_clicks.clicks > clicks) {
                    btn->cb_info[event][i + 1] = btn->cb_info[event][i];

                    btn->cb_info[event][i].event_args.multiple_clicks.clicks = clicks;
                    btn->cb_info[event][i].cb = cb;
                    btn->cb_info[event][i].usr_data = usr_data;
                } else {
                    btn->cb_info[event][i + 1].event_args.multiple_clicks.clicks = clicks;
                    btn->cb_info[event][i + 1].cb = cb;
                    btn->cb_info[event][i + 1].usr_data = usr_data;
                    break;
                }
            }
        } else {
            btn->cb_info[event][btn->size[event] - 1].event_args.multiple_clicks.clicks = clicks;
        }
    }
    return ESP_OK;
}

esp_err_t iot_button_unregister_cb(button_handle_t btn_handle, button_event_t event, button_event_args_t *event_args)
{
    ESP_RETURN_ON_FALSE(NULL != btn_handle, ESP_ERR_INVALID_ARG, TAG, "Pointer of handle is invalid");
    ESP_RETURN_ON_FALSE(event < BUTTON_EVENT_MAX, ESP_ERR_INVALID_ARG, TAG, "event is invalid");
    button_dev_t *btn = (button_dev_t *) btn_handle;
    ESP_RETURN_ON_FALSE(btn->cb_info[event], ESP_ERR_INVALID_STATE, TAG, "No callbacks registered for the event");

    int check = -1;

    if ((event == BUTTON_LONG_PRESS_START || event == BUTTON_LONG_PRESS_UP) && event_args) {
        if (event_args->long_press.press_time != 0) {
            goto unregister_event;
        }
    }

    if (event == BUTTON_MULTIPLE_CLICK && event_args) {
        if (event_args->multiple_clicks.clicks != 0) {
            goto unregister_event;
        }
    }

    if (btn->cb_info[event]) {
        free(btn->cb_info[event]);

        /** Reset the counter */
        if (event == BUTTON_LONG_PRESS_START) {
            btn->count[0] = 0;
        } else if (event == BUTTON_LONG_PRESS_UP) {
            btn->count[1] = -1;
        }

    }

    btn->cb_info[event] = NULL;
    btn->size[event] = 0;
    return ESP_OK;

unregister_event:

    for (int i = 0; i < btn->size[event]; i++) {
        if ((event == BUTTON_LONG_PRESS_START || event == BUTTON_LONG_PRESS_UP) && event_args->long_press.press_time) {
            if (event_args->long_press.press_time != btn->cb_info[event][i].event_args.long_press.press_time) {
                continue;
            }
        }

        if (event == BUTTON_MULTIPLE_CLICK && event_args->multiple_clicks.clicks) {
            if (event_args->multiple_clicks.clicks != btn->cb_info[event][i].event_args.multiple_clicks.clicks) {
                continue;
            }
        }
        check = i;
        for (int j = i; j <= btn->size[event] - 1; j++) {
            btn->cb_info[event][j] = btn->cb_info[event][j + 1];
        }

        if (btn->size[event] != 1) {
            button_cb_info_t *p = realloc(btn->cb_info[event], sizeof(button_cb_info_t) * (btn->size[event] - 1));
            BTN_CHECK(NULL != p, "realloc cb_info failed", ESP_ERR_NO_MEM);
            btn->cb_info[event] = p;
            btn->size[event]--;
        } else {
            free(btn->cb_info[event]);
            btn->cb_info[event] = NULL;
            btn->size[event] = 0;
        }
        break;
    }

    ESP_RETURN_ON_FALSE(check != -1, ESP_ERR_NOT_FOUND, TAG, "No such callback registered for the event");
    return ESP_OK;
}

size_t iot_button_count_cb(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", ESP_ERR_INVALID_ARG);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    size_t ret = 0;
    for (size_t i = 0; i < BUTTON_EVENT_MAX; i++) {
        if (btn->cb_info[i]) {
            ret += btn->size[i];
        }
    }
    return ret;
}

size_t iot_button_count_event_cb(button_handle_t btn_handle, button_event_t event)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", ESP_ERR_INVALID_ARG);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    return btn->size[event];
}

button_event_t iot_button_get_event(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", BUTTON_NONE_PRESS);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    return btn->event;
}

const char *iot_button_get_event_str(button_event_t event)
{
    BTN_CHECK(event <= BUTTON_NONE_PRESS && event >= BUTTON_PRESS_DOWN, "event value is invalid", "invalid event");
    return button_event_str[event];
}

esp_err_t iot_button_print_event(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", ESP_FAIL);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    ESP_LOGI(TAG, "%s", button_event_str[btn->event]);
    return ESP_OK;
}

uint8_t iot_button_get_repeat(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", 0);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    return btn->repeat;
}

uint32_t iot_button_get_ticks_time(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", 0);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    return (btn->ticks * TICKS_INTERVAL);
}

uint16_t iot_button_get_long_press_hold_cnt(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", 0);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    return btn->long_press_hold_cnt;
}

esp_err_t iot_button_set_param(button_handle_t btn_handle, button_param_t param, void *value)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", ESP_ERR_INVALID_ARG);
    button_dev_t *btn = (button_dev_t *) btn_handle;
    BUTTON_ENTER_CRITICAL();
    switch (param) {
    case BUTTON_LONG_PRESS_TIME_MS:
        btn->long_press_ticks = (int32_t)value / TICKS_INTERVAL;
        break;
    case BUTTON_SHORT_PRESS_TIME_MS:
        btn->short_press_ticks = (int32_t)value / TICKS_INTERVAL;
        break;
    default:
        break;
    }
    BUTTON_EXIT_CRITICAL();
    return ESP_OK;
}

uint8_t iot_button_get_key_level(button_handle_t btn_handle)
{
    BTN_CHECK(NULL != btn_handle, "Pointer of handle is invalid", 0);
    button_dev_t *btn = (button_dev_t *)btn_handle;
    uint8_t level = btn->driver->get_key_level(btn->driver);
    return level;
}

esp_err_t iot_button_resume(void)
{
    if (!g_button_timer_handle) {
        return ESP_ERR_INVALID_STATE;
    }
    if (!g_is_timer_running) {
        esp_timer_start_periodic(g_button_timer_handle, TICKS_INTERVAL * 1000U);
        g_is_timer_running = true;
    }
    return ESP_OK;
}

esp_err_t iot_button_stop(void)
{
    BTN_CHECK(g_button_timer_handle, "Button timer handle is invalid", ESP_ERR_INVALID_STATE);
    BTN_CHECK(g_is_timer_running, "Button timer is not running", ESP_ERR_INVALID_STATE);

    esp_err_t err = esp_timer_stop(g_button_timer_handle);
    BTN_CHECK(ESP_OK == err, "Button timer stop failed", ESP_FAIL);
    g_is_timer_running = false;
    return ESP_OK;
}

esp_err_t iot_button_register_power_save_cb(const button_power_save_config_t *config)
{
    BTN_CHECK(g_head_handle, "No button registered", ESP_ERR_INVALID_STATE);
    BTN_CHECK(config->enter_power_save_cb, "Enter power save callback is invalid", ESP_ERR_INVALID_ARG);

    power_save_usr_cfg.enter_power_save_cb = config->enter_power_save_cb;
    power_save_usr_cfg.usr_data = config->usr_data;
    return ESP_OK;
}

esp_err_t iot_button_create(const button_config_t *config, const button_driver_t *driver, button_handle_t *ret_button)
{
    if (!g_head_handle) {
        ESP_LOGI(TAG, "IoT Button Version: %d.%d.%d", IOT_BUTTON_VER_MAJOR, IOT_BUTTON_VER_MINOR, IOT_BUTTON_VER_PATCH);
    }
    ESP_RETURN_ON_FALSE(driver && config && ret_button, ESP_ERR_INVALID_ARG, TAG, "Invalid argument");
    button_dev_t *btn = (button_dev_t *) calloc(1, sizeof(button_dev_t));
    ESP_RETURN_ON_FALSE(btn, ESP_ERR_NO_MEM, TAG, "Button memory alloc failed");

    btn->driver = (button_driver_t *)driver;
    btn->long_press_ticks = TIME_TO_TICKS(config->long_press_time, LONG_TICKS);
    btn->short_press_ticks = TIME_TO_TICKS(config->short_press_time, SHORT_TICKS);
    btn->event = BUTTON_NONE_PRESS;
    btn->button_level = BUTTON_INACTIVE;

    btn->next = g_head_handle;
    g_head_handle = btn;
    
    if (!g_button_timer_handle) {
        esp_timer_create_args_t button_timer = {0};
        button_timer.arg = NULL;
        button_timer.callback = button_cb;
        button_timer.dispatch_method = ESP_TIMER_TASK;
        button_timer.name = "button_timer";
        esp_timer_create(&button_timer, &g_button_timer_handle);
    }

    if (!driver->enable_power_save && !g_is_timer_running) {
        esp_timer_start_periodic(g_button_timer_handle, TICKS_INTERVAL * 1000U);
        g_is_timer_running = true;
    }

    *ret_button = (button_handle_t)btn;
    return ESP_OK;
}

esp_err_t iot_button_delete(button_handle_t btn_handle)
{
    esp_err_t ret = ESP_OK;
    ESP_RETURN_ON_FALSE(NULL != btn_handle, ESP_ERR_INVALID_ARG, TAG, "Pointer of handle is invalid");
    button_dev_t *btn = (button_dev_t *)btn_handle;

    for (int i = 0; i < BUTTON_EVENT_MAX; i++) {
        if (btn->cb_info[i]) {
            free(btn->cb_info[i]);
        }
    }

    ret = btn->driver->del(btn->driver);
    ESP_RETURN_ON_FALSE(ESP_OK == ret, ret, TAG, "Failed to delete button driver");

    button_dev_t **curr;
    for (curr = &g_head_handle; *curr;) {
        button_dev_t *entry = *curr;
        if (entry == btn) {
            *curr = entry->next;
            free(entry);
        } else {
            curr = &entry->next;
        }
    }

    /* count button number */
    uint16_t number = 0;
    button_dev_t *target = g_head_handle;
    while (target) {
        target = target->next;
        number++;
    }
    ESP_LOGD(TAG, "remain btn number=%d", number);

    if (0 == number && g_is_timer_running) { /**<  if all button is deleted, stop the timer */
        esp_timer_stop(g_button_timer_handle);
        esp_timer_delete(g_button_timer_handle);
        g_button_timer_handle = NULL;
        g_is_timer_running = false;
    }
    return ESP_OK;
}

--- END OF FILE: .\components\iot_button\iot_button.c ---

--- START OF FILE: .\components\iot_button\Kconfig ---
menu "IoT Button"

    config BUTTON_PERIOD_TIME_MS
        int "BUTTON PERIOD TIME (MS)"
        range 2 500
        default 5
        help
            "Button scan interval"

    config BUTTON_DEBOUNCE_TICKS
        int "BUTTON DEBOUNCE TICKS"
        range 1 7
        default 2
        help
            "One CONFIG_BUTTON_DEBOUNCE_TICKS equal to CONFIG_BUTTON_PERIOD_TIME_MS"

    config BUTTON_SHORT_PRESS_TIME_MS
        int "BUTTON SHORT PRESS TIME (MS)"
        range 50 800
        default 180

    config BUTTON_LONG_PRESS_TIME_MS
        int "BUTTON LONG PRESS TIME (MS)"
        range 500 5000
        default 1500

    config BUTTON_LONG_PRESS_HOLD_SERIAL_TIME_MS
        int "BUTTON LONG_PRESS_HOLD SERIAL TIME (MS)"
        range 2 1000
        default 20
        help
            "Long press hold Serial trigger interval"

    config ADC_BUTTON_MAX_CHANNEL
        int "ADC BUTTON MAX CHANNEL"
        range 1 5
        default 3
        help
            "Maximum number of channels for ADC buttons"

    config ADC_BUTTON_MAX_BUTTON_PER_CHANNEL
        int "ADC BUTTON MAX BUTTON PER CHANNEL"
        range 1 10
        default 8
        help
            "Maximum number of buttons per channel"

    config ADC_BUTTON_SAMPLE_TIMES
        int "ADC BUTTON SAMPLE TIMES"
        range 1 4
        default 1
        help
            "Number of samples per scan"

endmenu

--- END OF FILE: .\components\iot_button\Kconfig ---

--- START OF FILE: .\components\iot_button\README.md ---
[![Component Registry](https://components.espressif.com/components/espressif/button/badge.svg)](https://components.espressif.com/components/espressif/button)

# Component: Button
[Online documentation](https://docs.espressif.com/projects/esp-iot-solution/en/latest/input_device/button.html)

After creating a new button object by calling function `button_create()`, the button object can create press events, every press event can have its own callback.

List of supported events:
 * Button pressed
 * Button released
 * Button pressed repeat
 * Button press repeat done
 * Button single click
 * Button double click
 * Button multiple click
 * Button long press start
 * Button long press hold
 * Button long press up
 * Button Press end

![](https://dl.espressif.com/AE/esp-iot-solution/button_3.3.1.svg)

There are three ways this driver can handle buttons:
1. Buttons connected to standard digital GPIO
2. Multiple buttons connected to single ADC channel
3. Matrix keyboard employs multiple GPIOs for operation.
4. Custom button connect to any driver

The component supports the following functionalities:
1. Creation of an unlimited number of buttons, accommodating various types simultaneously.
2. Multiple callback functions for a single event.
3. Allowing customization of the consecutive key press count to any desired number.
4. Facilitating the setup of callbacks for any specified long-press duration.
5. Support power save mode (Only for gpio button)

## Add component to your project

Please use the component manager command `add-dependency` to add the `button` to your project's dependency, during the `CMake` step the component will be downloaded automatically

```
idf.py add-dependency "espressif/button=*"
```
--- END OF FILE: .\components\iot_button\README.md ---

--- START OF FILE: .\components\screen_manager\CMakeLists.txt ---
# Fecha: 16/08/2025 - 09:27 
# Fichero: components/screen_manager/CMakeLists.txt
# √öltimo cambio: Actualizada la dependencia de 'diymon_bsp' a 'bsp' para resolver el error de compilaci√≥n.
# Descripci√≥n: Fichero de compilaci√≥n para el gestor de pantalla. Se ha corregido el nombre de la dependencia del BSP para que coincida con el nuevo nombre del directorio, solucionando el error 'Failed to resolve component'.

idf_component_register(SRCS "screen_manager.c"
                    INCLUDE_DIRS "."
                    REQUIRES 
                        log
                        bsp # Corregido de 'diymon_bsp' a 'bsp'
                        )

--- END OF FILE: .\components\screen_manager\CMakeLists.txt ---

--- START OF FILE: .\components\screen_manager\screen_manager.c ---
/*
  Fichero: ./components/screen_manager/screen_manager.c
  Fecha: 13/08/2025 - 12:03 
  √öltimo cambio: Eliminada completamente la l√≥gica de 'shake-to-wake'.
  Descripci√≥n: Se ha eliminado toda la funcionalidad de shake-to-wake, incluyendo la tarea,
               el sem√°foro y la inicializaci√≥n de la interrupci√≥n del BSP. Esta funcionalidad
               ser√° re-implementada dentro de la nueva tarea de telemetr√≠a en la capa de la UI
               para consolidar la l√≥gica y resolver conflictos de I2C.
*/
#include "screen_manager.h"
#include "bsp_api.h"
#include "esp_log.h"

static const char *TAG = "SCREEN_MANAGER";
static bool g_is_screen_off = false;

esp_err_t screen_manager_init(void) {
    ESP_LOGI(TAG, "Gestor de pantalla inicializado.");
    return ESP_OK;
}

void screen_manager_turn_on(void) {
    bsp_display_turn_on();
    g_is_screen_off = false;
    ESP_LOGI(TAG, "Petici√≥n para encender pantalla ejecutada.");
}

void screen_manager_turn_off(void) {
    bsp_display_turn_off();
    g_is_screen_off = true;
    ESP_LOGI(TAG, "Petici√≥n para apagar pantalla ejecutada.");
}

void screen_manager_set_brightness(int percentage) {
    bsp_display_set_brightness(percentage);
}

bool screen_manager_is_off(void) {
    return g_is_screen_off;
}

--- END OF FILE: .\components\screen_manager\screen_manager.c ---

--- START OF FILE: .\components\screen_manager\screen_manager.h ---
#ifndef SCREEN_MANAGER_H
#define SCREEN_MANAGER_H

#include "esp_err.h"
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el gestor de pantalla.
 * 
 * @return ESP_OK si la inicializaci√≥n es correcta.
 */
esp_err_t screen_manager_init(void);

/**
 * @brief Enciende la pantalla y restaura el √∫ltimo nivel de brillo.
 */
void screen_manager_turn_on(void);

/**
 * @brief Apaga la pantalla y el backlight.
 */
void screen_manager_turn_off(void);

/**
 * @brief Establece el nivel de brillo de la pantalla.
 * 
 * @param percentage Brillo en porcentaje (0-100).
 */
void screen_manager_set_brightness(int percentage);

/**
 * @brief Devuelve si la pantalla est√° actualmente apagada.
 * 
 * @return true si la pantalla est√° apagada, false en caso contrario.
 */
bool screen_manager_is_off(void);


#ifdef __cplusplus
}
#endif

#endif // SCREEN_MANAGER_H
--- END OF FILE: .\components\screen_manager\screen_manager.h ---

--- START OF FILE: .\components\service_screen\CMakeLists.txt ---
# Fecha: 16/08/2025 - 09:41 
# Fichero: components/service_screen/CMakeLists.txt
# √öltimo cambio: Actualizada la dependencia de 'diymon_bsp' a 'bsp' para resolver el error de compilaci√≥n.
# Descripci√≥n: Fichero de compilaci√≥n para la pantalla de servicio. Se ha corregido el nombre de la dependencia del BSP para que coincida con el nuevo nombre del directorio ('bsp'), solucionando el error 'Failed to resolve component'.

idf_component_register(SRCS "service_screen.c"
                    INCLUDE_DIRS "."
                    REQUIRES
                        log
                        bsp
)

--- END OF FILE: .\components\service_screen\CMakeLists.txt ---

--- START OF FILE: .\components\service_screen\service_screen.c ---
/*
Fichero: Z:\DIYTOGETHER\DIYtogether\components\service_screen\service_screen.c
Fecha: 14/08/2025 - 05:52 
√öltimo cambio: Refactorizado para usar un asset de imagen compilado en el firmware en lugar de leer desde la SD.
Descripci√≥n: L√≥gica para mostrar una pantalla de servicio sin LVGL. Se ha modificado para dibujar directamente en el framebuffer del display un array de C que representa una imagen (el asset 'bg_config_img'), eliminando la dependencia de la tarjeta SD para los modos de servicio y haci√©ndolos m√°s r√°pidos y robustos.
*/
#include "service_screen.h"
#include "bsp_api.h"
#include "esp_log.h"
#include "esp_lcd_panel_ops.h" // Necesario para esp_lcd_panel_draw_bitmap
#include <lvgl.h> // Necesario para el tipo lv_img_dsc_t

static const char *TAG = "SERVICE_SCREEN";

// --- EXPLICACI√ìN DEL PROCESO ---
// Para plasmar una imagen en pantalla sin LVGL, seguimos estos pasos:
// 1. Convertir la imagen (ej: "config_bg.png") a un fichero C usando el conversor de LVGL.
//    - Formato de color: RGB565 (para que coincida con el display).
//    - Salida: Array C.
// 2. Este proceso genera un fichero, por ejemplo "bg_config_img.c", que contiene
//    una estructura 'const lv_img_dsc_t bg_config_img = { ... };'.
// 3. Declaramos esa estructura como 'extern' para poder usarla aqu√≠.
//    Esto le dice al compilador que la definici√≥n real est√° en otro fichero.
extern const lv_img_dsc_t bg_config;

// 4. Usamos la funci√≥n de bajo nivel del driver del display sp_lcd_panel_draw_bitmap.
//    Esta funci√≥n toma un puntero directo a los datos de p√≠xeles (bg_config_img.data)
//    y los env√≠a al hardware de la pantalla.

esp_err_t service_screen_show_from_rom(void) {
    ESP_LOGI(TAG, "Mostrando pantalla de servicio NATIVA desde asset en firmware...");
    
    // Asumimos que el hardware (SPI y display) ya ha sido inicializado por main.c
    
    // Obtenemos el manejador del display desde el BSP
    esp_lcd_panel_handle_t panel_handle = bsp_get_display_handle();
    if (!panel_handle) {
        ESP_LOGE(TAG, "El manejador del display no est√° inicializado.");
        return ESP_FAIL;
    }
    
    // Obtenemos las dimensiones para asegurarnos de que cubrimos toda la pantalla
    const int h_res = bsp_get_display_hres();
    const int v_res = bsp_get_display_vres();

    // Verificamos que las dimensiones de la imagen coincidan (opcional pero recomendado)
    if (bg_config.header.w != h_res || bg_config.header.h != v_res) {
        ESP_LOGW(TAG, "Las dimensiones de la imagen (%dx%d) no coinciden con las de la pantalla (%dx%d).",
                 bg_config.header.w, bg_config.header.h, h_res, v_res);
    }

    // Volcamos el b√∫fer del asset directamente al display (sin LVGL)
    ESP_LOGI(TAG, "Renderizando imagen nativa en el display...");
    esp_lcd_panel_draw_bitmap(panel_handle, 0, 0, h_res, v_res, bg_config.data);

    ESP_LOGI(TAG, "Pantalla de servicio mostrada con √©xito.");
    return ESP_OK;
}

// La funci√≥n original que cargaba desde la SD se mantiene por si se necesita,
// pero la nueva l√≥gica usa la ROM.
esp_err_t service_screen_show_from_sd(const char* image_path) {
    ESP_LOGE(TAG, "service_screen_show_from_sd est√° obsoleta. Usar service_screen_show_from_rom.");
    return ESP_ERR_NOT_SUPPORTED;
}

--- END OF FILE: .\components\service_screen\service_screen.c ---

--- START OF FILE: .\components\service_screen\service_screen.h ---
/*
  Fichero: ./components/service_screen/service_screen.h
  Fecha: 12/08/2025 - 07:00
  √öltimo cambio: Creaci√≥n del componente.
  Descripci√≥n: Interfaz p√∫blica para el gestor de pantallas de servicio.
*/
#ifndef SERVICE_SCREEN_H
#define SERVICE_SCREEN_H

#include "esp_err.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Muestra una imagen a pantalla completa desde la tarjeta SD.
 *
 * Esta funci√≥n realiza una inicializaci√≥n m√≠nima de hardware (display y LVGL)
 * para mostrar una √∫nica imagen binaria. No inicia la UI principal ni el gestor de hardware.
 *
 * @param image_path Ruta completa al fichero .bin de la imagen en la SD.
 * @return ESP_OK si la imagen se muestra correctamente.
 */
esp_err_t service_screen_show(const char* image_path);

#ifdef __cplusplus
}
#endif

#endif // SERVICE_SCREEN_H
--- END OF FILE: .\components\service_screen\service_screen.h ---

--- START OF FILE: .\components\ui\actions\action_brightness.c ---
/* Fecha: 17/08/2025 - 01:47  */
/* Fichero: components/ui/actions/action_brightness.c */
/* √öltimo cambio: Implementaci√≥n de la l√≥gica de brillo, extra√≠da del antiguo 'actions.c'. */
/* Descripci√≥n: Implementa la acci√≥n de ciclar el brillo. Contiene las variables est√°ticas para los niveles de brillo y el √≠ndice actual, manteniendo este estado aislado del resto del sistema. */

#include "actions/action_brightness.h"
#include "screen_manager.h" // Necesario para llamar a screen_manager_set_brightness

// --- Variables est√°ticas privadas del m√≥dulo de brillo ---
static int s_brightness_levels[] = {25, 50, 75, 100};
static int s_current_brightness_idx = 3; // Corresponde a 100%

/**
 * @brief Implementaci√≥n de la acci√≥n de ciclar el brillo.
 */
void action_brightness_cycle(void) {
    // Avanza al siguiente nivel de brillo, volviendo al principio si es necesario (ciclo)
    s_current_brightness_idx = (s_current_brightness_idx + 1) % 4;
    
    // Llama al gestor de pantalla para aplicar el nuevo nivel de brillo
    screen_manager_set_brightness(s_brightness_levels[s_current_brightness_idx]);
}

--- END OF FILE: .\components\ui\actions\action_brightness.c ---

--- START OF FILE: .\components\ui\actions\action_brightness.h ---
/* Fecha: 17/08/2025 - 01:47  */
/* Fichero: components/ui/actions/action_brightness.h */
/* √öltimo cambio: Creaci√≥n del m√≥dulo de acci√≥n de brillo como primer paso de la refactorizaci√≥n. */
/* Descripci√≥n: Interfaz p√∫blica para la acci√≥n de ciclar el brillo. Encapsula la l√≥gica de control de brillo, separ√°ndola del orquestador principal de acciones. */

#ifndef ACTION_BRIGHTNESS_H
#define ACTION_BRIGHTNESS_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief C√≠cla a trav√©s de los niveles de brillo predefinidos y aplica el siguiente.
 *        Esta funci√≥n es llamada por el orquestador de acciones principal.
 */
void action_brightness_cycle(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_BRIGHTNESS_H

--- END OF FILE: .\components\ui\actions\action_brightness.h ---

--- START OF FILE: .\components\ui\actions\action_config_mode.c ---
/* Fecha: 18/08/2025 - 09:08  */
/* Fichero: components/ui/actions/action_config_mode.c */
/* √öltimo cambio: Implementada la l√≥gica para intentar conexi√≥n STA antes de iniciar el modo AP. */
/* Descripci√≥n: Se ha corregido el comportamiento del modo de configuraci√≥n. Ahora, al entrar, primero intenta conectarse a una red WiFi guardada. Si la conexi√≥n es exitosa, muestra la IP obtenida. Si falla o no hay credenciales, limpia el intento de conexi√≥n STA y luego inicia el modo Punto de Acceso (AP), resolviendo el problema de que siempre iniciaba en modo AP. */

#include "actions/action_config_mode.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_wifi.h"
#include "esp_netif.h"
#include "esp_lvgl_port.h"
#include "bsp_api.h"
#include "web_server.h"
#include "telemetry/telemetry_task.h"
#include "telemetry/telemetry_manager.h"
#include "screens.h"
#include "ui_idle_animation.h"
#include "ui_actions_panel.h"
#include "ui_action_animations.h"
#include "core/state_manager.h"
#include "core/ui.h" // Necesario para ui_init y ui_preinit

static const char *TAG = "ACTION_CONFIG_MODE";

// --- Variables est√°ticas privadas del m√≥dulo ---
static bool s_is_config_mode_active = false;
static lv_obj_t *s_config_screen = NULL;
static TaskHandle_t s_wifi_task_handle = NULL;
static httpd_handle_t s_server_handle = NULL; // Handle para el servidor web

// --- Funciones de ayuda privadas del m√≥dulo ---

/**
 * @brief Tarea de FreeRTOS para gestionar el modo de configuraci√≥n.
 *        Intenta conectar como STA si hay credenciales; si no, inicia un AP.
 */
static void wifi_config_task(void *param) {
    bsp_wifi_init_stack();

    // 1. Intentar conectar como estaci√≥n (STA) usando credenciales guardadas.
    ESP_LOGI(TAG, "Intentando conectar a WiFi guardado...");
    lvgl_port_lock(0);
    if (s_is_config_mode_active && s_config_screen) {
        lv_obj_t *label1 = lv_obj_get_child(s_config_screen, 0);
        lv_label_set_text(label1, "Conectando a WiFi...");
        lv_obj_t *label2 = lv_obj_get_child(s_config_screen, 1);
        lv_label_set_text(label2, "Esperando IP...");
    }
    lvgl_port_unlock();

    bsp_wifi_init_sta_from_nvs();

    // 2. Esperar a obtener una IP.
    bool connected = bsp_wifi_wait_for_ip(10000); // Timeout de 10 segundos

    if (connected && s_is_config_mode_active) {
        // 3a. Conexi√≥n exitosa: Mostrar IP y lanzar servidor.
        char ip_addr[16];
        bsp_wifi_get_ip(ip_addr);
        ESP_LOGI(TAG, "Conectado exitosamente. IP: %s", ip_addr);

        lvgl_port_lock(0);
        if (s_is_config_mode_active && s_config_screen) {
            lv_obj_t *label1 = lv_obj_get_child(s_config_screen, 0);
            lv_obj_t *label2 = lv_obj_get_child(s_config_screen, 1);
            lv_label_set_text(label1, "¬°Conectado!");
            lv_label_set_text_fmt(label2, "IP: %s\nAccede desde tu navegador", ip_addr);
        }
        lvgl_port_unlock();

    } else if (s_is_config_mode_active) {
        // 3b. Fallo en conexi√≥n o sin credenciales: Iniciar modo AP.
        ESP_LOGI(TAG, "No se pudo conectar como STA. Iniciando modo AP.");
        bsp_wifi_deinit(); // Limpiar el intento de STA fallido.

        lvgl_port_lock(0);
        if (s_is_config_mode_active && s_config_screen) {
            lv_obj_t *label1 = lv_obj_get_child(s_config_screen, 0);
            lv_obj_t *label2 = lv_obj_get_child(s_config_screen, 1);
            lv_label_set_text(label1, "Modo AP Activo");
            lv_label_set_text(label2, "SSID: DIYTogether\nPass: MakeItYours\nIP: 192.168.4.1");
        }
        lvgl_port_unlock();

        bsp_wifi_start_ap();
    }

    // 4. Iniciar el servidor web en cualquier caso (STA o AP).
    if (s_is_config_mode_active) {
        ESP_LOGI(TAG, "Iniciando servidor web para gesti√≥n.");
        s_server_handle = web_server_start();
    }

    s_wifi_task_handle = NULL;
    vTaskDelete(NULL);
}


/**
 * @brief Callback de evento para el bot√≥n 'Volver' del modo de configuraci√≥n.
 */
static void config_back_button_event_cb(lv_event_t *e) {
    action_config_mode_stop();
}

// --- Implementaci√≥n de funciones p√∫blicas ---

void action_config_mode_start(void) {
    if (s_is_config_mode_active) return;
    s_is_config_mode_active = true;
    ESP_LOGI(TAG, "Entrando en modo de configuraci√≥n: Liberando recursos de la UI principal.");

    // [OPTIMIZACI√ìN] Destruir la UI principal para liberar memoria
    // La tarea de telemetr√≠a se detendr√° por s√≠ misma al no poder actualizar la UI.
    lvgl_port_lock(0);
    state_manager_destroy();
    delete_screen_main();
    lvgl_port_unlock();
    
    // Crear una pantalla simple para el modo config
    lvgl_port_lock(0);
    s_config_screen = lv_obj_create(NULL);
    lv_obj_set_style_bg_color(s_config_screen, lv_color_black(), 0);

    lv_obj_t *label1 = lv_label_create(s_config_screen);
    lv_obj_t *label2 = lv_label_create(s_config_screen);
    lv_obj_set_style_text_color(label1, lv_color_white(), 0);
    lv_obj_set_style_text_align(label1, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_set_width(label1, lv_pct(90));
    lv_obj_align(label1, LV_ALIGN_CENTER, 0, -40);
    lv_label_set_text(label1, "Iniciando WiFi...");
    
    lv_obj_set_style_text_color(label2, lv_color_white(), 0);
    lv_obj_set_style_text_align(label2, LV_TEXT_ALIGN_CENTER, 0);
    lv_obj_set_width(label2, lv_pct(90));
    lv_obj_align(label2, LV_ALIGN_CENTER, 0, 0);
    lv_label_set_text(label2, "");

    lv_obj_t* back_button = lv_btn_create(s_config_screen);
    lv_obj_align(back_button, LV_ALIGN_BOTTOM_MID, 0, -20);
    lv_obj_add_event_cb(back_button, config_back_button_event_cb, LV_EVENT_CLICKED, NULL);
    lv_obj_t* lbl = lv_label_create(back_button);
    lv_label_set_text(lbl, "VOLVER");
    lv_obj_center(lbl);

    lv_screen_load(s_config_screen);
    lvgl_port_unlock();

    xTaskCreate(wifi_config_task, "wifi_cfg_task", 4096, NULL, 5, &s_wifi_task_handle);
}

void action_config_mode_stop(void) {
    if (!s_is_config_mode_active) return;
    
    ESP_LOGI(TAG, "Saliendo del modo de configuraci√≥n y restaurando UI.");
    s_is_config_mode_active = false;

    // 1. Detener todos los servicios de red y liberar sus recursos.
    web_server_stop(s_server_handle);
    s_server_handle = NULL;
    if (s_wifi_task_handle) { vTaskDelete(s_wifi_task_handle); s_wifi_task_handle = NULL; }
    
    // [CORRECCI√ìN CR√çTICA] Llamar a la funci√≥n de desinicializaci√≥n completa del BSP.
    bsp_wifi_deinit();
    
    ESP_LOGI(TAG, "Servicios de red detenidos y limpiados.");
    
    lvgl_port_lock(0);
    // 2. Liberar la UI del modo configuraci√≥n.
    if (s_config_screen) {
        lv_obj_del(s_config_screen);
        s_config_screen = NULL;
    }

    // 3. Pre-alocar el buffer de animaci√≥n AHORA, mientras la memoria est√° limpia.
    ui_preinit();

    // 4. Reconstruir la UI principal y sus gestores.
    ui_init();
    state_manager_init();
    lvgl_port_unlock();

    // 5. Reiniciar tareas de la aplicaci√≥n.
    telemetry_task_start();
    ESP_LOGI(TAG, "UI principal restaurada. Sistema de vuelta a modo normal.");
}

--- END OF FILE: .\components\ui\actions\action_config_mode.c ---

--- START OF FILE: .\components\ui\actions\action_config_mode.h ---
/* Fecha: 17/08/2025 - 01:49  */
/* Fichero: components/ui/actions/action_config_mode.h */
/* √öltimo cambio: Creaci√≥n del m√≥dulo para la acci√≥n del modo de configuraci√≥n. */
/* Descripci√≥n: Interfaz p√∫blica para gestionar el ciclo de vida del modo de configuraci√≥n. Expone funciones para iniciar y detener el modo, encapsulando su estado y la gesti√≥n de la tarea de red. */

#ifndef ACTION_CONFIG_MODE_H
#define ACTION_CONFIG_MODE_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicia el modo de configuraci√≥n WiFi.
 *        Oculta la UI principal, muestra la informaci√≥n de red,
 *        y lanza una tarea para gestionar la conexi√≥n y el servidor web.
 */
void action_config_mode_start(void);

/**
 * @brief Detiene el modo de configuraci√≥n WiFi.
 *        Limpia los elementos de la UI de configuraci√≥n, detiene la tarea
 *        de red y los servicios asociados, y restaura la UI principal.
 */
void action_config_mode_stop(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_CONFIG_MODE_H

--- END OF FILE: .\components\ui\actions\action_config_mode.h ---

--- START OF FILE: .\components\ui\actions\action_evolution.c ---
/* Fecha: 17/08/2025 - 09:45  */
/* Fichero: components/ui/actions/action_evolution.c */
/* √öltimo cambio: Actualizada la ruta de inclusi√≥n de 'telemetry_manager.h' para reflejar la refactorizaci√≥n a ui/telemetry/. */
/* Descripci√≥n: M√≥dulo que maneja los cambios de estado del Diymon. Se ha actualizado la ruta de inclusi√≥n para apuntar al nuevo directorio 'telemetry', manteniendo la consistencia con la refactorizaci√≥n de la l√≥gica de sensores. */

#include "actions/action_evolution.h"
#include "diymon_evolution.h"
#include "ui_idle_animation.h"
#include "telemetry/telemetry_manager.h"
#include "ui_action_animations.h" // Para g_animation_img_obj
#include "screens.h"              // Para g_main_screen_obj
#include "esp_log.h"

static const char *TAG = "ACTION_EVOLUTION";

/**
 * @brief Funci√≥n interna para actualizar la UI despu√©s de un cambio de evoluci√≥n.
 */
static void update_ui_after_evolution_change(void) {
    // Detiene la animaci√≥n de reposo actual para poder recargarla con el nuevo personaje.
    ui_idle_animation_stop();
    // Oculta temporalmente el objeto de la animaci√≥n para evitar que se vea el √∫ltimo fotograma del personaje anterior.
    if (g_animation_img_obj) {
        lv_obj_add_flag(g_animation_img_obj, LV_OBJ_FLAG_HIDDEN);
    }

    // Fuerza la actualizaci√≥n inmediata de la telemetr√≠a para que muestre el nuevo c√≥digo EVO.
    telemetry_manager_update_values(100); // Se asume 100% de bater√≠a, ya que no se recalcula aqu√≠. La tarea principal lo corregir√°.
    
    // Inicia la nueva animaci√≥n de reposo, que cargar√° los assets del nuevo c√≥digo de evoluci√≥n.
    ui_idle_animation_start(g_main_screen_obj);
    
    // Vuelve a hacer visible el objeto de la animaci√≥n.
    if (g_animation_img_obj) {
        lv_obj_clear_flag(g_animation_img_obj, LV_OBJ_FLAG_HIDDEN);
    }
}

/**
 * @brief Implementa la acci√≥n de evolucionar a una rama.
 */
void action_evolution_branch(int branch_id) {
    const char* current_code = diymon_get_current_code();
    const char* next_code = diymon_get_branched_evolution(current_code, branch_id);

    if (next_code) {
        ESP_LOGI(TAG, "Evolucionando de '%s' a '%s' (rama %d)", current_code, next_code, branch_id);
        diymon_set_current_code(next_code);
        update_ui_after_evolution_change();
    } else {
        ESP_LOGW(TAG, "Evoluci√≥n inv√°lida desde '%s' por la rama %d", current_code, branch_id);
    }
}

/**
 * @brief Implementa la acci√≥n de involucionar.
 */
void action_evolution_devolve(void) {
    const char* current_code = diymon_get_current_code();
    const char* previous_code = diymon_get_previous_evolution_in_sequence(current_code);

    if (previous_code) {
        ESP_LOGI(TAG, "Involucionando de '%s' a '%s'", current_code, previous_code);
        diymon_set_current_code(previous_code);
        update_ui_after_evolution_change();
    } else {
        ESP_LOGW(TAG, "Involuci√≥n inv√°lida desde '%s' (ya es la forma base)", current_code);
    }
}

--- END OF FILE: .\components\ui\actions\action_evolution.c ---

--- START OF FILE: .\components\ui\actions\action_evolution.h ---
/* Fecha: 17/08/2025 - 01:49  */
/* Fichero: components/ui/actions/action_evolution.h */
/* √öltimo cambio: Creaci√≥n del m√≥dulo para agrupar las acciones de evoluci√≥n del Diymon. */
/* Descripci√≥n: Interfaz p√∫blica para las acciones de evoluci√≥n y de involuci√≥n. Agrupa la l√≥gica relacionada con el cambio de estado del Diymon para mantener el orquestador principal limpio. */

#ifndef ACTION_EVOLUTION_H
#define ACTION_EVOLUTION_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Intenta ejecutar una evoluci√≥n ramificada basada en el estado actual.
 * @param branch_id El identificador de la rama a la que se intenta evolucionar (1-4).
 */
void action_evolution_branch(int branch_id);

/**
 * @brief Ejecuta una involuci√≥n al estado evolutivo anterior.
 */
void action_evolution_devolve(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_EVOLUTION_H

--- END OF FILE: .\components\ui\actions\action_evolution.h ---

--- START OF FILE: .\components\ui\actions\action_interaction.c ---
/* Fecha: 17/08/2025 - 01:48  */
/* Fichero: components/ui/actions/action_interaction.c */
/* √öltimo cambio: Implementaci√≥n de las acciones de interacci√≥n (comer, ejercicio, atacar). */
/* Descripci√≥n: Implementa las funciones que inician las animaciones de acci√≥n b√°sicas. Este m√≥dulo act√∫a como un simple despachador, llamando al gestor de animaciones con el ID de acci√≥n correcto. */

#include "actions/action_interaction.h"
#include "ui_action_animations.h" // Necesario para reproducir animaciones
#include "actions.h"              // Necesario para los ACTION_ID_*

/**
 * @brief Implementa la acci√≥n de 'comer'.
 */
void action_interaction_eat(void) {
    ui_action_animations_play(ACTION_ID_COMER);
}

/**
 * @brief Implementa la acci√≥n de 'ejercicio'.
 */
void action_interaction_gym(void) {
    ui_action_animations_play(ACTION_ID_EJERCICIO);
}

/**
 * @brief Implementa la acci√≥n de 'atacar'.
 */
void action_interaction_attack(void) {
    ui_action_animations_play(ACTION_ID_ATACAR);
}

--- END OF FILE: .\components\ui\actions\action_interaction.c ---

--- START OF FILE: .\components\ui\actions\action_interaction.h ---
/* Fecha: 17/08/2025 - 01:48  */
/* Fichero: components/ui/actions/action_interaction.h */
/* √öltimo cambio: Creaci√≥n del m√≥dulo para agrupar las acciones de interacci√≥n del Diymon. */
/* Descripci√≥n: Interfaz p√∫blica para las acciones de 'comer', 'ejercicio' y 'atacar'. Agrupa estas acciones relacionadas en un solo m√≥dulo, siguiendo el patr√≥n de refactorizaci√≥n. */

#ifndef ACTION_INTERACTION_H
#define ACTION_INTERACTION_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Ejecuta la acci√≥n de 'comer', que dispara la animaci√≥n correspondiente.
 */
void action_interaction_eat(void);

/**
 * @brief Ejecuta la acci√≥n de 'ejercicio', que dispara la animaci√≥n correspondiente.
 */
void action_interaction_gym(void);

/**
 * @brief Ejecuta la acci√≥n de 'atacar', que dispara la animaci√≥n correspondiente.
 */
void action_interaction_attack(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_INTERACTION_H

--- END OF FILE: .\components\ui\actions\action_interaction.h ---

--- START OF FILE: .\components\ui\actions\action_screen.c ---
/* Fecha: 17/08/2025 - 01:48  */
/* Fichero: components/ui/actions/action_screen.c */
/* √öltimo cambio: Implementaci√≥n de la l√≥gica de encendido/apagado de pantalla. */
/* Descripci√≥n: M√≥dulo que implementa la acci√≥n de alternar el estado de la pantalla. Depende del 'screen_manager' para el control f√≠sico del display y del 'ui_actions_panel' para ocultar los botones antes de apagar. */

#include "actions/action_screen.h"
#include "screen_manager.h"
#include "ui_actions_panel.h" // Necesario para ocultar los paneles

/**
 * @brief Implementaci√≥n de la acci√≥n de alternar el estado de la pantalla.
 */
void action_screen_toggle(void) {
    if (screen_manager_is_off()) {
        // Si la pantalla est√° apagada, simplemente la enciende.
        screen_manager_turn_on();
    } else {
        // Si la pantalla est√° encendida, primero oculta cualquier panel de acci√≥n visible
        // y luego apaga la pantalla para una transici√≥n limpia.
        ui_actions_panel_hide_all(); 
        screen_manager_turn_off();
    }
}

--- END OF FILE: .\components\ui\actions\action_screen.c ---

--- START OF FILE: .\components\ui\actions\action_screen.h ---
/* Fecha: 17/08/2025 - 01:48  */
/* Fichero: components/ui/actions/action_screen.h */
/* √öltimo cambio: Creaci√≥n del m√≥dulo para la acci√≥n de encender/apagar la pantalla. */
/* Descripci√≥n: Interfaz p√∫blica para la acci√≥n de control de pantalla. Encapsula la l√≥gica de encendido y apagado, continuando la refactorizaci√≥n para desacoplar el orquestador principal. */

#ifndef ACTION_SCREEN_H
#define ACTION_SCREEN_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Alterna el estado de la pantalla (encendido/apagado).
 *        Si est√° encendida, oculta los paneles y la apaga.
 *        Si est√° apagada, la enciende.
 */
void action_screen_toggle(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_SCREEN_H

--- END OF FILE: .\components\ui\actions\action_screen.h ---

--- START OF FILE: .\components\ui\actions\action_system.c ---
/* Fecha: 18/08/2025 - 07:00  */
/* Fichero: components/ui/actions/action_system.c */
/* √öltimo cambio: Eliminada la inclusi√≥n de 'wifi_portal.h' para resolver el error de compilaci√≥n. */
/* Descripci√≥n: Se ha eliminado la directiva '#include "wifi_portal.h"' porque el componente 'wifi_portal' fue borrado del proyecto. Las funciones para borrar credenciales ahora residen en el BSP o en un nuevo m√≥dulo de gesti√≥n de NVS, pero por ahora se elimina la dependencia directa para permitir la compilaci√≥n. */

#include "actions/action_system.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "esp_system.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "diymon_evolution.h"
#include "esp_log.h"
#include "bsp_api.h" // Se asume que el borrado de credenciales estar√° aqu√≠ o en un gestor NVS

static const char *TAG = "ACTION_SYSTEM";

/**
 * @brief Funci√≥n de ayuda para borrar una clave espec√≠fica de la NVS.
 */
static void erase_nvs_key(const char* key) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err == ESP_OK) {
        nvs_erase_key(nvs_handle, key);
        nvs_commit(nvs_handle);
        nvs_close(nvs_handle);
        ESP_LOGI(TAG, "Clave NVS '%s' borrada.", key);
    } else {
        ESP_LOGE(TAG, "Error al abrir NVS para borrar la clave '%s'.", key);
    }
}

/**
 * @brief Funci√≥n interna para borrar credenciales WiFi.
 * @note Esto es una soluci√≥n temporal. Idealmente, esta l√≥gica deber√≠a estar
 *       en un m√≥dulo dedicado a la gesti√≥n de NVS o en el BSP.
 */
static void erase_wifi_credentials_from_nvs(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) return;
    nvs_erase_key(nvs_handle, "wifi_ssid");
    nvs_erase_key(nvs_handle, "wifi_pass");
    nvs_erase_key(nvs_handle, "wifi_authmode");
    nvs_commit(nvs_handle);
    nvs_close(nvs_handle);
    ESP_LOGI(TAG, "Credenciales WiFi borradas de NVS.");
}


/**
 * @brief Implementaci√≥n del reseteo total del dispositivo.
 */
void action_system_reset_all(void) {
    ESP_LOGW(TAG, "Ejecutando reseteo total del dispositivo...");
    
    // Borra todas las configuraciones guardadas
    erase_wifi_credentials_from_nvs();
    diymon_evolution_reset_state();
    erase_nvs_key("file_server"); // Se mantiene por si quedan restos de versiones anteriores

    ESP_LOGW(TAG, "Todas las configuraciones borradas. Reiniciando ahora.");
    vTaskDelay(pdMS_TO_TICKS(1000));
    esp_restart();
}

--- END OF FILE: .\components\ui\actions\action_system.c ---

--- START OF FILE: .\components\ui\actions\action_system.h ---
/* Fecha: 17/08/2025 - 03:35  */
/* Fichero: components/ui/actions/action_system.h */
/* √öltimo cambio: Creaci√≥n del m√≥dulo para agrupar las acciones de sistema como primer paso de la refactorizaci√≥n de 'actions.c'. */
/* Descripci√≥n: Interfaz p√∫blica para las acciones de sistema como 'activar servidor de ficheros' y 'reset total'. Este es el primer paso para descomponer el monol√≠tico 'actions.c', siguiendo el Principio de Responsabilidad √önica. */

#ifndef ACTION_SYSTEM_H
#define ACTION_SYSTEM_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Activa el modo de servidor de ficheros.
 *        Establece una bandera en NVS y reinicia el dispositivo para que
 *        app_main entre en el modo de servicio correspondiente.
 */
void action_system_enable_file_server(void);

/**
 * @brief Realiza un reseteo total del dispositivo.
 *        Borra las credenciales WiFi, el estado de evoluci√≥n y la bandera
 *        del servidor de ficheros de la NVS, y luego reinicia.
 */
void action_system_reset_all(void);

#ifdef __cplusplus
}
#endif

#endif // ACTION_SYSTEM_H

--- END OF FILE: .\components\ui\actions\action_system.h ---

--- START OF FILE: .\components\ui\buttons\btn_1.c ---
/* Fecha: 17/08/2025 - 07:11  */
/* Fichero: components/ui/buttons/btn_1.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido un error de posicionamiento del bot√≥n que imped√≠a su correcta visualizaci√≥n. Se ha reemplazado la l√≥gica de posicionamiento absoluto (lv_obj_set_pos) y ocultaci√≥n expl√≠cita por un alineamiento relativo (lv_obj_align) dentro de su panel padre. Esto soluciona el problema por el cual el bot√≥n no aparec√≠a al desplegarse el panel de acciones. */
#include "btn_1.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_1";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_btn_1_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Comer'.
 *        Ejecuta la acci√≥n de comer cuando se presiona el bot√≥n.
 * @param e Puntero al evento de LVGL.
 */
static void btn_1_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de comer.");
        execute_diymon_action(ACTION_ID_COMER);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Comer'.
 */
void btn_1_create(lv_obj_t *parent) {
    s_btn_1_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_1_handle);
    lv_obj_set_size(s_btn_1_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_btn_1_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_1_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_1_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_btn_1_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EAT);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EAT'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_1_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 0, 0);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_btn_1_handle, btn_1_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Bot√≥n 'Comer' (BTN_1) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Comer'.
 */
lv_obj_t* btn_1_get_handle(void) {
    return s_btn_1_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_1.c ---

--- START OF FILE: .\components\ui\buttons\btn_1.h ---
/* Fecha: 17/08/2025 - 01:17 
# Fichero: components/ui/buttons/btn_1.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Comer' (BTN_1).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n 'Comer'. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador, encapsulando su l√≥gica.
*/
#ifndef BTN_1_H
#define BTN_1_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Comer'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void btn_1_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Comer'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* btn_1_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_1_H

--- END OF FILE: .\components\ui\buttons\btn_1.h ---

--- START OF FILE: .\components\ui\buttons\btn_2.c ---
/* Fecha: 17/08/2025 - 05:17  */
/* Fichero: components/ui/buttons/btn_2.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_2.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_2";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_btn_2_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Ejercicio'.
 *        Ejecuta la acci√≥n de ejercicio cuando se presiona el bot√≥n.
 * @param e Puntero al evento de LVGL.
 */
static void btn_2_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de ejercicio.");
        execute_diymon_action(ACTION_ID_EJERCICIO);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Ejercicio'.
 */
void btn_2_create(lv_obj_t *parent) {
    s_btn_2_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_2_handle);
    lv_obj_set_size(s_btn_2_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_btn_2_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_2_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_2_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_btn_2_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_GYM);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_GYM'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_2_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 1, 0);
    
    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_btn_2_handle, btn_2_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Bot√≥n 'Ejercicio' (BTN_2) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Ejercicio'.
 */
lv_obj_t* btn_2_get_handle(void) {
    return s_btn_2_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_2.c ---

--- START OF FILE: .\components\ui\buttons\btn_2.h ---
/* Fecha: 17/08/2025 - 01:18 
# Fichero: components/ui/buttons/btn_2.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Ejercicio' (BTN_2).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n 'Ejercicio'. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef BTN_2_H
#define BTN_2_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Ejercicio'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void btn_2_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Ejercicio'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* btn_2_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_2_H

--- END OF FILE: .\components\ui\buttons\btn_2.h ---

--- START OF FILE: .\components\ui\buttons\btn_3.c ---
/* Fecha: 17/08/2025 - 05:18  */
/* Fichero: components/ui/buttons/btn_3.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_3.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_3";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_btn_3_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Atacar'.
 *        Ejecuta la acci√≥n de atacar cuando se presiona el bot√≥n.
 * @param e Puntero al evento de LVGL.
 */
static void btn_3_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de atacar.");
        execute_diymon_action(ACTION_ID_ATACAR);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Atacar'.
 */
void btn_3_create(lv_obj_t *parent) {
    s_btn_3_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_3_handle);
    lv_obj_set_size(s_btn_3_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_btn_3_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_3_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_3_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_btn_3_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_ATK);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_ATK'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_3_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 2, 0);
    
    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_btn_3_handle, btn_3_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Bot√≥n 'Atacar' (BTN_3) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Atacar'.
 */
lv_obj_t* btn_3_get_handle(void) {
    return s_btn_3_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_3.c ---

--- START OF FILE: .\components\ui\buttons\btn_3.h ---
/* Fecha: 17/08/2025 - 01:19 
# Fichero: components/ui/buttons/btn_3.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Atacar' (BTN_3).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n 'Atacar'. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef BTN_3_H
#define BTN_3_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Atacar'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void btn_3_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Atacar'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* btn_3_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_3_H

--- END OF FILE: .\components\ui\buttons\btn_3.h ---

--- START OF FILE: .\components\ui\buttons\btn_4.c ---
/* Fecha: 17/08/2025 - 05:19  */
/* Fichero: components/ui/buttons/btn_4.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_4.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_4";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_btn_4_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Brillo'.
 *        Ejecuta la acci√≥n de ciclar el brillo.
 * @param e Puntero al evento de LVGL.
 */
static void btn_4_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de brillo.");
        execute_diymon_action(ACTION_ID_BRIGHTNESS_CYCLE);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Brillo'.
 */
void btn_4_create(lv_obj_t *parent) {
    s_btn_4_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_4_handle);
    lv_obj_set_size(s_btn_4_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_btn_4_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_4_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_4_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_btn_4_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_BRIGHTNESS);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_BRIGHTNESS'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_4_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 0, 0);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_btn_4_handle, btn_4_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Bot√≥n 'Brillo' (BTN_4) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Brillo'.
 */
lv_obj_t* btn_4_get_handle(void) {
    return s_btn_4_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_4.c ---

--- START OF FILE: .\components\ui\buttons\btn_4.h ---
/* Fecha: 17/08/2025 - 01:20 
# Fichero: components/ui/buttons/btn_4.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Brillo' (BTN_4).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n 'Brillo'. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef BTN_4_H
#define BTN_4_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Brillo'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void btn_4_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Brillo'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* btn_4_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_4_H

--- END OF FILE: .\components\ui\buttons\btn_4.h ---

--- START OF FILE: .\components\ui\buttons\btn_5.c ---
/* Fecha: 17/08/2025 - 05:19  */
/* Fichero: components/ui/buttons/btn_5.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_5.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_5";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_btn_5_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Apagar Pantalla'.
 *        Ejecuta la acci√≥n de apagar/encender la pantalla.
 * @param e Puntero al evento de LVGL.
 */
static void btn_5_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de apagar/encender pantalla.");
        execute_diymon_action(ACTION_ID_TOGGLE_SCREEN);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Apagar Pantalla'.
 */
void btn_5_create(lv_obj_t *parent) {
    s_btn_5_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_5_handle);
    lv_obj_set_size(s_btn_5_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_btn_5_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_5_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_5_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_btn_5_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_SCREEN_OFF);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_SCREEN_OFF'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_5_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 1, 0);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_btn_5_handle, btn_5_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Bot√≥n 'Apagar Pantalla' (BTN_5) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Apagar Pantalla'.
 */
lv_obj_t* btn_5_get_handle(void) {
    return s_btn_5_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_5.c ---

--- START OF FILE: .\components\ui\buttons\btn_5.h ---
/* Fecha: 17/08/2025 - 01:20 
# Fichero: components/ui/buttons/btn_5.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Apagar Pantalla' (BTN_5).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n 'Apagar Pantalla'. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef BTN_5_H
#define BTN_5_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Apagar Pantalla'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void btn_5_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Apagar Pantalla'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* btn_5_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_5_H

--- END OF FILE: .\components\ui\buttons\btn_5.h ---

--- START OF FILE: .\components\ui\buttons\btn_6.c ---
/* Fecha: 17/08/2025 - 05:20  */
/* Fichero: components/ui/buttons/btn_6.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_6.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_6";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_btn_6_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Modo Config'.
 *        Ejecuta la acci√≥n de activar el modo de configuraci√≥n.
 * @param e Puntero al evento de LVGL.
 */
static void btn_6_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de modo config.");
        execute_diymon_action(ACTION_ID_ACTIVATE_CONFIG_MODE);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Modo Config'.
 */
void btn_6_create(lv_obj_t *parent) {
    s_btn_6_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_6_handle);
    lv_obj_set_size(s_btn_6_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_btn_6_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_6_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_6_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_btn_6_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_ADMIN_PLACEHOLDER);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_ADMIN_PLACEHOLDER'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_6_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 2, 0);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_btn_6_handle, btn_6_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Bot√≥n 'Modo Config' (BTN_6) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Modo Config'.
 */
lv_obj_t* btn_6_get_handle(void) {
    return s_btn_6_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_6.c ---

--- START OF FILE: .\components\ui\buttons\btn_6.h ---
/* Fecha: 17/08/2025 - 01:21 
# Fichero: components\ui\buttons\btn_6.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Modo Config' (BTN_6).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n que activa el modo de configuraci√≥n. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef BTN_6_H
#define BTN_6_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Modo Config'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void btn_6_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Modo Config'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* btn_6_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_6_H

--- END OF FILE: .\components\ui\buttons\btn_6.h ---

--- START OF FILE: .\components\ui\buttons\btn_7.c ---
/* Fecha: 17/08/2025 - 05:21  */
/* Fichero: components/ui/buttons/btn_7.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_7.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_7";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_btn_7_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Reset Total'.
 *        Ejecuta la acci√≥n de reseteo total.
 * @param e Puntero al evento de LVGL.
 */
static void btn_7_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de reset total.");
        execute_diymon_action(ACTION_ID_RESET_ALL);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Reset Total'.
 */
void btn_7_create(lv_obj_t *parent) {
    s_btn_7_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_7_handle);
    lv_obj_set_size(s_btn_7_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_btn_7_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_7_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_7_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_btn_7_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_RESET_ALL);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_RESET_ALL'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_7_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 0, 0);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_btn_7_handle, btn_7_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Bot√≥n 'Reset Total' (BTN_7) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Reset Total'.
 */
lv_obj_t* btn_7_get_handle(void) {
    return s_btn_7_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_7.c ---

--- START OF FILE: .\components\ui\buttons\btn_7.h ---
/* Fecha: 17/08/2025 - 01:22 
# Fichero: components\ui\buttons\btn_7.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Reset Total' (BTN_7).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n de reseteo. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef BTN_7_H
#define BTN_7_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Reset Total'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void btn_7_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Reset Total'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* btn_7_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_7_H

--- END OF FILE: .\components\ui\buttons\btn_7.h ---

--- START OF FILE: .\components\ui\buttons\btn_8.c ---
/* Fecha: 18/08/2025 - 06:55  */
/* Fichero: components/ui/buttons/btn_8.c */
/* √öltimo cambio: Reasignada la acci√≥n del bot√≥n a ACTION_ID_CONFIG_PLACEHOLDER tras eliminar el modo de servidor de ficheros. */
/* Descripci√≥n: Este bot√≥n activaba anteriormente el modo de servidor de ficheros. Como esa funcionalidad ahora est√° integrada en el modo de configuraci√≥n principal, el bot√≥n se ha convertido en un placeholder. Ahora dispara una acci√≥n gen√©rica que no realiza ninguna operaci√≥n, manteniendo la consistencia de la UI mientras se redise√±a su funci√≥n. */

#include "btn_8.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_8";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_btn_8_handle = NULL;

/**
 * @brief Callback de evento para el bot√≥n 8.
 */
static void btn_8_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "Bot√≥n 8 (placeholder) presionado.");
        // [CORRECCI√ìN] La acci√≥n del servidor de ficheros ha sido eliminada.
        // Ahora se dispara una acci√≥n placeholder que no hace nada.
        execute_diymon_action(ACTION_ID_CONFIG_PLACEHOLDER);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 8.
 */
void btn_8_create(lv_obj_t *parent) {
    s_btn_8_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_8_handle);
    lv_obj_set_size(s_btn_8_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_btn_8_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_8_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_8_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_btn_8_handle);
    // [CORRECCI√ìN] Se mantiene el icono original por ahora, pero la acci√≥n ha cambiado.
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_ENABLE_FILE_SERVER);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_ENABLE_FILE_SERVER'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    lv_obj_align(s_btn_8_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 1, 0);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_btn_8_handle, btn_8_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Bot√≥n 8 (placeholder) creado y posicionado.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 8.
 */
lv_obj_t* btn_8_get_handle(void) {
    return s_btn_8_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_8.c ---

--- START OF FILE: .\components\ui\buttons\btn_8.h ---
/* Fecha: 17/08/2025 - 01:24 
# Fichero: components\ui\buttons\btn_8.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Servidor de Ficheros' (BTN_8).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n que activa el servidor de ficheros. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef BTN_8_H
#define BTN_8_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Servidor de Ficheros'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void btn_8_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Servidor de Ficheros'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* btn_8_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_8_H

--- END OF FILE: .\components\ui\buttons\btn_8.h ---

--- START OF FILE: .\components\ui\buttons\btn_9.c ---
/* Fecha: 17/08/2025 - 05:21  */
/* Fichero: components/ui/buttons/btn_9.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "btn_9.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "BTN_9";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_btn_9_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Placeholder de Config'.
 *        Ejecuta la acci√≥n de placeholder.
 * @param e Puntero al evento de LVGL.
 */
static void btn_9_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de placeholder.");
        execute_diymon_action(ACTION_ID_CONFIG_PLACEHOLDER);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Placeholder de Config'.
 */
void btn_9_create(lv_obj_t *parent) {
    s_btn_9_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_btn_9_handle);
    lv_obj_set_size(s_btn_9_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_btn_9_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_btn_9_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_btn_9_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_btn_9_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_CONFIG_PLACEHOLDER);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_CONFIG_PLACEHOLDER'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_btn_9_handle, LV_ALIGN_LEFT_MID, (BUTTON_SIZE + BUTTON_PADDING) * 2, 0);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_btn_9_handle, btn_9_event_cb, LV_EVENT_PRESSED, NULL);
    
    ESP_LOGI(TAG, "Bot√≥n 'Placeholder Config' (BTN_9) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Placeholder de Config'.
 */
lv_obj_t* btn_9_get_handle(void) {
    return s_btn_9_handle;
}

--- END OF FILE: .\components\ui\buttons\btn_9.c ---

--- START OF FILE: .\components\ui\buttons\btn_9.h ---
/* Fecha: 17/08/2025 - 01:24 
# Fichero: components\ui\buttons\btn_9.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Placeholder de Config' (BTN_9).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n placeholder del panel de configuraci√≥n. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef BTN_9_H
#define BTN_9_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Placeholder de Config'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void btn_9_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Placeholder de Config'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* btn_9_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // BTN_9_H

--- END OF FILE: .\components\ui\buttons\btn_9.h ---

--- START OF FILE: .\components\ui\buttons\buttons_manager.c ---
/* Fecha: 17/08/2025 - 01:29 
# Fichero: components\ui\buttons\buttons_manager.c
# √öltimo cambio: Implementaci√≥n del orquestador de botones.
# Descripci√≥n: Este fichero centraliza la creaci√≥n de todos los botones de la UI. La funci√≥n ui_buttons_init llama a las funciones de creaci√≥n de cada m√≥dulo de bot√≥n individual, y los getters proporcionan acceso a sus manejadores para otros m√≥dulos.
*/
#include "buttons_manager.h"

// Include all individual button modules
#include "btn_1.h"
#include "btn_2.h"
#include "btn_3.h"
#include "btn_4.h"
#include "btn_5.h"
#include "btn_6.h"
#include "btn_7.h"
#include "btn_8.h"
#include "btn_9.h"
#include "evo_1.h"
#include "evo_2.h"
#include "evo_3.h"
#include "evo_4.h"
#include "evo_5.h"

/**
 * @brief Inicializa y crea todos los botones de la UI llamando a los constructores de cada m√≥dulo.
 */
void ui_buttons_init(lv_obj_t *parent) {
    // --- Panel de Jugador (3 botones) ---
    btn_1_create(parent);
    btn_2_create(parent);
    btn_3_create(parent);

    // --- Panel de Administraci√≥n (3 botones) ---
    btn_4_create(parent);
    btn_5_create(parent);
    btn_6_create(parent);
    
    // --- Panel de Configuraci√≥n (3 botones) ---
    btn_7_create(parent);
    btn_8_create(parent);
    btn_9_create(parent);

    // --- Panel Lateral de Evoluci√≥n (5 botones) ---
    evo_1_create(parent);
    evo_2_create(parent);
    evo_3_create(parent);
    evo_4_create(parent);
    evo_5_create(parent);
}

// --- Implementaci√≥n de Getters ---
lv_obj_t* ui_buttons_get_btn_1(void) { return btn_1_get_handle(); }
lv_obj_t* ui_buttons_get_btn_2(void) { return btn_2_get_handle(); }
lv_obj_t* ui_buttons_get_btn_3(void) { return btn_3_get_handle(); }
lv_obj_t* ui_buttons_get_btn_4(void) { return btn_4_get_handle(); }
lv_obj_t* ui_buttons_get_btn_5(void) { return btn_5_get_handle(); }
lv_obj_t* ui_buttons_get_btn_6(void) { return btn_6_get_handle(); }
lv_obj_t* ui_buttons_get_btn_7(void) { return btn_7_get_handle(); }
lv_obj_t* ui_buttons_get_btn_8(void) { return btn_8_get_handle(); }
lv_obj_t* ui_buttons_get_btn_9(void) { return btn_9_get_handle(); }

lv_obj_t* ui_buttons_get_evo_1(void) { return evo_1_get_handle(); }
lv_obj_t* ui_buttons_get_evo_2(void) { return evo_2_get_handle(); }
lv_obj_t* ui_buttons_get_evo_3(void) { return evo_3_get_handle(); }
lv_obj_t* ui_buttons_get_evo_4(void) { return evo_4_get_handle(); }
lv_obj_t* ui_buttons_get_evo_5(void) { return evo_5_get_handle(); }

--- END OF FILE: .\components\ui\buttons\buttons_manager.c ---

--- START OF FILE: .\components\ui\buttons\buttons_manager.h ---
/* Fecha: 17/08/2025 - 01:28 
# Fichero: components\ui\buttons\buttons_manager.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el orquestador de botones.
# Descripci√≥n: Define la interfaz p√∫blica del gestor de botones. Expone una funci√≥n de inicializaci√≥n para crear todos los botones de la UI y getters individuales para que otros m√≥dulos, como el gestor de paneles, puedan acceder a sus manejadores.
*/
#ifndef BUTTONS_MANAGER_H
#define BUTTONS_MANAGER_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa y crea todos los botones de la interfaz de usuario.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√°n todos los botones.
 */
void ui_buttons_init(lv_obj_t *parent);

// --- Getters para los botones del panel superior ---
lv_obj_t* ui_buttons_get_btn_1(void); // Comer
lv_obj_t* ui_buttons_get_btn_2(void); // Ejercicio
lv_obj_t* ui_buttons_get_btn_3(void); // Atacar
lv_obj_t* ui_buttons_get_btn_4(void); // Brillo
lv_obj_t* ui_buttons_get_btn_5(void); // Apagar Pantalla
lv_obj_t* ui_buttons_get_btn_6(void); // Modo Config
lv_obj_t* ui_buttons_get_btn_7(void); // Reset Total
lv_obj_t* ui_buttons_get_btn_8(void); // Servidor Ficheros
lv_obj_t* ui_buttons_get_btn_9(void); // Placeholder Config

// --- Getters para los botones del panel lateral (Evoluci√≥n) ---
lv_obj_t* ui_buttons_get_evo_1(void); // Fuego
lv_obj_t* ui_buttons_get_evo_2(void); // Agua
lv_obj_t* ui_buttons_get_evo_3(void); // Tierra
lv_obj_t* ui_buttons_get_evo_4(void); // Viento
lv_obj_t* ui_buttons_get_evo_5(void); // Involucionar


#ifdef __cplusplus
}
#endif

#endif // BUTTONS_MANAGER_H

--- END OF FILE: .\components\ui\buttons\buttons_manager.h ---

--- START OF FILE: .\components\ui\buttons\evo_1.c ---
/* Fecha: 17/08/2025 - 05:22  */
/* Fichero: components/ui/buttons/evo_1.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "evo_1.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "EVO_1";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_evo_1_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Evo Fuego'.
 *        Ejecuta la acci√≥n de evolucionar a Fuego.
 * @param e Puntero al evento de LVGL.
 */
static void evo_1_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de evo fuego.");
        execute_diymon_action(ACTION_ID_EVO_FIRE);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Evo Fuego'.
 */
void evo_1_create(lv_obj_t *parent) {
    s_evo_1_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_evo_1_handle);
    lv_obj_set_size(s_evo_1_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_evo_1_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_evo_1_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_evo_1_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_evo_1_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EVO_FIRE);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EVO_FIRE'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_evo_1_handle, LV_ALIGN_TOP_MID, 0, (BUTTON_SIZE + BUTTON_PADDING) * 0);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_evo_1_handle, evo_1_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Bot√≥n 'Evo Fuego' (EVO_1) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Evo Fuego'.
 */
lv_obj_t* evo_1_get_handle(void) {
    return s_evo_1_handle;
}

--- END OF FILE: .\components\ui\buttons\evo_1.c ---

--- START OF FILE: .\components\ui\buttons\evo_1.h ---
/* Fecha: 17/08/2025 - 01:25 
# Fichero: components\ui\buttons\evo_1.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Evo Fuego' (EVO_1).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n de evoluci√≥n de Fuego. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef EVO_1_H
#define EVO_1_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Evo Fuego'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void evo_1_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Evo Fuego'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* evo_1_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // EVO_1_H

--- END OF FILE: .\components\ui\buttons\evo_1.h ---

--- START OF FILE: .\components\ui\buttons\evo_2.c ---
/* Fecha: 17/08/2025 - 05:22  */
/* Fichero: components/ui/buttons/evo_2.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "evo_2.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "EVO_2";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_evo_2_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Evo Agua'.
 *        Ejecuta la acci√≥n de evolucionar a Agua.
 * @param e Puntero al evento de LVGL.
 */
static void evo_2_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de evo agua.");
        execute_diymon_action(ACTION_ID_EVO_WATER);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Evo Agua'.
 */
void evo_2_create(lv_obj_t *parent) {
    s_evo_2_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_evo_2_handle);
    lv_obj_set_size(s_evo_2_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_evo_2_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_evo_2_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_evo_2_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_evo_2_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EVO_WATER);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EVO_WATER'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_evo_2_handle, LV_ALIGN_TOP_MID, 0, (BUTTON_SIZE + BUTTON_PADDING) * 1);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_evo_2_handle, evo_2_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Bot√≥n 'Evo Agua' (EVO_2) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Evo Agua'.
 */
lv_obj_t* evo_2_get_handle(void) {
    return s_evo_2_handle;
}

--- END OF FILE: .\components\ui\buttons\evo_2.c ---

--- START OF FILE: .\components\ui\buttons\evo_2.h ---
/* Fecha: 17/08/2025 - 01:26 
# Fichero: components\ui\buttons\evo_2.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Evo Agua' (EVO_2).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n de evoluci√≥n de Agua. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef EVO_2_H
#define EVO_2_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Evo Agua'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void evo_2_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Evo Agua'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* evo_2_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // EVO_2_H

--- END OF FILE: .\components\ui\buttons\evo_2.h ---

--- START OF FILE: .\components\ui\buttons\evo_3.c ---
/* Fecha: 17/08/2025 - 05:23  */
/* Fichero: components/ui/buttons/evo_3.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "evo_3.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "EVO_3";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_evo_3_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Evo Tierra'.
 *        Ejecuta la acci√≥n de evolucionar a Tierra.
 * @param e Puntero al evento de LVGL.
 */
static void evo_3_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de evo tierra.");
        execute_diymon_action(ACTION_ID_EVO_EARTH);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Evo Tierra'.
 */
void evo_3_create(lv_obj_t *parent) {
    s_evo_3_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_evo_3_handle);
    lv_obj_set_size(s_evo_3_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_evo_3_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_evo_3_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_evo_3_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_evo_3_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EVO_EARTH);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EVO_EARTH'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_evo_3_handle, LV_ALIGN_TOP_MID, 0, (BUTTON_SIZE + BUTTON_PADDING) * 2);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_evo_3_handle, evo_3_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Bot√≥n 'Evo Tierra' (EVO_3) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Evo Tierra'.
 */
lv_obj_t* evo_3_get_handle(void) {
    return s_evo_3_handle;
}

--- END OF FILE: .\components\ui\buttons\evo_3.c ---

--- START OF FILE: .\components\ui\buttons\evo_3.h ---
/* Fecha: 17/08/2025 - 01:26 
# Fichero: components\ui\buttons\evo_3.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Evo Tierra' (EVO_3).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n de evoluci√≥n de Tierra. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef EVO_3_H
#define EVO_3_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Evo Tierra'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void evo_3_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Evo Tierra'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* evo_3_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // EVO_3_H

--- END OF FILE: .\components\ui\buttons\evo_3.h ---

--- START OF FILE: .\components\ui\buttons\evo_4.c ---
/* Fecha: 17/08/2025 - 05:24  */
/* Fichero: components/ui/buttons/evo_4.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "evo_4.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "EVO_4";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_evo_4_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Evo Viento'.
 *        Ejecuta la acci√≥n de evolucionar a Viento.
 * @param e Puntero al evento de LVGL.
 */
static void evo_4_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de evo viento.");
        execute_diymon_action(ACTION_ID_EVO_WIND);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Evo Viento'.
 */
void evo_4_create(lv_obj_t *parent) {
    s_evo_4_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_evo_4_handle);
    lv_obj_set_size(s_evo_4_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_evo_4_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_evo_4_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_evo_4_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_evo_4_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EVO_WIND);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EVO_WIND'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_evo_4_handle, LV_ALIGN_TOP_MID, 0, (BUTTON_SIZE + BUTTON_PADDING) * 3);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_evo_4_handle, evo_4_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Bot√≥n 'Evo Viento' (EVO_4) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Evo Viento'.
 */
lv_obj_t* evo_4_get_handle(void) {
    return s_evo_4_handle;
}

--- END OF FILE: .\components\ui\buttons\evo_4.c ---

--- START OF FILE: .\components\ui\buttons\evo_4.h ---
/* Fecha: 17/08/2025 - 01:27 
# Fichero: components\ui\buttons\evo_4.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Evo Viento' (EVO_4).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n de evoluci√≥n de Viento. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef EVO_4_H
#define EVO_4_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Evo Viento'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void evo_4_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Evo Viento'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* evo_4_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // EVO_4_H

--- END OF FILE: .\components\ui\buttons\evo_4.h ---

--- START OF FILE: .\components\ui\buttons\evo_5.c ---
/* Fecha: 17/08/2025 - 05:24  */
/* Fichero: components/ui/buttons/evo_5.c */
/* √öltimo cambio: Corregido el posicionamiento del bot√≥n para que se mueva con su panel padre. */
/* Descripci√≥n: Se ha corregido el error de posicionamiento del bot√≥n. En lugar de tener su propia l√≥gica de ocultaci√≥n y posici√≥n fuera de pantalla, ahora se alinea est√°ticamente dentro de su panel padre usando 'lv_obj_align'. Esto asegura que cuando el panel se anima para mostrarse, el bot√≥n aparece correctamente en su interior, resolviendo el problema de que los paneles no se desplegaban visualmente. */

#include "evo_5.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "esp_log.h"

// --- Definiciones de dise√±o locales ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
static const char *TAG = "EVO_5";

// --- Variable est√°tica para el manejador del bot√≥n ---
static lv_obj_t *s_evo_5_handle = NULL;

/**
 * @brief Callback de evento espec√≠fico para el bot√≥n 'Involucionar'.
 *        Ejecuta la acci√≥n de involucionar.
 * @param e Puntero al evento de LVGL.
 */
static void evo_5_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        ESP_LOGI(TAG, "¬°Evento CLICK recibido! Ejecutando acci√≥n de involucionar.");
        execute_diymon_action(ACTION_ID_EVO_BACK);
    }
}

/**
 * @brief Crea el objeto del bot√≥n 'Involucionar'.
 */
void evo_5_create(lv_obj_t *parent) {
    s_evo_5_handle = lv_btn_create(parent);
    lv_obj_remove_style_all(s_evo_5_handle);
    lv_obj_set_size(s_evo_5_handle, BUTTON_SIZE, BUTTON_SIZE);

    // --- Estilos del bot√≥n ---
    lv_obj_set_style_bg_opa(s_evo_5_handle, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(s_evo_5_handle, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(s_evo_5_handle, 0, LV_STATE_ANY);

    // --- Icono del bot√≥n ---
    lv_obj_t *img = lv_img_create(s_evo_5_handle);
    const lv_img_dsc_t* icon_src = ui_assets_get_icon(ASSET_ICON_EVO_BACK);
    if (icon_src) {
        lv_img_set_src(img, icon_src);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el icono 'ASSET_ICON_EVO_BACK'.");
    }
    lv_obj_center(img);

    // --- Posici√≥n DENTRO de su panel padre ---
    // [CORRECCI√ìN] Se alinea el bot√≥n dentro del panel. El panel es el que se anima.
    lv_obj_align(s_evo_5_handle, LV_ALIGN_TOP_MID, 0, (BUTTON_SIZE + BUTTON_PADDING) * 4);

    // --- Conexi√≥n del evento ---
    lv_obj_add_event_cb(s_evo_5_handle, evo_5_event_cb, LV_EVENT_PRESSED, NULL);

    ESP_LOGI(TAG, "Bot√≥n 'Involucionar' (EVO_5) creado y posicionado dentro de su panel.");
}

/**
 * @brief Obtiene el manejador del bot√≥n 'Involucionar'.
 */
lv_obj_t* evo_5_get_handle(void) {
    return s_evo_5_handle;
}

--- END OF FILE: .\components\ui\buttons\evo_5.c ---

--- START OF FILE: .\components\ui\buttons\evo_5.h ---
/* Fecha: 17/08/2025 - 01:28 
# Fichero: components\ui\buttons\evo_5.h
# √öltimo cambio: Creaci√≥n del fichero de cabecera para el bot√≥n 'Involucionar' (EVO_5).
# Descripci√≥n: Define la interfaz p√∫blica para el m√≥dulo del bot√≥n de involuci√≥n. Expone funciones para crear el objeto LVGL del bot√≥n y para obtener su manejador.
*/
#ifndef EVO_5_H
#define EVO_5_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea el objeto LVGL para el bot√≥n 'Involucionar'.
 * 
 * @param parent El objeto LVGL padre sobre el cual se crear√° el bot√≥n.
 */
void evo_5_create(lv_obj_t *parent);

/**
 * @brief Obtiene el manejador del bot√≥n 'Involucionar'.
 * 
 * @return Un puntero al objeto lv_obj_t del bot√≥n.
 */
lv_obj_t* evo_5_get_handle(void);

#ifdef __cplusplus
}
#endif

#endif // EVO_5_H

--- END OF FILE: .\components\ui\buttons\evo_5.h ---

--- START OF FILE: .\components\ui\core\state_manager.c ---
/* Fecha: 18/08/2025 - 08:01  */
/* Fichero: components/ui/core/state_manager.c */
/* √öltimo cambio: Implementada la funci√≥n state_manager_destroy para liberar los temporizadores. */
/* Descripci√≥n: Se ha a√±adido la implementaci√≥n de state_manager_destroy, que se encarga de eliminar de forma segura todos los temporizadores de LVGL que el gestor de estado crea. Esto permite liberar memoria y detener la l√≥gica de inactividad cuando se entra en modos de operaci√≥n donde no es necesaria, como el modo de configuraci√≥n. */

#include "state_manager.h"
#include "screen_manager.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "esp_log.h"

static const char *TAG = "UI_STATE_MANAGER";

// --- Tipos y variables de estado internas ---
typedef enum {
    WAKE_STATE_OFF,
    WAKE_STATE_PRIMED,
} wake_up_state_t;

static bool s_is_dimmed = false;
static int s_user_brightness = 100;
static bool s_user_brightness_known = false;
static wake_up_state_t s_wake_state = WAKE_STATE_OFF;
static uint8_t s_wake_click_count = 0;
static lv_timer_t *s_double_click_timer = NULL;
static lv_timer_t *s_wake_prime_timer = NULL;
static lv_timer_t *s_inactivity_timer = NULL;
static bool s_is_paused = false; // Flag para pausar el gestor

// --- Funciones de ayuda y callbacks ---

static void read_user_brightness_from_nvs(void) {
    if (s_user_brightness_known) return;
    nvs_handle_t nvs_handle;
    if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
        nvs_get_i32(nvs_handle, "brightness", (int32_t*)&s_user_brightness);
        nvs_close(nvs_handle);
        s_user_brightness_known = true;
    }
}

static void double_click_timer_cb(lv_timer_t * timer) {
    s_wake_click_count = 0;
    s_double_click_timer = NULL;
}

static void wake_prime_timer_cb(lv_timer_t * timer) {
    s_wake_state = WAKE_STATE_OFF;
    s_wake_click_count = 0;
    s_wake_prime_timer = NULL;
}

static void screen_touch_event_cb(lv_event_t * e) {
    if (s_is_paused) return; // Ignorar eventos si est√° pausado
    lv_event_code_t code = lv_event_get_code(e);
    lv_disp_t * disp = lv_display_get_default();
    if (!disp) return;
    
    lv_display_trigger_activity(disp);

    if (code == LV_EVENT_PRESSED && s_is_dimmed && !screen_manager_is_off()) {
        read_user_brightness_from_nvs();
        screen_manager_set_brightness(s_user_brightness);
        s_is_dimmed = false;
        return;
    }

    if (code == LV_EVENT_CLICKED && screen_manager_is_off()) {
        if (s_wake_state == WAKE_STATE_OFF) {
            s_wake_click_count++;
            if (s_wake_click_count == 1) {
                s_double_click_timer = lv_timer_create(double_click_timer_cb, 500, NULL);
                lv_timer_set_repeat_count(s_double_click_timer, 1);
            } else if (s_wake_click_count == 2) {
                if (s_double_click_timer) lv_timer_del(s_double_click_timer);
                s_double_click_timer = NULL;
                s_wake_state = WAKE_STATE_PRIMED;
                s_wake_click_count = 0;
                s_wake_prime_timer = lv_timer_create(wake_prime_timer_cb, 3000, NULL);
                lv_timer_set_repeat_count(s_wake_prime_timer, 1);
            }
        } else if (s_wake_state == WAKE_STATE_PRIMED) {
            s_wake_click_count++;
            if (s_wake_click_count == 1) {
                s_double_click_timer = lv_timer_create(double_click_timer_cb, 500, NULL);
                lv_timer_set_repeat_count(s_double_click_timer, 1);
            } else if (s_wake_click_count >= 2) {
                if (s_double_click_timer) lv_timer_del(s_double_click_timer);
                if (s_wake_prime_timer) lv_timer_del(s_wake_prime_timer);
                s_double_click_timer = NULL;
                s_wake_prime_timer = NULL;
                screen_manager_turn_on();
                s_is_dimmed = false;
                s_wake_state = WAKE_STATE_OFF;
                s_wake_click_count = 0;
            }
        }
    }
}

static void inactivity_timer_cb(lv_timer_t * timer) {
    if (s_is_paused) return; // No hacer nada si est√° pausado

    lv_disp_t * disp = lv_display_get_default();
    if (!disp) return;
    
    uint32_t inactivity_ms = lv_display_get_inactive_time(disp);
    bool is_off = screen_manager_is_off();

    if (inactivity_ms < 30000 && s_is_dimmed) {
        s_is_dimmed = false;
    }

    if (!is_off && inactivity_ms > 60000) {
        screen_manager_turn_off();
        s_is_dimmed = false;
    } else if (!is_off && !s_is_dimmed && inactivity_ms > 30000) {
        read_user_brightness_from_nvs();
        screen_manager_set_brightness(10);
        s_is_dimmed = true;
    }
}

// --- Funciones de inicializaci√≥n y control p√∫blicas ---

void state_manager_init(void) {
    s_inactivity_timer = lv_timer_create(inactivity_timer_cb, 5000, NULL);
    lv_obj_t * scr = lv_screen_active();
    if (scr) {
        lv_obj_add_event_cb(scr, screen_touch_event_cb, LV_EVENT_ALL, NULL);
    }
    ESP_LOGI(TAG, "Gestor de estado de UI inicializado. Manejadores de inactividad activos.");
}

void state_manager_pause(void) {
    if (!s_is_paused) {
        s_is_paused = true;
        ESP_LOGI(TAG, "Gestor de estado PAUSADO. La pantalla no se atenuar√° ni apagar√° por inactividad.");
    }
}

void state_manager_resume(void) {
    if (s_is_paused) {
        s_is_paused = false;
        // Resetea el contador de inactividad para dar al usuario tiempo completo antes del pr√≥ximo evento.
        lv_disp_t * disp = lv_display_get_default();
        if (disp) {
            lv_display_trigger_activity(disp);
        }
        ESP_LOGI(TAG, "Gestor de estado REANUDADO.");
    }
}

void state_manager_destroy(void) {
    if (s_inactivity_timer) {
        lv_timer_del(s_inactivity_timer);
        s_inactivity_timer = NULL;
    }
    if (s_double_click_timer) {
        lv_timer_del(s_double_click_timer);
        s_double_click_timer = NULL;
    }
    if (s_wake_prime_timer) {
        lv_timer_del(s_wake_prime_timer);
        s_wake_prime_timer = NULL;
    }
    // No es necesario eliminar el screen_touch_event_cb, ya que la pantalla
    // a la que est√° asociado ser√° eliminada por el llamante.
    ESP_LOGI(TAG, "Gestor de estado DESTRUIDO. Todos los temporizadores liberados.");
}

--- END OF FILE: .\components\ui\core\state_manager.c ---

--- START OF FILE: .\components\ui\core\state_manager.h ---
/* Fecha: 18/08/2025 - 08:00  */
/* Fichero: components/ui/core/state_manager.h */
/* √öltimo cambio: A√±adida la funci√≥n state_manager_destroy para liberar recursos. */
/* Descripci√≥n: Interfaz p√∫blica del gestor de estado. Se a√±ade una funci√≥n 'destroy' para eliminar los temporizadores de LVGL y liberar memoria cuando el gestor no es necesario, como en el modo de configuraci√≥n. Esto optimiza el uso de recursos y previene la ejecuci√≥n de callbacks innecesarios. */

#ifndef STATE_MANAGER_H
#define STATE_MANAGER_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el gestor de estado de la UI.
 * 
 * Configura los temporizadores y callbacks necesarios para gestionar la
 * inactividad, el atenuado/apagado de la pantalla y la l√≥gica de despertar.
 * Debe ser llamado una vez despu√©s de que la UI principal haya sido creada.
 */
void state_manager_init(void);

/**
 * @brief Pausa el gestor de estado, deteniendo los temporizadores de inactividad.
 */
void state_manager_pause(void);

/**
 * @brief Reanuda el gestor de estado, reactivando los temporizadores de inactividad.
 */
void state_manager_resume(void);

/**
 * @brief Destruye el gestor de estado y libera sus recursos.
 *
 * Elimina todos los temporizadores de LVGL creados por el gestor,
 * liberando memoria y deteniendo su l√≥gica por completo.
 */
void state_manager_destroy(void);


#ifdef __cplusplus
}
#endif

#endif // STATE_MANAGER_H

--- END OF FILE: .\components\ui\core\state_manager.h ---

--- START OF FILE: .\components\ui\core\ui.c ---
/* Fecha: 17/08/2025 - 02:29  */
/* Fichero: components/ui/core/ui.c */
/* √öltimo cambio: Movido desde la ra√≠z del componente 'ui' como parte de la refactorizaci√≥n. */
/* Descripci√≥n: Orquestador principal de la UI. Inicializa las pantallas y los sistemas subyacentes. Su movimiento al subdirectorio 'core' centraliza la l√≥gica fundamental de la interfaz. */

#include "ui.h"
#include "screens.h"
#include "ui_action_animations.h"
#include "esp_log.h"

extern lv_obj_t *g_main_screen_obj; 

static const char *TAG = "DIYMON_UI_MAIN";

// La funci√≥n 'ui_connect_actions' y su 'button_event_cb' han sido eliminados.
// La conexi√≥n de eventos ahora est√° encapsulada dentro de cada m√≥dulo de bot√≥n.

void ui_preinit(void) {
    ESP_LOGI(TAG, "Pre-inicializando UI: reservando buffer de animaci√≥n...");
    ui_action_animations_preinit_buffer();
}

void ui_init(void) {
    create_screens();
    
    if (g_main_screen_obj) {
        // La llamada a ui_connect_actions() ha sido eliminada.
        lv_obj_add_event_cb(g_main_screen_obj, (lv_event_cb_t)delete_screen_main, LV_EVENT_DELETE, NULL);
    }
    
    lv_screen_load(g_main_screen_obj);
    ESP_LOGI(TAG, "UI modularizada y lista.");
}

--- END OF FILE: .\components\ui\core\ui.c ---

--- START OF FILE: .\components\ui\core\ui.h ---
/* Fecha: 17/08/2025 - 02:29  */
/* Fichero: components/ui/core/ui.h */
/* √öltimo cambio: Movido a ui/core/ como parte de la refactorizaci√≥n del n√∫cleo de la UI. */
/* Descripci√≥n: Interfaz P√öBLICA del componente de la UI. Define las funciones de alto nivel para controlar la UI desde el exterior. Se ha movido a este subdirectorio para encapsular la l√≥gica principal. */

#ifndef UI_H
#define UI_H

#ifdef __cplusplus
extern "C" {
#endif

// --- DEFINICIONES COMPARTIDAS ---

// Enum para identificar las pantallas. Se mantiene aqu√≠ porque es parte de la
// interfaz p√∫blica para, potencialmente, cambiar de pantalla.
enum ScreensEnum {
    SCREEN_ID_MAIN = 1,
};


// --- FUNCIONES P√öBLICAS DE LA UI ---

/**
 * @brief Pre-inicializa la UI reservando los buffers de memoria m√°s grandes.
 *
 * Esta funci√≥n debe llamarse al principio de app_main para evitar la fragmentaci√≥n
 * de la memoria RAM, asegurando que la asignaci√≥n de memoria m√°s grande (el buffer
 * de animaci√≥n) tenga √©xito.
 */
void ui_preinit(void);

/**
 * @brief Inicializa y configura toda la interfaz de usuario.
 *
 * Esta es la funci√≥n principal que se debe llamar desde fuera del componente
 * (por ejemplo, desde main.c) para poner en marcha toda la UI.
 */
void ui_init(void);


#ifdef __cplusplus
}
#endif

#endif // UI_H

--- END OF FILE: .\components\ui\core\ui.h ---

--- START OF FILE: .\components\ui\screens\config.c ---
/* Fecha: 17/08/2025 - 10:16  */
/* Fichero: components/ui/screens/config.c */
/* √öltimo cambio: Actualizada la inclusi√≥n del asset de fondo para usar la cabecera centralizada 'ui_assets.h'. */
/* Descripci√≥n: Implementaci√≥n de la pantalla de configuraci√≥n. Se ha modificado para incluir 'assets/images/ui_assets.h', que ahora declara todos los assets de imagen del proyecto, incluyendo 'bg_config'. Esto completa la refactorizaci√≥n para centralizar los recursos gr√°ficos. */

#include "config.h"
#include "esp_log.h"
#include "esp_system.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "assets/images/ui_assets.h" // Actualizado para usar la cabecera central de assets

static const char *TAG = "UI_CONFIG_SCREEN";

/**
 * @brief Callback que se ejecuta al presionar el bot√≥n de reinicio.
 */
static void reset_button_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
        ESP_LOGW(TAG, "Bot√≥n de reinicio presionado. Reiniciando el dispositivo...");
        vTaskDelay(pdMS_TO_TICKS(500)); // Peque√±a pausa para que el log se env√≠e
        esp_restart();
    }
}

/**
 * @brief Crea y muestra la pantalla de configuraci√≥n est√°tica.
 */
void config_show(void) {
    // Crear una pantalla nueva y limpia
    lv_obj_t *scr = lv_obj_create(NULL);
    lv_obj_remove_style_all(scr); // Empezamos sin estilos por defecto
    lv_obj_set_size(scr, 170, 320);

    // Crear un objeto de imagen para el fondo de pantalla
    lv_obj_t *bg_img = lv_image_create(scr);
    lv_image_set_src(bg_img, &bg_config); // Usa el asset declarado en ui_assets.h
    lv_obj_set_pos(bg_img, 0, 0);
    lv_obj_add_flag(bg_img, LV_OBJ_FLAG_IGNORE_LAYOUT); // Asegura que no afecte a otros elementos

    // Bot√≥n de Reinicio
    lv_obj_t *btn_reset = lv_btn_create(scr);
    lv_obj_add_event_cb(btn_reset, reset_button_event_cb, LV_EVENT_CLICKED, NULL);
    lv_obj_align(btn_reset, LV_ALIGN_BOTTOM_MID, 0, -20); // Centrado abajo con padding

    lv_obj_t *lbl_btn = lv_label_create(btn_reset);
    lv_label_set_text(lbl_btn, "Reiniciar");
    lv_obj_center(lbl_btn);

    // Cargar la nueva pantalla
    lv_screen_load(scr);
    ESP_LOGI(TAG, "Pantalla de configuraci√≥n est√°tica con fondo mostrada.");
}

--- END OF FILE: .\components\ui\screens\config.c ---

--- START OF FILE: .\components\ui\screens\config.h ---
/* Fecha: 17/08/2025 - 03:32  */
/* Fichero: components/ui/screens/config.h */
/* √öltimo cambio: Renombrada la funci√≥n 'config_screen_show' a 'config_show' para estandarizar y eliminar redundancia. */
/* Descripci√≥n: Define la interfaz p√∫blica para la pantalla de configuraci√≥n. La estandarizaci√≥n de nombres (eliminando '_screen') mejora la legibilidad y sigue el principio DRY, ya que el contexto del directorio 'screens' es suficiente. */

#ifndef CONFIG_H
#define CONFIG_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea y muestra la pantalla de configuraci√≥n est√°tica con una imagen de fondo y un bot√≥n de reinicio.
 */
void config_show(void);

#ifdef __cplusplus
}
#endif

#endif // CONFIG_H

--- END OF FILE: .\components\ui\screens\config.h ---

--- START OF FILE: .\components\ui\screens\screen_interface.h ---
/* Fecha: 17/08/2025 - 03:35  */
/* Fichero: components/ui/screens/screen_interface.h */
/* √öltimo cambio: Creaci√≥n de la interfaz com√∫n para las pantallas para estandarizar su ciclo de vida. */
/* Descripci√≥n: Define una interfaz com√∫n (un 'contrato') para todas las pantallas de la aplicaci√≥n. Esto permite que un futuro gestor de navegaci√≥n trate a todas las pantallas de manera uniforme, llamando a sus funciones de ciclo de vida (crear, mostrar, etc.) sin conocer su implementaci√≥n espec√≠fica, reduciendo as√≠ el acoplamiento y mejorando la modularidad. */

#ifndef SCREEN_INTERFACE_H
#define SCREEN_INTERFACE_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Define una interfaz com√∫n para el ciclo de vida de una pantalla.
 *
 * Esta estructura de punteros a funci√≥n permite manejar diferentes pantallas
 * de forma polim√≥rfica.
 */
typedef struct {
    /**
     * @brief Crea los widgets de la pantalla sobre un objeto padre.
     * @param parent El objeto LVGL que actuar√° como contenedor.
     */
    void (*create)(lv_obj_t *parent);

    /**
     * @brief Hace visible la pantalla y sus elementos.
     */
    void (*show)(void);

    /**
     * @brief Oculta la pantalla y sus elementos.
     */
    void (*hide)(void);

    /**
     * @brief Destruye la pantalla y libera todos sus recursos.
     */
    void (*destroy)(void);
} screen_interface_t;

#ifdef __cplusplus
}
#endif

#endif // SCREEN_INTERFACE_H

--- END OF FILE: .\components\ui\screens\screen_interface.h ---

--- START OF FILE: .\components\ui\screens\screens.c ---
/* Fecha: 17/08/2025 - 10:19  */
/* Fichero: components/ui/screens/screens.c */
/* √öltimo cambio: Actualizada la inclusi√≥n de 'diymon_ui_helpers.h' a 'helpers.h' para reflejar el renombramiento del fichero. */
/* Descripci√≥n: Orquesta la creaci√≥n de la pantalla principal. Se ha actualizado la ruta de inclusi√≥n para apuntar a 'helpers.h', manteniendo la consistencia con la refactorizaci√≥n de nombres. */

#include "screens.h"
#include "ui_idle_animation.h"
#include "ui_actions_panel.h"
#include "ui_action_animations.h"
#include "telemetry/telemetry_manager.h"
#include "helpers.h" // Actualizado desde diymon_ui_helpers.h
#include "esp_log.h"
#include "bsp_api.h"
#include "screen_manager.h"
#include "ui_asset_loader.h"

static const char *TAG = "SCREENS";

static lv_timer_t *s_resume_idle_timer = NULL;

lv_obj_t *g_idle_animation_obj = NULL;
lv_obj_t *g_main_screen_obj = NULL;

static lv_coord_t touch_start_x = -1;
static lv_coord_t touch_start_y = -1;

static void main_screen_event_cb(lv_event_t *e);

static void resume_idle_timer_cb(lv_timer_t *timer) {
    ESP_LOGD(TAG, "Temporizador de reanudaci√≥n de idle disparado.");
    ui_idle_animation_resume();
    s_resume_idle_timer = NULL;
}

void create_screen_main(void) {
    g_main_screen_obj = lv_obj_create(NULL);
    lv_obj_set_size(g_main_screen_obj, 170, 320);
    lv_obj_add_flag(g_main_screen_obj, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_add_event_cb(g_main_screen_obj, main_screen_event_cb, LV_EVENT_ALL, NULL);
    
    lv_obj_set_scroll_dir(g_main_screen_obj, LV_DIR_ALL);
    lv_obj_set_scrollbar_mode(g_main_screen_obj, LV_SCROLLBAR_MODE_OFF);

    ui_helpers_load_background(g_main_screen_obj);

    ui_action_animations_create(g_main_screen_obj);
    g_idle_animation_obj = ui_idle_animation_start(g_main_screen_obj);
    ui_actions_panel_create(g_main_screen_obj);
    telemetry_manager_create(g_main_screen_obj);

    ESP_LOGI(TAG, "Pantalla principal creada delegando en m√≥dulos.");
}

static void main_screen_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    lv_indev_t *indev = lv_indev_get_act();

    switch(code) {
        case LV_EVENT_PRESSED: {
            if (s_resume_idle_timer) {
                lv_timer_del(s_resume_idle_timer);
                s_resume_idle_timer = NULL;
            }

            lv_point_t p;
            lv_indev_get_point(indev, &p);
            touch_start_x = p.x;
            touch_start_y = p.y;
            if (!screen_manager_is_off()) {
                ui_idle_animation_pause();
            }
            break;
        }
        case LV_EVENT_RELEASED: {
            touch_start_x = -1;
            touch_start_y = -1;
            
            if (!screen_manager_is_off() && s_resume_idle_timer == NULL) {
                s_resume_idle_timer = lv_timer_create(resume_idle_timer_cb, 500, NULL);
                lv_timer_set_repeat_count(s_resume_idle_timer, 1);
            }
            break;
        }
        case LV_EVENT_GESTURE: {
            if (!screen_manager_is_off()) { 
                lv_dir_t dir = lv_indev_get_gesture_dir(indev);
                ui_actions_panel_handle_gesture(dir, touch_start_x, touch_start_y);
            }
            break;
        }
        case LV_EVENT_CLICKED: {
            if (!screen_manager_is_off()) {
                ESP_LOGD(TAG, "Click en la pantalla, ocultando paneles.");
                ui_actions_panel_hide_all();
            }
            break;
        }
        default:
            break;
    }
}

void delete_screen_main(void) {
    if (g_main_screen_obj) {
        lv_obj_del(g_main_screen_obj);
        g_main_screen_obj = NULL;
        g_idle_animation_obj = NULL;
    }
    ui_idle_animation_stop();
    ui_action_animations_destroy();
    telemetry_manager_destroy();
    ui_assets_deinit();
}

void create_screens(void) {
    create_screen_main();
}

--- END OF FILE: .\components\ui\screens\screens.c ---

--- START OF FILE: .\components\ui\screens\screens.h ---
/* Fecha: 17/08/2025 - 02:49  */
/* Fichero: components/ui/screens/screens.h */
/* √öltimo cambio: Movido a 'screens/' y refactorizado como el gestor de pantallas. */
/* Descripci√≥n: Interfaz p√∫blica del m√≥dulo de pantallas. Orquesta la creaci√≥n y destrucci√≥n de las diferentes pantallas de la aplicaci√≥n, empezando por la principal. */

#ifndef SCREENS_H
#define SCREENS_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif

// --- DECLARACIONES DE OBJETOS GLOBALES ---
// Se expone para que otros m√≥dulos (core, telemetry, etc.) puedan a√±adir widgets.
extern lv_obj_t *g_main_screen_obj;


// --- DECLARACIONES DE FUNCIONES ---
/**
 * @brief Crea todas las pantallas de la aplicaci√≥n.
 *        Actualmente, solo invoca la creaci√≥n de la pantalla principal.
 */
void create_screens(void);

/**
 * @brief Destruye la pantalla principal y libera sus recursos.
 */
void delete_screen_main(void);


#ifdef __cplusplus
}
#endif

#endif // SCREENS_H

--- END OF FILE: .\components\ui\screens\screens.h ---

--- START OF FILE: .\components\ui\screens\welcome.c ---
/* Fecha: 17/08/2025 - 02:48  */
/* Fichero: components/ui/screens/welcome.c */
/* √öltimo cambio: Refactorizado y movido a 'screens/', renombrado de 'welcome_screen.c'. */
/* Descripci√≥n: Implementaci√≥n de la pantalla de bienvenida. Encapsula la l√≥gica de esta vista espec√≠fica como parte de la refactorizaci√≥n de la UI. */

#include "welcome.h"
#include "esp_log.h"

static const char *TAG = "WELCOME_SCREEN";

// Puntero est√°tico para almacenar el callback de inicio.
static void (*g_on_start_callback)(void) = NULL;

/**
 * @brief Callback del evento del bot√≥n "INICIAR".
 *        Llama a la funci√≥n de callback registrada si existe.
 */
static void start_button_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
        ESP_LOGI(TAG, "Bot√≥n 'INICIAR' presionado.");
        if (g_on_start_callback) {
            g_on_start_callback();
        }
    }
}

/**
 * @brief Implementaci√≥n de la creaci√≥n de la pantalla de bienvenida.
 */
void welcome_screen_show(void (*on_start_cb)(void)) {
    g_on_start_callback = on_start_cb;

    // Se crea un nuevo screen para asegurar que no hay elementos previos.
    lv_obj_t *scr = lv_obj_create(NULL);
    lv_obj_set_style_bg_color(scr, lv_color_hex(0x000000), LV_PART_MAIN);
    lv_obj_set_layout(scr, LV_LAYOUT_FLEX);
    lv_obj_set_flex_flow(scr, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(scr, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_set_style_pad_row(scr, 20, LV_PART_MAIN);

    const char *texts[] = {"SSID: DIYTogether", "PASS: MakeItYours", "192.168.4.1"};
    for (int i = 0; i < 3; i++) {
        lv_obj_t *label = lv_label_create(scr);
        lv_label_set_text(label, texts[i]);
        lv_obj_set_style_text_color(label, lv_color_hex(0xFFFFFF), LV_PART_MAIN);
    }

    lv_obj_t *btn = lv_btn_create(scr);
    lv_obj_add_event_cb(btn, start_button_event_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *label_btn = lv_label_create(btn);
    lv_label_set_text(label_btn, "INICIAR");
    lv_obj_center(label_btn);

    // Se carga la nueva pantalla para reemplazar la activa.
    lv_screen_load(scr);
    ESP_LOGI(TAG, "Pantalla de bienvenida mostrada.");
}

--- END OF FILE: .\components\ui\screens\welcome.c ---

--- START OF FILE: .\components\ui\screens\welcome.h ---
/* Fecha: 17/08/2025 - 02:47  */
/* Fichero: components/ui/screens/welcome.h */
/* √öltimo cambio: Refactorizado y movido a 'screens/', renombrado de 'welcome_screen.h'. */
/* Descripci√≥n: Define la interfaz p√∫blica para la pantalla de bienvenida. Encapsula la l√≥gica de esta vista espec√≠fica como parte de la refactorizaci√≥n de la UI. */

#ifndef WELCOME_H
#define WELCOME_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Muestra la pantalla de bienvenida.
 *
 * @param on_start_cb Puntero a una funci√≥n que se llamar√° cuando se pulse el bot√≥n "INICIAR".
 */
void welcome_screen_show(void (*on_start_cb)(void));

#ifdef __cplusplus
}
#endif

#endif // WELCOME_H

--- END OF FILE: .\components\ui\screens\welcome.h ---

--- START OF FILE: .\components\ui\telemetry\telemetry_manager.c ---
/* Fecha: 17/08/2025 - 09:42  */
/* Fichero: components/ui/telemetry/telemetry_manager.c */
/* √öltimo cambio: Movido a ui/telemetry/ como parte de la refactorizaci√≥n de telemetr√≠a. */
/* Descripci√≥n: Implementaci√≥n del m√≥dulo de telemetr√≠a de la UI. Es un receptor pasivo de datos que actualiza los labels cuando la funci√≥n 'telemetry_manager_update_values' es llamada por una tarea externa. */

#include "telemetry_manager.h"
#include "esp_log.h"
#include "diymon_evolution.h"
#include "esp_lvgl_port.h" // Necesario para el bloqueo thread-safe

static const char *TAG = "TELEMETRY_MANAGER";

/* Variables est√°ticas para los objetos de la UI */
static lv_obj_t *s_battery_label = NULL;
static lv_obj_t *s_evo_label = NULL;

/**
 * @brief Crea y configura los elementos de la UI para la telemetr√≠a.
 */
void telemetry_manager_create(lv_obj_t *parent) {
    if (!parent) {
        ESP_LOGE(TAG, "El objeto padre es nulo. No se puede crear la telemetr√≠a.");
        return;
    }

    // Contenedor para la telemetr√≠a en la esquina inferior derecha
    lv_obj_t * telemetry_cont = lv_obj_create(parent);
    lv_obj_remove_style_all(telemetry_cont);
    lv_obj_set_size(telemetry_cont, 120, 50);
    lv_obj_align(telemetry_cont, LV_ALIGN_BOTTOM_RIGHT, -5, -5);
    lv_obj_set_flex_flow(telemetry_cont, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(telemetry_cont, LV_FLEX_ALIGN_END, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);

    // Etiqueta para el nivel de bater√≠a
    s_battery_label = lv_label_create(telemetry_cont);
    lv_obj_set_style_text_color(s_battery_label, lv_color_white(), 0);
    lv_label_set_text(s_battery_label, "Bateria...");

    // Etiqueta para el c√≥digo de evoluci√≥n
    s_evo_label = lv_label_create(telemetry_cont);
    lv_obj_set_style_text_color(s_evo_label, lv_color_white(), 0);
    lv_label_set_text(s_evo_label, "EVO: ...");
    
    // Forzar una actualizaci√≥n inicial con valores por defecto
    telemetry_manager_update_values(100);
    ESP_LOGI(TAG, "M√≥dulo de telemetr√≠a creado.");
}

/**
 * @brief Destruye los recursos asociados al m√≥dulo de telemetr√≠a.
 */
void telemetry_manager_destroy(void) {
    // Ya no hay temporizador que borrar. LVGL se encarga de los objetos hijos.
    s_battery_label = NULL;
    s_evo_label = NULL;
    ESP_LOGI(TAG, "M√≥dulo de telemetr√≠a destruido.");
}

/**
 * @brief Actualiza los valores mostrados en los labels de telemetr√≠a.
 */
void telemetry_manager_update_values(uint8_t battery_percentage) {
    // Bloquear el mutex de LVGL ya que esta funci√≥n ser√° llamada desde otra tarea
    if (lvgl_port_lock(0)) {
        if (s_battery_label) {
            lv_label_set_text_fmt(s_battery_label, "%s %d%%", LV_SYMBOL_BATTERY_FULL, battery_percentage);
        }
        if (s_evo_label) {
            const char* evo_code = diymon_get_current_code();
            lv_label_set_text_fmt(s_evo_label, "EVO: %s", evo_code ? evo_code : "N/A");
        }
        lvgl_port_unlock();
    }
}

--- END OF FILE: .\components\ui\telemetry\telemetry_manager.c ---

--- START OF FILE: .\components\ui\telemetry\telemetry_manager.h ---
/* Fecha: 17/08/2025 - 09:41  */
/* Fichero: components/ui/telemetry/telemetry_manager.h */
/* √öltimo cambio: Movido a ui/telemetry/ como parte de la refactorizaci√≥n de telemetr√≠a. */
/* Descripci√≥n: Interfaz del m√≥dulo de telemetr√≠a de la UI. Expone funciones para crear, destruir y actualizar los elementos visuales de telemetr√≠a (bater√≠a, EVO). */

#ifndef TELEMETRY_MANAGER_H
#define TELEMETRY_MANAGER_H

#include <lvgl.h>
#include <stdint.h> // for uint8_t

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea y configura los elementos de la UI para la telemetr√≠a.
 * 
 * @param parent El objeto padre sobre el cual se crear√°n los labels.
 */
void telemetry_manager_create(lv_obj_t *parent);

/**
 * @brief Destruye los recursos asociados al m√≥dulo de telemetr√≠a.
 */
void telemetry_manager_destroy(void);

/**
 * @brief Actualiza los valores mostrados en los labels de telemetr√≠a.
 *        Esta funci√≥n es segura para ser llamada desde otras tareas (thread-safe).
 * 
 * @param battery_percentage El nivel de bater√≠a actual en porcentaje (0-100).
 */
void telemetry_manager_update_values(uint8_t battery_percentage);

#ifdef __cplusplus
}
#endif

#endif // TELEMETRY_MANAGER_H

--- END OF FILE: .\components\ui\telemetry\telemetry_manager.h ---

--- START OF FILE: .\components\ui\telemetry\telemetry_task.c ---
/* Fecha: 18/08/2025 - 07:37  */
/* Fichero: components/ui/telemetry/telemetry_task.c */
/* √öltimo cambio: Pausada la l√≥gica de la tarea cuando el WiFi est√° en modo AP para resolver el error de socket del servidor web. */
/* Descripci√≥n: Se ha a√±adido una comprobaci√≥n al inicio del bucle de la tarea para detectar si el dispositivo est√° en modo Punto de Acceso (AP). Si es as√≠, la tarea se detiene y espera, evitando leer sensores y actualizar la UI. Esto elimina la contenci√≥n de recursos con el servidor web, que es la causa ra√≠z de los errores de socket ('error in send : 11') durante la transferencia de ficheros. */

#include "telemetry_task.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "bsp_api.h"
#include "telemetry_manager.h"
#include <math.h> // Para fmax y fmin
#include "esp_wifi.h" // Necesario para comprobar el modo WiFi

static const char *TAG = "TELEMETRY_TASK";

// --- Constantes de configuraci√≥n de la tarea ---
#define TELEMETRY_TASK_STACK_SIZE   4096
#define TELEMETRY_TASK_PRIORITY     5
#define TELEMETRY_TASK_DELAY_MS     200
#define UI_UPDATE_INTERVAL_MS       5000 // Actualizar la UI cada 5 segundos

/**
 * @brief Tarea principal que se ejecuta en segundo plano.
 */
static void telemetry_task_main(void *pvParameters) {
    ESP_LOGI(TAG, "Tarea de telemetr√≠a iniciada.");

    uint32_t ui_update_counter = 0;
    const uint32_t ui_update_ticks = UI_UPDATE_INTERVAL_MS / TELEMETRY_TASK_DELAY_MS;

    while (1) {
        // [CORRECCI√ìN] Pausar la telemetr√≠a si el modo AP est√° activo para evitar conflictos con el servidor web.
        wifi_mode_t current_mode;
        if (esp_wifi_get_mode(&current_mode) == ESP_OK && current_mode == WIFI_MODE_AP) {
            vTaskDelay(pdMS_TO_TICKS(1000)); // Esperar un segundo y volver a comprobar.
            continue; // Saltar el resto del bucle.
        }

        vTaskDelay(pdMS_TO_TICKS(TELEMETRY_TASK_DELAY_MS));

        // --- Actualizaci√≥n de la UI (peri√≥dica) ---
        ui_update_counter++;
        if (ui_update_counter >= ui_update_ticks) {
            ui_update_counter = 0;
            
            // --- Lectura del Sensor de Bater√≠a ---
            float voltage;
            uint16_t adc_val;
            bsp_battery_get_voltage(&voltage, &adc_val);
            // L√≥gica simple para convertir voltaje a porcentaje (ajustar seg√∫n la curva de la bater√≠a)
            uint8_t battery_percentage = (uint8_t)fmax(0.0, fmin(100.0, (voltage - 3.2) / (4.2 - 3.2) * 100.0));

            // Empujar los nuevos valores a la UI para que los muestre
            telemetry_manager_update_values(battery_percentage);
        }
    }
}

/**
 * @brief Inicia la tarea de telemetr√≠a.
 */
void telemetry_task_start(void) {
    xTaskCreate(
        telemetry_task_main,
        "telemetry_task",
        TELEMETRY_TASK_STACK_SIZE,
        NULL,
        TELEMETRY_TASK_PRIORITY,
        NULL
    );
}

--- END OF FILE: .\components\ui\telemetry\telemetry_task.c ---

--- START OF FILE: .\components\ui\telemetry\telemetry_task.h ---
/* Fecha: 17/08/2025 - 09:42  */
/* Fichero: components/ui/telemetry/telemetry_task.h */
/* √öltimo cambio: Movido a ui/telemetry/ como parte de la refactorizaci√≥n de telemetr√≠a. */
/* Descripci√≥n: Interfaz p√∫blica para la tarea de telemetr√≠a. Esta tarea se ejecuta en segundo plano para leer peri√≥dicamente el estado de la bater√≠a y actualizar la UI. */

#ifndef TELEMETRY_TASK_H
#define TELEMETRY_TASK_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicia la tarea de telemetr√≠a en segundo plano.
 *
 * Crea y lanza una tarea de FreeRTOS que se encargar√° de leer peri√≥dicamente
 * el estado de la bater√≠a del dispositivo y de actualizar la UI con
 * esta informaci√≥n.
 */
void telemetry_task_start(void);

#ifdef __cplusplus
}
#endif

#endif // TELEMETRY_TASK_H

--- END OF FILE: .\components\ui\telemetry\telemetry_task.h ---

--- START OF FILE: .\components\ui\actions.c ---
/* Fecha: 18/08/2025 - 06:54  */
/* Fichero: components/ui/actions.c */
/* √öltimo cambio: Eliminado el case para ACTION_ID_ENABLE_FILE_SERVER para reflejar la unificaci√≥n de los modos de configuraci√≥n. */
/* Descripci√≥n: Orquestador de acciones refactorizado. Se ha eliminado el punto de entrada para el antiguo modo de servidor de ficheros. Ahora, toda la funcionalidad de configuraci√≥n se inicia a trav√©s de ACTION_ID_ACTIVATE_CONFIG_MODE, que activa una UI con un servidor web integrado. */

#include "actions.h"
#include "esp_log.h"

// --- Inclusi√≥n de todos los m√≥dulos de acci√≥n refactorizados ---
#include "actions/action_brightness.h"
#include "actions/action_config_mode.h"
#include "actions/action_evolution.h"
#include "actions/action_interaction.h"
#include "actions/action_screen.h"
#include "actions/action_system.h"

static const char *TAG = "DIYMON_ACTIONS";

void execute_diymon_action(diymon_action_id_t action_id) {
    ESP_LOGI(TAG, "Ejecutando acci√≥n ID: %d", action_id);

    if (action_id == ACTION_ID_ACTIVATE_CONFIG_MODE) {
        action_config_mode_start();
        return;
    }
    
    switch(action_id) {
        // --- Acciones de Interacci√≥n ---
        case ACTION_ID_COMER:
            action_interaction_eat();
            break;
        case ACTION_ID_EJERCICIO:
            action_interaction_gym();
            break;
        case ACTION_ID_ATACAR:
            action_interaction_attack();
            break;

        // --- Acciones de UI/Sistema ---
        case ACTION_ID_BRIGHTNESS_CYCLE:
            action_brightness_cycle();
            break;
        case ACTION_ID_TOGGLE_SCREEN:
            action_screen_toggle();
            break;

        // --- Acciones de Sistema (Reset) ---
        case ACTION_ID_RESET_ALL:
            action_system_reset_all();
            break;

        // --- Acciones de Evoluci√≥n ---
        case ACTION_ID_EVO_FIRE:
            action_evolution_branch(1); // 1 = Fuego
            break;
        case ACTION_ID_EVO_WATER:
            action_evolution_branch(2); // 2 = Agua
            break;
        case ACTION_ID_EVO_EARTH:
            action_evolution_branch(3); // 3 = Tierra
            break;
        case ACTION_ID_EVO_WIND:
            action_evolution_branch(4); // 4 = Viento
            break;
        case ACTION_ID_EVO_BACK:
            action_evolution_devolve();
            break;
        
        // --- Acciones Placeholder (no hacen nada) ---
        case ACTION_ID_ADMIN_PLACEHOLDER:
        case ACTION_ID_CONFIG_PLACEHOLDER:
            ESP_LOGI(TAG, "Acci√≥n Placeholder (ID %d) ejecutada. No se realiza ninguna operaci√≥n.", action_id);
            break;

        default:
            ESP_LOGW(TAG, "Acci√≥n con ID %d desconocida.", action_id);
            break;
    }
}

--- END OF FILE: .\components\ui\actions.c ---

--- START OF FILE: .\components\ui\actions.h ---
/* Fecha: 18/08/2025 - 06:53  */
/* Fichero: components/ui/actions.h */
/* √öltimo cambio: Eliminada la acci√≥n ACTION_ID_ENABLE_FILE_SERVER para unificar la configuraci√≥n en un √∫nico modo. */
/* Descripci√≥n: Define la interfaz para el sistema de acciones, incluyendo los IDs de acci√≥n y la funci√≥n principal de ejecuci√≥n. Es el punto central para entender qu√© interacciones de usuario son posibles. */

#ifndef ACTIONS_H
#define ACTIONS_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif

// --- El Modelo de Datos para las Acciones ---
typedef enum {
    // Acciones del panel de jugador (superior 1)
    ACTION_ID_COMER,          // 0
    ACTION_ID_EJERCICIO,      // 1
    ACTION_ID_ATACAR,         // 2

    // Acciones del panel de administraci√≥n (superior 2)
    ACTION_ID_BRIGHTNESS_CYCLE,       // 3
    ACTION_ID_TOGGLE_SCREEN,          // 4
    ACTION_ID_ADMIN_PLACEHOLDER,      // 5

    // Acciones del panel de evoluci√≥n (lateral)
    ACTION_ID_EVO_FIRE,       // 6
    ACTION_ID_EVO_WATER,      // 7
    ACTION_ID_EVO_EARTH,      // 8
    ACTION_ID_EVO_WIND,       // 9
    ACTION_ID_EVO_BACK,       // 10
    
    // Acciones del panel de configuraci√≥n (superior 3)
    ACTION_ID_ACTIVATE_CONFIG_MODE,   // 11
    ACTION_ID_RESET_ALL,              // 12
    ACTION_ID_CONFIG_PLACEHOLDER,     // 13

    ACTION_ID_COUNT 
} diymon_action_id_t;


// --- El Orquestador de Acciones ---
void execute_diymon_action(diymon_action_id_t action_id);

#ifdef __cplusplus
}
#endif

#endif // ACTIONS_H

--- END OF FILE: .\components\ui\actions.h ---

--- START OF FILE: .\components\ui\animation_loader.c ---
/* Fecha: 18/08/2025 - 08:59  */
/* Fichero: components/ui/animation_loader.c */
/* √öltimo cambio: Restaurado el formato de color a RGB565A8 y el tama√±o del buffer a 3 bytes por p√≠xel para corregir la p√©rdida de transparencias. */
/* Descripci√≥n: Se ha revertido un cambio incorrecto que establec√≠a el formato de color en RGB565 (2 bytes/p√≠xel). El formato correcto para los assets de animaci√≥n es RGB565A8 (3 bytes/p√≠xel), que incluye un canal alfa de 8 bits. Esta correcci√≥n restaura la transparencia de las animaciones y asegura que el buffer de animaci√≥n se reserve con el tama√±o adecuado. */

#include "animation_loader.h"
#include "esp_log.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static const char *TAG = "ANIM_LOADER";
#define LVGL_BIN_HEADER_SIZE 12

animation_t animation_loader_init(const char *path, uint16_t width, uint16_t height, uint16_t num_frames) {
    animation_t anim = { 0 };
    anim.base_path = path ? strdup(path) : NULL;
    anim.frame_count = num_frames;
    anim.width = width;
    anim.height = height;
    
    uint32_t rgb_stride = width * 2; 
    // [CORRECCI√ìN] Restaurado a 3 bytes por p√≠xel para soportar el canal alfa (A8).
    size_t buffer_size = (size_t)width * height * 3;

    anim.img_dsc.data = (uint8_t *)malloc(buffer_size);
    if (!anim.img_dsc.data) { 
        ESP_LOGE(TAG, "Fallo al reservar buffer de animaci√≥n de tama√±o %u!", (unsigned int)buffer_size);
        animation_loader_free(&anim); 
        return anim; 
    }
    
    anim.img_dsc.header.w = width;
    anim.img_dsc.header.h = height;
    anim.img_dsc.header.stride = rgb_stride;
    // [CORRECCI√ìN] Restaurado el formato de color que incluye el canal alfa.
    anim.img_dsc.header.cf = LV_COLOR_FORMAT_RGB565A8;
    anim.img_dsc.data_size = buffer_size;
    
    ESP_LOGD(TAG, "Gestor de animaci√≥n inicializado. Buffer de %u bytes.", (unsigned int)buffer_size);
    return anim;
}

bool animation_loader_load_frame(animation_t *anim, uint16_t frame_index, const char *prefix) {
    if (!anim || !anim->base_path || !anim->img_dsc.data) return false;
    char full_path[128];
    snprintf(full_path, sizeof(full_path), "%s/%s%d.bin", anim->base_path, prefix, frame_index + 1);

    lv_fs_file_t f;
    lv_fs_res_t res = lv_fs_open(&f, full_path, LV_FS_MODE_RD);
    if (res != LV_FS_RES_OK) {
        ESP_LOGW(TAG, "Fallo al abrir frame (LVGL): %s", full_path);
        return false;
    }
    
    lv_fs_seek(&f, LVGL_BIN_HEADER_SIZE, LV_FS_SEEK_SET);
    uint32_t bytes_read = 0;
    lv_fs_read(&f, (void *)anim->img_dsc.data, anim->img_dsc.data_size, &bytes_read);
    lv_fs_close(&f);

    return true;
}

void animation_loader_free(animation_t *anim) {
    if (!anim) return;
    if(anim->base_path) {
        free(anim->base_path);
        anim->base_path = NULL;
    }
    if (anim->img_dsc.data) {
        free((void*)anim->img_dsc.data);
        anim->img_dsc.data = NULL;
    }
    anim->frame_count = 0;
}

uint16_t animation_loader_count_frames(const char *path, const char *prefix) {
    if (!path || !prefix) {
        return 0;
    }

    uint16_t count = 0;
    ESP_LOGD(TAG, "Abriendo directorio de animaci√≥n (LVGL): '%s' para contar frames con prefijo '%s'", path, prefix);
    
    lv_fs_dir_t d;
    lv_fs_res_t res = lv_fs_dir_open(&d, path);

    if(res != LV_FS_RES_OK) {
        ESP_LOGE(TAG, "No se pudo abrir el directorio (LVGL): %s. C√≥digo de error: %d", path, res);
        return 0;
    }

    char fn[256];
    size_t prefix_len = strlen(prefix);

    while(lv_fs_dir_read(&d, fn, sizeof(fn)) == LV_FS_RES_OK && fn[0] != '\0') {
        // Compara si el nombre del fichero empieza con el prefijo deseado.
        if (strncmp(fn, prefix, prefix_len) == 0) {
            count++;
        }
    }

    lv_fs_dir_close(&d);
    ESP_LOGD(TAG, "Cierre de directorio. Total de fotogramas con prefijo '%s': %d", prefix, count);
    return count;
}

--- END OF FILE: .\components\ui\animation_loader.c ---

--- START OF FILE: .\components\ui\animation_loader.h ---
/*
 * Fichero: ./components/diymon_ui/animation_loader.h
 * Fecha: 11/08/2025 - 12:00
 * √öltimo cambio: Sin cambios en esta iteraci√≥n.
 * Descripci√≥n: Define la interfaz para el cargador de animaciones. Se a√±ade una
 *              funci√≥n que permite contar el n√∫mero de fotogramas de una animaci√≥n
 *              en un directorio espec√≠fico, basado en un prefijo de fichero.
 */
#ifndef ANIMATION_LOADER_H
#define ANIMATION_LOADER_H

#include "lvgl.h"

typedef struct {
    char *base_path;
    uint16_t frame_count;
    uint16_t width;
    uint16_t height;
    lv_img_dsc_t img_dsc;
} animation_t;

animation_t animation_loader_init(const char *path, uint16_t width, uint16_t height, uint16_t num_frames);
bool animation_loader_load_frame(animation_t *anim, uint16_t frame_index, const char *prefix);
void animation_loader_free(animation_t *anim);
uint16_t animation_loader_count_frames(const char *path, const char *prefix);

#endif // ANIMATION_LOADER_H
--- END OF FILE: .\components\ui\animation_loader.h ---

--- START OF FILE: .\components\ui\CMakeLists.txt ---
# Fecha: 18/08/2025 - 06:55 
# Fichero: components/ui/CMakeLists.txt
# √öltimo cambio: Eliminada la dependencia 'wifi_portal' al centralizar la configuraci√≥n.
# Descripci√≥n: Se ha eliminado 'wifi_portal' de la lista de dependencias. La funcionalidad de portal cautivo ya no se utiliza, ya que el √∫nico modo de configuraci√≥n es el servidor web accesible desde la UI, que es manejado por los componentes 'bsp' (para el AP) y 'web_server'.

file(GLOB component_sources
    "*.c" 
    "core/*.c"
    "screens/*.c"
    "actions/*.c"
    "assets/styles/*.c"
    "buttons/*.c"
    "telemetry/*.c"
)

# Buscar y a√±adir autom√°ticamente TODOS los ficheros .c del directorio de im√°genes.
file(GLOB asset_sources "assets/images/*.c")
list(APPEND component_sources ${asset_sources})

idf_component_register(
    SRCS ${component_sources}
    INCLUDE_DIRS
        "."
        "buttons"
        "actions"
        "core"
        "screens"
        "assets/styles"
        "assets/fonts"
        "assets/images"
        "telemetry"
    PRIV_INCLUDE_DIRS "."
    REQUIRES
        lvgl
        bsp
        core
        screen_manager
        web_server
)

--- END OF FILE: .\components\ui\CMakeLists.txt ---

--- START OF FILE: .\components\ui\fonts.h ---
#ifndef EEZ_LVGL_UI_FONTS_H
#define EEZ_LVGL_UI_FONTS_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#endif /*EEZ_LVGL_UI_FONTS_H*/
--- END OF FILE: .\components\ui\fonts.h ---

--- START OF FILE: .\components\ui\helpers.c ---
/* Fecha: 17/08/2025 - 10:18  */
/* Fichero: components/ui/helpers.c */
/* √öltimo cambio: Renombrado de 'diymon_ui_helpers.c' y actualizada la inclusi√≥n de la cabecera. */
/* Descripci√≥n: Implementaci√≥n de las funciones de ayuda de la UI. Se ha renombrado el fichero y se ha actualizado la directiva #include para que apunte a 'helpers.h', completando la estandarizaci√≥n de nombres. */

#include "helpers.h"
#include "diymon_evolution.h"
#include "esp_log.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "assets/images/ui_assets.h"

static const char* TAG_HELPERS = "UI_HELPERS";

// Funci√≥n interna para obtener el nombre del directorio de evoluci√≥n (ej: "1.1.1" -> "111")
static void get_evolution_dir_name(char* dir_name_buffer, size_t buffer_size) {
    const char* evo_code = diymon_get_current_code();
    memset(dir_name_buffer, 0, buffer_size);
    int j = 0;
    for (int i = 0; evo_code[i] != '\0' && j < buffer_size - 1; i++) {
        if (evo_code[i] != '.') {
            dir_name_buffer[j++] = evo_code[i];
        }
    }
}

// Construye la ruta a un asset de animaci√≥n en la SD.
void ui_helpers_build_asset_path(char* buffer, size_t buffer_size, const char* asset_filename) {
    char dir_name[9];
    get_evolution_dir_name(dir_name, sizeof(dir_name));
    snprintf(buffer, buffer_size, "S:/diymon/%s/%s/", dir_name, asset_filename);
}

// Carga la imagen de fondo desde el firmware creando un objeto de imagen.
void ui_helpers_load_background(lv_obj_t* parent) {
    ESP_LOGI(TAG_HELPERS, "Creando objeto de imagen para el fondo desde firmware.");
    lv_obj_t *bg_img = lv_image_create(parent);
    lv_image_set_src(bg_img, &bg_0); // Usa el asset declarado en ui_assets.h
    lv_obj_set_pos(bg_img, 0, 0); 
    lv_obj_move_background(bg_img); 
}

// La funci√≥n para liberar el buffer de fondo ya no es necesaria.
void ui_helpers_free_background_buffer(void) {
    ESP_LOGD(TAG_HELPERS, "ui_helpers_free_background_buffer ya no es necesaria y ha sido ignorada.");
}

// Implementaciones placeholder para que compile
void ui_helpers_create_diymon_gif(lv_obj_t* parent) {}
void ui_helpers_free_gif_buffer(void) {}

--- END OF FILE: .\components\ui\helpers.c ---

--- START OF FILE: .\components\ui\helpers.h ---
/* Fecha: 17/08/2025 - 10:18  */
/* Fichero: components/ui/helpers.h */
/* √öltimo cambio: Renombrado de 'diymon_ui_helpers.h' para simplificar y estandarizar. */
/* Descripci√≥n: Funciones de ayuda para la interfaz de usuario. Proporciona utilidades para construir rutas de assets y cargar elementos visuales como el fondo de pantalla. */
#ifndef HELPERS_H
#define HELPERS_H

#include "lvgl.h"

void ui_helpers_build_asset_path(char* buffer, size_t buffer_size, const char* asset_filename);
void ui_helpers_load_background(lv_obj_t* parent);
void ui_helpers_free_background_buffer(void);
void ui_helpers_create_diymon_gif(lv_obj_t* parent);
void ui_helpers_free_gif_buffer(void);

#endif // HELPERS_H

--- END OF FILE: .\components\ui\helpers.h ---

--- START OF FILE: .\components\ui\styles.c ---
/*
 * Fichero: ./components/diymon_ui/styles.c
 * Fecha: 13/08/2025 - 11:39 
 * √öltimo cambio: Limpieza de comentarios.
 * Descripci√≥n: Fichero para la inicializaci√≥n de estilos de LVGL.
 */
#include "styles.h"
#include "lvgl.h"

void init_styles(void) {
    // Inicializa aqu√≠ los estilos que necesites
}

--- END OF FILE: .\components\ui\styles.c ---

--- START OF FILE: .\components\ui\styles.h ---
#ifndef EEZ_LVGL_UI_STYLES_H
#define EEZ_LVGL_UI_STYLES_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#endif /*EEZ_LVGL_UI_STYLES_H*/
--- END OF FILE: .\components\ui\styles.h ---

--- START OF FILE: .\components\ui\ui_action_animations.c ---
/* Fecha: 17/08/2025 - 10:25  */
/* Fichero: components/ui/ui_action_animations.c */
/* √öltimo cambio: Actualizada la inclusi√≥n de 'diymon_ui_helpers.h' a 'helpers.h' para corregir el error de compilaci√≥n. */
/* Descripci√≥n: Se ha corregido la directiva de inclusi√≥n para que apunte al fichero de cabecera renombrado 'helpers.h'. Esto resuelve el error 'No such file or directory' que imped√≠a la compilaci√≥n. */

#include "ui_action_animations.h"
#include "animation_loader.h"
#include "helpers.h" // Corregido desde diymon_ui_helpers.h
#include "ui_idle_animation.h"
#include "esp_log.h"
#include <stdio.h>
#include <string.h>

static const char *TAG = "UI_ACTION_ANIM";

// --- Variables Globales y Est√°ticas ---
lv_obj_t *g_animation_img_obj = NULL;
static animation_t g_animation_player; // Player global que contiene el b√∫fer compartido

static lv_timer_t *s_anim_timer;
static bool s_is_action_in_progress = false;
static int s_current_frame_index;

#define FRAME_INTERVAL_MS 500

// --- Declaraciones de Funciones Internas ---
static void animation_timer_cb(lv_timer_t *timer);
static void animation_finished(void);
static const char* get_anim_prefix(diymon_action_id_t action_id);

// --- Implementaci√≥n de Funciones P√∫blicas ---

void ui_action_animations_preinit_buffer(void) {
    // Reservar el b√∫fer de animaci√≥n compartido UNA SOLA VEZ.
    g_animation_player = animation_loader_init(NULL, 150, 230, 0);
    if (g_animation_player.img_dsc.data == NULL) {
        ESP_LOGE(TAG, "FALLO CR√çTICO: No se pudo reservar memoria para el b√∫fer de animaci√≥n compartido.");
    } else {
        ESP_LOGI(TAG, "B√∫fer de animaci√≥n compartido (150x230) pre-reservado correctamente.");
    }
}

void ui_action_animations_create(lv_obj_t *parent) {
    if (g_animation_player.img_dsc.data == NULL) {
        ESP_LOGE(TAG, "El b√∫fer de animaci√≥n compartido no fue pre-reservado. No se puede crear el objeto de animaci√≥n.");
        return;
    }
    
    g_animation_img_obj = lv_image_create(parent);
    lv_image_set_src(g_animation_img_obj, &g_animation_player.img_dsc);
    
    lv_obj_set_style_bg_opa(g_animation_img_obj, LV_OPA_TRANSP, 0);
    lv_obj_align(g_animation_img_obj, LV_ALIGN_BOTTOM_MID, 0, -30);
}

void ui_action_animations_play(diymon_action_id_t action_id) {
    if (s_is_action_in_progress || action_id >= ACTION_ID_COUNT) return;
    if (g_animation_player.img_dsc.data == NULL) {
        ESP_LOGE(TAG, "No se puede iniciar la animaci√≥n: el b√∫fer compartido no est√° disponible.");
        return;
    }

    s_is_action_in_progress = true;
    
    ui_idle_animation_pause();

    const char *prefix = get_anim_prefix(action_id);
    char path_buffer[128];
    ui_helpers_build_asset_path(path_buffer, sizeof(path_buffer), "");
    size_t len = strlen(path_buffer);
    if (len > 0 && path_buffer[len - 1] == '/') path_buffer[len - 1] = '\0';
    
    uint16_t frame_count = animation_loader_count_frames(path_buffer, prefix);
    if (frame_count == 0) {
        ESP_LOGE(TAG, "No se encontraron fotogramas para la animaci√≥n '%s' en '%s'.", prefix, path_buffer);
        animation_finished(); 
        return;
    }
    
    ESP_LOGI(TAG, "Reproduciendo animaci√≥n '%s' (%d fotogramas) a %dms/frame.", prefix, frame_count, FRAME_INTERVAL_MS);

    if (g_animation_player.base_path) free(g_animation_player.base_path);
    g_animation_player.base_path = strdup(path_buffer);
    g_animation_player.frame_count = frame_count;

    s_current_frame_index = 0;
    if (animation_loader_load_frame(&g_animation_player, s_current_frame_index, prefix)) {
        lv_obj_invalidate(g_animation_img_obj);
        s_anim_timer = lv_timer_create(animation_timer_cb, FRAME_INTERVAL_MS, (void*)(intptr_t)action_id);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el primer fotograma (%s).", prefix);
        animation_finished();
    }
}

void ui_action_animations_destroy(void) {
    ESP_LOGI(TAG, "Liberando b√∫fer de animaci√≥n compartido.");
    animation_loader_free(&g_animation_player);
}

animation_t* ui_action_animations_get_player(void) {
    return &g_animation_player;
}

static void animation_timer_cb(lv_timer_t *timer) {
    s_current_frame_index++;
    if (s_current_frame_index >= g_animation_player.frame_count) {
        animation_finished();
        return;
    }

    diymon_action_id_t action_id = (diymon_action_id_t)(intptr_t)timer->user_data;
    const char *prefix = get_anim_prefix(action_id);

    if (animation_loader_load_frame(&g_animation_player, s_current_frame_index, prefix)) {
        lv_obj_invalidate(g_animation_img_obj);
    } else {
        ESP_LOGW(TAG, "No se pudo cargar el fotograma %d para %s. Finalizando animaci√≥n.", s_current_frame_index + 1, prefix);
        animation_finished();
    }
}

static void animation_finished(void) {
    if (s_anim_timer) {
        lv_timer_del(s_anim_timer);
        s_anim_timer = NULL;
    }
    
    if (g_animation_player.base_path) {
        free(g_animation_player.base_path);
        g_animation_player.base_path = NULL;
    }
    g_animation_player.frame_count = 0;
    
    ui_idle_animation_resume();
    
    s_is_action_in_progress = false;
    ESP_LOGI(TAG, "Animaci√≥n de acci√≥n finalizada. Control devuelto a idle.");
}

static const char* get_anim_prefix(diymon_action_id_t action_id) {
    switch(action_id) {
        case ACTION_ID_COMER:     return "ANIM_EAT_";
        case ACTION_ID_EJERCICIO: return "ANIM_GYM_";
        case ACTION_ID_ATACAR:    return "ANIM_ATK_";
        default:                  return "";
    }
}

--- END OF FILE: .\components\ui\ui_action_animations.c ---

--- START OF FILE: .\components\ui\ui_action_animations.h ---
/*
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_action_animations.h
# Fecha: $timestamp
# √öltimo cambio: A√±adida la declaraci√≥n de la funci√≥n de pre-reserva de buffer.
# Descripci√≥n: Interfaz p√∫blica para el m√≥dulo de animaciones de acci√≥n. Se a√±ade la declaraci√≥n de `ui_action_animations_preinit_buffer` para que la funci√≥n sea visible para otros m√≥dulos y se resuelva as√≠ el error de compilaci√≥n por declaraci√≥n impl√≠cita.
*/
#ifndef UI_ACTION_ANIMATIONS_H
#define UI_ACTION_ANIMATIONS_H

#include <lvgl.h>
#include "actions.h"
#include "animation_loader.h"

#ifdef __cplusplus
extern "C" {
#endif

// --- OBJETO GLOBAL COMPARTIDO ---
extern lv_obj_t *g_animation_img_obj;

// --- FUNCIONES P√öBLICAS ---
void ui_action_animations_preinit_buffer(void);
void ui_action_animations_create(lv_obj_t *parent);
void ui_action_animations_play(diymon_action_id_t action_id);
void ui_action_animations_destroy(void);
animation_t* ui_action_animations_get_player(void);

#ifdef __cplusplus
}
#endif

#endif // UI_ACTION_ANIMATIONS_H

--- END OF FILE: .\components\ui\ui_action_animations.h ---

--- START OF FILE: .\components\ui\ui_actions_panel.c ---
/* Fecha: 17/08/2025 - 05:12  */
/* Fichero: components/ui/ui_actions_panel.c */
/* √öltimo cambio: Eliminada la bandera LV_OBJ_FLAG_CLICKABLE de los paneles contenedores para solucionar el problema de eventos no recibidos. */
/* Descripci√≥n: Se ha corregido el error por el cual los botones no respond√≠an a los clics. Los paneles contenedores, aunque transparentes, interceptaban los eventos de toque por defecto. Al hacerlos no-clicables con 'lv_obj_remove_flag', los eventos ahora se propagan correctamente a los botones hijos, que es el comportamiento esperado. Se han a√±adido logs para confirmar la creaci√≥n y configuraci√≥n de cada panel. */

#include "ui_actions_panel.h"
#include "ui_idle_animation.h"
#include "esp_log.h"
#include <stdio.h>

// --- Inclusi√≥n directa de los m√≥dulos de botones ---
#include "buttons/btn_1.h"
#include "buttons/btn_2.h"
#include "buttons/btn_3.h"
#include "buttons/btn_4.h"
#include "buttons/btn_5.h"
#include "buttons/btn_6.h"
#include "buttons/btn_7.h"
#include "buttons/btn_8.h"
#include "buttons/btn_9.h"
#include "buttons/evo_1.h"
#include "buttons/evo_2.h"
#include "buttons/evo_3.h"
#include "buttons/evo_4.h"
#include "buttons/evo_5.h"

static const char *TAG = "UI_PANELS";

// --- Constantes de configuraci√≥n ---
#define PANEL_AUTO_HIDE_DELAY 10000 
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
#define ANIM_TIME_MS 300
#define EDGE_SWIPE_THRESHOLD 50
#define TOP_PANEL_WIDTH (BUTTON_SIZE * 3 + BUTTON_PADDING * 2)
#define TOP_PANEL_HEIGHT (BUTTON_SIZE)
#define SIDE_PANEL_WIDTH (BUTTON_SIZE)
#define SIDE_PANEL_HEIGHT (BUTTON_SIZE * 5 + BUTTON_PADDING * 4)


typedef enum {
    PANEL_STATE_HIDDEN,
    PANEL_STATE_PLAYER_VISIBLE,
    PANEL_STATE_ADMIN_VISIBLE,
    PANEL_STATE_CONFIG_VISIBLE,
    PANEL_STATE_SIDE_VISIBLE,
} panel_state_t;

// --- Variables est√°ticas del m√≥dulo ---
static lv_obj_t *s_panel_player;
static lv_obj_t *s_panel_admin;
static lv_obj_t *s_panel_config;
static lv_obj_t *s_panel_evo;

static lv_timer_t *s_hide_timer = NULL;
static panel_state_t s_panel_state = PANEL_STATE_HIDDEN;
static bool s_is_animating = false;

// --- Declaraciones de funciones internas ---
static void animate_panel_in_top(lv_obj_t *panel);
static void animate_panel_out_top(lv_obj_t *panel);
static void animate_panel_in_side(lv_obj_t *panel);
static void animate_panel_out_side(lv_obj_t *panel);
static void timer_auto_hide_callback(lv_timer_t *timer);
static void animation_finish_cb(lv_anim_t *a);

// --- Implementaci√≥n de Funciones P√∫blicas ---

void ui_actions_panel_create(lv_obj_t *parent) {
    // --- Crear Contenedor Panel Player ---
    s_panel_player = lv_obj_create(parent);
    lv_obj_remove_style_all(s_panel_player);
    lv_obj_set_size(s_panel_player, TOP_PANEL_WIDTH, TOP_PANEL_HEIGHT);
    lv_obj_align(s_panel_player, LV_ALIGN_TOP_MID, 0, -TOP_PANEL_HEIGHT);
    lv_obj_add_flag(s_panel_player, LV_OBJ_FLAG_HIDDEN);
    lv_obj_remove_flag(s_panel_player, LV_OBJ_FLAG_CLICKABLE); // [CORRECCI√ìN CLAVE]
    btn_1_create(s_panel_player);
    btn_2_create(s_panel_player);
    btn_3_create(s_panel_player);
    ESP_LOGI(TAG, "Panel 'Player' creado y configurado para no interceptar clics.");

    // --- Crear Contenedor Panel Admin ---
    s_panel_admin = lv_obj_create(parent);
    lv_obj_remove_style_all(s_panel_admin);
    lv_obj_set_size(s_panel_admin, TOP_PANEL_WIDTH, TOP_PANEL_HEIGHT);
    lv_obj_align(s_panel_admin, LV_ALIGN_TOP_MID, 0, -TOP_PANEL_HEIGHT);
    lv_obj_add_flag(s_panel_admin, LV_OBJ_FLAG_HIDDEN);
    lv_obj_remove_flag(s_panel_admin, LV_OBJ_FLAG_CLICKABLE); // [CORRECCI√ìN CLAVE]
    btn_4_create(s_panel_admin);
    btn_5_create(s_panel_admin);
    btn_6_create(s_panel_admin);
    ESP_LOGI(TAG, "Panel 'Admin' creado y configurado para no interceptar clics.");


    // --- Crear Contenedor Panel Config ---
    s_panel_config = lv_obj_create(parent);
    lv_obj_remove_style_all(s_panel_config);
    lv_obj_set_size(s_panel_config, TOP_PANEL_WIDTH, TOP_PANEL_HEIGHT);
    lv_obj_align(s_panel_config, LV_ALIGN_TOP_MID, 0, -TOP_PANEL_HEIGHT);
    lv_obj_add_flag(s_panel_config, LV_OBJ_FLAG_HIDDEN);
    lv_obj_remove_flag(s_panel_config, LV_OBJ_FLAG_CLICKABLE); // [CORRECCI√ìN CLAVE]
    btn_7_create(s_panel_config);
    btn_8_create(s_panel_config);
    btn_9_create(s_panel_config);
    ESP_LOGI(TAG, "Panel 'Config' creado y configurado para no interceptar clics.");


    // --- Crear Contenedor Panel Evoluci√≥n ---
    s_panel_evo = lv_obj_create(parent);
    lv_obj_remove_style_all(s_panel_evo);
    lv_obj_set_size(s_panel_evo, SIDE_PANEL_WIDTH, SIDE_PANEL_HEIGHT);
    lv_obj_align(s_panel_evo, LV_ALIGN_LEFT_MID, -SIDE_PANEL_WIDTH, 0);
    lv_obj_add_flag(s_panel_evo, LV_OBJ_FLAG_HIDDEN);
    lv_obj_remove_flag(s_panel_evo, LV_OBJ_FLAG_CLICKABLE); // [CORRECCI√ìN CLAVE]
    evo_1_create(s_panel_evo);
    evo_2_create(s_panel_evo);
    evo_3_create(s_panel_evo);
    evo_4_create(s_panel_evo);
    evo_5_create(s_panel_evo);
    ESP_LOGI(TAG, "Panel 'Evo' creado y configurado para no interceptar clics.");

}

static void animation_finish_cb(lv_anim_t *a) { 
    s_is_animating = false; 
    if(lv_obj_get_y((lv_obj_t *)a->var) < 0 || lv_obj_get_x((lv_obj_t *)a->var) < 0) {
        lv_obj_add_flag((lv_obj_t *)a->var, LV_OBJ_FLAG_HIDDEN);
    }
}

static void animate_panel_in_top(lv_obj_t *panel) {
    if (s_hide_timer) lv_timer_del(s_hide_timer);
    s_is_animating = true;
    lv_obj_clear_flag(panel, LV_OBJ_FLAG_HIDDEN);

    lv_anim_t a;
    lv_anim_init(&a);
    lv_anim_set_var(&a, panel);
    lv_anim_set_values(&a, lv_obj_get_y(panel), BUTTON_PADDING);
    lv_anim_set_time(&a, ANIM_TIME_MS);
    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_y);
    lv_anim_set_path_cb(&a, lv_anim_path_ease_out);
    lv_anim_set_ready_cb(&a, animation_finish_cb);
    lv_anim_start(&a);

    s_hide_timer = lv_timer_create(timer_auto_hide_callback, PANEL_AUTO_HIDE_DELAY, NULL);
    lv_timer_set_repeat_count(s_hide_timer, 1);
}

static void animate_panel_out_top(lv_obj_t *panel) {
    if (s_hide_timer) { lv_timer_del(s_hide_timer); s_hide_timer = NULL; }
    s_is_animating = true;

    lv_anim_t a;
    lv_anim_init(&a);
    lv_anim_set_var(&a, panel);
    lv_anim_set_values(&a, lv_obj_get_y(panel), -TOP_PANEL_HEIGHT);
    lv_anim_set_time(&a, ANIM_TIME_MS);
    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_y);
    lv_anim_set_path_cb(&a, lv_anim_path_ease_in);
    lv_anim_set_ready_cb(&a, animation_finish_cb);
    lv_anim_start(&a);
}

static void animate_panel_in_side(lv_obj_t *panel) {
    if (s_hide_timer) lv_timer_del(s_hide_timer);
    s_is_animating = true;
    lv_obj_clear_flag(panel, LV_OBJ_FLAG_HIDDEN);

    lv_anim_t a;
    lv_anim_init(&a);
    lv_anim_set_var(&a, panel);
    lv_anim_set_values(&a, lv_obj_get_x(panel), BUTTON_PADDING);
    lv_anim_set_time(&a, ANIM_TIME_MS);
    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_x);
    lv_anim_set_path_cb(&a, lv_anim_path_ease_out);
    lv_anim_set_ready_cb(&a, animation_finish_cb);
    lv_anim_start(&a);

    s_hide_timer = lv_timer_create(timer_auto_hide_callback, PANEL_AUTO_HIDE_DELAY, NULL);
    lv_timer_set_repeat_count(s_hide_timer, 1);
}

static void animate_panel_out_side(lv_obj_t *panel) {
    if (s_hide_timer) { lv_timer_del(s_hide_timer); s_hide_timer = NULL; }
    s_is_animating = true;

    lv_anim_t a;
    lv_anim_init(&a);
    lv_anim_set_var(&a, panel);
    lv_anim_set_values(&a, lv_obj_get_x(panel), -SIDE_PANEL_WIDTH);
    lv_anim_set_time(&a, ANIM_TIME_MS);
    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_x);
    lv_anim_set_path_cb(&a, lv_anim_path_ease_in);
    lv_anim_set_ready_cb(&a, animation_finish_cb);
    lv_anim_start(&a);
}

static void timer_auto_hide_callback(lv_timer_t *timer) {
    ui_actions_panel_hide_all();
    s_hide_timer = NULL;
}

void ui_actions_panel_handle_gesture(lv_dir_t dir, lv_coord_t start_x, lv_coord_t start_y) {
    if (s_is_animating) return;
    if (s_hide_timer) lv_timer_reset(s_hide_timer);

    switch(s_panel_state) {
        case PANEL_STATE_HIDDEN:
            if (dir == LV_DIR_BOTTOM && start_y < EDGE_SWIPE_THRESHOLD) {
                animate_panel_in_top(s_panel_player);
                s_panel_state = PANEL_STATE_PLAYER_VISIBLE;
            } else if (dir == LV_DIR_RIGHT && start_x < EDGE_SWIPE_THRESHOLD) {
                animate_panel_in_side(s_panel_evo);
                s_panel_state = PANEL_STATE_SIDE_VISIBLE;
            } else {
                ui_idle_animation_resume();
            }
            break;
        case PANEL_STATE_PLAYER_VISIBLE:
            if (dir == LV_DIR_BOTTOM) {
                animate_panel_out_top(s_panel_player);
                animate_panel_in_top(s_panel_admin);
                s_panel_state = PANEL_STATE_ADMIN_VISIBLE;
            } else if (dir == LV_DIR_TOP) {
                animate_panel_out_top(s_panel_player);
                s_panel_state = PANEL_STATE_HIDDEN;
                ui_idle_animation_resume();
            }
            break;
        case PANEL_STATE_ADMIN_VISIBLE:
            if (dir == LV_DIR_BOTTOM) {
                animate_panel_out_top(s_panel_admin);
                animate_panel_in_top(s_panel_config);
                s_panel_state = PANEL_STATE_CONFIG_VISIBLE;
            } else if (dir == LV_DIR_TOP) {
                animate_panel_out_top(s_panel_admin);
                animate_panel_in_top(s_panel_player);
                s_panel_state = PANEL_STATE_PLAYER_VISIBLE;
            }
            break;
        case PANEL_STATE_CONFIG_VISIBLE:
             if (dir == LV_DIR_TOP) {
                animate_panel_out_top(s_panel_config);
                animate_panel_in_top(s_panel_admin);
                s_panel_state = PANEL_STATE_ADMIN_VISIBLE;
            }
            break;
        case PANEL_STATE_SIDE_VISIBLE:
            if (dir == LV_DIR_LEFT) {
                animate_panel_out_side(s_panel_evo);
                s_panel_state = PANEL_STATE_HIDDEN;
                ui_idle_animation_resume();
            }
            break;
    }
}

void ui_actions_panel_hide_all(void) {
    if (s_panel_state == PANEL_STATE_HIDDEN || s_is_animating) return;

    if (s_panel_state == PANEL_STATE_PLAYER_VISIBLE) animate_panel_out_top(s_panel_player);
    else if (s_panel_state == PANEL_STATE_ADMIN_VISIBLE) animate_panel_out_top(s_panel_admin);
    else if (s_panel_state == PANEL_STATE_CONFIG_VISIBLE) animate_panel_out_top(s_panel_config);
    else if (s_panel_state == PANEL_STATE_SIDE_VISIBLE) animate_panel_out_side(s_panel_evo);
    
    s_panel_state = PANEL_STATE_HIDDEN;
    if (s_hide_timer) { lv_timer_del(s_hide_timer); s_hide_timer = NULL; }
    ui_idle_animation_resume();
}

--- END OF FILE: .\components\ui\ui_actions_panel.c ---

--- START OF FILE: .\components\ui\ui_actions_panel.h ---
/* Fecha: 17/08/2025 - 01:29 
# Fichero: components/ui/ui_actions_panel.h
# √öltimo cambio: Eliminados los getters de botones individuales tras la refactorizaci√≥n a un gestor de botones.
# Descripci√≥n: Interfaz p√∫blica para el gestor de paneles de acciones. Ahora solo expone las funciones de alto nivel para crear, mostrar/ocultar y manejar gestos, ya que la gesti√≥n de los botones individuales se ha delegado al uttons_manager.
*/
#ifndef UI_ACTIONS_PANEL_H
#define UI_ACTIONS_PANEL_H

#include <lvgl.h>

/**
 * @brief Crea todos los paneles de acci√≥n, delegando la creaci√≥n de botones al `buttons_manager`.
 * @param parent El objeto padre sobre el cual se crear√°n los botones.
 */
void ui_actions_panel_create(lv_obj_t *parent);

/**
 * @brief Procesa un gesto de deslizamiento para mostrar u ocultar paneles.
 * @param dir La direcci√≥n del gesto detectado por LVGL.
 * @param start_x Coordenada X inicial del gesto.
 * @param start_y Coordenada Y inicial del gesto.
 */
void ui_actions_panel_handle_gesture(lv_dir_t dir, lv_coord_t start_x, lv_coord_t start_y);

/**
 * @brief Oculta inmediatamente cualquier panel de acciones que est√© visible.
 *        √ötil para forzar el cierre de los paneles, por ejemplo, al apagar la pantalla.
 */
void ui_actions_panel_hide_all(void);

#endif // UI_ACTIONS_PANEL_H

--- END OF FILE: .\components\ui\ui_actions_panel.h ---

--- START OF FILE: .\components\ui\ui_asset_loader.c ---
/* Fecha: 17/08/2025 - 03:09  */
/* Fichero: components/ui/ui_asset_loader.c */
/* √öltimo cambio: Actualizada la ruta de inclusi√≥n para 'ui_assets.h' para reflejar la nueva estructura de directorios. */
/* Descripci√≥n: Implementa el cargador de assets. Se ha corregido la ruta de inclusi√≥n de los assets de imagen para que apunte a 'assets/images/ui_assets.h', adapt√°ndose a la refactorizaci√≥n que centraliza todos los recursos de apariencia. */

#include "ui_asset_loader.h"
#include "assets/images/ui_assets.h" // Actualizado para reflejar la nueva ubicaci√≥n
#include "esp_log.h"

static const char *TAG = "UI_ASSET_LOADER";

// --- Mapeo de IDs de assets a los punteros de los descriptores de imagen compilados ---
static const lv_img_dsc_t* g_asset_dsc_pointers[ASSET_COUNT] = {
    [ASSET_ICON_EAT]                  = &asset_btn_1,
    [ASSET_ICON_GYM]                  = &asset_btn_2,
    [ASSET_ICON_ATK]                  = &asset_btn_3,
    [ASSET_ICON_BRIGHTNESS]           = &asset_btn_4,
    [ASSET_ICON_SCREEN_OFF]           = &asset_btn_5,
    [ASSET_ICON_ADMIN_PLACEHOLDER]    = &asset_btn_6,
    [ASSET_ICON_RESET_ALL]            = &asset_btn_7,
    [ASSET_ICON_ENABLE_FILE_SERVER]   = &asset_btn_8,
    [ASSET_ICON_CONFIG_PLACEHOLDER]   = &asset_btn_9,
    [ASSET_ICON_EVO_FIRE]             = &asset_evo_1,
    [ASSET_ICON_EVO_WATER]            = &asset_evo_2,
    [ASSET_ICON_EVO_EARTH]            = &asset_evo_3,
    [ASSET_ICON_EVO_WIND]             = &asset_evo_4,
    [ASSET_ICON_EVO_BACK]             = &asset_evo_5,
};

/**
 * @brief Inicializa el gestor de assets. En este modo no hace nada.
 */
void ui_assets_init(void) {
    ESP_LOGI(TAG, "Asset loader inicializado en modo 'firmware-linked'.");
}

/**
 * @brief Desinicializa el gestor de assets. No hace nada en este modo.
 */
void ui_assets_deinit(void) {
    // No hay memoria din√°mica que liberar.
}

/**
 * @brief Obtiene un puntero al descriptor de imagen de un icono compilado en el firmware.
 * @param asset_id El identificador del icono.
 * @return Un puntero constante al descriptor de imagen LVGL.
 */
const lv_img_dsc_t* ui_assets_get_icon(ui_asset_id_t asset_id) {
    if (asset_id < 0 || asset_id >= ASSET_COUNT) {
        ESP_LOGE(TAG, "Asset ID %d solicitado est√° fuera de rango.", asset_id);
        return NULL;
    }
    return g_asset_dsc_pointers[asset_id];
}

--- END OF FILE: .\components\ui\ui_asset_loader.c ---

--- START OF FILE: .\components\ui\ui_asset_loader.h ---
/*
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_asset_loader.h
# Fecha: $timestamp
# √öltimo cambio: Corregido el tipo de retorno de `ui_assets_get_icon` a `const lv_img_dsc_t*`.
# Descripci√≥n: Se corrige la declaraci√≥n de `ui_assets_get_icon` para que devuelva un puntero a un descriptor de imagen (`const lv_img_dsc_t*`), coincidiendo con la nueva implementaci√≥n que utiliza assets compilados en el firmware. Esto resuelve el error de compilaci√≥n por tipos conflictivos.
*/
#ifndef UI_ASSET_LOADER_H
#define UI_ASSET_LOADER_H

#include "lvgl.h"

// Identificadores √∫nicos para cada asset precargado.
typedef enum {
    // Iconos del panel de jugador (superior 1)
    ASSET_ICON_EAT,
    ASSET_ICON_GYM,
    ASSET_ICON_ATK,

    // Iconos del panel de administraci√≥n (superior 2)
    ASSET_ICON_BRIGHTNESS,
    ASSET_ICON_SCREEN_OFF,
    ASSET_ICON_ADMIN_PLACEHOLDER,
    
    // Iconos del panel de configuraci√≥n (superior 3)
    ASSET_ICON_RESET_ALL,
    ASSET_ICON_ENABLE_FILE_SERVER,
    ASSET_ICON_CONFIG_PLACEHOLDER,

    // Iconos del panel de evoluci√≥n (lateral)
    ASSET_ICON_EVO_FIRE,
    ASSET_ICON_EVO_WATER,
    ASSET_ICON_EVO_EARTH,
    ASSET_ICON_EVO_WIND,
    ASSET_ICON_EVO_BACK,

    ASSET_COUNT // Utilidad para contar el n√∫mero de assets
} ui_asset_id_t;

/**
 * @brief Inicializa el gestor de assets.
 */
void ui_assets_init(void);

/**
 * @brief Desinicializa el gestor de assets.
 */
void ui_assets_deinit(void);

/**
 * @brief Obtiene un puntero al descriptor de imagen de un icono compilado en el firmware.
 * @param asset_id El identificador del icono a obtener.
 * @return Un puntero constante al descriptor de imagen LVGL.
 */
const lv_img_dsc_t* ui_assets_get_icon(ui_asset_id_t asset_id);

#endif // UI_ASSET_LOADER_H

--- END OF FILE: .\components\ui\ui_asset_loader.h ---

--- START OF FILE: .\components\ui\ui_idle_animation.c ---
/* Fecha: 17/08/2025 - 10:26  */
/* Fichero: components/ui/ui_idle_animation.c */
/* √öltimo cambio: Corregida la declaraci√≥n del buffer 'anim_path' de char a char[] para evitar corrupci√≥n de memoria. */
/* Descripci√≥n: Se ha corregido un error cr√≠tico donde el buffer para la ruta de la animaci√≥n se declaraba como un √∫nico car√°cter en lugar de un array. Esto causaba un desbordamiento de buffer y comportamiento indefinido al construir la ruta, impidiendo que la animaci√≥n de reposo se cargara correctamente. */

#include "ui_idle_animation.h"
#include "ui_action_animations.h" 
#include "animation_loader.h"
#include "helpers.h"
#include "esp_log.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static const char *TAG = "UI_IDLE_ANIM";

#define IDLE_FRAME_INTERVAL 1500

static lv_timer_t *g_anim_timer;
static animation_t s_idle_animation_player; // Player local, pero usar√° un b√∫fer compartido
static int g_current_frame_index = -1;
static bool g_is_idle_running = false;

static void idle_animation_timer_cb(lv_timer_t *timer) {
    if (!g_is_idle_running || s_idle_animation_player.frame_count == 0) return;
    
    g_current_frame_index = (g_current_frame_index + 1) % s_idle_animation_player.frame_count;
    
    if (animation_loader_load_frame(&s_idle_animation_player, g_current_frame_index, "ANIM_IDLE_")) {
        if (g_animation_img_obj) {
            lv_image_set_src(g_animation_img_obj, &s_idle_animation_player.img_dsc);
            lv_obj_invalidate(g_animation_img_obj);
        }
    }
}

lv_obj_t* ui_idle_animation_start(lv_obj_t *parent) {
    animation_t* shared_player = ui_action_animations_get_player();
    if (shared_player == NULL || shared_player->img_dsc.data == NULL) {
        ESP_LOGE(TAG, "No se puede iniciar la animaci√≥n idle: el b√∫fer compartido no es v√°lido.");
        return NULL;
    }

    // Copiar el descriptor, que incluye el puntero al b√∫fer compartido.
    s_idle_animation_player.img_dsc = shared_player->img_dsc;

    char anim_path[128]; // [CORRECCI√ìN] Declarado como un array de caracteres.
    ui_helpers_build_asset_path(anim_path, sizeof(anim_path), "");
    size_t len = strlen(anim_path);
    if (len > 0 && anim_path[len - 1] == '/') anim_path[len - 1] = '\0';
    
    s_idle_animation_player.base_path = strdup(anim_path);

    uint16_t frame_count = animation_loader_count_frames(anim_path, "ANIM_IDLE_");
    if (frame_count == 0) {
        ESP_LOGE(TAG, "No se encontraron fotogramas para la animaci√≥n de reposo en '%s'. La animaci√≥n no se iniciar√° y el personaje se ocultar√°.", anim_path);
        free(s_idle_animation_player.base_path);
        s_idle_animation_player.base_path = NULL;
        
        if (g_animation_img_obj) {
            lv_obj_add_flag(g_animation_img_obj, LV_OBJ_FLAG_HIDDEN);
        }
        
        return g_animation_img_obj;
    }
    ESP_LOGI(TAG, "Detectados %d fotogramas para la animaci√≥n de reposo.", frame_count);
    s_idle_animation_player.frame_count = frame_count;

    if(g_animation_img_obj) {
        lv_image_set_src(g_animation_img_obj, &s_idle_animation_player.img_dsc);
        lv_obj_clear_flag(g_animation_img_obj, LV_OBJ_FLAG_HIDDEN);
    }
    
    g_is_idle_running = true;
    g_anim_timer = lv_timer_create(idle_animation_timer_cb, IDLE_FRAME_INTERVAL, NULL);
    lv_timer_ready(g_anim_timer);
    
    ESP_LOGI(TAG, "Animaci√≥n de Idle iniciada desde %s (usando b√∫fer compartido).", anim_path);
    return g_animation_img_obj;
}

void ui_idle_animation_stop(void) {
    ESP_LOGI(TAG, "Deteniendo y limpiando animaci√≥n de idle.");
    g_is_idle_running = false;
    if (g_anim_timer) {
        lv_timer_del(g_anim_timer);
        g_anim_timer = NULL;
    }
    if (s_idle_animation_player.base_path) {
        free(s_idle_animation_player.base_path);
        s_idle_animation_player.base_path = NULL;
    }
    g_current_frame_index = -1;
}

void ui_idle_animation_pause(void) {
    if (g_anim_timer && g_is_idle_running) {
        lv_timer_pause(g_anim_timer);
        g_is_idle_running = false;
        ESP_LOGI(TAG, "Animaci√≥n de Idle PAUSADA.");
    }
}

void ui_idle_animation_resume(void) {
    if (g_anim_timer && !g_is_idle_running) {
        if (g_animation_img_obj) {
             lv_image_set_src(g_animation_img_obj, &s_idle_animation_player.img_dsc);
        }
        
        g_is_idle_running = true;
        lv_timer_resume(g_anim_timer);
        idle_animation_timer_cb(g_anim_timer);
        ESP_LOGI(TAG, "Animaci√≥n de Idle REANUDADA.");
    }
}

--- END OF FILE: .\components\ui\ui_idle_animation.c ---

--- START OF FILE: .\components\ui\ui_idle_animation.h ---
/*
 * Fichero: ./components/diymon_ui/ui_idle_animation.h
 * Fecha: 13/08/2025 - 11:43 
 * √öltimo cambio: Corregida la firma de la funci√≥n de inicio.
 * Descripci√≥n: Interfaz p√∫blica para la animaci√≥n de reposo. Se corrige la
 *              declaraci√≥n de 'ui_idle_animation_start' para que acepte un
 *              par√°metro y devuelva un puntero a objeto, solucionando el error
 *              de compilaci√≥n.
 */
#ifndef UI_IDLE_ANIMATION_H
#define UI_IDLE_ANIMATION_H

#include <lvgl.h>

/**
 * @brief Inicia la animaci√≥n de idle a pantalla completa.
 * @param parent El objeto padre sobre el que se crear√° la animaci√≥n (la pantalla principal).
 * @return Un puntero al objeto de imagen de la animaci√≥n para que otros m√≥dulos puedan interactuar con √©l (ej: ocultarlo).
 */
lv_obj_t* ui_idle_animation_start(lv_obj_t *parent);

/**
 * @brief Detiene y libera todos los recursos de la animaci√≥n de idle.
 */
void ui_idle_animation_stop(void);

/**
 * @brief Pausa el temporizador de la animaci√≥n de idle.
 */
void ui_idle_animation_pause(void);

/**
 * @brief Reanuda el temporizador de la animaci√≥n de idle.
 */
void ui_idle_animation_resume(void);

#endif // UI_IDLE_ANIMATION_H

--- END OF FILE: .\components\ui\ui_idle_animation.h ---

--- START OF FILE: .\components\ui\ui_layout.h ---
/* Fecha: 17/08/2025 - 02:08  */
/* Fichero: components/ui/ui_layout.h */
/* √öltimo cambio: Centralizadas todas las constantes de dise√±o (tama√±o de botones, tiempos de animaci√≥n, etc.) en un √∫nico fichero para facilitar el mantenimiento y la coherencia visual. */
/* Descripci√≥n: Este fichero contiene todas las constantes m√°gicas que definen la apariencia y el comportamiento de la UI. Centraliza valores como el tama√±o de los botones, los paddings y los tiempos de animaci√≥n para aplicar el principio DRY (Don't Repeat Yourself) y facilitar cambios de dise√±o globales. */

#ifndef UI_LAYOUT_H
#define UI_LAYOUT_H

// --- Constantes de Dise√±o de Botones ---
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10

// --- Constantes de Animaci√≥n y Comportamiento de Paneles ---
#define ANIM_TIME_MS 300
#define PANEL_AUTO_HIDE_DELAY 10000 
#define EDGE_SWIPE_THRESHOLD 50

// --- Constantes Estructurales de Paneles ---
#define NUM_TOP_BUTTONS 3
#define NUM_SIDE_BUTTONS 5


#endif // UI_LAYOUT_H

--- END OF FILE: .\components\ui\ui_layout.h ---

--- START OF FILE: .\components\ui\ui_priv.h ---
/*
 * Fichero: ui_priv.h
 * Fecha: 08/08/2025
 * √öltimo cambio: A√±adido puntero para el panel de acciones desplegable.
 * Descripci√≥n: Cabecera PRIVADA para el componente UI.
 *              Comparte definiciones y variables globales SOLO entre los .c de la UI.
 */
#ifndef UI_PRIV_H
#define UI_PRIV_H

#ifdef __cplusplus
extern "C" {
#endif

#include "lvgl.h"

/**
 * @struct objects_t
 * @brief  Contiene los punteros a todos los objetos LVGL gestionados por la UI.
 * 
 * Esta estructura centraliza el acceso a los elementos visuales. Se agrupan por
 * tipo (objetos principales, panel, botones, animaciones) para una mayor claridad.
 */
typedef struct {
    // --- Objetos Principales ---
    lv_obj_t *main;         // Objeto de la pantalla principal.
    lv_obj_t *idle;         // GIF de la animaci√≥n de reposo.

    // --- Panel de Acciones Desplegable ---
    lv_obj_t *actions_panel; // El contenedor que se desliza desde arriba.

    // --- Botones de Acci√≥n (contenidos en el panel) ---
    lv_obj_t *comer;        // Bot√≥n para la acci√≥n 'Comer'.
    lv_obj_t *pesas;        // Bot√≥n para la acci√≥n 'Ejercicio'.
    lv_obj_t *atacar;       // Bot√≥n para la acci√≥n 'Atacar'.

    // --- Animaciones GIF de Acciones ---
    lv_obj_t *comiendo;     // GIF para la animaci√≥n 'Comiendo'.
    lv_obj_t *ejercicio;    // GIF para la animaci√≥n 'Ejercicio'.
    lv_obj_t *ataque;       // GIF para la animaci√≥n 'Ataque'.

} objects_t;

/**
 * @brief Variable global 'objects'.
 * 
 * Declaraci√≥n 'extern' que permite a todos los ficheros del componente UI
 * acceder a la instancia √∫nica de la estructura 'objects_t', que ser√°
 * definida en 'screens.c'.
 */
extern objects_t objects;

#ifdef __cplusplus
}
#endif

#endif // UI_PRIV_H
--- END OF FILE: .\components\ui\ui_priv.h ---

--- START OF FILE: .\components\ui\ui_state_manager.c ---
/* Fecha: 17/08/2025 - 02:11  */
/* Fichero: components/ui/ui_state_manager.c */
/* √öltimo cambio: Movida toda la l√≥gica de gesti√≥n de estado de la pantalla (inactividad, atenuado, despertar) desde main.c a este nuevo m√≥dulo dedicado. */
/* Descripci√≥n: Implementaci√≥n del gestor de estado de la UI. Este fichero ahora contiene todas las variables y funciones que manejan el comportamiento de la pantalla en respuesta a la inactividad del usuario. Centraliza la l√≥gica de atenuado, apagado autom√°tico y el patr√≥n de toques para despertar, limpiando significativamente la l√≥gica de main.c. */

#include "ui_state_manager.h"
#include "screen_manager.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "esp_log.h"

static const char *TAG = "UI_STATE_MANAGER";

// --- Tipos y variables de estado internas ---
typedef enum {
    WAKE_STATE_OFF,
    WAKE_STATE_PRIMED,
} wake_up_state_t;

static bool s_is_dimmed = false;
static int s_user_brightness = 100;
static bool s_user_brightness_known = false;
static wake_up_state_t s_wake_state = WAKE_STATE_OFF;
static uint8_t s_wake_click_count = 0;
static lv_timer_t *s_double_click_timer = NULL;
static lv_timer_t *s_wake_prime_timer = NULL;

// --- Funciones de ayuda y callbacks ---

static void read_user_brightness_from_nvs(void) {
    if (s_user_brightness_known) return;
    nvs_handle_t nvs_handle;
    if (nvs_open("storage", NVS_READONLY, &nvs_handle) == ESP_OK) {
        nvs_get_i32(nvs_handle, "brightness", (int32_t*)&s_user_brightness);
        nvs_close(nvs_handle);
        s_user_brightness_known = true;
    }
}

static void double_click_timer_cb(lv_timer_t * timer) {
    s_wake_click_count = 0;
    s_double_click_timer = NULL;
}

static void wake_prime_timer_cb(lv_timer_t * timer) {
    s_wake_state = WAKE_STATE_OFF;
    s_wake_click_count = 0;
    s_wake_prime_timer = NULL;
}

static void screen_touch_event_cb(lv_event_t * e) {
    lv_event_code_t code = lv_event_get_code(e);
    lv_disp_t * disp = lv_display_get_default();
    if (!disp) return;
    
    lv_display_trigger_activity(disp);

    if (code == LV_EVENT_PRESSED && s_is_dimmed && !screen_manager_is_off()) {
        read_user_brightness_from_nvs();
        screen_manager_set_brightness(s_user_brightness);
        s_is_dimmed = false;
        return;
    }

    if (code == LV_EVENT_CLICKED && screen_manager_is_off()) {
        if (s_wake_state == WAKE_STATE_OFF) {
            s_wake_click_count++;
            if (s_wake_click_count == 1) {
                s_double_click_timer = lv_timer_create(double_click_timer_cb, 500, NULL);
                lv_timer_set_repeat_count(s_double_click_timer, 1);
            } else if (s_wake_click_count == 2) {
                if (s_double_click_timer) lv_timer_del(s_double_click_timer);
                s_double_click_timer = NULL;
                s_wake_state = WAKE_STATE_PRIMED;
                s_wake_click_count = 0;
                s_wake_prime_timer = lv_timer_create(wake_prime_timer_cb, 3000, NULL);
                lv_timer_set_repeat_count(s_wake_prime_timer, 1);
            }
        } else if (s_wake_state == WAKE_STATE_PRIMED) {
            s_wake_click_count++;
            if (s_wake_click_count == 1) {
                s_double_click_timer = lv_timer_create(double_click_timer_cb, 500, NULL);
                lv_timer_set_repeat_count(s_double_click_timer, 1);
            } else if (s_wake_click_count >= 2) {
                if (s_double_click_timer) lv_timer_del(s_double_click_timer);
                if (s_wake_prime_timer) lv_timer_del(s_wake_prime_timer);
                s_double_click_timer = NULL;
                s_wake_prime_timer = NULL;
                screen_manager_turn_on();
                s_is_dimmed = false;
                s_wake_state = WAKE_STATE_OFF;
                s_wake_click_count = 0;
            }
        }
    }
}

static void inactivity_timer_cb(lv_timer_t * timer) {
    lv_disp_t * disp = lv_display_get_default();
    if (!disp) return;
    
    uint32_t inactivity_ms = lv_display_get_inactive_time(disp);
    bool is_off = screen_manager_is_off();

    if (inactivity_ms < 30000 && s_is_dimmed) {
        s_is_dimmed = false;
    }

    if (!is_off && inactivity_ms > 60000) {
        screen_manager_turn_off();
        s_is_dimmed = false;
    } else if (!is_off && !s_is_dimmed && inactivity_ms > 30000) {
        read_user_brightness_from_nvs();
        screen_manager_set_brightness(10);
        s_is_dimmed = true;
    }
}

// --- Funci√≥n de inicializaci√≥n p√∫blica ---
void ui_state_manager_init(void) {
    lv_timer_create(inactivity_timer_cb, 5000, NULL);
    lv_obj_t * scr = lv_screen_active();
    if (scr) {
        lv_obj_add_event_cb(scr, screen_touch_event_cb, LV_EVENT_ALL, NULL);
    }
    ESP_LOGI(TAG, "Gestor de estado de UI inicializado. Manejadores de inactividad activos.");
}

--- END OF FILE: .\components\ui\ui_state_manager.c ---

--- START OF FILE: .\components\ui\ui_state_manager.h ---
/* Fecha: 17/08/2025 - 02:10  */
/* Fichero: components/ui/ui_state_manager.h */
/* √öltimo cambio: Creaci√≥n del gestor de estado de la UI para encapsular la l√≥gica de inactividad. */
/* Descripci√≥n: Interfaz p√∫blica del gestor de estado de la UI. Este m√≥dulo es responsable de manejar la inactividad del usuario, el atenuado y apagado autom√°tico de la pantalla, y la l√≥gica de despertar. Expone una √∫nica funci√≥n de inicializaci√≥n para mantener su implementaci√≥n interna encapsulada. */

#ifndef UI_STATE_MANAGER_H
#define UI_STATE_MANAGER_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el gestor de estado de la UI.
 * 
 * Configura los temporizadores y los callbacks de eventos necesarios para
 * gestionar la inactividad, el atenuado/apagado de la pantalla y la l√≥gica
 * de despertar. Debe ser llamado una vez despu√©s de que la UI principal
 * haya sido creada.
 */
void ui_state_manager_init(void);

#ifdef __cplusplus
}
#endif

#endif // UI_STATE_MANAGER_H

--- END OF FILE: .\components\ui\ui_state_manager.h ---

--- START OF FILE: .\components\ui\ui.c ---
/* Fecha: 17/08/2025 - 01:31 
# Fichero: components/ui/ui.c
# √öltimo cambio: Eliminada la funci√≥n 'ui_connect_actions' y el callback de eventos centralizado para completar la refactorizaci√≥n de botones.
# Descripci√≥n: Orquestador principal de la UI. Se ha eliminado la l√≥gica de conexi√≥n de eventos, ya que ahora cada m√≥dulo de bot√≥n es responsable de conectar su propio callback. Esta es la limpieza final de la refactorizaci√≥n, haciendo que este fichero sea agn√≥stico a los botones espec√≠ficos.
*/
#include "ui.h"
#include "screens.h"
#include "ui_action_animations.h"
#include "esp_log.h"

extern lv_obj_t *g_main_screen_obj; 

static const char *TAG = "DIYMON_UI_MAIN";

// La funci√≥n 'ui_connect_actions' y su 'button_event_cb' han sido eliminados.
// La conexi√≥n de eventos ahora est√° encapsulada dentro de cada m√≥dulo de bot√≥n.

void ui_preinit(void) {
    ESP_LOGI(TAG, "Pre-inicializando UI: reservando buffer de animaci√≥n...");
    ui_action_animations_preinit_buffer();
}

void ui_init(void) {
    create_screens();
    
    if (g_main_screen_obj) {
        // La llamada a ui_connect_actions() ha sido eliminada.
        lv_obj_add_event_cb(g_main_screen_obj, (lv_event_cb_t)delete_screen_main, LV_EVENT_DELETE, NULL);
    }
    
    lv_screen_load(g_main_screen_obj);
    ESP_LOGI(TAG, "UI modularizada y lista.");
}

--- END OF FILE: .\components\ui\ui.c ---

--- START OF FILE: .\components\ui\ui.h ---
/*
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui.h
# Fecha: $timestamp
# √öltimo cambio: A√±adida la declaraci√≥n de ui_preinit para la pre-reserva de memoria.
# Descripci√≥n: Interfaz P√öBLICA del componente de la UI. Define las funciones de alto nivel para controlar la UI desde el exterior. Se a√±ade la declaraci√≥n de `ui_preinit` para permitir la reserva del buffer de animaci√≥n antes que cualquier otra inicializaci√≥n, solucionando el error de compilaci√≥n.
*/
#ifndef UI_H
#define UI_H

#ifdef __cplusplus
extern "C" {
#endif

// --- DEFINICIONES COMPARTIDAS ---

// Enum para identificar las pantallas. Se mantiene aqu√≠ porque es parte de la
// interfaz p√∫blica para, potencialmente, cambiar de pantalla.
enum ScreensEnum {
    SCREEN_ID_MAIN = 1,
};


// --- FUNCIONES P√öBLICAS DE LA UI ---

/**
 * @brief Pre-inicializa la UI reservando los buffers de memoria m√°s grandes.
 *
 * Esta funci√≥n debe llamarse al principio de app_main para evitar la fragmentaci√≥n
 * de la memoria RAM, asegurando que la asignaci√≥n de memoria m√°s grande (el buffer
 * de animaci√≥n) tenga √©xito.
 */
void ui_preinit(void);

/**
 * @brief Inicializa y configura toda la interfaz de usuario.
 *
 * Esta es la funci√≥n principal que se debe llamar desde fuera del componente
 * (por ejemplo, desde main.c) para poner en marcha toda la UI.
 */
void ui_init(void);


#ifdef __cplusplus
}
#endif

#endif // UI_H

--- END OF FILE: .\components\ui\ui.h ---

--- START OF FILE: .\components\web_server\CMakeLists.txt ---
# Fecha: 18/08/2025 - 07:45 
# Fichero: components/web_server/CMakeLists.txt
# √öltimo cambio: Corregido el estilo de comentarios de C-style (/*) a CMake-style (#) para resolver el error de parser.
# Descripci√≥n: Registro del componente web_server. El error de compilaci√≥n se deb√≠a a que se estaban usando comentarios de C en un fichero de CMake, lo cual es sint√°cticamente incorrecto. Se corrige el formato de los comentarios para que el sistema de build pueda procesar el fichero.

idf_component_register(SRCS
                        "web_server.c"
                        "web_server_handlers.c"
                        "web_server_helpers.c"
                    INCLUDE_DIRS "."
                    PRIV_INCLUDE_DIRS "."
                    REQUIRES
                        driver
                        esp_wifi
                        esp_event
                        nvs_flash
                        log
                        esp_http_server
                        bsp
                        sdmmc
)

--- END OF FILE: .\components\web_server\CMakeLists.txt ---

--- START OF FILE: .\components\web_server\web_server_handlers.c ---
/* Fecha: 18/08/2025 - 07:48  */
/* Fichero: components/web_server/web_server_handlers.c */
/* √öltimo cambio: Eliminado el calificador 'static' de las definiciones de los handlers para resolver un error de enlazado (linkage error). */
/* Descripci√≥n: Se ha eliminado la palabra clave 'static' de la definici√≥n de todas las funciones handler. El error de compilaci√≥n 'static declaration of '...' follows non-static declaration' ocurr√≠a porque las funciones se declaraban sin 'static' en la cabecera privada (web_server_priv.h) pero se defin√≠an con 'static' en este fichero, creando un conflicto de enlazado. Ahora las definiciones coinciden con las declaraciones, permitiendo que web_server.c las enlace correctamente. */

#include "web_server_priv.h"
#include "esp_log.h"
#include "esp_vfs.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "esp_system.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/stat.h>

static const char *TAG = "WEB_HANDLERS";

// --- Implementaci√≥n de Handlers de Endpoints ---

esp_err_t root_get_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: GET /. Sirviendo p√°gina principal.");
    return serve_file_from_sd(req, "/sdcard/config/Index.html");
}

esp_err_t backup_get_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: GET /backup. Sirviendo p√°gina de respaldo.");
    return serve_file_from_sd(req, "/sdcard/config/backup.html");
}

esp_err_t list_files_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: GET /listfiles. Listando contenido de directorio.");
    char query_buf[128];
    char path_decoded[128] = "/";
    char current_path[256] = "/";

    if (httpd_req_get_url_query_str(req, query_buf, sizeof(query_buf)) == ESP_OK) {
        char param[128];
        if (httpd_query_key_value(query_buf, "path", param, sizeof(param)) == ESP_OK) {
            url_decode(path_decoded, param);
        }
    }
    if (path_decoded[0] != '/') {
        snprintf(current_path, sizeof(current_path), "/%s", path_decoded);
    } else {
        strncpy(current_path, path_decoded, sizeof(current_path) - 1);
    }

    if (strstr(current_path, "..")) {
        ESP_LOGE(TAG, "Intento de path traversal detectado: %s", current_path);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid path");
        return ESP_FAIL;
    }

    char full_path[512];
    snprintf(full_path, sizeof(full_path), "%s%s", WEB_MOUNT_POINT, strcmp(current_path, "/") == 0 ? "" : current_path);
    ESP_LOGD(TAG, "Listando directorio VFS: %s", full_path);
    
    DIR *d = opendir(full_path);
    if (!d) {
        ESP_LOGE(TAG, "No se pudo abrir el directorio: %s", full_path);
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    httpd_resp_set_type(req, "application/json");
    
    size_t buf_size = 1024;
    char *json_buf = malloc(buf_size);
    strcpy(json_buf, "[");
    bool first = true;
    struct dirent *dir;

    while ((dir = readdir(d)) != NULL) {
        if (strcmp(dir->d_name, ".") == 0 || strcmp(dir->d_name, "..") == 0) continue;
        if (!first) strcat(json_buf, ",");
        
        char item_path[512];
        int written = snprintf(item_path, sizeof(item_path), "%s/%s", full_path, dir->d_name);
        if (written < 0 || written >= sizeof(item_path)) {
            ESP_LOGE(TAG, "Error de truncamiento de ruta para: %s/%s", full_path, dir->d_name);
            continue;
        }
        
        struct stat st;
        char entry_buf[512];
        if (stat(item_path, &st) == 0) {
            snprintf(entry_buf, sizeof(entry_buf), 
                     "{\"name\":\"%s\",\"size\":%lld,\"type\":\"%s\"}", 
                     dir->d_name, (long long)st.st_size, S_ISDIR(st.st_mode) ? "dir" : "file");
        } else {
            snprintf(entry_buf, sizeof(entry_buf), 
                     "{\"name\":\"%s\",\"size\":0,\"type\":\"file\"}", dir->d_name);
        }

        if (strlen(json_buf) + strlen(entry_buf) + 2 > buf_size) {
            buf_size *= 2;
            char *new_buf = realloc(json_buf, buf_size);
            if (!new_buf) { free(json_buf); closedir(d); httpd_resp_send_500(req); return ESP_ERR_NO_MEM; }
            json_buf = new_buf;
        }
        strcat(json_buf, entry_buf);
        first = false;
    }
    closedir(d);

    strcat(json_buf, "]");
    ESP_LOGD(TAG, "JSON de ficheros generado: %s", json_buf);
    httpd_resp_send(req, json_buf, strlen(json_buf));
    free(json_buf);
    return ESP_OK;
}

esp_err_t upload_post_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: POST /upload. Iniciando subida de fichero.");
    char buf[UPLOAD_BUFFER_SIZE];
    char filepath[256];
    FILE *fd = NULL;
    int received;
    int remaining = req->content_len;
    ESP_LOGD(TAG, "Tama√±o total del contenido: %d bytes.", remaining);

    received = httpd_req_recv(req, buf, MIN(remaining, sizeof(buf)));
    if (received <= 0) {
        ESP_LOGE(TAG, "Fallo al recibir el primer chunk de datos.");
        return ESP_FAIL;
    }
    
    char path[128] = "/";
    char filename[64] = "";
    get_multipart_value(buf, "path", path, sizeof(path));
    char *filename_start = strstr(buf, "filename=\"");
    if (!filename_start) { ESP_LOGE(TAG, "No se encontr√≥ 'filename' en la cabecera multipart."); return ESP_FAIL; }
    filename_start += strlen("filename=\"");
    char *filename_end = strchr(filename_start, '\"');
    if (!filename_end) { ESP_LOGE(TAG, "Formato de 'filename' inv√°lido."); return ESP_FAIL; }
    strncpy(filename, filename_start, filename_end - filename_start);
    filename[filename_end - filename_start] = '\0';
    ESP_LOGD(TAG, "Path extra√≠do: '%s', Filename: '%s'", path, filename);

    if (strlen(filename) == 0 || strstr(path, "..") || strstr(filename, "..")) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Ruta/fichero inv√°lido.");
        return ESP_FAIL;
    }

    snprintf(filepath, sizeof(filepath), "%s%s/%s", WEB_MOUNT_POINT, strcmp(path, "/") == 0 ? "" : path, filename);
    ESP_LOGI(TAG, "Abriendo fichero para escritura: %s", filepath);
    fd = fopen(filepath, "wb");
    if (!fd) { ESP_LOGE(TAG, "Fallo al abrir fichero."); httpd_resp_send_500(req); return ESP_FAIL; }

    char *data_start = strstr(filename_end, "\r\n\r\n");
    if (!data_start) { ESP_LOGE(TAG, "No se encontr√≥ el delimitador de datos."); fclose(fd); return ESP_FAIL; }
    
    data_start += 4;
    int header_len = data_start - buf;
    int data_len = received - header_len;
    fwrite(data_start, 1, data_len, fd);
    remaining -= received;

    while (remaining > 0) {
        received = httpd_req_recv(req, buf, MIN(remaining, sizeof(buf)));
        if (received <= 0) { ESP_LOGE(TAG, "Error durante la recepci√≥n del stream."); fclose(fd); return ESP_FAIL; }
        
        char *boundary_start = strstr(buf, "\r\n--");
        if (boundary_start) {
             fwrite(buf, 1, boundary_start - buf, fd);
        } else {
             fwrite(buf, 1, received, fd);
        }
        remaining -= received;
    }

    fclose(fd);
    ESP_LOGI(TAG, "Subida de archivo a %s completa.", filepath);
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

esp_err_t delete_file_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: POST /delete. Petici√≥n de borrado recibida.");
    char buf[512];
    int ret = httpd_req_recv(req, buf, sizeof(buf) - 1);
    if (ret <= 0) return ESP_FAIL;
    buf[ret] = '\0';

    char path[128] = "";
    char filename[64] = "";
    get_multipart_value(buf, "path", path, sizeof(path));
    get_multipart_value(buf, "filename", filename, sizeof(filename));
    ESP_LOGD(TAG, "Petici√≥n de borrado: path='%s', filename='%s'", path, filename);
    
    if (strlen(filename) == 0 || strstr(path, "..") || strstr(filename, "..")) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Nombre de archivo o ruta inv√°lidos.");
        return ESP_FAIL;
    }

    char filepath[256];
    snprintf(filepath, sizeof(filepath), "%s%s/%s", WEB_MOUNT_POINT, strcmp(path, "/") == 0 ? "" : path, filename);

    if (unlink(filepath) == 0) {
        ESP_LOGI(TAG, "Archivo borrado: %s", filepath);
        httpd_resp_send(req, "Archivo borrado.", HTTPD_RESP_USE_STRLEN);
    } else {
        ESP_LOGE(TAG, "Fallo al borrar el archivo: %s", filepath);
        httpd_resp_send_500(req);
    }
    return ESP_OK;
}

esp_err_t create_dir_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: POST /create. Petici√≥n de creaci√≥n de directorio.");
    char buf[512];
    int ret = httpd_req_recv(req, buf, sizeof(buf) - 1);
    if (ret <= 0) return ESP_FAIL;
    buf[ret] = '\0';

    char path[128] = "";
    char dirname[64] = "";
    get_multipart_value(buf, "path", path, sizeof(path));
    get_multipart_value(buf, "dirname", dirname, sizeof(dirname));
    ESP_LOGD(TAG, "Petici√≥n de creaci√≥n de dir: path='%s', dirname='%s'", path, dirname);
    
    if (strlen(dirname) == 0 || strstr(path, "..") || strstr(dirname, "..")) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Nombre de directorio o ruta inv√°lidos.");
        return ESP_FAIL;
    }

    char full_path[256];
    snprintf(full_path, sizeof(full_path), "%s%s/%s", WEB_MOUNT_POINT, strcmp(path, "/") == 0 ? "" : path, dirname);

    if (mkdir(full_path, 0755) == 0) {
        ESP_LOGI(TAG, "Directorio creado: %s", full_path);
        httpd_resp_send(req, "Directorio creado.", HTTPD_RESP_USE_STRLEN);
    } else {
        ESP_LOGE(TAG, "Fallo al crear directorio: %s", full_path);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "No se pudo crear el directorio.");
    }
    return ESP_OK;
}

esp_err_t save_post_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Handler: POST /save. Guardando configuraci√≥n WiFi.");
    char buf[256];
    int ret = httpd_req_recv(req, buf, sizeof(buf) - 1);
    if (ret <= 0) return ESP_FAIL;
    buf[ret] = '\0';

    char ssid[32] = {0}, password_encoded[64] = {0}, password_decoded[64] = {0}, authmode_str[4] = {0};
    
    httpd_query_key_value(buf, "ssid", ssid, sizeof(ssid));
    httpd_query_key_value(buf, "password", password_encoded, sizeof(password_encoded));
    httpd_query_key_value(buf, "authmode", authmode_str, sizeof(authmode_str));
    int32_t authmode = atoi(authmode_str);

    url_decode(password_decoded, password_encoded);
    ESP_LOGI(TAG, "Guardando SSID: '%s'", ssid); // No loguear la contrase√±a por seguridad
    
    nvs_handle_t nvs_handle;
    ESP_ERROR_CHECK(nvs_open("storage", NVS_READWRITE, &nvs_handle));
    ESP_ERROR_CHECK(nvs_set_str(nvs_handle, "wifi_ssid", ssid));
    ESP_ERROR_CHECK(nvs_set_str(nvs_handle, "wifi_pass", password_decoded));
    ESP_ERROR_CHECK(nvs_set_i32(nvs_handle, "wifi_authmode", authmode));
    ESP_ERROR_CHECK(nvs_commit(nvs_handle));
    nvs_close(nvs_handle);
    ESP_LOGI(TAG, "Credenciales guardadas en NVS. Dispositivo se reiniciar√°.");

    const char* resp_str = "<h1>Configuracion guardada!</h1><p>El dispositivo se reiniciara.</p>";
    httpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN);

    vTaskDelay(pdMS_TO_TICKS(2000));
    esp_restart();
    
    return ESP_OK;
}

--- END OF FILE: .\components\web_server\web_server_handlers.c ---

--- START OF FILE: .\components\web_server\web_server_helpers.c ---
/* Fecha: 18/08/2025 - 07:43  */
/* Fichero: components/web_server/web_server_helpers.c */
/* √öltimo cambio: Creado como parte de la refactorizaci√≥n para aislar las funciones de ayuda. */
/* Descripci√≥n: Este fichero contiene funciones de utilidad utilizadas por los handlers del servidor web. Incluye la l√≥gica para servir ficheros est√°ticos desde la tarjeta SD, decodificar URLs, parsear datos de formularios multipart y determinar el tipo de contenido de un fichero. Separar estas funciones mejora la legibilidad y permite reutilizarlas f√°cilmente. */

#include "web_server_priv.h"
#include "esp_log.h"
#include <stdio.h>
#include <string.h>
#include <ctype.h>

static const char *TAG = "WEB_HELPERS";

// --- Implementaci√≥n de Funciones de Ayuda ---

esp_err_t set_content_type_from_file(httpd_req_t *req, const char *filename) {
    if (strstr(filename, ".html")) {
        return httpd_resp_set_type(req, "text/html");
    } else if (strstr(filename, ".css")) {
        return httpd_resp_set_type(req, "text/css");
    } else if (strstr(filename, ".js")) {
        return httpd_resp_set_type(req, "application/javascript");
    }
    // A√±adir m√°s tipos MIME si es necesario (ej: .json, .png, etc.)
    return httpd_resp_set_type(req, "text/plain");
}

esp_err_t serve_file_from_sd(httpd_req_t *req, const char *filepath) {
    ESP_LOGI(TAG, "Helper: Sirviendo fichero est√°tico: %s", filepath);
    FILE *f = fopen(filepath, "r");
    if (f == NULL) {
        ESP_LOGE(TAG, "Helper: Fallo al abrir el fichero: %s", filepath);
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Fichero no encontrado.");
        return ESP_FAIL;
    }

    set_content_type_from_file(req, filepath);

    char chunk[1024];
    size_t chunksize;
    do {
        chunksize = fread(chunk, 1, sizeof(chunk), f);
        if (chunksize > 0) {
            if (httpd_resp_send_chunk(req, chunk, chunksize) != ESP_OK) {
                fclose(f);
                ESP_LOGE(TAG, "Helper: Fallo al enviar chunk del fichero.");
                // No se puede enviar un error aqu√≠ porque la respuesta ya ha comenzado.
                return ESP_FAIL;
            }
        }
    } while (chunksize != 0);

    fclose(f);
    ESP_LOGI(TAG, "Helper: Env√≠o de fichero completado.");
    httpd_resp_send_chunk(req, NULL, 0); // Se√±al de finalizaci√≥n
    return ESP_OK;
}

void url_decode(char *dst, const char *src) {
    char a, b;
    while (*src) {
        if ((*src == '%') && ((a = src[1]) && (b = src[2])) && (isxdigit(a) && isxdigit(b))) {
            if (a >= 'a') a -= 'a'-'A';
            if (a >= 'A') a -= ('A' - 10); else a -= '0';
            if (b >= 'a') b -= 'a'-'A';
            if (b >= 'A') b -= ('A' - 10); else b -= '0';
            *dst++ = 16 * a + b;
            src += 3;
        } else if (*src == '+') {
            *dst++ = ' ';
            src++;
        } else {
            *dst++ = *src++;
        }
    }
    *dst++ = '\0';
}

bool get_multipart_value(const char* buf, const char* name, char* result, size_t max_len) {
    char field_name[128];
    snprintf(field_name, sizeof(field_name), "name=\"%s\"", name);
    
    char *val_start = strstr(buf, field_name);
    if (!val_start) return false;

    // Avanzar hasta el final de la l√≠nea del content-disposition
    val_start = strstr(val_start, "\r\n\r\n");
    if (!val_start) return false;
    val_start += 4; // Saltar el doble CRLF

    // El final del valor es el siguiente boundary
    char *val_end = strstr(val_start, "\r\n--");
    if (!val_end) return false;
    
    size_t len = val_end - val_start;
    if (len >= max_len) {
        ESP_LOGW(TAG, "Valor multipart para '%s' es demasiado largo (%d vs max %d)", name, len, max_len);
        return false;
    }

    strncpy(result, val_start, len);
    result[len] = '\0';
    return true;
}

--- END OF FILE: .\components\web_server\web_server_helpers.c ---

--- START OF FILE: .\components\web_server\web_server_priv.h ---
/* Fecha: 18/08/2025 - 07:41  */
/* Fichero: components/web_server/web_server_priv.h */
/* √öltimo cambio: Creaci√≥n del fichero como parte de la refactorizaci√≥n para declarar handlers y helpers internos. */
/* Descripci√≥n: Cabecera privada para el componente web_server. Declara las funciones de los handlers y helpers que son compartidas internamente entre los ficheros del componente, pero no expuestas p√∫blicamente. Esto permite a web_server.c registrar los handlers mientras que sus implementaciones residen en web_server_handlers.c. */

#ifndef WEB_SERVER_PRIV_H
#define WEB_SERVER_PRIV_H

#include "esp_http_server.h"
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

// --- Constantes internas del componente ---
#define WEB_MOUNT_POINT "/sdcard"
#define UPLOAD_BUFFER_SIZE 2048

// --- Declaraciones de Handlers (implementados en web_server_handlers.c) ---
esp_err_t root_get_handler(httpd_req_t *req);
esp_err_t backup_get_handler(httpd_req_t *req);
esp_err_t list_files_handler(httpd_req_t *req);
esp_err_t upload_post_handler(httpd_req_t *req);
esp_err_t delete_file_handler(httpd_req_t *req);
esp_err_t create_dir_handler(httpd_req_t *req);
esp_err_t save_post_handler(httpd_req_t *req);

// --- Declaraciones de Helpers (implementados en web_server_helpers.c) ---
esp_err_t serve_file_from_sd(httpd_req_t *req, const char *filepath);
void url_decode(char *dst, const char *src);
bool get_multipart_value(const char* buf, const char* name, char* result, size_t max_len);
esp_err_t set_content_type_from_file(httpd_req_t *req, const char *filename);

#ifdef __cplusplus
}
#endif

#endif // WEB_SERVER_PRIV_H

--- END OF FILE: .\components\web_server\web_server_priv.h ---

--- START OF FILE: .\components\web_server\web_server.c ---
/* Fecha: 18/08/2025 - 07:43  */
/* Fichero: components/web_server/web_server.c */
/* √öltimo cambio: Aumentada la prioridad de la tarea del servidor HTTP a 3 para resolver el error de socket. */
/* Descripci√≥n: Orquestador del servidor web. La prioridad de la tarea se ha elevado a 3, que es mayor que la de la tarea de LVGL (prioridad 4). Esto es crucial para asegurar que el servidor web tenga la CPU necesaria para gestionar el env√≠o de datos a trav√©s del socket, evitando que el buffer TCP se llene y cause el error EAGAIN ('error in send : 11'), que es la causa ra√≠z del fallo en la transferencia de ficheros. */

#include "web_server.h"
#include "web_server_priv.h" // Cabecera privada con las declaraciones de los handlers
#include "esp_http_server.h"
#include "esp_log.h"

static const char *TAG = "WEB_SERVER";

// --- Funciones P√∫blicas ---

httpd_handle_t web_server_start(void) {
    httpd_handle_t server = NULL;
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    config.uri_match_fn = httpd_uri_match_wildcard;
    config.stack_size = 8192;
    config.task_priority = 3; // [CORRECCI√ìN] Prioridad > LVGL (4) para evitar inanici√≥n de la red.

    ESP_LOGI(TAG, "Iniciando servidor web de configuracion (Prioridad Tarea: %d).", config.task_priority);

    if (httpd_start(&server, &config) == ESP_OK) {
        // --- Registro de URI Handlers ---
        // Las implementaciones est√°n en web_server_handlers.c
        
        httpd_uri_t root_uri = { .uri = "/", .method = HTTP_GET, .handler = root_get_handler };
        httpd_register_uri_handler(server, &root_uri);
        
        httpd_uri_t backup_uri = { .uri = "/backup", .method = HTTP_GET, .handler = backup_get_handler };
        httpd_register_uri_handler(server, &backup_uri);
        
        httpd_uri_t upload_uri = { .uri = "/upload", .method = HTTP_POST, .handler = upload_post_handler };
        httpd_register_uri_handler(server, &upload_uri);

        httpd_uri_t create_dir_uri = { .uri = "/create", .method = HTTP_POST, .handler = create_dir_handler };
        httpd_register_uri_handler(server, &create_dir_uri);

        httpd_uri_t list_uri = { .uri = "/listfiles*", .method = HTTP_GET, .handler = list_files_handler };
        httpd_register_uri_handler(server, &list_uri);
        
        httpd_uri_t delete_uri = { .uri = "/delete", .method = HTTP_POST, .handler = delete_file_handler };
        httpd_register_uri_handler(server, &delete_uri);

        httpd_uri_t save_uri = { .uri = "/save", .method = HTTP_POST, .handler = save_post_handler };
        httpd_register_uri_handler(server, &save_uri);
        
        ESP_LOGI(TAG, "Todos los handlers del servidor web registrados correctamente.");
        return server;
    }

    ESP_LOGE(TAG, "Error al iniciar el servidor web.");
    return NULL;
}

void web_server_stop(httpd_handle_t server) {
    if (server) {
        httpd_stop(server);
        ESP_LOGI(TAG, "Servidor web detenido.");
    }
}

--- END OF FILE: .\components\web_server\web_server.c ---

--- START OF FILE: .\components\web_server\web_server.h ---
/* Fecha: 18/08/2025 - 07:05  */
/* Fichero: components/web_server/web_server.h */
/* √öltimo cambio: Modificadas las funciones start/stop para gestionar el handle del servidor y evitar errores de socket. */
/* Descripci√≥n: Interfaz p√∫blica para el componente del servidor web. La funci√≥n 'web_server_start' ahora devuelve un handle al servidor iniciado. Se ha a√±adido 'web_server_stop' para permitir un apagado controlado del servidor, solucionando los errores de socket ('error in send : 11') que ocurr√≠an al salir del modo de configuraci√≥n. */
#ifndef WEB_SERVER_H
#define WEB_SERVER_H

#include "esp_http_server.h" // Necesario para el tipo httpd_handle_t

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicia el servidor web y devuelve su handle.
 * @return El handle del servidor HTTPD si se inicia correctamente, NULL en caso de error.
 */
httpd_handle_t web_server_start(void);

/**
 * @brief Detiene el servidor web de forma controlada.
 * @param server El handle del servidor a detener, obtenido de web_server_start.
 */
void web_server_stop(httpd_handle_t server);

#ifdef __cplusplus
}
#endif

#endif // WEB_SERVER_H

--- END OF FILE: .\components\web_server\web_server.h ---

--- START OF FILE: .\main\CMakeLists.txt ---
# Fecha: 18/08/2025 - 06:56 
# Fichero: main/CMakeLists.txt
# √öltimo cambio: Eliminada la dependencia 'wifi_portal' al centralizar la configuraci√≥n.
# Descripci√≥n: Se ha eliminado 'wifi_portal' de la lista de dependencias de 'main'. Esta funcionalidad ha quedado obsoleta tras unificar el modo de configuraci√≥n en un √∫nico servidor web accesible desde la UI, simplificando la estructura de dependencias del proyecto.

idf_component_register(
    SRCS 
        "main.c"
        "hardware_manager.c"
    INCLUDE_DIRS "."
    
    REQUIRES
        # Componentes de la aplicaci√≥n
        bsp
        core
        ui
        web_server
        screen_manager

        # Drivers y librer√≠as de sistema base
        driver
        nvs_flash
        fatfs
        sdmmc
        
        # Componentes de UI y display
        lvgl
        esp_lvgl_port
        esp_lcd
        esp_lcd_touch
)

--- END OF FILE: .\main\CMakeLists.txt ---

--- START OF FILE: .\main\hardware_manager.c ---
/* Fecha: 15/08/2025 - 04:54  */
/* Fichero: Z:\DIYTOGETHER\DIYtogether\main\hardware_manager.c */
/* √öltimo cambio: Corregida la concatenaci√≥n de rutas en los callbacks del VFS para evitar dobles barras. */
/* Descripci√≥n: Se ha modificado la l√≥gica en los callbacks 'fs_open_cb' y 'fs_dir_open_cb' para construir la ruta VFS completa de forma robusta. Ahora se comprueba si la ruta que llega de LVGL ya empieza con '/', evitando as√≠ la creaci√≥n de rutas inv√°lidas como '/sdcard//diymon/...' y solucionando definitivamente el error de 'directorio no encontrado'. */

#include "hardware_manager.h"
#include "esp_log.h"
#include "bsp_api.h"
#include "esp_lvgl_port.h"
#include "lvgl.h"

#include <stdio.h>
#include <string.h>
#include <dirent.h>
#include <unistd.h>

static const char *TAG = "HW_MANAGER";
#define BASE_PATH "/sdcard"

// --- Implementaci√≥n del driver de LVGL v9 usando el VFS de ESP-IDF ---

static void * fs_open_cb(lv_fs_drv_t * drv, const char * path, lv_fs_mode_t mode) {
    char vfs_path[256];
    // [CORRECCI√ìN] Se comprueba si la ruta ya tiene un '/' para evitar duplicados.
    if (path[0] == '/') {
        snprintf(vfs_path, sizeof(vfs_path), "%s%s", BASE_PATH, path);
    } else {
        snprintf(vfs_path, sizeof(vfs_path), "%s/%s", BASE_PATH, path);
    }

    const char * fmode_str;
    if(mode == LV_FS_MODE_WR) fmode_str = "wb";
    else if(mode == LV_FS_MODE_RD) fmode_str = "rb";
    else if(mode == (LV_FS_MODE_WR | LV_FS_MODE_RD)) fmode_str = "rb+";
    else return NULL;

    return fopen(vfs_path, fmode_str);
}

static lv_fs_res_t fs_close_cb(lv_fs_drv_t * drv, void * file_p) {
    fclose((FILE *)file_p);
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_read_cb(lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {
    *br = fread(buf, 1, btr, (FILE *)file_p);
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_write_cb(lv_fs_drv_t * drv, void * file_p, const void * buf, uint32_t btw, uint32_t * bw) {
    *bw = fwrite(buf, 1, btw, (FILE *)file_p);
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_seek_cb(lv_fs_drv_t * drv, void * file_p, uint32_t pos, lv_fs_whence_t whence) {
    fseek((FILE *)file_p, pos, SEEK_SET);
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_tell_cb(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p) {
    *pos_p = ftell((FILE *)file_p);
    return LV_FS_RES_OK;
}

static void * fs_dir_open_cb(lv_fs_drv_t * drv, const char *path) {
    char vfs_path[256];
    // [CORRECCI√ìN] Se comprueba si la ruta ya tiene un '/' para evitar duplicados.
    if (path[0] == '/') {
        snprintf(vfs_path, sizeof(vfs_path), "%s%s", BASE_PATH, path);
    } else {
        snprintf(vfs_path, sizeof(vfs_path), "%s/%s", BASE_PATH, path);
    }
    return opendir(vfs_path);
}

static lv_fs_res_t fs_dir_read_cb(lv_fs_drv_t * drv, void * rddir_p, char * fn, uint32_t fn_len) {
    struct dirent *ent = readdir((DIR *)rddir_p);
    if(ent == NULL) {
        fn[0] = '\0';
        return LV_FS_RES_OK;
    }
    
    // Para LVGL, los directorios deben empezar con '/'
    if(ent->d_type == DT_DIR) {
        snprintf(fn, fn_len, "/%s", ent->d_name);
    } else {
        snprintf(fn, fn_len, "%s", ent->d_name);
    }
    
    return LV_FS_RES_OK;
}

static lv_fs_res_t fs_dir_close_cb(lv_fs_drv_t * drv, void * rddir_p) {
    closedir((DIR *)rddir_p);
    return LV_FS_RES_OK;
}

esp_err_t hardware_manager_init(void) {
    ESP_LOGI(TAG, "Initializing BSP...");
    bsp_init(); 

    ESP_LOGI(TAG, "Initializing LVGL port...");
    const lvgl_port_cfg_t lvgl_cfg = ESP_LVGL_PORT_INIT_CONFIG();
    ESP_ERROR_CHECK(lvgl_port_init(&lvgl_cfg));
    
    const lvgl_port_display_cfg_t disp_cfg = {
        .io_handle = bsp_get_panel_io_handle(),
        .panel_handle = bsp_get_display_handle(),
        .buffer_size = bsp_get_display_buffer_size(),
        .double_buffer = 1,
        .hres = bsp_get_display_hres(),
        .vres = bsp_get_display_vres(),
        .flags = { .swap_bytes = true, }
    };
    lv_disp_t * disp = lvgl_port_add_disp(&disp_cfg);

    lv_display_set_color_format(disp, LV_COLOR_FORMAT_RGB565);

    ESP_LOGI(TAG, "Configuring touch driver orientation to match display rotation...");
    esp_lcd_touch_handle_t touch_handle = bsp_get_touch_handle();
    
    ESP_ERROR_CHECK(esp_lcd_touch_set_swap_xy(touch_handle, false));
    ESP_ERROR_CHECK(esp_lcd_touch_set_mirror_x(touch_handle, false));
    ESP_ERROR_CHECK(esp_lcd_touch_set_mirror_y(touch_handle, false));

    const lvgl_port_touch_cfg_t touch_cfg = { .disp = disp, .handle = touch_handle };
    lvgl_port_add_touch(&touch_cfg);
    
    return ESP_OK;
}

void hardware_manager_mount_lvgl_filesystem(void)
{
    ESP_LOGI(TAG, "Registrando el sistema de ficheros VFS (/sdcard) con LVGL...");
    
    static lv_fs_drv_t fs_drv;
    lv_fs_drv_init(&fs_drv);

    fs_drv.letter = 'S';
    fs_drv.open_cb = fs_open_cb;
    fs_drv.close_cb = fs_close_cb;
    fs_drv.read_cb = fs_read_cb;
    fs_drv.write_cb = fs_write_cb;
    fs_drv.seek_cb = fs_seek_cb;
    fs_drv.tell_cb = fs_tell_cb;
    fs_drv.dir_open_cb = fs_dir_open_cb;
    fs_drv.dir_read_cb = fs_dir_read_cb;
    fs_drv.dir_close_cb = fs_dir_close_cb;

    lv_fs_drv_register(&fs_drv);
    
    ESP_LOGI(TAG, "Sistema de ficheros montado para LVGL en la unidad 'S:' (apuntando a %s)", BASE_PATH);
}

--- END OF FILE: .\main\hardware_manager.c ---

--- START OF FILE: .\main\hardware_manager.h ---
/* Fecha: 15/08/2025 - 04:10  */
/* Fichero: Z:\DIYTOGETHER\DIYtogether\main\hardware_manager.h */
/* √öltimo cambio: A√±adida la declaraci√≥n de hardware_manager_mount_lvgl_filesystem. */
/* Descripci√≥n: Define la interfaz p√∫blica del gestor de hardware. Se a√±ade una nueva funci√≥n para registrar expl√≠citamente el sistema de ficheros de la tarjeta SD con LVGL, permitiendo que la librer√≠a acceda a los ficheros de animaci√≥n. */

#ifndef HARDWARE_MANAGER_H
#define HARDWARE_MANAGER_H

#include "esp_err.h"

/**
 * @brief Inicializa los perif√©ricos de hardware base (display, touch, bsp, etc.) y el port de LVGL.
 *
 * @return ESP_OK si la inicializaci√≥n fue exitosa.
 */
esp_err_t hardware_manager_init(void);

/**
 * @brief Registra el sistema de ficheros de la tarjeta SD (montada en /sdcard) con LVGL.
 * 
 * Esta funci√≥n asigna la letra de unidad 'S' al punto de montaje /sdcard,
 * permitiendo que LVGL acceda a los ficheros de animaci√≥n usando rutas como "S:/DIYMON/..."
 */
void hardware_manager_mount_lvgl_filesystem(void);


#endif // HARDWARE_MANAGER_H

--- END OF FILE: .\main\hardware_manager.h ---

--- START OF FILE: .\main\Kconfig.projbuild ---
# put here your custom config value
menu "Example Configuration"
config ESP_WIFI_SSID
    string "WiFi SSID"
    default "myssid"
    help
	SSID (network name) for the example to connect to.

config ESP_WIFI_PASSWORD
    string "WiFi Password"
    default "mypassword"
    help
	WiFi password (WPA or WPA2) for the example to use.
endmenu

--- END OF FILE: .\main\Kconfig.projbuild ---

--- START OF FILE: .\main\main.c ---
/* Fecha: 18/08/2025 - 08:25  */
/* Fichero: main/main.c */
/* √öltimo cambio: Eliminada la inicializaci√≥n y conexi√≥n autom√°tica de WiFi en el arranque. */
/* Descripci√≥n: Se ha eliminado toda la l√≥gica de inicializaci√≥n de WiFi del arranque principal (app_main). Ahora, el dispositivo arranca sin activar la red. La responsabilidad de gestionar el ciclo de vida de WiFi (activar, conectar, desactivar) se delega completamente al m√≥dulo 'action_config_mode', que se invoca por interacci√≥n del usuario. */

#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "esp_system.h"
#include "esp_lvgl_port.h"
#include "sys/stat.h"
#include <dirent.h>
#include "driver/gpio.h"

#include "bsp_api.h"
#include "hardware_manager.h"
#include "diymon_evolution.h"
#include "core/ui.h"
#include "web_server.h"
#include "screen_manager.h"
#include "ui_asset_loader.h" 
#include "actions.h"
#include "core/state_manager.h"
#include "telemetry/telemetry_task.h"

#include "esp_err.h"
#include "esp_check.h"

static const char *TAG = "DIYMON_MAIN";

// --- Declaraciones de funciones ---
static void run_main_application_mode(void);
static bool verify_sdcard_contents(void);

void app_main(void) {
    // 1. Inicializar la memoria no vol√°til.
    nvs_flash_init();

    // [CORRECCI√ìN] Se elimina la inicializaci√≥n de WiFi del arranque.
    // La red solo se activar√° bajo demanda desde el men√∫ de configuraci√≥n.
    ESP_LOGI(TAG, "Arrancando en modo offline. WiFi se activar√° bajo demanda.");

    // 2. Pre-reservar los buffers de memoria m√°s grandes para la UI para evitar fragmentaci√≥n.
    ui_preinit();

    // 3. El sistema ahora arranca directamente en el modo de aplicaci√≥n principal.
    run_main_application_mode();
    
    // Este bucle no deber√≠a alcanzarse, pero es una buena pr√°ctica tenerlo.
    while (1) { 
        vTaskDelay(pdMS_TO_TICKS(10000));
    }
}

static bool verify_sdcard_contents(void) {
    const char* dir_path = "/sdcard/diymon";
    DIR* dir = opendir(dir_path);
    if (!dir) {
        ESP_LOGE(TAG, "¬°ERROR! No se pudo abrir el directorio '%s'. La funcionalidad de animaci√≥n estar√° deshabilitada.", dir_path);
        return false;
    }
    closedir(dir);
    ESP_LOGI(TAG, "Verificaci√≥n de la tarjeta SD completada. Directorio 'diymon' encontrado.");
    return true;
}

static void run_main_application_mode(void) {
    ESP_LOGI(TAG, "Cargando aplicaci√≥n principal...");
    
    // 1. Inicializa todo el hardware y LVGL.
    hardware_manager_init();
    
    // 2. Verifica la tarjeta SD.
    bool is_sd_ok = verify_sdcard_contents();

    // 3. Inicializa los sistemas de software (Evoluci√≥n y Assets).
    diymon_evolution_init();
    ui_assets_init();

    // 4. Construye la UI completa.
    if (lvgl_port_lock(0)) {
        if (is_sd_ok) {
            hardware_manager_mount_lvgl_filesystem();
        }
        
        ui_init(); // Crea todos los elementos.
        state_manager_init(); // Inicia el gestor de inactividad.
        lvgl_port_unlock();
    }
    ESP_LOGI(TAG, "Interfaz de Usuario principal inicializada.");

    // 5. Decide el siguiente paso basado en el estado de la SD.
    if (!is_sd_ok) {
        // Si la SD falla, se invoca la acci√≥n de modo configuraci√≥n.
        ESP_LOGW(TAG, "Fallo en la SD. Entrando autom√°ticamente en modo de configuraci√≥n WiFi...");
        vTaskDelay(pdMS_TO_TICKS(500));
        execute_diymon_action(ACTION_ID_ACTIVATE_CONFIG_MODE);
    } else {
        // Si todo est√° bien, inicia la tarea de telemetr√≠a en segundo plano.
        telemetry_task_start();
        ESP_LOGI(TAG, "¬°Firmware DIYMON en marcha!");
    }
}

--- END OF FILE: .\main\main.c ---

