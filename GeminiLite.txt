
# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\CMakeLists.txt
# =================================================================================================

# The following lines of boilerplate have to be in your project's
# CMakeLists in this exact order for cmake to work correctly
cmake_minimum_required(VERSION 3.16)

# Le decimos al sistema que, adem√°s de 'components', tambi√©n busque herramientas en nuestro almac√©n local.
set(EXTRA_COMPONENT_DIRS components_dependencies)
add_compile_definitions(LVGL_VERSION_MAJOR=9)

include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(DIYTOGUETHER)

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\main.c
# =================================================================================================

#include <stdio.h>

#include "esp_err.h"
#include "esp_log.h"
#include "esp_check.h"

#include "nvs_flash.h"

#include "esp_lvgl_port.h"

#include "bsp_display.h"
#include "bsp_touch.h"
#include "bsp_i2c.h"
#include "bsp_spi.h"
#include "bsp_wifi.h"
#include "bsp_sdcard.h"
#include "bsp_battery.h"
#include "bsp_qmi8658.h"

#include "iot_button.h"
#include "button_gpio.h"

#include "demos/lv_demos.h"


#include "lvgl_ui.h"

#define EXAMPLE_DISPLAY_ROTATION 0

#if EXAMPLE_DISPLAY_ROTATION == 90 || EXAMPLE_DISPLAY_ROTATION == 270
#define EXAMPLE_LCD_H_RES (320)
#define EXAMPLE_LCD_V_RES (172)
#else
#define EXAMPLE_LCD_H_RES (172)
#define EXAMPLE_LCD_V_RES (320)
#endif

#define EXAMPLE_LCD_DRAW_BUFF_HEIGHT (50)
#define EXAMPLE_LCD_DRAW_BUFF_DOUBLE (1)


static char *TAG = "factory";

/* LCD IO and panel */
static esp_lcd_panel_io_handle_t io_handle = NULL;
static esp_lcd_panel_handle_t panel_handle = NULL;
static esp_lcd_touch_handle_t touch_handle = NULL;

/* LVGL display and touch */
static lv_display_t *lvgl_disp = NULL;
static lv_indev_t *lvgl_touch_indev = NULL;


void lv_fs_fatfs_init(void);
static esp_err_t app_lvgl_init(void);
static void button_init(void);
static void touch_test(void);

void app_main(void)
{
    i2c_master_bus_handle_t i2c_bus_handle;
    // Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    i2c_bus_handle = bsp_i2c_init();
    bsp_spi_init();

    bsp_battery_init();
    bsp_qmi8658_init(i2c_bus_handle);
    bsp_wifi_init("WSTEST", "waveshare0755");
    bsp_display_init(&io_handle, &panel_handle, EXAMPLE_LCD_H_RES * EXAMPLE_LCD_DRAW_BUFF_HEIGHT);
    bsp_touch_init(&touch_handle, i2c_bus_handle, EXAMPLE_LCD_H_RES, EXAMPLE_LCD_V_RES, EXAMPLE_DISPLAY_ROTATION);
    bsp_sdcard_init();
    ESP_ERROR_CHECK(app_lvgl_init());
    lv_fs_fatfs_init();


    bsp_display_brightness_init();
    bsp_display_set_brightness(100);

    button_init();
    touch_test();


    if (lvgl_port_lock(0))
    {
        // lv_demo_benchmark();
        // lv_demo_music();
        // lv_demo_widgets();
        lvgl_ui_init();
        lvgl_port_unlock();
    }
}

static esp_err_t app_lvgl_init(void)
{
    /* Initialize LVGL */
    const lvgl_port_cfg_t lvgl_cfg = {
        .task_priority = 4,       /* LVGL task priority */
        .task_stack = 1024 * 10,  /* LVGL task stack size */
        .task_affinity = -1,      /* LVGL task pinned to core (-1 is no affinity) */
        .task_max_sleep_ms = 500, /* Maximum sleep in LVGL task */
        .timer_period_ms = 5      /* LVGL timer tick period in ms */
    };
    ESP_RETURN_ON_ERROR(lvgl_port_init(&lvgl_cfg), TAG, "LVGL port initialization failed");

    /* Add LCD screen */
    ESP_LOGD(TAG, "Add LCD screen");
    lvgl_port_display_cfg_t disp_cfg = {
        .io_handle = io_handle,
        .panel_handle = panel_handle,
        .buffer_size = EXAMPLE_LCD_H_RES * EXAMPLE_LCD_DRAW_BUFF_HEIGHT,
        .double_buffer = EXAMPLE_LCD_DRAW_BUFF_DOUBLE,
        .hres = EXAMPLE_LCD_H_RES,
        .vres = EXAMPLE_LCD_V_RES,
        .monochrome = false,
        /* Rotation values must be same as used in esp_lcd for initial settings of the screen */
        .rotation = {
            .swap_xy = false,
            .mirror_x = false,
            .mirror_y = false,
        },
        .flags = {
            .buff_dma = true,
        }};
#if EXAMPLE_DISPLAY_ROTATION == 90
    disp_cfg.rotation.swap_xy = true;
    disp_cfg.rotation.mirror_x = true;
    disp_cfg.rotation.mirror_y = false;
    ESP_ERROR_CHECK(esp_lcd_panel_set_gap(panel_handle, 0, 34));
#elif EXAMPLE_DISPLAY_ROTATION == 180
    disp_cfg.rotation.swap_xy = false;
    disp_cfg.rotation.mirror_x = true;
    disp_cfg.rotation.mirror_y = true;
    ESP_ERROR_CHECK(esp_lcd_panel_set_gap(panel_handle, 34, 0));
#elif EXAMPLE_DISPLAY_ROTATION == 270
    disp_cfg.rotation.swap_xy = true;
    disp_cfg.rotation.mirror_x = false;
    disp_cfg.rotation.mirror_y = true;
    ESP_ERROR_CHECK(esp_lcd_panel_set_gap(panel_handle, 0, 34));
#else
    ESP_ERROR_CHECK(esp_lcd_panel_set_gap(panel_handle, 34, 0));
#endif
    lvgl_disp = lvgl_port_add_disp(&disp_cfg);

    /* Add touch input (for selected screen) */
    const lvgl_port_touch_cfg_t touch_cfg = {
        .disp = lvgl_disp,
        .handle = touch_handle,
    };
    lvgl_touch_indev = lvgl_port_add_touch(&touch_cfg);

    return ESP_OK;
}



static bool touch_test_done = false;


static void button_event_cb(void *arg, void *data)
{
    button_event_t event = iot_button_get_event((button_handle_t)arg);
    ESP_LOGI(TAG, "%s", iot_button_get_event_str(event));
    touch_test_done = true;
}

static void button_init(void)
{
    button_config_t btn_cfg = {};
    button_gpio_config_t btn_gpio_cfg = {};
    btn_gpio_cfg.gpio_num = GPIO_NUM_9;
    btn_gpio_cfg.active_level = 0;
    static button_handle_t btn = NULL;
    ESP_ERROR_CHECK(iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &btn));
    iot_button_register_cb(btn, BUTTON_SINGLE_CLICK, NULL, button_event_cb, NULL);
    // iot_button_register_cb(btn, BUTTON_LONG_PRESS_START, NULL, button_event_cb, NULL);
    // iot_button_register_cb(btn, BUTTON_LONG_PRESS_HOLD, NULL, button_event_cb, NULL);
    // iot_button_register_cb(btn, BUTTON_LONG_PRESS_UP, NULL, button_event_cb, NULL);
    // iot_button_register_cb(btn, BUTTON_PRESS_END, NULL, button_event_cb, NULL);
}

static void touch_test(void)
{
    uint16_t touchpad_x[1] = {0};
    uint16_t touchpad_y[1] = {0};
    uint8_t touchpad_cnt = 0;
    uint16_t color_arr[16] = {0};
    lv_obj_t *lable = NULL;

    for (int i = 0; i < 16; i++)
    {
        color_arr[i] = 0xf800;
    }
    if (lvgl_port_lock(0))
    {
        lable = lv_label_create(lv_scr_act());
        lv_label_set_text(lable, "Touch testing mode \nExit with BOOT button");
        lv_obj_center(lable);
        lvgl_port_unlock();
    }
    vTaskDelay(pdMS_TO_TICKS(500));
    if (lvgl_port_lock(0))
    {
        while (!touch_test_done)
        {
            /* Read data from touch controller into memory */
            esp_lcd_touch_read_data(touch_handle);

            /* Read data from touch controller */
            bool touchpad_pressed = esp_lcd_touch_get_coordinates(touch_handle, touchpad_x, touchpad_y, NULL, &touchpad_cnt, 1);
            if (touchpad_pressed && touchpad_cnt > 0)
            {
                // touchpad_x[0] = EXAMPLE_LCD_H_RES - 1 - touchpad_x[0];

                if (touchpad_x[0] < 2)
                    touchpad_x[0] = 2;
                else if (touchpad_x[0] > EXAMPLE_LCD_H_RES - 2 - 1)
                    touchpad_x[0] = EXAMPLE_LCD_H_RES - 2 - 1;

                if (touchpad_y[0] < 2)
                    touchpad_y[0] = 2;
                else if (touchpad_y[0] > EXAMPLE_LCD_V_RES - 2 - 1)
                    touchpad_y[0] = EXAMPLE_LCD_V_RES - 2 - 1;

                esp_lcd_panel_draw_bitmap(panel_handle, touchpad_x[0] - 2, touchpad_y[0] - 2, touchpad_x[0] + 2, touchpad_y[0] + 2, color_arr);
            }
            vTaskDelay(pdMS_TO_TICKS(10));
        }
        lv_obj_del(lable);
        lvgl_port_unlock();
    }
    
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\partitions.csv
# =================================================================================================

# Name,   Type, SubType, Offset,  Size, Flags
nvs,      data, nvs,     0x9000,  0x6000,
phy_init, data, phy,     0xf000,  0x1000,
factory,  app,  factory, 0x10000, 6M,

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\README.md
# =================================================================================================

# DIYTogether - Tu Mascota Virtual DIY

![Ilustraci√≥n de DIYTogether en acci√≥n]([Link a git3.png])

**DIYTogether** no es solo un gadget. Es una aventura de aprendizaje, una puerta a la creatividad y una excusa para construir algo incre√≠ble con las personas que te importan.

## La Historia detr√°s de DIYTogether

Constantemente sue√±o despierto.

Fantaseo con ser *"ese t√≠o guay"* para mis sobrinos, el que les ense√±a a crear, a entender la tecnolog√≠a, a jugar con la electr√≥nica y la dom√≥tica. Quer√≠a construir algo que nos uniera, un juego que les apasionara y despertara su curiosidad por dentro. Una excusa perfecta para aprender divirti√©ndose y pasar tiempo de calidad juntos.

De esa idea nace **DIYTogether**.

Un proyecto que empez√≥ con mis mejores amigos y que ahora abro al mundo, invitando a todo aquel que quiera unirse a crear una tecnolog√≠a con alma.

---

## ¬øQu√© es DIYTogether?

DIYTogether es un proyecto de mascota virtual open-source basada en hardware ESP32. Es un **"Tamagotchi para Hackers"** dise√±ado desde cero para ser:

*   üé® **Personalizable**: Crea y carga tus propios "Skins" (gr√°ficos, animaciones y sonidos) sin necesidad de reprogramar nada. ¬°Haz tu DIYTogether verdaderamente tuyo!
*   üß† **Educativo**: Aprende electr√≥nica, programaci√≥n (C++/Arduino) y conectividad IoT de una forma pr√°ctica y progresiva. Cada paso es una lecci√≥n, y los errores son parte del viaje.
*   üåç **Interactivo**: Utiliza sensores como el aceler√≥metro y la conectividad Bluetooth para interactuar con tu criatura de formas nuevas y creativas.
*   ‚ù§Ô∏è **Abierto y Comunitario**: Todo el proyecto (firmware, hardware, dise√±os 3D) es libre. Queremos que lo copies, lo modifiques, lo mejores y lo compartas.

![Variedad de colores y criaturas DIYTogether]([Link a git2.png])

---

## Caracter√≠sticas Principales

*   **Hardware**: Basado en la placa Waveshare ESP32-S3-Touch-LCD-1.28 (o hardware similar).
*   **Firmware**: Escrito en C++ con el framework de Arduino para ESP32.
*   **Sistema de Evoluci√≥n Modular**: Las criaturas evolucionan seg√∫n tus cuidados, el entorno e interacciones.
*   **Licencias**:
    *   **C√≥digo**: `GPLv3` - ¬°Libre para siempre!
    *   **Dise√±os de la carcasa**: `CC BY-NC` - ¬°Comp√°rtela, pero no para uso comercial sin permiso!

![Prototipo de DIYTogether con interfaz hologr√°fica]([Link a git1.png])

---

### Estado Actual del Proyecto
> *Nota: Esta secci√≥n se actualizar√° con los avances.*

*   ‚úÖ Prototipo funcional con interacciones b√°sicas (alimentar, entrenar, limpiar).
*   ‚úÖ Sistema de skins din√°micas implementado.
*   üöß Trabajando en la conectividad Bluetooth con la App de soporte (FIYNDEX).
*   üí° Planeando una campa√±a de Kickstarter para ofrecer kits DIY asequibles.

---

## ¬øC√≥mo puedes empezar?

*(Esta secci√≥n se ir√° completando con gu√≠as detalladas)*

1.  **Monta tu propio DIYTogether**: `[Enlace a la Wiki con la lista de componentes y gu√≠a de montaje]`
2.  **Flashea el Firmware**: Sigue las instrucciones de nuestra `[Gu√≠a de instalaci√≥n]`.
3.  **Dise√±a tu Skin**: ¬°Aprende a crear tus propios gr√°ficos y personaliza tu experiencia! `[Enlace a la gu√≠a de creaci√≥n de skins]`

*(Aqu√≠ puedes poner un GIF animado de tu prototipo funcionando. ¬°Esto es s√∫per efectivo!)*
`![alt text](ruta/a/tu/gif/animado.gif)`

---

## ¬°√önete a la Comunidad!

Este proyecto vive gracias a gente como t√∫. Si te gusta la idea, ¬°invol√∫crate!

*   ‚≠ê **Dale una estrella a este repositorio**: ¬°Nos ayuda a ganar visibilidad!
*   üí¨ **√önete a nuestro canal de Discord/Telegram**: El mejor lugar para charlar, pedir ayuda y compartir tus creaciones.
*   üí° **Aporta ideas o reporta bugs**: Abre un "Issue" aqu√≠ en GitHub.
*   üöÄ **Contribuye con c√≥digo o dise√±os**: ¬°Los Pull Requests son bienvenidos! Revisa nuestra `[gu√≠a de contribuci√≥n]`.

Gracias por tu apoyo y por creer en un proyecto hecho con cari√±o y curiosidad.


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\sdkconfig
# =================================================================================================

#
# Automatically generated file. DO NOT EDIT.
# Espressif IoT Development Framework (ESP-IDF) 5.5.0 Project Configuration
#
CONFIG_SOC_ADC_SUPPORTED=y
CONFIG_SOC_DEDICATED_GPIO_SUPPORTED=y
CONFIG_SOC_UART_SUPPORTED=y
CONFIG_SOC_UHCI_SUPPORTED=y
CONFIG_SOC_GDMA_SUPPORTED=y
CONFIG_SOC_AHB_GDMA_SUPPORTED=y
CONFIG_SOC_GPTIMER_SUPPORTED=y
CONFIG_SOC_PCNT_SUPPORTED=y
CONFIG_SOC_MCPWM_SUPPORTED=y
CONFIG_SOC_TWAI_SUPPORTED=y
CONFIG_SOC_ETM_SUPPORTED=y
CONFIG_SOC_PARLIO_SUPPORTED=y
CONFIG_SOC_BT_SUPPORTED=y
CONFIG_SOC_IEEE802154_SUPPORTED=y
CONFIG_SOC_ASYNC_MEMCPY_SUPPORTED=y
CONFIG_SOC_USB_SERIAL_JTAG_SUPPORTED=y
CONFIG_SOC_TEMP_SENSOR_SUPPORTED=y
CONFIG_SOC_PHY_SUPPORTED=y
CONFIG_SOC_WIFI_SUPPORTED=y
CONFIG_SOC_SUPPORTS_SECURE_DL_MODE=y
CONFIG_SOC_ULP_SUPPORTED=y
CONFIG_SOC_LP_CORE_SUPPORTED=y
CONFIG_SOC_EFUSE_KEY_PURPOSE_FIELD=y
CONFIG_SOC_EFUSE_SUPPORTED=y
CONFIG_SOC_RTC_FAST_MEM_SUPPORTED=y
CONFIG_SOC_RTC_MEM_SUPPORTED=y
CONFIG_SOC_I2S_SUPPORTED=y
CONFIG_SOC_RMT_SUPPORTED=y
CONFIG_SOC_SDM_SUPPORTED=y
CONFIG_SOC_GPSPI_SUPPORTED=y
CONFIG_SOC_LEDC_SUPPORTED=y
CONFIG_SOC_I2C_SUPPORTED=y
CONFIG_SOC_SYSTIMER_SUPPORTED=y
CONFIG_SOC_SUPPORT_COEXISTENCE=y
CONFIG_SOC_AES_SUPPORTED=y
CONFIG_SOC_MPI_SUPPORTED=y
CONFIG_SOC_SHA_SUPPORTED=y
CONFIG_SOC_HMAC_SUPPORTED=y
CONFIG_SOC_DIG_SIGN_SUPPORTED=y
CONFIG_SOC_ECC_SUPPORTED=y
CONFIG_SOC_FLASH_ENC_SUPPORTED=y
CONFIG_SOC_SECURE_BOOT_SUPPORTED=y
CONFIG_SOC_SDIO_SLAVE_SUPPORTED=y
CONFIG_SOC_BOD_SUPPORTED=y
CONFIG_SOC_APM_SUPPORTED=y
CONFIG_SOC_PMU_SUPPORTED=y
CONFIG_SOC_PAU_SUPPORTED=y
CONFIG_SOC_LP_TIMER_SUPPORTED=y
CONFIG_SOC_LP_AON_SUPPORTED=y
CONFIG_SOC_LP_PERIPHERALS_SUPPORTED=y
CONFIG_SOC_LP_I2C_SUPPORTED=y
CONFIG_SOC_ULP_LP_UART_SUPPORTED=y
CONFIG_SOC_CLK_TREE_SUPPORTED=y
CONFIG_SOC_ASSIST_DEBUG_SUPPORTED=y
CONFIG_SOC_WDT_SUPPORTED=y
CONFIG_SOC_SPI_FLASH_SUPPORTED=y
CONFIG_SOC_RNG_SUPPORTED=y
CONFIG_SOC_LIGHT_SLEEP_SUPPORTED=y
CONFIG_SOC_DEEP_SLEEP_SUPPORTED=y
CONFIG_SOC_MODEM_CLOCK_SUPPORTED=y
CONFIG_SOC_PM_SUPPORTED=y
CONFIG_SOC_XTAL_SUPPORT_40M=y
CONFIG_SOC_XTAL_CLOCK_PATH_DEPENDS_ON_TOP_DOMAIN=y
CONFIG_SOC_AES_SUPPORT_DMA=y
CONFIG_SOC_AES_GDMA=y
CONFIG_SOC_AES_SUPPORT_AES_128=y
CONFIG_SOC_AES_SUPPORT_AES_256=y
CONFIG_SOC_ADC_DIG_CTRL_SUPPORTED=y
CONFIG_SOC_ADC_DIG_IIR_FILTER_SUPPORTED=y
CONFIG_SOC_ADC_MONITOR_SUPPORTED=y
CONFIG_SOC_ADC_DMA_SUPPORTED=y
CONFIG_SOC_ADC_PERIPH_NUM=1
CONFIG_SOC_ADC_MAX_CHANNEL_NUM=7
CONFIG_SOC_ADC_ATTEN_NUM=4
CONFIG_SOC_ADC_DIGI_CONTROLLER_NUM=1
CONFIG_SOC_ADC_PATT_LEN_MAX=8
CONFIG_SOC_ADC_DIGI_MAX_BITWIDTH=12
CONFIG_SOC_ADC_DIGI_MIN_BITWIDTH=12
CONFIG_SOC_ADC_DIGI_IIR_FILTER_NUM=2
CONFIG_SOC_ADC_DIGI_MONITOR_NUM=2
CONFIG_SOC_ADC_DIGI_RESULT_BYTES=4
CONFIG_SOC_ADC_DIGI_DATA_BYTES_PER_CONV=4
CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_HIGH=83333
CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_LOW=611
CONFIG_SOC_ADC_RTC_MIN_BITWIDTH=12
CONFIG_SOC_ADC_RTC_MAX_BITWIDTH=12
CONFIG_SOC_ADC_CALIBRATION_V1_SUPPORTED=y
CONFIG_SOC_ADC_SELF_HW_CALI_SUPPORTED=y
CONFIG_SOC_ADC_CALIB_CHAN_COMPENS_SUPPORTED=y
CONFIG_SOC_ADC_TEMPERATURE_SHARE_INTR=y
CONFIG_SOC_ADC_SHARED_POWER=y
CONFIG_SOC_BROWNOUT_RESET_SUPPORTED=y
CONFIG_SOC_SHARED_IDCACHE_SUPPORTED=y
CONFIG_SOC_CACHE_FREEZE_SUPPORTED=y
CONFIG_SOC_CPU_CORES_NUM=1
CONFIG_SOC_CPU_INTR_NUM=32
CONFIG_SOC_CPU_HAS_FLEXIBLE_INTC=y
CONFIG_SOC_INT_PLIC_SUPPORTED=y
CONFIG_SOC_CPU_HAS_CSR_PC=y
CONFIG_SOC_CPU_BREAKPOINTS_NUM=4
CONFIG_SOC_CPU_WATCHPOINTS_NUM=4
CONFIG_SOC_CPU_WATCHPOINT_MAX_REGION_SIZE=0x80000000
CONFIG_SOC_CPU_HAS_PMA=y
CONFIG_SOC_CPU_IDRAM_SPLIT_USING_PMP=y
CONFIG_SOC_CPU_PMP_REGION_GRANULARITY=4
CONFIG_SOC_DS_SIGNATURE_MAX_BIT_LEN=3072
CONFIG_SOC_DS_KEY_PARAM_MD_IV_LENGTH=16
CONFIG_SOC_DS_KEY_CHECK_MAX_WAIT_US=1100
CONFIG_SOC_AHB_GDMA_VERSION=1
CONFIG_SOC_GDMA_NUM_GROUPS_MAX=1
CONFIG_SOC_GDMA_PAIRS_PER_GROUP_MAX=3
CONFIG_SOC_GDMA_SUPPORT_ETM=y
CONFIG_SOC_GDMA_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_ETM_GROUPS=1
CONFIG_SOC_ETM_CHANNELS_PER_GROUP=50
CONFIG_SOC_ETM_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_GPIO_PORT=1
CONFIG_SOC_GPIO_PIN_COUNT=31
CONFIG_SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER=y
CONFIG_SOC_GPIO_FLEX_GLITCH_FILTER_NUM=8
CONFIG_SOC_GPIO_SUPPORT_ETM=y
CONFIG_SOC_GPIO_SUPPORT_RTC_INDEPENDENT=y
CONFIG_SOC_GPIO_SUPPORT_DEEPSLEEP_WAKEUP=y
CONFIG_SOC_LP_IO_CLOCK_IS_INDEPENDENT=y
CONFIG_SOC_GPIO_IN_RANGE_MAX=30
CONFIG_SOC_GPIO_OUT_RANGE_MAX=30
CONFIG_SOC_GPIO_DEEP_SLEEP_WAKE_VALID_GPIO_MASK=0
CONFIG_SOC_GPIO_DEEP_SLEEP_WAKE_SUPPORTED_PIN_CNT=8
CONFIG_SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK=0x000000007FFFFF00
CONFIG_SOC_GPIO_SUPPORT_FORCE_HOLD=y
CONFIG_SOC_GPIO_SUPPORT_HOLD_IO_IN_DSLP=y
CONFIG_SOC_GPIO_SUPPORT_HOLD_SINGLE_IO_IN_DSLP=y
CONFIG_SOC_GPIO_CLOCKOUT_BY_GPIO_MATRIX=y
CONFIG_SOC_CLOCKOUT_HAS_SOURCE_GATE=y
CONFIG_SOC_GPIO_CLOCKOUT_CHANNEL_NUM=3
CONFIG_SOC_RTCIO_PIN_COUNT=8
CONFIG_SOC_RTCIO_INPUT_OUTPUT_SUPPORTED=y
CONFIG_SOC_RTCIO_HOLD_SUPPORTED=y
CONFIG_SOC_RTCIO_WAKE_SUPPORTED=y
CONFIG_SOC_RTCIO_EDGE_WAKE_SUPPORTED=y
CONFIG_SOC_DEDIC_GPIO_OUT_CHANNELS_NUM=8
CONFIG_SOC_DEDIC_GPIO_IN_CHANNELS_NUM=8
CONFIG_SOC_DEDIC_PERIPH_ALWAYS_ENABLE=y
CONFIG_SOC_I2C_NUM=2
CONFIG_SOC_HP_I2C_NUM=1
CONFIG_SOC_I2C_FIFO_LEN=32
CONFIG_SOC_I2C_CMD_REG_NUM=8
CONFIG_SOC_I2C_SUPPORT_SLAVE=y
CONFIG_SOC_I2C_SUPPORT_HW_FSM_RST=y
CONFIG_SOC_I2C_SUPPORT_HW_CLR_BUS=y
CONFIG_SOC_I2C_SUPPORT_XTAL=y
CONFIG_SOC_I2C_SUPPORT_RTC=y
CONFIG_SOC_I2C_SUPPORT_10BIT_ADDR=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_BROADCAST=y
CONFIG_SOC_I2C_SLAVE_CAN_GET_STRETCH_CAUSE=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_I2CRAM_ACCESS=y
CONFIG_SOC_I2C_SLAVE_SUPPORT_SLAVE_UNMATCH=y
CONFIG_SOC_I2C_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_LP_I2C_NUM=1
CONFIG_SOC_LP_I2C_FIFO_LEN=16
CONFIG_SOC_I2S_NUM=1
CONFIG_SOC_I2S_HW_VERSION_2=y
CONFIG_SOC_I2S_SUPPORTS_ETM=y
CONFIG_SOC_I2S_SUPPORTS_XTAL=y
CONFIG_SOC_I2S_SUPPORTS_PLL_F160M=y
CONFIG_SOC_I2S_SUPPORTS_PCM=y
CONFIG_SOC_I2S_SUPPORTS_PDM=y
CONFIG_SOC_I2S_SUPPORTS_PDM_TX=y
CONFIG_SOC_I2S_SUPPORTS_PCM2PDM=y
CONFIG_SOC_I2S_SUPPORTS_PDM_RX=y
CONFIG_SOC_I2S_PDM_MAX_TX_LINES=2
CONFIG_SOC_I2S_PDM_MAX_RX_LINES=1
CONFIG_SOC_I2S_SUPPORTS_TDM=y
CONFIG_SOC_I2S_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_LEDC_SUPPORT_PLL_DIV_CLOCK=y
CONFIG_SOC_LEDC_SUPPORT_XTAL_CLOCK=y
CONFIG_SOC_LEDC_TIMER_NUM=4
CONFIG_SOC_LEDC_CHANNEL_NUM=6
CONFIG_SOC_LEDC_TIMER_BIT_WIDTH=20
CONFIG_SOC_LEDC_SUPPORT_FADE_STOP=y
CONFIG_SOC_LEDC_GAMMA_CURVE_FADE_SUPPORTED=y
CONFIG_SOC_LEDC_GAMMA_CURVE_FADE_RANGE_MAX=16
CONFIG_SOC_LEDC_FADE_PARAMS_BIT_WIDTH=10
CONFIG_SOC_LEDC_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MMU_PAGE_SIZE_CONFIGURABLE=y
CONFIG_SOC_MMU_PAGE_SIZE_8KB_SUPPORTED=y
CONFIG_SOC_MMU_PERIPH_NUM=1
CONFIG_SOC_MMU_LINEAR_ADDRESS_REGION_NUM=1
CONFIG_SOC_MMU_DI_VADDR_SHARED=y
CONFIG_SOC_MPU_MIN_REGION_SIZE=0x20000000
CONFIG_SOC_MPU_REGIONS_MAX_NUM=8
CONFIG_SOC_PCNT_GROUPS=1
CONFIG_SOC_PCNT_UNITS_PER_GROUP=4
CONFIG_SOC_PCNT_CHANNELS_PER_UNIT=2
CONFIG_SOC_PCNT_THRES_POINT_PER_UNIT=2
CONFIG_SOC_PCNT_SUPPORT_RUNTIME_THRES_UPDATE=y
CONFIG_SOC_PCNT_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_RMT_GROUPS=1
CONFIG_SOC_RMT_TX_CANDIDATES_PER_GROUP=2
CONFIG_SOC_RMT_RX_CANDIDATES_PER_GROUP=2
CONFIG_SOC_RMT_CHANNELS_PER_GROUP=4
CONFIG_SOC_RMT_MEM_WORDS_PER_CHANNEL=48
CONFIG_SOC_RMT_SUPPORT_RX_PINGPONG=y
CONFIG_SOC_RMT_SUPPORT_RX_DEMODULATION=y
CONFIG_SOC_RMT_SUPPORT_TX_ASYNC_STOP=y
CONFIG_SOC_RMT_SUPPORT_TX_LOOP_COUNT=y
CONFIG_SOC_RMT_SUPPORT_TX_LOOP_AUTO_STOP=y
CONFIG_SOC_RMT_SUPPORT_TX_SYNCHRO=y
CONFIG_SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY=y
CONFIG_SOC_RMT_SUPPORT_XTAL=y
CONFIG_SOC_RMT_SUPPORT_RC_FAST=y
CONFIG_SOC_RMT_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MCPWM_GROUPS=1
CONFIG_SOC_MCPWM_TIMERS_PER_GROUP=3
CONFIG_SOC_MCPWM_OPERATORS_PER_GROUP=3
CONFIG_SOC_MCPWM_COMPARATORS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_GENERATORS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_TRIGGERS_PER_OPERATOR=2
CONFIG_SOC_MCPWM_GPIO_FAULTS_PER_GROUP=3
CONFIG_SOC_MCPWM_CAPTURE_TIMERS_PER_GROUP=y
CONFIG_SOC_MCPWM_CAPTURE_CHANNELS_PER_TIMER=3
CONFIG_SOC_MCPWM_GPIO_SYNCHROS_PER_GROUP=3
CONFIG_SOC_MCPWM_SWSYNC_CAN_PROPAGATE=y
CONFIG_SOC_MCPWM_SUPPORT_ETM=y
CONFIG_SOC_MCPWM_CAPTURE_CLK_FROM_GROUP=y
CONFIG_SOC_MCPWM_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_PARLIO_GROUPS=1
CONFIG_SOC_PARLIO_TX_UNITS_PER_GROUP=1
CONFIG_SOC_PARLIO_RX_UNITS_PER_GROUP=1
CONFIG_SOC_PARLIO_TX_UNIT_MAX_DATA_WIDTH=16
CONFIG_SOC_PARLIO_RX_UNIT_MAX_DATA_WIDTH=16
CONFIG_SOC_PARLIO_TX_RX_SHARE_INTERRUPT=y
CONFIG_SOC_PARLIO_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MPI_MEM_BLOCKS_NUM=4
CONFIG_SOC_MPI_OPERATIONS_NUM=3
CONFIG_SOC_RSA_MAX_BIT_LEN=3072
CONFIG_SOC_SHA_DMA_MAX_BUFFER_SIZE=3968
CONFIG_SOC_SHA_SUPPORT_DMA=y
CONFIG_SOC_SHA_SUPPORT_RESUME=y
CONFIG_SOC_SHA_GDMA=y
CONFIG_SOC_SHA_SUPPORT_SHA1=y
CONFIG_SOC_SHA_SUPPORT_SHA224=y
CONFIG_SOC_SHA_SUPPORT_SHA256=y
CONFIG_SOC_SDM_GROUPS=1
CONFIG_SOC_SDM_CHANNELS_PER_GROUP=4
CONFIG_SOC_SDM_CLK_SUPPORT_PLL_F80M=y
CONFIG_SOC_SDM_CLK_SUPPORT_XTAL=y
CONFIG_SOC_SPI_PERIPH_NUM=2
CONFIG_SOC_SPI_MAX_CS_NUM=6
CONFIG_SOC_SPI_MAXIMUM_BUFFER_SIZE=64
CONFIG_SOC_SPI_SUPPORT_DDRCLK=y
CONFIG_SOC_SPI_SLAVE_SUPPORT_SEG_TRANS=y
CONFIG_SOC_SPI_SUPPORT_CD_SIG=y
CONFIG_SOC_SPI_SUPPORT_CONTINUOUS_TRANS=y
CONFIG_SOC_SPI_SUPPORT_SLAVE_HD_VER2=y
CONFIG_SOC_SPI_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_SPI_SUPPORT_CLK_XTAL=y
CONFIG_SOC_SPI_SUPPORT_CLK_PLL_F80M=y
CONFIG_SOC_SPI_SUPPORT_CLK_RC_FAST=y
CONFIG_SOC_SPI_SCT_SUPPORTED=y
CONFIG_SOC_SPI_SCT_REG_NUM=14
CONFIG_SOC_SPI_SCT_BUFFER_NUM_MAX=y
CONFIG_SOC_SPI_SCT_CONF_BITLEN_MAX=0x3FFFA
CONFIG_SOC_MEMSPI_IS_INDEPENDENT=y
CONFIG_SOC_SPI_MAX_PRE_DIVIDER=16
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE=y
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND=y
CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_RESUME=y
CONFIG_SOC_SPI_MEM_SUPPORT_IDLE_INTR=y
CONFIG_SOC_SPI_MEM_SUPPORT_SW_SUSPEND=y
CONFIG_SOC_SPI_MEM_SUPPORT_CHECK_SUS=y
CONFIG_SOC_SPI_MEM_SUPPORT_WRAP=y
CONFIG_SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED=y
CONFIG_SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED=y
CONFIG_SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED=y
CONFIG_SOC_SYSTIMER_COUNTER_NUM=2
CONFIG_SOC_SYSTIMER_ALARM_NUM=3
CONFIG_SOC_SYSTIMER_BIT_WIDTH_LO=32
CONFIG_SOC_SYSTIMER_BIT_WIDTH_HI=20
CONFIG_SOC_SYSTIMER_FIXED_DIVIDER=y
CONFIG_SOC_SYSTIMER_SUPPORT_RC_FAST=y
CONFIG_SOC_SYSTIMER_INT_LEVEL=y
CONFIG_SOC_SYSTIMER_ALARM_MISS_COMPENSATE=y
CONFIG_SOC_SYSTIMER_SUPPORT_ETM=y
CONFIG_SOC_LP_TIMER_BIT_WIDTH_LO=32
CONFIG_SOC_LP_TIMER_BIT_WIDTH_HI=16
CONFIG_SOC_TIMER_GROUPS=2
CONFIG_SOC_TIMER_GROUP_TIMERS_PER_GROUP=1
CONFIG_SOC_TIMER_GROUP_COUNTER_BIT_WIDTH=54
CONFIG_SOC_TIMER_GROUP_SUPPORT_XTAL=y
CONFIG_SOC_TIMER_GROUP_SUPPORT_RC_FAST=y
CONFIG_SOC_TIMER_GROUP_TOTAL_TIMERS=2
CONFIG_SOC_TIMER_SUPPORT_ETM=y
CONFIG_SOC_TIMER_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_MWDT_SUPPORT_XTAL=y
CONFIG_SOC_MWDT_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_TWAI_CONTROLLER_NUM=2
CONFIG_SOC_TWAI_MASK_FILTER_NUM=1
CONFIG_SOC_TWAI_CLK_SUPPORT_XTAL=y
CONFIG_SOC_TWAI_BRP_MIN=2
CONFIG_SOC_TWAI_BRP_MAX=32768
CONFIG_SOC_TWAI_SUPPORTS_RX_STATUS=y
CONFIG_SOC_TWAI_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_EFUSE_DIS_DOWNLOAD_ICACHE=y
CONFIG_SOC_EFUSE_DIS_PAD_JTAG=y
CONFIG_SOC_EFUSE_DIS_USB_JTAG=y
CONFIG_SOC_EFUSE_DIS_DIRECT_BOOT=y
CONFIG_SOC_EFUSE_SOFT_DIS_JTAG=y
CONFIG_SOC_EFUSE_DIS_ICACHE=y
CONFIG_SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK=y
CONFIG_SOC_SECURE_BOOT_V2_RSA=y
CONFIG_SOC_SECURE_BOOT_V2_ECC=y
CONFIG_SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS=3
CONFIG_SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS=y
CONFIG_SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY=y
CONFIG_SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX=64
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES=y
CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_128=y
CONFIG_SOC_APM_CTRL_FILTER_SUPPORTED=y
CONFIG_SOC_APM_LP_APM0_SUPPORTED=y
CONFIG_SOC_CRYPTO_DPA_PROTECTION_SUPPORTED=y
CONFIG_SOC_UART_NUM=3
CONFIG_SOC_UART_HP_NUM=2
CONFIG_SOC_UART_LP_NUM=1
CONFIG_SOC_UART_FIFO_LEN=128
CONFIG_SOC_LP_UART_FIFO_LEN=16
CONFIG_SOC_UART_BITRATE_MAX=5000000
CONFIG_SOC_UART_SUPPORT_PLL_F80M_CLK=y
CONFIG_SOC_UART_SUPPORT_RTC_CLK=y
CONFIG_SOC_UART_SUPPORT_XTAL_CLK=y
CONFIG_SOC_UART_SUPPORT_WAKEUP_INT=y
CONFIG_SOC_UART_HAS_LP_UART=y
CONFIG_SOC_UART_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_UART_SUPPORT_FSM_TX_WAIT_SEND=y
CONFIG_SOC_UART_WAKEUP_CHARS_SEQ_MAX_LEN=5
CONFIG_SOC_UART_WAKEUP_SUPPORT_ACTIVE_THRESH_MODE=y
CONFIG_SOC_UART_WAKEUP_SUPPORT_FIFO_THRESH_MODE=y
CONFIG_SOC_UART_WAKEUP_SUPPORT_START_BIT_MODE=y
CONFIG_SOC_UART_WAKEUP_SUPPORT_CHAR_SEQ_MODE=y
CONFIG_SOC_UHCI_NUM=1
CONFIG_SOC_COEX_HW_PTI=y
CONFIG_SOC_EXTERNAL_COEX_ADVANCE=y
CONFIG_SOC_PHY_DIG_REGS_MEM_SIZE=21
CONFIG_SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH=12
CONFIG_SOC_RTC_MEM_SUPPORT_SPEED_MODE_SWITCH=y
CONFIG_SOC_PM_SUPPORT_WIFI_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_BEACON_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_BT_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP=y
CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP_MODE_PER_PIN=y
CONFIG_SOC_PM_SUPPORT_CPU_PD=y
CONFIG_SOC_PM_SUPPORT_MODEM_PD=y
CONFIG_SOC_PM_SUPPORT_XTAL32K_PD=y
CONFIG_SOC_PM_SUPPORT_RC32K_PD=y
CONFIG_SOC_PM_SUPPORT_RC_FAST_PD=y
CONFIG_SOC_PM_SUPPORT_VDDSDIO_PD=y
CONFIG_SOC_PM_SUPPORT_TOP_PD=y
CONFIG_SOC_PM_SUPPORT_HP_AON_PD=y
CONFIG_SOC_PM_SUPPORT_MAC_BB_PD=y
CONFIG_SOC_PM_SUPPORT_RTC_PERIPH_PD=y
CONFIG_SOC_PM_SUPPORT_PMU_MODEM_STATE=y
CONFIG_SOC_PM_SUPPORT_PMU_CLK_ICG=y
CONFIG_SOC_PM_SUPPORT_DEEPSLEEP_CHECK_STUB_ONLY=y
CONFIG_SOC_PM_CPU_RETENTION_BY_SW=y
CONFIG_SOC_PM_MODEM_RETENTION_BY_REGDMA=y
CONFIG_SOC_PM_RETENTION_HAS_CLOCK_BUG=y
CONFIG_SOC_EXT_MEM_CACHE_TAG_IN_CPU_DOMAIN=y
CONFIG_SOC_PM_PAU_LINK_NUM=4
CONFIG_SOC_PM_PAU_REGDMA_LINK_MULTI_ADDR=y
CONFIG_SOC_PM_PAU_REGDMA_LINK_WIFIMAC=y
CONFIG_SOC_PM_PAU_REGDMA_UPDATE_CACHE_BEFORE_WAIT_COMPARE=y
CONFIG_SOC_PM_PMU_MIN_SLP_SLOW_CLK_CYCLE_FIXED=y
CONFIG_SOC_PM_RETENTION_MODULE_NUM=32
CONFIG_SOC_CLK_RC_FAST_SUPPORT_CALIBRATION=y
CONFIG_SOC_MODEM_CLOCK_IS_INDEPENDENT=y
CONFIG_SOC_CLK_XTAL32K_SUPPORTED=y
CONFIG_SOC_CLK_OSC_SLOW_SUPPORTED=y
CONFIG_SOC_CLK_RC32K_SUPPORTED=y
CONFIG_SOC_CLK_LP_FAST_SUPPORT_XTAL_D2=y
CONFIG_SOC_RCC_IS_INDEPENDENT=y
CONFIG_SOC_CLK_ANA_I2C_MST_HAS_ROOT_GATE=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_XTAL=y
CONFIG_SOC_TEMPERATURE_SENSOR_INTR_SUPPORT=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_ETM=y
CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_SLEEP_RETENTION=y
CONFIG_SOC_TEMPERATURE_SENSOR_UNDER_PD_TOP_DOMAIN=y
CONFIG_SOC_RNG_CLOCK_IS_INDEPENDENT=y
CONFIG_SOC_WIFI_HW_TSF=y
CONFIG_SOC_WIFI_FTM_SUPPORT=y
CONFIG_SOC_WIFI_GCMP_SUPPORT=y
CONFIG_SOC_WIFI_WAPI_SUPPORT=y
CONFIG_SOC_WIFI_CSI_SUPPORT=y
CONFIG_SOC_WIFI_MESH_SUPPORT=y
CONFIG_SOC_WIFI_HE_SUPPORT=y
CONFIG_SOC_WIFI_MAC_VERSION_NUM=2
CONFIG_SOC_BLE_SUPPORTED=y
CONFIG_SOC_BLE_MESH_SUPPORTED=y
CONFIG_SOC_ESP_NIMBLE_CONTROLLER=y
CONFIG_SOC_BLE_50_SUPPORTED=y
CONFIG_SOC_BLE_DEVICE_PRIVACY_SUPPORTED=y
CONFIG_SOC_BLE_POWER_CONTROL_SUPPORTED=y
CONFIG_SOC_BLE_PERIODIC_ADV_ENH_SUPPORTED=y
CONFIG_SOC_BLUFI_SUPPORTED=y
CONFIG_SOC_BLE_MULTI_CONN_OPTIMIZATION=y
CONFIG_SOC_BLE_USE_WIFI_PWR_CLK_WORKAROUND=y
CONFIG_SOC_PHY_COMBO_MODULE=y
CONFIG_SOC_CAPS_NO_RESET_BY_ANA_BOD=y
CONFIG_SOC_LP_CORE_SINGLE_INTERRUPT_VECTOR=y
CONFIG_SOC_LP_CORE_SUPPORT_ETM=y
CONFIG_SOC_DEBUG_HAVE_OCD_STUB_BINS=y
CONFIG_IDF_CMAKE=y
CONFIG_IDF_TOOLCHAIN="gcc"
CONFIG_IDF_TOOLCHAIN_GCC=y
CONFIG_IDF_TARGET_ARCH_RISCV=y
CONFIG_IDF_TARGET_ARCH="riscv"
CONFIG_IDF_TARGET="esp32c6"
CONFIG_IDF_INIT_VERSION="5.5.0"
CONFIG_IDF_TARGET_ESP32C6=y
CONFIG_IDF_FIRMWARE_CHIP_ID=0x000D

#
# Build type
#
CONFIG_APP_BUILD_TYPE_APP_2NDBOOT=y
# CONFIG_APP_BUILD_TYPE_RAM is not set
CONFIG_APP_BUILD_GENERATE_BINARIES=y
CONFIG_APP_BUILD_BOOTLOADER=y
CONFIG_APP_BUILD_USE_FLASH_SECTIONS=y
# CONFIG_APP_REPRODUCIBLE_BUILD is not set
# CONFIG_APP_NO_BLOBS is not set
# end of Build type

#
# Bootloader config
#

#
# Bootloader manager
#
CONFIG_BOOTLOADER_COMPILE_TIME_DATE=y
CONFIG_BOOTLOADER_PROJECT_VER=1
# end of Bootloader manager

#
# Application Rollback
#
# CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE is not set
# end of Application Rollback

#
# Bootloader Rollback
#
# end of Bootloader Rollback

CONFIG_BOOTLOADER_OFFSET_IN_FLASH=0x0
CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE=y
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_DEBUG is not set
# CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_PERF is not set

#
# Log
#
CONFIG_BOOTLOADER_LOG_VERSION_1=y
CONFIG_BOOTLOADER_LOG_VERSION=1
# CONFIG_BOOTLOADER_LOG_LEVEL_NONE is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_ERROR is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_WARN is not set
CONFIG_BOOTLOADER_LOG_LEVEL_INFO=y
# CONFIG_BOOTLOADER_LOG_LEVEL_DEBUG is not set
# CONFIG_BOOTLOADER_LOG_LEVEL_VERBOSE is not set
CONFIG_BOOTLOADER_LOG_LEVEL=3

#
# Format
#
# CONFIG_BOOTLOADER_LOG_COLORS is not set
CONFIG_BOOTLOADER_LOG_TIMESTAMP_SOURCE_CPU_TICKS=y
# end of Format

#
# Settings
#
CONFIG_BOOTLOADER_LOG_MODE_TEXT_EN=y
CONFIG_BOOTLOADER_LOG_MODE_TEXT=y
# end of Settings
# end of Log

#
# Serial Flash Configurations
#
# CONFIG_BOOTLOADER_FLASH_DC_AWARE is not set
CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT=y
# end of Serial Flash Configurations

# CONFIG_BOOTLOADER_FACTORY_RESET is not set
# CONFIG_BOOTLOADER_APP_TEST is not set
CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE=y
CONFIG_BOOTLOADER_WDT_ENABLE=y
# CONFIG_BOOTLOADER_WDT_DISABLE_IN_USER_CODE is not set
CONFIG_BOOTLOADER_WDT_TIME_MS=9000
# CONFIG_BOOTLOADER_SKIP_VALIDATE_IN_DEEP_SLEEP is not set
# CONFIG_BOOTLOADER_SKIP_VALIDATE_ON_POWER_ON is not set
# CONFIG_BOOTLOADER_SKIP_VALIDATE_ALWAYS is not set
CONFIG_BOOTLOADER_RESERVE_RTC_SIZE=0
# CONFIG_BOOTLOADER_CUSTOM_RESERVE_RTC is not set
# end of Bootloader config

#
# Security features
#
CONFIG_SECURE_BOOT_V2_RSA_SUPPORTED=y
CONFIG_SECURE_BOOT_V2_ECC_SUPPORTED=y
CONFIG_SECURE_BOOT_V2_PREFERRED=y
# CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT is not set
# CONFIG_SECURE_BOOT is not set
# CONFIG_SECURE_FLASH_ENC_ENABLED is not set
CONFIG_SECURE_ROM_DL_MODE_ENABLED=y
# end of Security features

#
# Application manager
#
CONFIG_APP_COMPILE_TIME_DATE=y
# CONFIG_APP_EXCLUDE_PROJECT_VER_VAR is not set
# CONFIG_APP_EXCLUDE_PROJECT_NAME_VAR is not set
# CONFIG_APP_PROJECT_VER_FROM_CONFIG is not set
CONFIG_APP_RETRIEVE_LEN_ELF_SHA=9
# end of Application manager

CONFIG_ESP_ROM_HAS_CRC_LE=y
CONFIG_ESP_ROM_HAS_CRC_BE=y
CONFIG_ESP_ROM_HAS_JPEG_DECODE=y
CONFIG_ESP_ROM_UART_CLK_IS_XTAL=y
CONFIG_ESP_ROM_USB_SERIAL_DEVICE_NUM=3
CONFIG_ESP_ROM_HAS_RETARGETABLE_LOCKING=y
CONFIG_ESP_ROM_GET_CLK_FREQ=y
CONFIG_ESP_ROM_HAS_RVFPLIB=y
CONFIG_ESP_ROM_HAS_HAL_WDT=y
CONFIG_ESP_ROM_HAS_HAL_SYSTIMER=y
CONFIG_ESP_ROM_HAS_HEAP_TLSF=y
CONFIG_ESP_ROM_TLSF_CHECK_PATCH=y
CONFIG_ESP_ROM_MULTI_HEAP_WALK_PATCH=y
CONFIG_ESP_ROM_HAS_LAYOUT_TABLE=y
CONFIG_ESP_ROM_HAS_SPI_FLASH=y
CONFIG_ESP_ROM_HAS_SPI_FLASH_MMAP=y
CONFIG_ESP_ROM_HAS_REGI2C_BUG=y
CONFIG_ESP_ROM_HAS_NEWLIB=y
CONFIG_ESP_ROM_HAS_NEWLIB_NORMAL_FORMAT=y
CONFIG_ESP_ROM_REV0_HAS_NO_ECDSA_INTERFACE=y
CONFIG_ESP_ROM_WDT_INIT_PATCH=y
CONFIG_ESP_ROM_NEEDS_SET_CACHE_MMU_SIZE=y
CONFIG_ESP_ROM_RAM_APP_NEEDS_MMU_INIT=y
CONFIG_ESP_ROM_HAS_SW_FLOAT=y
CONFIG_ESP_ROM_USB_OTG_NUM=-1
CONFIG_ESP_ROM_HAS_VERSION=y
CONFIG_ESP_ROM_SUPPORT_DEEP_SLEEP_WAKEUP_STUB=y
CONFIG_ESP_ROM_HAS_OUTPUT_PUTC_FUNC=y
CONFIG_ESP_ROM_NO_USB_SERIAL_OUTPUT_API=y
CONFIG_ESP_ROM_HAS_SUBOPTIMAL_NEWLIB_ON_MISALIGNED_MEMORY=y

#
# Boot ROM Behavior
#
CONFIG_BOOT_ROM_LOG_ALWAYS_ON=y
# CONFIG_BOOT_ROM_LOG_ALWAYS_OFF is not set
# CONFIG_BOOT_ROM_LOG_ON_GPIO_HIGH is not set
# CONFIG_BOOT_ROM_LOG_ON_GPIO_LOW is not set
# end of Boot ROM Behavior

#
# ESP-TEE (Trusted Execution Environment)
#
# CONFIG_SECURE_ENABLE_TEE is not set
CONFIG_SECURE_TEE_LOG_LEVEL=0
# end of ESP-TEE (Trusted Execution Environment)

#
# Serial flasher config
#
# CONFIG_ESPTOOLPY_NO_STUB is not set
# CONFIG_ESPTOOLPY_FLASHMODE_QIO is not set
# CONFIG_ESPTOOLPY_FLASHMODE_QOUT is not set
CONFIG_ESPTOOLPY_FLASHMODE_DIO=y
# CONFIG_ESPTOOLPY_FLASHMODE_DOUT is not set
CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_STR=y
CONFIG_ESPTOOLPY_FLASHMODE="dio"
CONFIG_ESPTOOLPY_FLASHFREQ_80M=y
# CONFIG_ESPTOOLPY_FLASHFREQ_40M is not set
# CONFIG_ESPTOOLPY_FLASHFREQ_20M is not set
CONFIG_ESPTOOLPY_FLASHFREQ="80m"
# CONFIG_ESPTOOLPY_FLASHSIZE_1MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_2MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_4MB is not set
CONFIG_ESPTOOLPY_FLASHSIZE_8MB=y
# CONFIG_ESPTOOLPY_FLASHSIZE_16MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_32MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_64MB is not set
# CONFIG_ESPTOOLPY_FLASHSIZE_128MB is not set
CONFIG_ESPTOOLPY_FLASHSIZE="8MB"
# CONFIG_ESPTOOLPY_HEADER_FLASHSIZE_UPDATE is not set
CONFIG_ESPTOOLPY_BEFORE_RESET=y
# CONFIG_ESPTOOLPY_BEFORE_NORESET is not set
CONFIG_ESPTOOLPY_BEFORE="default_reset"
CONFIG_ESPTOOLPY_AFTER_RESET=y
# CONFIG_ESPTOOLPY_AFTER_NORESET is not set
CONFIG_ESPTOOLPY_AFTER="hard_reset"
CONFIG_ESPTOOLPY_MONITOR_BAUD=115200
# end of Serial flasher config

#
# Partition Table
#
# CONFIG_PARTITION_TABLE_SINGLE_APP is not set
# CONFIG_PARTITION_TABLE_SINGLE_APP_LARGE is not set
# CONFIG_PARTITION_TABLE_TWO_OTA is not set
# CONFIG_PARTITION_TABLE_TWO_OTA_LARGE is not set
CONFIG_PARTITION_TABLE_CUSTOM=y
CONFIG_PARTITION_TABLE_CUSTOM_FILENAME="partitions.csv"
CONFIG_PARTITION_TABLE_FILENAME="partitions.csv"
CONFIG_PARTITION_TABLE_OFFSET=0x8000
CONFIG_PARTITION_TABLE_MD5=y
# end of Partition Table

#
# Example Configuration
#
CONFIG_ESP_WIFI_SSID="myssid"
CONFIG_ESP_WIFI_PASSWORD="mypassword"
# end of Example Configuration

#
# DIYMON Board Support Package
#
# CONFIG_DIYMON_BOARD_ORIGINAL is not set
CONFIG_DIYMON_BOARD_WAVESHARE_C6=y
# end of DIYMON Board Support Package

#
# Compiler options
#
CONFIG_COMPILER_OPTIMIZATION_DEBUG=y
# CONFIG_COMPILER_OPTIMIZATION_SIZE is not set
# CONFIG_COMPILER_OPTIMIZATION_PERF is not set
# CONFIG_COMPILER_OPTIMIZATION_NONE is not set
CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE=y
# CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_SILENT is not set
# CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_DISABLE is not set
CONFIG_COMPILER_ASSERT_NDEBUG_EVALUATE=y
# CONFIG_COMPILER_FLOAT_LIB_FROM_GCCLIB is not set
CONFIG_COMPILER_FLOAT_LIB_FROM_RVFPLIB=y
CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL=2
# CONFIG_COMPILER_OPTIMIZATION_CHECKS_SILENT is not set
CONFIG_COMPILER_HIDE_PATHS_MACROS=y
# CONFIG_COMPILER_CXX_EXCEPTIONS is not set
# CONFIG_COMPILER_CXX_RTTI is not set
CONFIG_COMPILER_STACK_CHECK_MODE_NONE=y
# CONFIG_COMPILER_STACK_CHECK_MODE_NORM is not set
# CONFIG_COMPILER_STACK_CHECK_MODE_STRONG is not set
# CONFIG_COMPILER_STACK_CHECK_MODE_ALL is not set
# CONFIG_COMPILER_NO_MERGE_CONSTANTS is not set
# CONFIG_COMPILER_WARN_WRITE_STRINGS is not set
# CONFIG_COMPILER_SAVE_RESTORE_LIBCALLS is not set
CONFIG_COMPILER_DISABLE_DEFAULT_ERRORS=y
# CONFIG_COMPILER_DISABLE_GCC12_WARNINGS is not set
# CONFIG_COMPILER_DISABLE_GCC13_WARNINGS is not set
# CONFIG_COMPILER_DISABLE_GCC14_WARNINGS is not set
# CONFIG_COMPILER_DUMP_RTL_FILES is not set
CONFIG_COMPILER_RT_LIB_GCCLIB=y
CONFIG_COMPILER_RT_LIB_NAME="gcc"
CONFIG_COMPILER_ORPHAN_SECTIONS_WARNING=y
# CONFIG_COMPILER_ORPHAN_SECTIONS_PLACE is not set
# CONFIG_COMPILER_STATIC_ANALYZER is not set
# end of Compiler options

#
# Component config
#

#
# Application Level Tracing
#
# CONFIG_APPTRACE_DEST_JTAG is not set
CONFIG_APPTRACE_DEST_NONE=y
# CONFIG_APPTRACE_DEST_UART1 is not set
# CONFIG_APPTRACE_DEST_UART2 is not set
CONFIG_APPTRACE_DEST_UART_NONE=y
CONFIG_APPTRACE_UART_TASK_PRIO=1
CONFIG_APPTRACE_LOCK_ENABLE=y
# end of Application Level Tracing

#
# Bluetooth
#
# CONFIG_BT_ENABLED is not set

#
# Common Options
#
# CONFIG_BT_BLE_LOG_SPI_OUT_ENABLED is not set
# end of Common Options
# end of Bluetooth

#
# Console Library
#
# CONFIG_CONSOLE_SORTED_HELP is not set
# end of Console Library

#
# Driver Configurations
#

#
# Legacy TWAI Driver Configurations
#
# CONFIG_TWAI_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy TWAI Driver Configurations

#
# Legacy ADC Driver Configuration
#
# CONFIG_ADC_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_ADC_SKIP_LEGACY_CONFLICT_CHECK is not set

#
# Legacy ADC Calibration Configuration
#
# CONFIG_ADC_CALI_SUPPRESS_DEPRECATE_WARN is not set
# end of Legacy ADC Calibration Configuration
# end of Legacy ADC Driver Configuration

#
# Legacy MCPWM Driver Configurations
#
# CONFIG_MCPWM_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_MCPWM_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy MCPWM Driver Configurations

#
# Legacy Timer Group Driver Configurations
#
# CONFIG_GPTIMER_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_GPTIMER_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy Timer Group Driver Configurations

#
# Legacy RMT Driver Configurations
#
# CONFIG_RMT_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_RMT_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy RMT Driver Configurations

#
# Legacy I2S Driver Configurations
#
# CONFIG_I2S_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_I2S_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy I2S Driver Configurations

#
# Legacy I2C Driver Configurations
#
# CONFIG_I2C_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy I2C Driver Configurations

#
# Legacy PCNT Driver Configurations
#
# CONFIG_PCNT_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_PCNT_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy PCNT Driver Configurations

#
# Legacy SDM Driver Configurations
#
# CONFIG_SDM_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_SDM_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy SDM Driver Configurations

#
# Legacy Temperature Sensor Driver Configurations
#
# CONFIG_TEMP_SENSOR_SUPPRESS_DEPRECATE_WARN is not set
# CONFIG_TEMP_SENSOR_SKIP_LEGACY_CONFLICT_CHECK is not set
# end of Legacy Temperature Sensor Driver Configurations
# end of Driver Configurations

#
# eFuse Bit Manager
#
# CONFIG_EFUSE_CUSTOM_TABLE is not set
# CONFIG_EFUSE_VIRTUAL is not set
CONFIG_EFUSE_MAX_BLK_LEN=256
# end of eFuse Bit Manager

#
# ESP-TLS
#
CONFIG_ESP_TLS_USING_MBEDTLS=y
# CONFIG_ESP_TLS_USE_SECURE_ELEMENT is not set
CONFIG_ESP_TLS_USE_DS_PERIPHERAL=y
# CONFIG_ESP_TLS_CLIENT_SESSION_TICKETS is not set
# CONFIG_ESP_TLS_SERVER_SESSION_TICKETS is not set
# CONFIG_ESP_TLS_SERVER_CERT_SELECT_HOOK is not set
# CONFIG_ESP_TLS_SERVER_MIN_AUTH_MODE_OPTIONAL is not set
# CONFIG_ESP_TLS_PSK_VERIFICATION is not set
# CONFIG_ESP_TLS_INSECURE is not set
# end of ESP-TLS

#
# ADC and ADC Calibration
#
# CONFIG_ADC_ONESHOT_CTRL_FUNC_IN_IRAM is not set
# CONFIG_ADC_CONTINUOUS_ISR_IRAM_SAFE is not set
# CONFIG_ADC_ENABLE_DEBUG_LOG is not set
# end of ADC and ADC Calibration

#
# Wireless Coexistence
#
CONFIG_ESP_COEX_ENABLED=y
CONFIG_ESP_COEX_SW_COEXIST_ENABLE=y
# CONFIG_ESP_COEX_EXTERNAL_COEXIST_ENABLE is not set
# CONFIG_ESP_COEX_POWER_MANAGEMENT is not set
# CONFIG_ESP_COEX_GPIO_DEBUG is not set
# end of Wireless Coexistence

#
# Common ESP-related
#
CONFIG_ESP_ERR_TO_NAME_LOOKUP=y
# end of Common ESP-related

#
# ESP-Driver:GPIO Configurations
#
# CONFIG_GPIO_CTRL_FUNC_IN_IRAM is not set
# end of ESP-Driver:GPIO Configurations

#
# ESP-Driver:GPTimer Configurations
#
CONFIG_GPTIMER_ISR_HANDLER_IN_IRAM=y
# CONFIG_GPTIMER_CTRL_FUNC_IN_IRAM is not set
# CONFIG_GPTIMER_ISR_CACHE_SAFE is not set
CONFIG_GPTIMER_OBJ_CACHE_SAFE=y
# CONFIG_GPTIMER_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:GPTimer Configurations

#
# ESP-Driver:I2C Configurations
#
# CONFIG_I2C_ISR_IRAM_SAFE is not set
# CONFIG_I2C_ENABLE_DEBUG_LOG is not set
# CONFIG_I2C_ENABLE_SLAVE_DRIVER_VERSION_2 is not set
CONFIG_I2C_MASTER_ISR_HANDLER_IN_IRAM=y
# end of ESP-Driver:I2C Configurations

#
# ESP-Driver:I2S Configurations
#
# CONFIG_I2S_ISR_IRAM_SAFE is not set
# CONFIG_I2S_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:I2S Configurations

#
# ESP-Driver:LEDC Configurations
#
# CONFIG_LEDC_CTRL_FUNC_IN_IRAM is not set
# end of ESP-Driver:LEDC Configurations

#
# ESP-Driver:MCPWM Configurations
#
CONFIG_MCPWM_ISR_HANDLER_IN_IRAM=y
# CONFIG_MCPWM_ISR_CACHE_SAFE is not set
# CONFIG_MCPWM_CTRL_FUNC_IN_IRAM is not set
CONFIG_MCPWM_OBJ_CACHE_SAFE=y
# CONFIG_MCPWM_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:MCPWM Configurations

#
# ESP-Driver:Parallel IO Configurations
#
CONFIG_PARLIO_TX_ISR_HANDLER_IN_IRAM=y
CONFIG_PARLIO_RX_ISR_HANDLER_IN_IRAM=y
# CONFIG_PARLIO_TX_ISR_CACHE_SAFE is not set
# CONFIG_PARLIO_RX_ISR_CACHE_SAFE is not set
CONFIG_PARLIO_OBJ_CACHE_SAFE=y
# CONFIG_PARLIO_ENABLE_DEBUG_LOG is not set
# CONFIG_PARLIO_ISR_IRAM_SAFE is not set
# end of ESP-Driver:Parallel IO Configurations

#
# ESP-Driver:PCNT Configurations
#
# CONFIG_PCNT_CTRL_FUNC_IN_IRAM is not set
# CONFIG_PCNT_ISR_IRAM_SAFE is not set
# CONFIG_PCNT_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:PCNT Configurations

#
# ESP-Driver:RMT Configurations
#
CONFIG_RMT_ENCODER_FUNC_IN_IRAM=y
CONFIG_RMT_TX_ISR_HANDLER_IN_IRAM=y
CONFIG_RMT_RX_ISR_HANDLER_IN_IRAM=y
# CONFIG_RMT_RECV_FUNC_IN_IRAM is not set
# CONFIG_RMT_TX_ISR_CACHE_SAFE is not set
# CONFIG_RMT_RX_ISR_CACHE_SAFE is not set
CONFIG_RMT_OBJ_CACHE_SAFE=y
# CONFIG_RMT_ENABLE_DEBUG_LOG is not set
# CONFIG_RMT_ISR_IRAM_SAFE is not set
# end of ESP-Driver:RMT Configurations

#
# ESP-Driver:Sigma Delta Modulator Configurations
#
# CONFIG_SDM_CTRL_FUNC_IN_IRAM is not set
# CONFIG_SDM_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:Sigma Delta Modulator Configurations

#
# ESP-Driver:SPI Configurations
#
# CONFIG_SPI_MASTER_IN_IRAM is not set
CONFIG_SPI_MASTER_ISR_IN_IRAM=y
# CONFIG_SPI_SLAVE_IN_IRAM is not set
CONFIG_SPI_SLAVE_ISR_IN_IRAM=y
# end of ESP-Driver:SPI Configurations

#
# ESP-Driver:Temperature Sensor Configurations
#
# CONFIG_TEMP_SENSOR_ENABLE_DEBUG_LOG is not set
# CONFIG_TEMP_SENSOR_ISR_IRAM_SAFE is not set
# end of ESP-Driver:Temperature Sensor Configurations

#
# ESP-Driver:TWAI Configurations
#
# CONFIG_TWAI_ISR_IN_IRAM is not set
# CONFIG_TWAI_ISR_CACHE_SAFE is not set
# CONFIG_TWAI_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:TWAI Configurations

#
# ESP-Driver:UART Configurations
#
# CONFIG_UART_ISR_IN_IRAM is not set
# end of ESP-Driver:UART Configurations

#
# ESP-Driver:UHCI Configurations
#
# CONFIG_UHCI_ISR_HANDLER_IN_IRAM is not set
# CONFIG_UHCI_ISR_CACHE_SAFE is not set
# CONFIG_UHCI_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:UHCI Configurations

#
# ESP-Driver:USB Serial/JTAG Configuration
#
CONFIG_USJ_ENABLE_USB_SERIAL_JTAG=y
# end of ESP-Driver:USB Serial/JTAG Configuration

#
# Ethernet
#
CONFIG_ETH_ENABLED=y
CONFIG_ETH_USE_SPI_ETHERNET=y
# CONFIG_ETH_SPI_ETHERNET_DM9051 is not set
# CONFIG_ETH_SPI_ETHERNET_W5500 is not set
# CONFIG_ETH_SPI_ETHERNET_KSZ8851SNL is not set
# CONFIG_ETH_USE_OPENETH is not set
# CONFIG_ETH_TRANSMIT_MUTEX is not set
# end of Ethernet

#
# Event Loop Library
#
# CONFIG_ESP_EVENT_LOOP_PROFILING is not set
CONFIG_ESP_EVENT_POST_FROM_ISR=y
CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR=y
# end of Event Loop Library

#
# GDB Stub
#
CONFIG_ESP_GDBSTUB_ENABLED=y
# CONFIG_ESP_SYSTEM_GDBSTUB_RUNTIME is not set
CONFIG_ESP_GDBSTUB_SUPPORT_TASKS=y
CONFIG_ESP_GDBSTUB_MAX_TASKS=32
# end of GDB Stub

#
# ESP HID
#
CONFIG_ESPHID_TASK_SIZE_BT=2048
CONFIG_ESPHID_TASK_SIZE_BLE=4096
# end of ESP HID

#
# ESP HTTP client
#
CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS=y
# CONFIG_ESP_HTTP_CLIENT_ENABLE_BASIC_AUTH is not set
# CONFIG_ESP_HTTP_CLIENT_ENABLE_DIGEST_AUTH is not set
# CONFIG_ESP_HTTP_CLIENT_ENABLE_CUSTOM_TRANSPORT is not set
CONFIG_ESP_HTTP_CLIENT_EVENT_POST_TIMEOUT=2000
# end of ESP HTTP client

#
# HTTP Server
#
CONFIG_HTTPD_MAX_REQ_HDR_LEN=1024
CONFIG_HTTPD_MAX_URI_LEN=512
CONFIG_HTTPD_ERR_RESP_NO_DELAY=y
CONFIG_HTTPD_PURGE_BUF_LEN=32
# CONFIG_HTTPD_LOG_PURGE_DATA is not set
# CONFIG_HTTPD_WS_SUPPORT is not set
# CONFIG_HTTPD_QUEUE_WORK_BLOCKING is not set
CONFIG_HTTPD_SERVER_EVENT_POST_TIMEOUT=2000
# end of HTTP Server

#
# ESP HTTPS OTA
#
# CONFIG_ESP_HTTPS_OTA_DECRYPT_CB is not set
# CONFIG_ESP_HTTPS_OTA_ALLOW_HTTP is not set
CONFIG_ESP_HTTPS_OTA_EVENT_POST_TIMEOUT=2000
# end of ESP HTTPS OTA

#
# ESP HTTPS server
#
# CONFIG_ESP_HTTPS_SERVER_ENABLE is not set
CONFIG_ESP_HTTPS_SERVER_EVENT_POST_TIMEOUT=2000
# CONFIG_ESP_HTTPS_SERVER_CERT_SELECT_HOOK is not set
# end of ESP HTTPS server

#
# Hardware Settings
#

#
# Chip revision
#
CONFIG_ESP32C6_REV_MIN_0=y
# CONFIG_ESP32C6_REV_MIN_1 is not set
# CONFIG_ESP32C6_REV_MIN_2 is not set
CONFIG_ESP32C6_REV_MIN_FULL=0
CONFIG_ESP_REV_MIN_FULL=0

#
# Maximum Supported ESP32-C6 Revision (Rev v0.99)
#
CONFIG_ESP32C6_REV_MAX_FULL=99
CONFIG_ESP_REV_MAX_FULL=99
CONFIG_ESP_EFUSE_BLOCK_REV_MIN_FULL=0
CONFIG_ESP_EFUSE_BLOCK_REV_MAX_FULL=99

#
# Maximum Supported ESP32-C6 eFuse Block Revision (eFuse Block Rev v0.99)
#
# end of Chip revision

#
# MAC Config
#
CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_BT=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_ETH=y
CONFIG_ESP_MAC_ADDR_UNIVERSE_IEEE802154=y
CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES_FOUR=y
CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES=4
# CONFIG_ESP32C6_UNIVERSAL_MAC_ADDRESSES_TWO is not set
CONFIG_ESP32C6_UNIVERSAL_MAC_ADDRESSES_FOUR=y
CONFIG_ESP32C6_UNIVERSAL_MAC_ADDRESSES=4
# CONFIG_ESP_MAC_USE_CUSTOM_MAC_AS_BASE_MAC is not set
# end of MAC Config

#
# Sleep Config
#
# CONFIG_ESP_SLEEP_POWER_DOWN_FLASH is not set
CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND=y
# CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU is not set
CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND=y
CONFIG_ESP_SLEEP_WAIT_FLASH_READY_EXTRA_DELAY=0
# CONFIG_ESP_SLEEP_CACHE_SAFE_ASSERTION is not set
# CONFIG_ESP_SLEEP_DEBUG is not set
CONFIG_ESP_SLEEP_GPIO_ENABLE_INTERNAL_RESISTORS=y
# end of Sleep Config

#
# RTC Clock Config
#
CONFIG_RTC_CLK_SRC_INT_RC=y
# CONFIG_RTC_CLK_SRC_EXT_CRYS is not set
# CONFIG_RTC_CLK_SRC_EXT_OSC is not set
# CONFIG_RTC_CLK_SRC_USE_DANGEROUS_RC32K_ALLOWED is not set
CONFIG_RTC_CLK_CAL_CYCLES=1024
# end of RTC Clock Config

#
# Peripheral Control
#
CONFIG_ESP_PERIPH_CTRL_FUNC_IN_IRAM=y
CONFIG_ESP_REGI2C_CTRL_FUNC_IN_IRAM=y
# end of Peripheral Control

#
# ETM Configuration
#
# CONFIG_ETM_ENABLE_DEBUG_LOG is not set
# end of ETM Configuration

#
# GDMA Configurations
#
CONFIG_GDMA_CTRL_FUNC_IN_IRAM=y
CONFIG_GDMA_ISR_HANDLER_IN_IRAM=y
CONFIG_GDMA_OBJ_DRAM_SAFE=y
# CONFIG_GDMA_ENABLE_DEBUG_LOG is not set
# CONFIG_GDMA_ISR_IRAM_SAFE is not set
# end of GDMA Configurations

#
# Main XTAL Config
#
CONFIG_XTAL_FREQ_40=y
CONFIG_XTAL_FREQ=40
# end of Main XTAL Config

#
# Power Supplier
#

#
# Brownout Detector
#
CONFIG_ESP_BROWNOUT_DET=y
CONFIG_ESP_BROWNOUT_DET_LVL_SEL_7=y
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_ESP_BROWNOUT_DET_LVL_SEL_2 is not set
CONFIG_ESP_BROWNOUT_DET_LVL=7
CONFIG_ESP_BROWNOUT_USE_INTR=y
# end of Brownout Detector
# end of Power Supplier

CONFIG_ESP_SPI_BUS_LOCK_ISR_FUNCS_IN_IRAM=y
CONFIG_ESP_INTR_IN_IRAM=y
# end of Hardware Settings

#
# ESP-Driver:LCD Controller Configurations
#
# CONFIG_LCD_ENABLE_DEBUG_LOG is not set
# end of ESP-Driver:LCD Controller Configurations

#
# ESP-MM: Memory Management Configurations
#
# end of ESP-MM: Memory Management Configurations

#
# ESP NETIF Adapter
#
CONFIG_ESP_NETIF_IP_LOST_TIMER_INTERVAL=120
# CONFIG_ESP_NETIF_PROVIDE_CUSTOM_IMPLEMENTATION is not set
CONFIG_ESP_NETIF_TCPIP_LWIP=y
# CONFIG_ESP_NETIF_LOOPBACK is not set
CONFIG_ESP_NETIF_USES_TCPIP_WITH_BSD_API=y
CONFIG_ESP_NETIF_REPORT_DATA_TRAFFIC=y
# CONFIG_ESP_NETIF_RECEIVE_REPORT_ERRORS is not set
# CONFIG_ESP_NETIF_L2_TAP is not set
# CONFIG_ESP_NETIF_BRIDGE_EN is not set
# CONFIG_ESP_NETIF_SET_DNS_PER_DEFAULT_NETIF is not set
# end of ESP NETIF Adapter

#
# Partition API Configuration
#
# end of Partition API Configuration

#
# PHY
#
CONFIG_ESP_PHY_ENABLED=y
CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE=y
# CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION is not set
CONFIG_ESP_PHY_MAX_WIFI_TX_POWER=20
CONFIG_ESP_PHY_MAX_TX_POWER=20
# CONFIG_ESP_PHY_REDUCE_TX_POWER is not set
# CONFIG_ESP_PHY_ENABLE_CERT_TEST is not set
CONFIG_ESP_PHY_RF_CAL_PARTIAL=y
# CONFIG_ESP_PHY_RF_CAL_NONE is not set
# CONFIG_ESP_PHY_RF_CAL_FULL is not set
CONFIG_ESP_PHY_CALIBRATION_MODE=0
# CONFIG_ESP_PHY_PLL_TRACK_DEBUG is not set
# CONFIG_ESP_PHY_RECORD_USED_TIME is not set
CONFIG_ESP_PHY_IRAM_OPT=y
# end of PHY

#
# Power Management
#
CONFIG_PM_SLEEP_FUNC_IN_IRAM=y
# CONFIG_PM_ENABLE is not set
CONFIG_PM_SLP_IRAM_OPT=y
CONFIG_PM_SLP_DEFAULT_PARAMS_OPT=y
CONFIG_PM_POWER_DOWN_CPU_IN_LIGHT_SLEEP=y
# CONFIG_PM_POWER_DOWN_PERIPHERAL_IN_LIGHT_SLEEP is not set
# end of Power Management

#
# ESP PSRAM
#

#
# ESP Ringbuf
#
# CONFIG_RINGBUF_PLACE_FUNCTIONS_INTO_FLASH is not set
# end of ESP Ringbuf

#
# ESP-ROM
#
CONFIG_ESP_ROM_PRINT_IN_IRAM=y
# end of ESP-ROM

#
# ESP Security Specific
#

#
# Crypto DPA Protection
#
CONFIG_ESP_CRYPTO_DPA_PROTECTION_AT_STARTUP=y
CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL_LOW=y
# CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL_MEDIUM is not set
# CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL_HIGH is not set
CONFIG_ESP_CRYPTO_DPA_PROTECTION_LEVEL=1
# end of Crypto DPA Protection
# end of ESP Security Specific

#
# ESP System Settings
#
# CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_80 is not set
# CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_120 is not set
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_160=y
CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ=160
# CONFIG_ESP_SYSTEM_PANIC_PRINT_HALT is not set
CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT=y
# CONFIG_ESP_SYSTEM_PANIC_SILENT_REBOOT is not set
# CONFIG_ESP_SYSTEM_PANIC_GDBSTUB is not set
CONFIG_ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS=0
CONFIG_ESP_SYSTEM_SINGLE_CORE_MODE=y
CONFIG_ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK=y
CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP=y
CONFIG_ESP_SYSTEM_NO_BACKTRACE=y
# CONFIG_ESP_SYSTEM_USE_EH_FRAME is not set
# CONFIG_ESP_SYSTEM_USE_FRAME_POINTER is not set

#
# Memory protection
#
CONFIG_ESP_SYSTEM_PMP_IDRAM_SPLIT=y
# CONFIG_ESP_SYSTEM_PMP_LP_CORE_RESERVE_MEM_EXECUTABLE is not set
# end of Memory protection

CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE=32
CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE=2304
CONFIG_ESP_MAIN_TASK_STACK_SIZE=16384
CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0=y
# CONFIG_ESP_MAIN_TASK_AFFINITY_NO_AFFINITY is not set
CONFIG_ESP_MAIN_TASK_AFFINITY=0x0
CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE=2048
CONFIG_ESP_CONSOLE_UART_DEFAULT=y
# CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG is not set
# CONFIG_ESP_CONSOLE_UART_CUSTOM is not set
# CONFIG_ESP_CONSOLE_NONE is not set
# CONFIG_ESP_CONSOLE_SECONDARY_NONE is not set
CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG=y
CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG_ENABLED=y
CONFIG_ESP_CONSOLE_UART=y
CONFIG_ESP_CONSOLE_UART_NUM=0
CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM=0
CONFIG_ESP_CONSOLE_UART_BAUDRATE=115200
CONFIG_ESP_INT_WDT=y
CONFIG_ESP_INT_WDT_TIMEOUT_MS=300
CONFIG_ESP_TASK_WDT_EN=y
CONFIG_ESP_TASK_WDT_INIT=y
# CONFIG_ESP_TASK_WDT_PANIC is not set
CONFIG_ESP_TASK_WDT_TIMEOUT_S=5
CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0=y
# CONFIG_ESP_PANIC_HANDLER_IRAM is not set
# CONFIG_ESP_DEBUG_STUBS_ENABLE is not set
# CONFIG_ESP_DEBUG_INCLUDE_OCD_STUB_BINS is not set
CONFIG_ESP_DEBUG_OCDAWARE=y
CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4=y
CONFIG_ESP_SYSTEM_HW_STACK_GUARD=y
CONFIG_ESP_SYSTEM_BBPLL_RECALIB=y
CONFIG_ESP_SYSTEM_HW_PC_RECORD=y
# end of ESP System Settings

#
# IPC (Inter-Processor Call)
#
CONFIG_ESP_IPC_TASK_STACK_SIZE=1024
# end of IPC (Inter-Processor Call)

#
# ESP Timer (High Resolution Timer)
#
CONFIG_ESP_TIMER_IN_IRAM=y
# CONFIG_ESP_TIMER_PROFILING is not set
CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER=y
CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER=y
CONFIG_ESP_TIMER_TASK_STACK_SIZE=3584
CONFIG_ESP_TIMER_INTERRUPT_LEVEL=1
# CONFIG_ESP_TIMER_SHOW_EXPERIMENTAL is not set
CONFIG_ESP_TIMER_TASK_AFFINITY=0x0
CONFIG_ESP_TIMER_TASK_AFFINITY_CPU0=y
CONFIG_ESP_TIMER_ISR_AFFINITY_CPU0=y
# CONFIG_ESP_TIMER_SUPPORTS_ISR_DISPATCH_METHOD is not set
CONFIG_ESP_TIMER_IMPL_SYSTIMER=y
# end of ESP Timer (High Resolution Timer)

#
# Wi-Fi
#
CONFIG_ESP_WIFI_ENABLED=y
CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM=10
CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM=32
# CONFIG_ESP_WIFI_STATIC_TX_BUFFER is not set
CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER=y
CONFIG_ESP_WIFI_TX_BUFFER_TYPE=1
CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM=32
CONFIG_ESP_WIFI_STATIC_RX_MGMT_BUFFER=y
# CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUFFER is not set
CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUF=0
CONFIG_ESP_WIFI_RX_MGMT_BUF_NUM_DEF=5
# CONFIG_ESP_WIFI_CSI_ENABLED is not set
CONFIG_ESP_WIFI_AMPDU_TX_ENABLED=y
CONFIG_ESP_WIFI_TX_BA_WIN=6
CONFIG_ESP_WIFI_AMPDU_RX_ENABLED=y
CONFIG_ESP_WIFI_RX_BA_WIN=6
CONFIG_ESP_WIFI_NVS_ENABLED=y
CONFIG_ESP_WIFI_SOFTAP_BEACON_MAX_LEN=752
CONFIG_ESP_WIFI_MGMT_SBUF_NUM=32
CONFIG_ESP_WIFI_IRAM_OPT=y
CONFIG_ESP_WIFI_EXTRA_IRAM_OPT=y
CONFIG_ESP_WIFI_RX_IRAM_OPT=y
CONFIG_ESP_WIFI_ENABLE_WPA3_SAE=y
CONFIG_ESP_WIFI_ENABLE_SAE_PK=y
CONFIG_ESP_WIFI_ENABLE_SAE_H2E=y
CONFIG_ESP_WIFI_SOFTAP_SAE_SUPPORT=y
CONFIG_ESP_WIFI_ENABLE_WPA3_OWE_STA=y
CONFIG_ESP_WIFI_SLP_IRAM_OPT=y
CONFIG_ESP_WIFI_SLP_DEFAULT_MIN_ACTIVE_TIME=50
CONFIG_ESP_WIFI_BSS_MAX_IDLE_SUPPORT=y
CONFIG_ESP_WIFI_SLP_DEFAULT_MAX_ACTIVE_TIME=10
CONFIG_ESP_WIFI_SLP_DEFAULT_WAIT_BROADCAST_DATA_TIME=15
# CONFIG_ESP_WIFI_FTM_ENABLE is not set
CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE=y
# CONFIG_ESP_WIFI_GCMP_SUPPORT is not set
CONFIG_ESP_WIFI_GMAC_SUPPORT=y
CONFIG_ESP_WIFI_SOFTAP_SUPPORT=y
# CONFIG_ESP_WIFI_SLP_BEACON_LOST_OPT is not set
CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM=7
CONFIG_ESP_WIFI_MBEDTLS_CRYPTO=y
CONFIG_ESP_WIFI_MBEDTLS_TLS_CLIENT=y
# CONFIG_ESP_WIFI_WAPI_PSK is not set
# CONFIG_ESP_WIFI_SUITE_B_192 is not set
# CONFIG_ESP_WIFI_11KV_SUPPORT is not set
# CONFIG_ESP_WIFI_MBO_SUPPORT is not set
# CONFIG_ESP_WIFI_DPP_SUPPORT is not set
# CONFIG_ESP_WIFI_11R_SUPPORT is not set
# CONFIG_ESP_WIFI_WPS_SOFTAP_REGISTRAR is not set
# CONFIG_ESP_WIFI_ENABLE_WIFI_TX_STATS is not set
# CONFIG_ESP_WIFI_ENABLE_WIFI_RX_STATS is not set
CONFIG_ESP_WIFI_TX_HETB_QUEUE_NUM=3

#
# WPS Configuration Options
#
# CONFIG_ESP_WIFI_WPS_STRICT is not set
# CONFIG_ESP_WIFI_WPS_PASSPHRASE is not set
# end of WPS Configuration Options

# CONFIG_ESP_WIFI_DEBUG_PRINT is not set
# CONFIG_ESP_WIFI_TESTING_OPTIONS is not set
CONFIG_ESP_WIFI_ENTERPRISE_SUPPORT=y
# CONFIG_ESP_WIFI_ENT_FREE_DYNAMIC_BUFFER is not set
# end of Wi-Fi

#
# Core dump
#
# CONFIG_ESP_COREDUMP_ENABLE_TO_FLASH is not set
# CONFIG_ESP_COREDUMP_ENABLE_TO_UART is not set
CONFIG_ESP_COREDUMP_ENABLE_TO_NONE=y
# end of Core dump

#
# FAT Filesystem support
#
CONFIG_FATFS_VOLUME_COUNT=2
# CONFIG_FATFS_LFN_NONE is not set
CONFIG_FATFS_LFN_HEAP=y
# CONFIG_FATFS_LFN_STACK is not set
# CONFIG_FATFS_SECTOR_512 is not set
CONFIG_FATFS_SECTOR_4096=y
# CONFIG_FATFS_CODEPAGE_DYNAMIC is not set
CONFIG_FATFS_CODEPAGE_437=y
# CONFIG_FATFS_CODEPAGE_720 is not set
# CONFIG_FATFS_CODEPAGE_737 is not set
# CONFIG_FATFS_CODEPAGE_771 is not set
# CONFIG_FATFS_CODEPAGE_775 is not set
# CONFIG_FATFS_CODEPAGE_850 is not set
# CONFIG_FATFS_CODEPAGE_852 is not set
# CONFIG_FATFS_CODEPAGE_855 is not set
# CONFIG_FATFS_CODEPAGE_857 is not set
# CONFIG_FATFS_CODEPAGE_860 is not set
# CONFIG_FATFS_CODEPAGE_861 is not set
# CONFIG_FATFS_CODEPAGE_862 is not set
# CONFIG_FATFS_CODEPAGE_863 is not set
# CONFIG_FATFS_CODEPAGE_864 is not set
# CONFIG_FATFS_CODEPAGE_865 is not set
# CONFIG_FATFS_CODEPAGE_866 is not set
# CONFIG_FATFS_CODEPAGE_869 is not set
# CONFIG_FATFS_CODEPAGE_932 is not set
# CONFIG_FATFS_CODEPAGE_936 is not set
# CONFIG_FATFS_CODEPAGE_949 is not set
# CONFIG_FATFS_CODEPAGE_950 is not set
CONFIG_FATFS_CODEPAGE=437
CONFIG_FATFS_MAX_LFN=255
CONFIG_FATFS_API_ENCODING_ANSI_OEM=y
# CONFIG_FATFS_API_ENCODING_UTF_8 is not set
CONFIG_FATFS_FS_LOCK=0
CONFIG_FATFS_TIMEOUT_MS=10000
CONFIG_FATFS_PER_FILE_CACHE=y
# CONFIG_FATFS_USE_FASTSEEK is not set
CONFIG_FATFS_USE_STRFUNC_NONE=y
# CONFIG_FATFS_USE_STRFUNC_WITHOUT_CRLF_CONV is not set
# CONFIG_FATFS_USE_STRFUNC_WITH_CRLF_CONV is not set
CONFIG_FATFS_VFS_FSTAT_BLKSIZE=0
# CONFIG_FATFS_IMMEDIATE_FSYNC is not set
# CONFIG_FATFS_USE_LABEL is not set
CONFIG_FATFS_LINK_LOCK=y
# CONFIG_FATFS_USE_DYN_BUFFERS is not set

#
# File system free space calculation behavior
#
CONFIG_FATFS_DONT_TRUST_FREE_CLUSTER_CNT=0
CONFIG_FATFS_DONT_TRUST_LAST_ALLOC=0
# end of File system free space calculation behavior
# end of FAT Filesystem support

#
# FreeRTOS
#

#
# Kernel
#
# CONFIG_FREERTOS_SMP is not set
CONFIG_FREERTOS_UNICORE=y
CONFIG_FREERTOS_HZ=100
CONFIG_FREERTOS_OPTIMIZED_SCHEDULER=y
# CONFIG_FREERTOS_CHECK_STACKOVERFLOW_NONE is not set
# CONFIG_FREERTOS_CHECK_STACKOVERFLOW_PTRVAL is not set
CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY=y
CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS=1
CONFIG_FREERTOS_IDLE_TASK_STACKSIZE=1536
# CONFIG_FREERTOS_USE_IDLE_HOOK is not set
# CONFIG_FREERTOS_USE_TICK_HOOK is not set
CONFIG_FREERTOS_MAX_TASK_NAME_LEN=16
# CONFIG_FREERTOS_ENABLE_BACKWARD_COMPATIBILITY is not set
CONFIG_FREERTOS_USE_TIMERS=y
CONFIG_FREERTOS_TIMER_SERVICE_TASK_NAME="Tmr Svc"
# CONFIG_FREERTOS_TIMER_TASK_AFFINITY_CPU0 is not set
CONFIG_FREERTOS_TIMER_TASK_NO_AFFINITY=y
CONFIG_FREERTOS_TIMER_SERVICE_TASK_CORE_AFFINITY=0x7FFFFFFF
CONFIG_FREERTOS_TIMER_TASK_PRIORITY=1
CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH=2048
CONFIG_FREERTOS_TIMER_QUEUE_LENGTH=10
CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE=0
CONFIG_FREERTOS_TASK_NOTIFICATION_ARRAY_ENTRIES=1
# CONFIG_FREERTOS_USE_TRACE_FACILITY is not set
# CONFIG_FREERTOS_USE_LIST_DATA_INTEGRITY_CHECK_BYTES is not set
# CONFIG_FREERTOS_GENERATE_RUN_TIME_STATS is not set
# CONFIG_FREERTOS_USE_APPLICATION_TASK_TAG is not set
# end of Kernel

#
# Port
#
CONFIG_FREERTOS_TASK_FUNCTION_WRAPPER=y
# CONFIG_FREERTOS_WATCHPOINT_END_OF_STACK is not set
CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS=y
# CONFIG_FREERTOS_TASK_PRE_DELETION_HOOK is not set
# CONFIG_FREERTOS_ENABLE_STATIC_TASK_CLEAN_UP is not set
CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER=y
CONFIG_FREERTOS_ISR_STACKSIZE=1536
CONFIG_FREERTOS_INTERRUPT_BACKTRACE=y
CONFIG_FREERTOS_TICK_SUPPORT_SYSTIMER=y
CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL1=y
# CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL3 is not set
CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER=y
# CONFIG_FREERTOS_PLACE_FUNCTIONS_INTO_FLASH is not set
# CONFIG_FREERTOS_CHECK_PORT_CRITICAL_COMPLIANCE is not set
# end of Port

#
# Extra
#
# end of Extra

CONFIG_FREERTOS_PORT=y
CONFIG_FREERTOS_NO_AFFINITY=0x7FFFFFFF
CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION=y
CONFIG_FREERTOS_DEBUG_OCDAWARE=y
CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT=y
CONFIG_FREERTOS_PLACE_SNAPSHOT_FUNS_INTO_FLASH=y
CONFIG_FREERTOS_NUMBER_OF_CORES=1
CONFIG_FREERTOS_IN_IRAM=y
# end of FreeRTOS

#
# Hardware Abstraction Layer (HAL) and Low Level (LL)
#
CONFIG_HAL_ASSERTION_EQUALS_SYSTEM=y
# CONFIG_HAL_ASSERTION_DISABLE is not set
# CONFIG_HAL_ASSERTION_SILENT is not set
# CONFIG_HAL_ASSERTION_ENABLE is not set
CONFIG_HAL_DEFAULT_ASSERTION_LEVEL=2
CONFIG_HAL_SYSTIMER_USE_ROM_IMPL=y
CONFIG_HAL_WDT_USE_ROM_IMPL=y
# end of Hardware Abstraction Layer (HAL) and Low Level (LL)

#
# Heap memory debugging
#
CONFIG_HEAP_POISONING_DISABLED=y
# CONFIG_HEAP_POISONING_LIGHT is not set
# CONFIG_HEAP_POISONING_COMPREHENSIVE is not set
CONFIG_HEAP_TRACING_OFF=y
# CONFIG_HEAP_TRACING_STANDALONE is not set
# CONFIG_HEAP_TRACING_TOHOST is not set
# CONFIG_HEAP_USE_HOOKS is not set
# CONFIG_HEAP_TASK_TRACKING is not set
# CONFIG_HEAP_ABORT_WHEN_ALLOCATION_FAILS is not set
CONFIG_HEAP_TLSF_USE_ROM_IMPL=y
# CONFIG_HEAP_PLACE_FUNCTION_INTO_FLASH is not set
# end of Heap memory debugging

#
# IEEE 802.15.4
#
CONFIG_IEEE802154_ENABLED=y
CONFIG_IEEE802154_RX_BUFFER_SIZE=20
# CONFIG_IEEE802154_CCA_CARRIER is not set
CONFIG_IEEE802154_CCA_ED=y
# CONFIG_IEEE802154_CCA_CARRIER_OR_ED is not set
# CONFIG_IEEE802154_CCA_CARRIER_AND_ED is not set
CONFIG_IEEE802154_CCA_MODE=1
CONFIG_IEEE802154_CCA_THRESHOLD=-60
CONFIG_IEEE802154_PENDING_TABLE_SIZE=20
# CONFIG_IEEE802154_MULTI_PAN_ENABLE is not set
CONFIG_IEEE802154_TIMING_OPTIMIZATION=y
# CONFIG_IEEE802154_DEBUG is not set
# CONFIG_IEEE802154_DEBUG_ASSERT_MONITOR is not set
# end of IEEE 802.15.4

#
# Log
#
CONFIG_LOG_VERSION_1=y
# CONFIG_LOG_VERSION_2 is not set
CONFIG_LOG_VERSION=1

#
# Log Level
#
# CONFIG_LOG_DEFAULT_LEVEL_NONE is not set
# CONFIG_LOG_DEFAULT_LEVEL_ERROR is not set
# CONFIG_LOG_DEFAULT_LEVEL_WARN is not set
CONFIG_LOG_DEFAULT_LEVEL_INFO=y
# CONFIG_LOG_DEFAULT_LEVEL_DEBUG is not set
# CONFIG_LOG_DEFAULT_LEVEL_VERBOSE is not set
CONFIG_LOG_DEFAULT_LEVEL=3
CONFIG_LOG_MAXIMUM_EQUALS_DEFAULT=y
# CONFIG_LOG_MAXIMUM_LEVEL_DEBUG is not set
# CONFIG_LOG_MAXIMUM_LEVEL_VERBOSE is not set
CONFIG_LOG_MAXIMUM_LEVEL=3

#
# Level Settings
#
# CONFIG_LOG_MASTER_LEVEL is not set
CONFIG_LOG_DYNAMIC_LEVEL_CONTROL=y
# CONFIG_LOG_TAG_LEVEL_IMPL_NONE is not set
# CONFIG_LOG_TAG_LEVEL_IMPL_LINKED_LIST is not set
CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_AND_LINKED_LIST=y
# CONFIG_LOG_TAG_LEVEL_CACHE_ARRAY is not set
CONFIG_LOG_TAG_LEVEL_CACHE_BINARY_MIN_HEAP=y
CONFIG_LOG_TAG_LEVEL_IMPL_CACHE_SIZE=31
# end of Level Settings
# end of Log Level

#
# Format
#
# CONFIG_LOG_COLORS is not set
CONFIG_LOG_TIMESTAMP_SOURCE_RTOS=y
# CONFIG_LOG_TIMESTAMP_SOURCE_SYSTEM is not set
# end of Format

#
# Settings
#
CONFIG_LOG_MODE_TEXT_EN=y
CONFIG_LOG_MODE_TEXT=y
# end of Settings

CONFIG_LOG_IN_IRAM=y
# end of Log

#
# LWIP
#
CONFIG_LWIP_ENABLE=y
CONFIG_LWIP_LOCAL_HOSTNAME="espressif"
CONFIG_LWIP_TCPIP_TASK_PRIO=18
# CONFIG_LWIP_TCPIP_CORE_LOCKING is not set
# CONFIG_LWIP_CHECK_THREAD_SAFETY is not set
CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES=y
# CONFIG_LWIP_L2_TO_L3_COPY is not set
# CONFIG_LWIP_IRAM_OPTIMIZATION is not set
# CONFIG_LWIP_EXTRA_IRAM_OPTIMIZATION is not set
CONFIG_LWIP_TIMERS_ONDEMAND=y
CONFIG_LWIP_ND6=y
# CONFIG_LWIP_FORCE_ROUTER_FORWARDING is not set
CONFIG_LWIP_MAX_SOCKETS=10
# CONFIG_LWIP_USE_ONLY_LWIP_SELECT is not set
# CONFIG_LWIP_SO_LINGER is not set
CONFIG_LWIP_SO_REUSE=y
CONFIG_LWIP_SO_REUSE_RXTOALL=y
# CONFIG_LWIP_SO_RCVBUF is not set
# CONFIG_LWIP_NETBUF_RECVINFO is not set
CONFIG_LWIP_IP_DEFAULT_TTL=64
CONFIG_LWIP_IP4_FRAG=y
CONFIG_LWIP_IP6_FRAG=y
# CONFIG_LWIP_IP4_REASSEMBLY is not set
# CONFIG_LWIP_IP6_REASSEMBLY is not set
CONFIG_LWIP_IP_REASS_MAX_PBUFS=10
# CONFIG_LWIP_IP_FORWARD is not set
# CONFIG_LWIP_STATS is not set
CONFIG_LWIP_ESP_GRATUITOUS_ARP=y
CONFIG_LWIP_GARP_TMR_INTERVAL=60
CONFIG_LWIP_ESP_MLDV6_REPORT=y
CONFIG_LWIP_MLDV6_TMR_INTERVAL=40
CONFIG_LWIP_TCPIP_RECVMBOX_SIZE=32
CONFIG_LWIP_DHCP_DOES_ARP_CHECK=y
# CONFIG_LWIP_DHCP_DOES_ACD_CHECK is not set
# CONFIG_LWIP_DHCP_DOES_NOT_CHECK_OFFERED_IP is not set
# CONFIG_LWIP_DHCP_DISABLE_CLIENT_ID is not set
CONFIG_LWIP_DHCP_DISABLE_VENDOR_CLASS_ID=y
# CONFIG_LWIP_DHCP_RESTORE_LAST_IP is not set
CONFIG_LWIP_DHCP_OPTIONS_LEN=68
CONFIG_LWIP_NUM_NETIF_CLIENT_DATA=0
CONFIG_LWIP_DHCP_COARSE_TIMER_SECS=1

#
# DHCP server
#
CONFIG_LWIP_DHCPS=y
CONFIG_LWIP_DHCPS_LEASE_UNIT=60
CONFIG_LWIP_DHCPS_MAX_STATION_NUM=8
CONFIG_LWIP_DHCPS_STATIC_ENTRIES=y
CONFIG_LWIP_DHCPS_ADD_DNS=y
# end of DHCP server

# CONFIG_LWIP_AUTOIP is not set
CONFIG_LWIP_IPV4=y
CONFIG_LWIP_IPV6=y
# CONFIG_LWIP_IPV6_AUTOCONFIG is not set
CONFIG_LWIP_IPV6_NUM_ADDRESSES=3
# CONFIG_LWIP_IPV6_FORWARD is not set
# CONFIG_LWIP_NETIF_STATUS_CALLBACK is not set
CONFIG_LWIP_NETIF_LOOPBACK=y
CONFIG_LWIP_LOOPBACK_MAX_PBUFS=8

#
# TCP
#
CONFIG_LWIP_MAX_ACTIVE_TCP=16
CONFIG_LWIP_MAX_LISTENING_TCP=16
CONFIG_LWIP_TCP_HIGH_SPEED_RETRANSMISSION=y
CONFIG_LWIP_TCP_MAXRTX=12
CONFIG_LWIP_TCP_SYNMAXRTX=12
CONFIG_LWIP_TCP_MSS=1440
CONFIG_LWIP_TCP_TMR_INTERVAL=250
CONFIG_LWIP_TCP_MSL=60000
CONFIG_LWIP_TCP_FIN_WAIT_TIMEOUT=20000
CONFIG_LWIP_TCP_SND_BUF_DEFAULT=5760
CONFIG_LWIP_TCP_WND_DEFAULT=5760
CONFIG_LWIP_TCP_RECVMBOX_SIZE=6
CONFIG_LWIP_TCP_ACCEPTMBOX_SIZE=6
CONFIG_LWIP_TCP_QUEUE_OOSEQ=y
CONFIG_LWIP_TCP_OOSEQ_TIMEOUT=6
CONFIG_LWIP_TCP_OOSEQ_MAX_PBUFS=4
# CONFIG_LWIP_TCP_SACK_OUT is not set
CONFIG_LWIP_TCP_OVERSIZE_MSS=y
# CONFIG_LWIP_TCP_OVERSIZE_QUARTER_MSS is not set
# CONFIG_LWIP_TCP_OVERSIZE_DISABLE is not set
CONFIG_LWIP_TCP_RTO_TIME=1500
# end of TCP

#
# UDP
#
CONFIG_LWIP_MAX_UDP_PCBS=16
CONFIG_LWIP_UDP_RECVMBOX_SIZE=6
# end of UDP

#
# Checksums
#
# CONFIG_LWIP_CHECKSUM_CHECK_IP is not set
# CONFIG_LWIP_CHECKSUM_CHECK_UDP is not set
CONFIG_LWIP_CHECKSUM_CHECK_ICMP=y
# end of Checksums

CONFIG_LWIP_TCPIP_TASK_STACK_SIZE=3072
CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY=y
# CONFIG_LWIP_TCPIP_TASK_AFFINITY_CPU0 is not set
CONFIG_LWIP_TCPIP_TASK_AFFINITY=0x7FFFFFFF
CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE=3
CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS=5
CONFIG_LWIP_IPV6_ND6_NUM_PREFIXES=5
CONFIG_LWIP_IPV6_ND6_NUM_ROUTERS=3
CONFIG_LWIP_IPV6_ND6_NUM_DESTINATIONS=10
# CONFIG_LWIP_PPP_SUPPORT is not set
# CONFIG_LWIP_SLIP_SUPPORT is not set

#
# ICMP
#
CONFIG_LWIP_ICMP=y
# CONFIG_LWIP_MULTICAST_PING is not set
# CONFIG_LWIP_BROADCAST_PING is not set
# end of ICMP

#
# LWIP RAW API
#
CONFIG_LWIP_MAX_RAW_PCBS=16
# end of LWIP RAW API

#
# SNTP
#
CONFIG_LWIP_SNTP_MAX_SERVERS=1
# CONFIG_LWIP_DHCP_GET_NTP_SRV is not set
CONFIG_LWIP_SNTP_UPDATE_DELAY=3600000
CONFIG_LWIP_SNTP_STARTUP_DELAY=y
CONFIG_LWIP_SNTP_MAXIMUM_STARTUP_DELAY=5000
# end of SNTP

#
# DNS
#
CONFIG_LWIP_DNS_MAX_HOST_IP=1
CONFIG_LWIP_DNS_MAX_SERVERS=3
# CONFIG_LWIP_FALLBACK_DNS_SERVER_SUPPORT is not set
# CONFIG_LWIP_DNS_SETSERVER_WITH_NETIF is not set
# CONFIG_LWIP_USE_ESP_GETADDRINFO is not set
# end of DNS

CONFIG_LWIP_BRIDGEIF_MAX_PORTS=7
CONFIG_LWIP_ESP_LWIP_ASSERT=y

#
# Hooks
#
# CONFIG_LWIP_HOOK_TCP_ISN_NONE is not set
CONFIG_LWIP_HOOK_TCP_ISN_DEFAULT=y
# CONFIG_LWIP_HOOK_TCP_ISN_CUSTOM is not set
CONFIG_LWIP_HOOK_IP6_ROUTE_NONE=y
# CONFIG_LWIP_HOOK_IP6_ROUTE_DEFAULT is not set
# CONFIG_LWIP_HOOK_IP6_ROUTE_CUSTOM is not set
CONFIG_LWIP_HOOK_ND6_GET_GW_NONE=y
# CONFIG_LWIP_HOOK_ND6_GET_GW_DEFAULT is not set
# CONFIG_LWIP_HOOK_ND6_GET_GW_CUSTOM is not set
CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_NONE=y
# CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_DEFAULT is not set
# CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_CUSTOM is not set
CONFIG_LWIP_HOOK_DHCP_EXTRA_OPTION_NONE=y
# CONFIG_LWIP_HOOK_DHCP_EXTRA_OPTION_DEFAULT is not set
# CONFIG_LWIP_HOOK_DHCP_EXTRA_OPTION_CUSTOM is not set
CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_NONE=y
# CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_DEFAULT is not set
# CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_CUSTOM is not set
CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_NONE=y
# CONFIG_LWIP_HOOK_DNS_EXT_RESOLVE_CUSTOM is not set
# CONFIG_LWIP_HOOK_IP6_INPUT_NONE is not set
CONFIG_LWIP_HOOK_IP6_INPUT_DEFAULT=y
# CONFIG_LWIP_HOOK_IP6_INPUT_CUSTOM is not set
# end of Hooks

# CONFIG_LWIP_DEBUG is not set
# end of LWIP

#
# mbedTLS
#
CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC=y
# CONFIG_MBEDTLS_DEFAULT_MEM_ALLOC is not set
# CONFIG_MBEDTLS_CUSTOM_MEM_ALLOC is not set
CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN=y
CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN=16384
CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN=4096
# CONFIG_MBEDTLS_DYNAMIC_BUFFER is not set
# CONFIG_MBEDTLS_DEBUG is not set

#
# mbedTLS v3.x related
#
# CONFIG_MBEDTLS_SSL_PROTO_TLS1_3 is not set
# CONFIG_MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH is not set
# CONFIG_MBEDTLS_X509_TRUSTED_CERT_CALLBACK is not set
# CONFIG_MBEDTLS_SSL_CONTEXT_SERIALIZATION is not set
CONFIG_MBEDTLS_SSL_KEEP_PEER_CERTIFICATE=y
CONFIG_MBEDTLS_PKCS7_C=y
# end of mbedTLS v3.x related

#
# Certificate Bundle
#
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE=y
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL=y
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_CMN is not set
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_NONE is not set
# CONFIG_MBEDTLS_CUSTOM_CERTIFICATE_BUNDLE is not set
# CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEPRECATED_LIST is not set
CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_MAX_CERTS=200
# end of Certificate Bundle

# CONFIG_MBEDTLS_ECP_RESTARTABLE is not set
CONFIG_MBEDTLS_CMAC_C=y
CONFIG_MBEDTLS_HARDWARE_AES=y
CONFIG_MBEDTLS_AES_USE_INTERRUPT=y
CONFIG_MBEDTLS_AES_INTERRUPT_LEVEL=0
CONFIG_MBEDTLS_GCM_SUPPORT_NON_AES_CIPHER=y
CONFIG_MBEDTLS_HARDWARE_MPI=y
CONFIG_MBEDTLS_LARGE_KEY_SOFTWARE_MPI=y
CONFIG_MBEDTLS_MPI_USE_INTERRUPT=y
CONFIG_MBEDTLS_MPI_INTERRUPT_LEVEL=0
CONFIG_MBEDTLS_HARDWARE_SHA=y
CONFIG_MBEDTLS_HARDWARE_ECC=y
CONFIG_MBEDTLS_ECC_OTHER_CURVES_SOFT_FALLBACK=y
CONFIG_MBEDTLS_ROM_MD5=y
# CONFIG_MBEDTLS_ATCA_HW_ECDSA_SIGN is not set
# CONFIG_MBEDTLS_ATCA_HW_ECDSA_VERIFY is not set
CONFIG_MBEDTLS_HAVE_TIME=y
# CONFIG_MBEDTLS_PLATFORM_TIME_ALT is not set
# CONFIG_MBEDTLS_HAVE_TIME_DATE is not set
CONFIG_MBEDTLS_ECDSA_DETERMINISTIC=y
CONFIG_MBEDTLS_SHA1_C=y
CONFIG_MBEDTLS_SHA512_C=y
# CONFIG_MBEDTLS_SHA3_C is not set
CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT=y
# CONFIG_MBEDTLS_TLS_SERVER_ONLY is not set
# CONFIG_MBEDTLS_TLS_CLIENT_ONLY is not set
# CONFIG_MBEDTLS_TLS_DISABLED is not set
CONFIG_MBEDTLS_TLS_SERVER=y
CONFIG_MBEDTLS_TLS_CLIENT=y
CONFIG_MBEDTLS_TLS_ENABLED=y

#
# TLS Key Exchange Methods
#
# CONFIG_MBEDTLS_PSK_MODES is not set
CONFIG_MBEDTLS_KEY_EXCHANGE_RSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA=y
CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA=y
# end of TLS Key Exchange Methods

CONFIG_MBEDTLS_SSL_RENEGOTIATION=y
CONFIG_MBEDTLS_SSL_PROTO_TLS1_2=y
# CONFIG_MBEDTLS_SSL_PROTO_GMTSSL1_1 is not set
# CONFIG_MBEDTLS_SSL_PROTO_DTLS is not set
CONFIG_MBEDTLS_SSL_ALPN=y
CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS=y
CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS=y

#
# Symmetric Ciphers
#
CONFIG_MBEDTLS_AES_C=y
# CONFIG_MBEDTLS_CAMELLIA_C is not set
# CONFIG_MBEDTLS_DES_C is not set
# CONFIG_MBEDTLS_BLOWFISH_C is not set
# CONFIG_MBEDTLS_XTEA_C is not set
CONFIG_MBEDTLS_CCM_C=y
CONFIG_MBEDTLS_GCM_C=y
# CONFIG_MBEDTLS_NIST_KW_C is not set
# end of Symmetric Ciphers

# CONFIG_MBEDTLS_RIPEMD160_C is not set

#
# Certificates
#
CONFIG_MBEDTLS_PEM_PARSE_C=y
CONFIG_MBEDTLS_PEM_WRITE_C=y
CONFIG_MBEDTLS_X509_CRL_PARSE_C=y
CONFIG_MBEDTLS_X509_CSR_PARSE_C=y
# end of Certificates

CONFIG_MBEDTLS_ECP_C=y
CONFIG_MBEDTLS_PK_PARSE_EC_EXTENDED=y
CONFIG_MBEDTLS_PK_PARSE_EC_COMPRESSED=y
# CONFIG_MBEDTLS_DHM_C is not set
CONFIG_MBEDTLS_ECDH_C=y
CONFIG_MBEDTLS_ECDSA_C=y
# CONFIG_MBEDTLS_ECJPAKE_C is not set
CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED=y
CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED=y
CONFIG_MBEDTLS_ECP_NIST_OPTIM=y
# CONFIG_MBEDTLS_ECP_FIXED_POINT_OPTIM is not set
# CONFIG_MBEDTLS_POLY1305_C is not set
# CONFIG_MBEDTLS_CHACHA20_C is not set
# CONFIG_MBEDTLS_HKDF_C is not set
# CONFIG_MBEDTLS_THREADING_C is not set
CONFIG_MBEDTLS_ERROR_STRINGS=y
CONFIG_MBEDTLS_FS_IO=y
# CONFIG_MBEDTLS_ALLOW_WEAK_CERTIFICATE_VERIFICATION is not set
# end of mbedTLS

#
# ESP-MQTT Configurations
#
CONFIG_MQTT_PROTOCOL_311=y
# CONFIG_MQTT_PROTOCOL_5 is not set
CONFIG_MQTT_TRANSPORT_SSL=y
CONFIG_MQTT_TRANSPORT_WEBSOCKET=y
CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE=y
# CONFIG_MQTT_MSG_ID_INCREMENTAL is not set
# CONFIG_MQTT_SKIP_PUBLISH_IF_DISCONNECTED is not set
# CONFIG_MQTT_REPORT_DELETED_MESSAGES is not set
# CONFIG_MQTT_USE_CUSTOM_CONFIG is not set
# CONFIG_MQTT_TASK_CORE_SELECTION_ENABLED is not set
# CONFIG_MQTT_CUSTOM_OUTBOX is not set
# end of ESP-MQTT Configurations

#
# LibC
#
CONFIG_LIBC_NEWLIB=y
CONFIG_LIBC_MISC_IN_IRAM=y
CONFIG_LIBC_LOCKS_PLACE_IN_IRAM=y
CONFIG_LIBC_STDOUT_LINE_ENDING_CRLF=y
# CONFIG_LIBC_STDOUT_LINE_ENDING_LF is not set
# CONFIG_LIBC_STDOUT_LINE_ENDING_CR is not set
# CONFIG_LIBC_STDIN_LINE_ENDING_CRLF is not set
# CONFIG_LIBC_STDIN_LINE_ENDING_LF is not set
CONFIG_LIBC_STDIN_LINE_ENDING_CR=y
# CONFIG_LIBC_NEWLIB_NANO_FORMAT is not set
CONFIG_LIBC_TIME_SYSCALL_USE_RTC_HRT=y
# CONFIG_LIBC_TIME_SYSCALL_USE_RTC is not set
# CONFIG_LIBC_TIME_SYSCALL_USE_HRT is not set
# CONFIG_LIBC_TIME_SYSCALL_USE_NONE is not set
# CONFIG_LIBC_OPTIMIZED_MISALIGNED_ACCESS is not set
# end of LibC

#
# NVS
#
# CONFIG_NVS_ENCRYPTION is not set
# CONFIG_NVS_ASSERT_ERROR_CHECK is not set
# CONFIG_NVS_LEGACY_DUP_KEYS_COMPATIBILITY is not set
# end of NVS

#
# OpenThread
#
# CONFIG_OPENTHREAD_ENABLED is not set

#
# OpenThread Spinel
#
# CONFIG_OPENTHREAD_SPINEL_ONLY is not set
# end of OpenThread Spinel
# end of OpenThread

#
# Protocomm
#
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_0=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_1=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_2=y
CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_PATCH_VERSION=y
# end of Protocomm

#
# PThreads
#
CONFIG_PTHREAD_TASK_PRIO_DEFAULT=5
CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT=3072
CONFIG_PTHREAD_STACK_MIN=768
CONFIG_PTHREAD_TASK_CORE_DEFAULT=-1
CONFIG_PTHREAD_TASK_NAME_DEFAULT="pthread"
# end of PThreads

#
# MMU Config
#
CONFIG_MMU_PAGE_SIZE_64KB=y
CONFIG_MMU_PAGE_MODE="64KB"
CONFIG_MMU_PAGE_SIZE=0x10000
# end of MMU Config

#
# Main Flash configuration
#

#
# SPI Flash behavior when brownout
#
CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC=y
CONFIG_SPI_FLASH_BROWNOUT_RESET=y
# end of SPI Flash behavior when brownout

#
# Optional and Experimental Features (READ DOCS FIRST)
#

#
# Features here require specific hardware (READ DOCS FIRST!)
#
# CONFIG_SPI_FLASH_AUTO_SUSPEND is not set
CONFIG_SPI_FLASH_SUSPEND_TSUS_VAL_US=50
# CONFIG_SPI_FLASH_FORCE_ENABLE_XMC_C_SUSPEND is not set
# CONFIG_SPI_FLASH_FORCE_ENABLE_C6_H2_SUSPEND is not set
CONFIG_SPI_FLASH_PLACE_FUNCTIONS_IN_IRAM=y
# end of Optional and Experimental Features (READ DOCS FIRST)
# end of Main Flash configuration

#
# SPI Flash driver
#
# CONFIG_SPI_FLASH_VERIFY_WRITE is not set
# CONFIG_SPI_FLASH_ENABLE_COUNTERS is not set
CONFIG_SPI_FLASH_ROM_DRIVER_PATCH=y
# CONFIG_SPI_FLASH_ROM_IMPL is not set
CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS=y
# CONFIG_SPI_FLASH_DANGEROUS_WRITE_FAILS is not set
# CONFIG_SPI_FLASH_DANGEROUS_WRITE_ALLOWED is not set
# CONFIG_SPI_FLASH_BYPASS_BLOCK_ERASE is not set
CONFIG_SPI_FLASH_YIELD_DURING_ERASE=y
CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS=20
CONFIG_SPI_FLASH_ERASE_YIELD_TICKS=1
CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE=8192
# CONFIG_SPI_FLASH_SIZE_OVERRIDE is not set
# CONFIG_SPI_FLASH_CHECK_ERASE_TIMEOUT_DISABLED is not set
# CONFIG_SPI_FLASH_OVERRIDE_CHIP_DRIVER_LIST is not set

#
# Auto-detect flash chips
#
CONFIG_SPI_FLASH_VENDOR_XMC_SUPPORTED=y
# CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_MXIC_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_GD_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_WINBOND_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_BOYA_CHIP is not set
# CONFIG_SPI_FLASH_SUPPORT_TH_CHIP is not set
# end of Auto-detect flash chips

CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE=y
# end of SPI Flash driver

#
# SPIFFS Configuration
#
CONFIG_SPIFFS_MAX_PARTITIONS=3

#
# SPIFFS Cache Configuration
#
CONFIG_SPIFFS_CACHE=y
CONFIG_SPIFFS_CACHE_WR=y
# CONFIG_SPIFFS_CACHE_STATS is not set
# end of SPIFFS Cache Configuration

CONFIG_SPIFFS_PAGE_CHECK=y
CONFIG_SPIFFS_GC_MAX_RUNS=10
# CONFIG_SPIFFS_GC_STATS is not set
CONFIG_SPIFFS_PAGE_SIZE=256
CONFIG_SPIFFS_OBJ_NAME_LEN=32
# CONFIG_SPIFFS_FOLLOW_SYMLINKS is not set
CONFIG_SPIFFS_USE_MAGIC=y
CONFIG_SPIFFS_USE_MAGIC_LENGTH=y
CONFIG_SPIFFS_META_LENGTH=4
CONFIG_SPIFFS_USE_MTIME=y

#
# Debug Configuration
#
# CONFIG_SPIFFS_DBG is not set
# CONFIG_SPIFFS_API_DBG is not set
# CONFIG_SPIFFS_GC_DBG is not set
# CONFIG_SPIFFS_CACHE_DBG is not set
# CONFIG_SPIFFS_CHECK_DBG is not set
# CONFIG_SPIFFS_TEST_VISUALISATION is not set
# end of Debug Configuration
# end of SPIFFS Configuration

#
# TCP Transport
#

#
# Websocket
#
CONFIG_WS_TRANSPORT=y
CONFIG_WS_BUFFER_SIZE=1024
# CONFIG_WS_DYNAMIC_BUFFER is not set
# end of Websocket
# end of TCP Transport

#
# Ultra Low Power (ULP) Co-processor
#
# CONFIG_ULP_COPROC_ENABLED is not set

#
# ULP Debugging Options
#
# end of ULP Debugging Options
# end of Ultra Low Power (ULP) Co-processor

#
# Unity unit testing library
#
CONFIG_UNITY_ENABLE_FLOAT=y
CONFIG_UNITY_ENABLE_DOUBLE=y
# CONFIG_UNITY_ENABLE_64BIT is not set
# CONFIG_UNITY_ENABLE_COLOR is not set
CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER=y
# CONFIG_UNITY_ENABLE_FIXTURE is not set
# CONFIG_UNITY_ENABLE_BACKTRACE_ON_FAIL is not set
# CONFIG_UNITY_TEST_ORDER_BY_FILE_PATH_AND_LINE is not set
# end of Unity unit testing library

#
# Virtual file system
#
CONFIG_VFS_SUPPORT_IO=y
CONFIG_VFS_SUPPORT_DIR=y
CONFIG_VFS_SUPPORT_SELECT=y
CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT=y
# CONFIG_VFS_SELECT_IN_RAM is not set
CONFIG_VFS_SUPPORT_TERMIOS=y
CONFIG_VFS_MAX_COUNT=8

#
# Host File System I/O (Semihosting)
#
CONFIG_VFS_SEMIHOSTFS_MAX_MOUNT_POINTS=1
# end of Host File System I/O (Semihosting)

CONFIG_VFS_INITIALIZE_DEV_NULL=y
# end of Virtual file system

#
# Wear Levelling
#
# CONFIG_WL_SECTOR_SIZE_512 is not set
CONFIG_WL_SECTOR_SIZE_4096=y
CONFIG_WL_SECTOR_SIZE=4096
# end of Wear Levelling

#
# Wi-Fi Provisioning Manager
#
CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES=16
CONFIG_WIFI_PROV_AUTOSTOP_TIMEOUT=30
CONFIG_WIFI_PROV_STA_ALL_CHANNEL_SCAN=y
# CONFIG_WIFI_PROV_STA_FAST_SCAN is not set
# end of Wi-Fi Provisioning Manager

#
# ESP LCD TOUCH
#
CONFIG_ESP_LCD_TOUCH_MAX_POINTS=5
CONFIG_ESP_LCD_TOUCH_MAX_BUTTONS=1
# end of ESP LCD TOUCH

#
# ESP LVGL PORT
#
# end of ESP LVGL PORT

#
# CMake Utilities
#
# CONFIG_CU_RELINKER_ENABLE is not set
# CONFIG_CU_DIAGNOSTICS_COLOR_NEVER is not set
CONFIG_CU_DIAGNOSTICS_COLOR_ALWAYS=y
# CONFIG_CU_DIAGNOSTICS_COLOR_AUTO is not set
# CONFIG_CU_GCC_LTO_ENABLE is not set
# CONFIG_CU_GCC_STRING_1BYTE_ALIGN is not set
# end of CMake Utilities

#
# LVGL configuration
#
CONFIG_LV_CONF_SKIP=y
# CONFIG_LV_CONF_MINIMAL is not set

#
# Color Settings
#
# CONFIG_LV_COLOR_DEPTH_32 is not set
# CONFIG_LV_COLOR_DEPTH_24 is not set
CONFIG_LV_COLOR_DEPTH_16=y
# CONFIG_LV_COLOR_DEPTH_8 is not set
# CONFIG_LV_COLOR_DEPTH_1 is not set
CONFIG_LV_COLOR_DEPTH=16
# end of Color Settings

#
# Memory Settings
#
CONFIG_LV_USE_BUILTIN_MALLOC=y
# CONFIG_LV_USE_CLIB_MALLOC is not set
# CONFIG_LV_USE_MICROPYTHON_MALLOC is not set
# CONFIG_LV_USE_RTTHREAD_MALLOC is not set
# CONFIG_LV_USE_CUSTOM_MALLOC is not set
CONFIG_LV_USE_BUILTIN_STRING=y
# CONFIG_LV_USE_CLIB_STRING is not set
# CONFIG_LV_USE_CUSTOM_STRING is not set
CONFIG_LV_USE_BUILTIN_SPRINTF=y
# CONFIG_LV_USE_CLIB_SPRINTF is not set
# CONFIG_LV_USE_CUSTOM_SPRINTF is not set
CONFIG_LV_MEM_SIZE_KILOBYTES=64
CONFIG_LV_MEM_POOL_EXPAND_SIZE_KILOBYTES=0
CONFIG_LV_MEM_ADR=0x0
# end of Memory Settings

#
# HAL Settings
#
CONFIG_LV_DEF_REFR_PERIOD=33
CONFIG_LV_DPI_DEF=130
# end of HAL Settings

#
# Operating System (OS)
#
CONFIG_LV_OS_NONE=y
# CONFIG_LV_OS_PTHREAD is not set
# CONFIG_LV_OS_FREERTOS is not set
# CONFIG_LV_OS_CMSIS_RTOS2 is not set
# CONFIG_LV_OS_RTTHREAD is not set
# CONFIG_LV_OS_WINDOWS is not set
# CONFIG_LV_OS_CUSTOM is not set
CONFIG_LV_USE_OS=0
# end of Operating System (OS)

#
# Rendering Configuration
#
CONFIG_LV_DRAW_BUF_STRIDE_ALIGN=1
CONFIG_LV_DRAW_BUF_ALIGN=4
CONFIG_LV_DRAW_LAYER_SIMPLE_BUF_SIZE=24576
CONFIG_LV_USE_DRAW_SW=y
CONFIG_LV_DRAW_SW_DRAW_UNIT_CNT=1
# CONFIG_LV_USE_DRAW_ARM2D_SYNC is not set
CONFIG_LV_USE_NATIVE_HELIUM_ASM=y
CONFIG_LV_DRAW_SW_COMPLEX=y
CONFIG_LV_DRAW_SW_SHADOW_CACHE_SIZE=0
CONFIG_LV_DRAW_SW_CIRCLE_CACHE_SIZE=4
CONFIG_LV_DRAW_SW_ASM_NONE=y
# CONFIG_LV_DRAW_SW_ASM_NEON is not set
# CONFIG_LV_DRAW_SW_ASM_HELIUM is not set
# CONFIG_LV_DRAW_SW_ASM_CUSTOM is not set
CONFIG_LV_USE_DRAW_SW_ASM=0
# CONFIG_LV_USE_DRAW_VGLITE is not set
# CONFIG_LV_USE_DRAW_PXP is not set
# CONFIG_LV_USE_DRAW_DAVE2D is not set
# CONFIG_LV_USE_DRAW_SDL is not set
# CONFIG_LV_USE_DRAW_VG_LITE is not set
# CONFIG_LV_USE_VECTOR_GRAPHIC is not set
# end of Rendering Configuration

#
# Feature Configuration
#

#
# Logging
#
# CONFIG_LV_USE_LOG is not set
# end of Logging

#
# Asserts
#
CONFIG_LV_USE_ASSERT_NULL=y
CONFIG_LV_USE_ASSERT_MALLOC=y
# CONFIG_LV_USE_ASSERT_STYLE is not set
# CONFIG_LV_USE_ASSERT_MEM_INTEGRITY is not set
# CONFIG_LV_USE_ASSERT_OBJ is not set
CONFIG_LV_ASSERT_HANDLER_INCLUDE="assert.h"
# end of Asserts

#
# Debug
#
# CONFIG_LV_USE_REFR_DEBUG is not set
# CONFIG_LV_USE_LAYER_DEBUG is not set
# CONFIG_LV_USE_PARALLEL_DRAW_DEBUG is not set
# end of Debug

#
# Others
#
# CONFIG_LV_ENABLE_GLOBAL_CUSTOM is not set
CONFIG_LV_CACHE_DEF_SIZE=0
CONFIG_LV_IMAGE_HEADER_CACHE_DEF_CNT=0
CONFIG_LV_GRADIENT_MAX_STOPS=2
CONFIG_LV_COLOR_MIX_ROUND_OFS=128
# CONFIG_LV_OBJ_STYLE_CACHE is not set
# CONFIG_LV_USE_OBJ_ID is not set
# CONFIG_LV_USE_OBJ_ID_BUILTIN is not set
# CONFIG_LV_USE_OBJ_PROPERTY is not set
# end of Others
# end of Feature Configuration

#
# Compiler Settings
#
# CONFIG_LV_BIG_ENDIAN_SYSTEM is not set
CONFIG_LV_ATTRIBUTE_MEM_ALIGN_SIZE=1
# CONFIG_LV_ATTRIBUTE_FAST_MEM_USE_IRAM is not set
# CONFIG_LV_USE_FLOAT is not set
# end of Compiler Settings

#
# Font Usage
#

#
# Enable built-in fonts
#
# CONFIG_LV_FONT_MONTSERRAT_8 is not set
# CONFIG_LV_FONT_MONTSERRAT_10 is not set
# CONFIG_LV_FONT_MONTSERRAT_12 is not set
CONFIG_LV_FONT_MONTSERRAT_14=y
# CONFIG_LV_FONT_MONTSERRAT_16 is not set
# CONFIG_LV_FONT_MONTSERRAT_18 is not set
# CONFIG_LV_FONT_MONTSERRAT_20 is not set
# CONFIG_LV_FONT_MONTSERRAT_22 is not set
# CONFIG_LV_FONT_MONTSERRAT_24 is not set
# CONFIG_LV_FONT_MONTSERRAT_26 is not set
# CONFIG_LV_FONT_MONTSERRAT_28 is not set
# CONFIG_LV_FONT_MONTSERRAT_30 is not set
# CONFIG_LV_FONT_MONTSERRAT_32 is not set
# CONFIG_LV_FONT_MONTSERRAT_34 is not set
# CONFIG_LV_FONT_MONTSERRAT_36 is not set
# CONFIG_LV_FONT_MONTSERRAT_38 is not set
# CONFIG_LV_FONT_MONTSERRAT_40 is not set
# CONFIG_LV_FONT_MONTSERRAT_42 is not set
# CONFIG_LV_FONT_MONTSERRAT_44 is not set
# CONFIG_LV_FONT_MONTSERRAT_46 is not set
# CONFIG_LV_FONT_MONTSERRAT_48 is not set
# CONFIG_LV_FONT_MONTSERRAT_28_COMPRESSED is not set
# CONFIG_LV_FONT_DEJAVU_16_PERSIAN_HEBREW is not set
# CONFIG_LV_FONT_SIMSUN_16_CJK is not set
# CONFIG_LV_FONT_UNSCII_8 is not set
# CONFIG_LV_FONT_UNSCII_16 is not set
# end of Enable built-in fonts

# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_8 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_12 is not set
CONFIG_LV_FONT_DEFAULT_MONTSERRAT_14=y
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_16 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_18 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_20 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_22 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_24 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_26 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_28 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_30 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_32 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_34 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_36 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_38 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_40 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_42 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_44 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_46 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_48 is not set
# CONFIG_LV_FONT_DEFAULT_MONTSERRAT_28_COMPRESSED is not set
# CONFIG_LV_FONT_DEFAULT_DEJAVU_16_PERSIAN_HEBREW is not set
# CONFIG_LV_FONT_DEFAULT_SIMSUN_16_CJK is not set
# CONFIG_LV_FONT_DEFAULT_UNSCII_8 is not set
# CONFIG_LV_FONT_DEFAULT_UNSCII_16 is not set
# CONFIG_LV_FONT_FMT_TXT_LARGE is not set
# CONFIG_LV_USE_FONT_COMPRESSED is not set
CONFIG_LV_USE_FONT_PLACEHOLDER=y
# end of Font Usage

#
# Text Settings
#
CONFIG_LV_TXT_ENC_UTF8=y
# CONFIG_LV_TXT_ENC_ASCII is not set
CONFIG_LV_TXT_BREAK_CHARS=" ,.;:-_)]}"
CONFIG_LV_TXT_LINE_BREAK_LONG_LEN=0
# CONFIG_LV_USE_BIDI is not set
# CONFIG_LV_USE_ARABIC_PERSIAN_CHARS is not set
# end of Text Settings

#
# Widget Usage
#
CONFIG_LV_WIDGETS_HAS_DEFAULT_VALUE=y
CONFIG_LV_USE_ANIMIMG=y
CONFIG_LV_USE_ARC=y
CONFIG_LV_USE_BAR=y
CONFIG_LV_USE_BUTTON=y
CONFIG_LV_USE_BUTTONMATRIX=y
CONFIG_LV_USE_CALENDAR=y
# CONFIG_LV_CALENDAR_WEEK_STARTS_MONDAY is not set
CONFIG_LV_USE_CALENDAR_HEADER_ARROW=y
CONFIG_LV_USE_CALENDAR_HEADER_DROPDOWN=y
CONFIG_LV_USE_CANVAS=y
CONFIG_LV_USE_CHART=y
CONFIG_LV_USE_CHECKBOX=y
CONFIG_LV_USE_DROPDOWN=y
CONFIG_LV_USE_IMAGE=y
CONFIG_LV_USE_IMAGEBUTTON=y
CONFIG_LV_USE_KEYBOARD=y
CONFIG_LV_USE_LABEL=y
CONFIG_LV_LABEL_TEXT_SELECTION=y
CONFIG_LV_LABEL_LONG_TXT_HINT=y
CONFIG_LV_LABEL_WAIT_CHAR_COUNT=3
CONFIG_LV_USE_LED=y
CONFIG_LV_USE_LINE=y
CONFIG_LV_USE_LIST=y
CONFIG_LV_USE_MENU=y
CONFIG_LV_USE_MSGBOX=y
# CONFIG_LV_USE_OBSERVER is not set
CONFIG_LV_USE_ROLLER=y
CONFIG_LV_USE_SCALE=y
CONFIG_LV_USE_SLIDER=y
CONFIG_LV_USE_SPAN=y
CONFIG_LV_SPAN_SNIPPET_STACK_SIZE=64
CONFIG_LV_USE_SPINBOX=y
CONFIG_LV_USE_SPINNER=y
CONFIG_LV_USE_SWITCH=y
CONFIG_LV_USE_TEXTAREA=y
CONFIG_LV_TEXTAREA_DEF_PWD_SHOW_TIME=1500
CONFIG_LV_USE_TABLE=y
CONFIG_LV_USE_TABVIEW=y
CONFIG_LV_USE_TILEVIEW=y
CONFIG_LV_USE_WIN=y
# end of Widget Usage

#
# Themes
#
CONFIG_LV_USE_THEME_DEFAULT=y
# CONFIG_LV_THEME_DEFAULT_DARK is not set
CONFIG_LV_THEME_DEFAULT_GROW=y
CONFIG_LV_THEME_DEFAULT_TRANSITION_TIME=80
CONFIG_LV_USE_THEME_SIMPLE=y
# CONFIG_LV_USE_THEME_MONO is not set
# end of Themes

#
# Layouts
#
CONFIG_LV_USE_FLEX=y
CONFIG_LV_USE_GRID=y
# end of Layouts

#
# 3rd Party Libraries
#
# CONFIG_LV_USE_FS_STDIO is not set
# CONFIG_LV_USE_FS_POSIX is not set
# CONFIG_LV_USE_FS_WIN32 is not set
# CONFIG_LV_USE_FS_FATFS is not set
# CONFIG_LV_USE_FS_MEMFS is not set
# CONFIG_LV_USE_FS_LITTLEFS is not set
CONFIG_LV_USE_LODEPNG=y
CONFIG_LV_USE_LIBPNG=y
CONFIG_LV_USE_BMP=y
CONFIG_LV_USE_TJPGD=y
# CONFIG_LV_USE_LIBJPEG_TURBO is not set
CONFIG_LV_USE_GIF=y
CONFIG_LV_GIF_CACHE_DECODE_DATA=y
# CONFIG_LV_BIN_DECODER_RAM_LOAD is not set
# CONFIG_LV_USE_RLE is not set
# CONFIG_LV_USE_QRCODE is not set
# CONFIG_LV_USE_BARCODE is not set
# CONFIG_LV_USE_FREETYPE is not set
# CONFIG_LV_USE_TINY_TTF is not set
# CONFIG_LV_USE_RLOTTIE is not set
# CONFIG_LV_USE_THORVG is not set
# CONFIG_LV_USE_LZ4 is not set
# CONFIG_LV_USE_FFMPEG is not set
# end of 3rd Party Libraries

#
# Others
#
# CONFIG_LV_USE_SNAPSHOT is not set
# CONFIG_LV_USE_SYSMON is not set
# CONFIG_LV_USE_MONKEY is not set
# CONFIG_LV_USE_PROFILER is not set
# CONFIG_LV_USE_GRIDNAV is not set
# CONFIG_LV_USE_FRAGMENT is not set
# CONFIG_LV_USE_IMGFONT is not set
# CONFIG_LV_USE_IME_PINYIN is not set
# CONFIG_LV_USE_FILE_EXPLORER is not set
# end of Others

#
# Devices
#
# CONFIG_LV_USE_SDL is not set
# CONFIG_LV_USE_X11 is not set
# CONFIG_LV_USE_LINUX_FBDEV is not set
# CONFIG_LV_USE_NUTTX is not set
# CONFIG_LV_USE_LINUX_DRM is not set
# CONFIG_LV_USE_TFT_ESPI is not set
# CONFIG_LV_USE_EVDEV is not set
# CONFIG_LV_USE_LIBINPUT is not set
# CONFIG_LV_USE_ST7735 is not set
# CONFIG_LV_USE_ST7789 is not set
# CONFIG_LV_USE_ST7796 is not set
# CONFIG_LV_USE_ILI9341 is not set
# CONFIG_LV_USE_GENERIC_MIPI is not set
# CONFIG_LV_USE_WINDOWS is not set
# end of Devices

#
# Examples
#
CONFIG_LV_BUILD_EXAMPLES=y
# end of Examples

#
# Demos
#
# CONFIG_LV_USE_DEMO_WIDGETS is not set
# CONFIG_LV_USE_DEMO_KEYPAD_AND_ENCODER is not set
# CONFIG_LV_USE_DEMO_RENDER is not set
# CONFIG_LV_USE_DEMO_SCROLL is not set
# CONFIG_LV_USE_DEMO_STRESS is not set
# CONFIG_LV_USE_DEMO_MUSIC is not set
# CONFIG_LV_USE_DEMO_FLEX_LAYOUT is not set
# CONFIG_LV_USE_DEMO_MULTILANG is not set
# end of Demos
# end of LVGL configuration

#
# DIYMON Board Options
#
CONFIG_BSP_SD_CARD_ENABLED=y
# end of DIYMON Board Options

#
# IoT Button
#
CONFIG_BUTTON_PERIOD_TIME_MS=5
CONFIG_BUTTON_DEBOUNCE_TICKS=2
CONFIG_BUTTON_SHORT_PRESS_TIME_MS=180
CONFIG_BUTTON_LONG_PRESS_TIME_MS=1500
CONFIG_BUTTON_LONG_PRESS_HOLD_SERIAL_TIME_MS=20
CONFIG_ADC_BUTTON_MAX_CHANNEL=3
CONFIG_ADC_BUTTON_MAX_BUTTON_PER_CHANNEL=8
CONFIG_ADC_BUTTON_SAMPLE_TIMES=1
# end of IoT Button

#
# ESP LCD TOUCH - CST816S
#
# CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID is not set
# end of ESP LCD TOUCH - CST816S
# end of Component config

# CONFIG_IDF_EXPERIMENTAL_FEATURES is not set

# Deprecated options for backward compatibility
# CONFIG_APP_BUILD_TYPE_ELF_RAM is not set
# CONFIG_NO_BLOBS is not set
# CONFIG_APP_ROLLBACK_ENABLE is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_NONE is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_ERROR is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_WARN is not set
CONFIG_LOG_BOOTLOADER_LEVEL_INFO=y
# CONFIG_LOG_BOOTLOADER_LEVEL_DEBUG is not set
# CONFIG_LOG_BOOTLOADER_LEVEL_VERBOSE is not set
CONFIG_LOG_BOOTLOADER_LEVEL=3
# CONFIG_FLASH_ENCRYPTION_ENABLED is not set
# CONFIG_FLASHMODE_QIO is not set
# CONFIG_FLASHMODE_QOUT is not set
CONFIG_FLASHMODE_DIO=y
# CONFIG_FLASHMODE_DOUT is not set
CONFIG_MONITOR_BAUD=115200
CONFIG_OPTIMIZATION_LEVEL_DEBUG=y
CONFIG_COMPILER_OPTIMIZATION_LEVEL_DEBUG=y
CONFIG_COMPILER_OPTIMIZATION_DEFAULT=y
# CONFIG_OPTIMIZATION_LEVEL_RELEASE is not set
# CONFIG_COMPILER_OPTIMIZATION_LEVEL_RELEASE is not set
CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED=y
# CONFIG_OPTIMIZATION_ASSERTIONS_SILENT is not set
# CONFIG_OPTIMIZATION_ASSERTIONS_DISABLED is not set
CONFIG_OPTIMIZATION_ASSERTION_LEVEL=2
# CONFIG_CXX_EXCEPTIONS is not set
CONFIG_STACK_CHECK_NONE=y
# CONFIG_STACK_CHECK_NORM is not set
# CONFIG_STACK_CHECK_STRONG is not set
# CONFIG_STACK_CHECK_ALL is not set
# CONFIG_WARN_WRITE_STRINGS is not set
# CONFIG_ESP32_APPTRACE_DEST_TRAX is not set
CONFIG_ESP32_APPTRACE_DEST_NONE=y
CONFIG_ESP32_APPTRACE_LOCK_ENABLE=y
CONFIG_SW_COEXIST_ENABLE=y
CONFIG_ESP32_WIFI_SW_COEXIST_ENABLE=y
CONFIG_ESP_WIFI_SW_COEXIST_ENABLE=y
# CONFIG_EXTERNAL_COEX_ENABLE is not set
# CONFIG_ESP_WIFI_EXTERNAL_COEXIST_ENABLE is not set
# CONFIG_GPTIMER_ISR_IRAM_SAFE is not set
# CONFIG_MCPWM_ISR_IRAM_SAFE is not set
# CONFIG_EVENT_LOOP_PROFILING is not set
CONFIG_POST_EVENTS_FROM_ISR=y
CONFIG_POST_EVENTS_FROM_IRAM_ISR=y
CONFIG_GDBSTUB_SUPPORT_TASKS=y
CONFIG_GDBSTUB_MAX_TASKS=32
# CONFIG_OTA_ALLOW_HTTP is not set
# CONFIG_ESP_SYSTEM_PD_FLASH is not set
CONFIG_PERIPH_CTRL_FUNC_IN_IRAM=y
CONFIG_BROWNOUT_DET=y
CONFIG_BROWNOUT_DET_LVL_SEL_7=y
# CONFIG_BROWNOUT_DET_LVL_SEL_6 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_5 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_4 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_3 is not set
# CONFIG_BROWNOUT_DET_LVL_SEL_2 is not set
CONFIG_BROWNOUT_DET_LVL=7
CONFIG_ESP_SYSTEM_BROWNOUT_INTR=y
CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE=y
# CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION is not set
CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER=20
CONFIG_ESP32_PHY_MAX_TX_POWER=20
# CONFIG_REDUCE_PHY_TX_POWER is not set
# CONFIG_ESP32_REDUCE_PHY_TX_POWER is not set
CONFIG_ESP_SYSTEM_PM_POWER_DOWN_CPU=y
CONFIG_SYSTEM_EVENT_QUEUE_SIZE=32
CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE=2304
CONFIG_MAIN_TASK_STACK_SIZE=16384
CONFIG_CONSOLE_UART_DEFAULT=y
# CONFIG_CONSOLE_UART_CUSTOM is not set
# CONFIG_CONSOLE_UART_NONE is not set
# CONFIG_ESP_CONSOLE_UART_NONE is not set
CONFIG_CONSOLE_UART=y
CONFIG_CONSOLE_UART_NUM=0
CONFIG_CONSOLE_UART_BAUDRATE=115200
CONFIG_INT_WDT=y
CONFIG_INT_WDT_TIMEOUT_MS=300
CONFIG_TASK_WDT=y
CONFIG_ESP_TASK_WDT=y
# CONFIG_TASK_WDT_PANIC is not set
CONFIG_TASK_WDT_TIMEOUT_S=5
CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0=y
# CONFIG_ESP32_DEBUG_STUBS_ENABLE is not set
CONFIG_IPC_TASK_STACK_SIZE=1024
CONFIG_TIMER_TASK_STACK_SIZE=3584
CONFIG_ESP32_WIFI_ENABLED=y
CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM=10
CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM=32
# CONFIG_ESP32_WIFI_STATIC_TX_BUFFER is not set
CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER=y
CONFIG_ESP32_WIFI_TX_BUFFER_TYPE=1
CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM=32
# CONFIG_ESP32_WIFI_CSI_ENABLED is not set
CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED=y
CONFIG_ESP32_WIFI_TX_BA_WIN=6
CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED=y
CONFIG_ESP32_WIFI_RX_BA_WIN=6
CONFIG_ESP32_WIFI_NVS_ENABLED=y
CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN=752
CONFIG_ESP32_WIFI_MGMT_SBUF_NUM=32
CONFIG_ESP32_WIFI_IRAM_OPT=y
CONFIG_ESP32_WIFI_RX_IRAM_OPT=y
CONFIG_ESP32_WIFI_ENABLE_WPA3_SAE=y
CONFIG_ESP32_WIFI_ENABLE_WPA3_OWE_STA=y
CONFIG_WPA_MBEDTLS_CRYPTO=y
CONFIG_WPA_MBEDTLS_TLS_CLIENT=y
# CONFIG_WPA_WAPI_PSK is not set
# CONFIG_WPA_SUITE_B_192 is not set
# CONFIG_WPA_11KV_SUPPORT is not set
# CONFIG_WPA_MBO_SUPPORT is not set
# CONFIG_WPA_DPP_SUPPORT is not set
# CONFIG_WPA_11R_SUPPORT is not set
# CONFIG_WPA_WPS_SOFTAP_REGISTRAR is not set
# CONFIG_WPA_WPS_STRICT is not set
# CONFIG_WPA_DEBUG_PRINT is not set
# CONFIG_WPA_TESTING_OPTIONS is not set
# CONFIG_ESP32_ENABLE_COREDUMP_TO_FLASH is not set
# CONFIG_ESP32_ENABLE_COREDUMP_TO_UART is not set
CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE=y
CONFIG_TIMER_TASK_PRIORITY=1
CONFIG_TIMER_TASK_STACK_DEPTH=2048
CONFIG_TIMER_QUEUE_LENGTH=10
# CONFIG_ENABLE_STATIC_TASK_CLEAN_UP_HOOK is not set
# CONFIG_HAL_ASSERTION_SILIENT is not set
# CONFIG_L2_TO_L3_COPY is not set
CONFIG_ESP_GRATUITOUS_ARP=y
CONFIG_GARP_TMR_INTERVAL=60
CONFIG_TCPIP_RECVMBOX_SIZE=32
CONFIG_TCP_MAXRTX=12
CONFIG_TCP_SYNMAXRTX=12
CONFIG_TCP_MSS=1440
CONFIG_TCP_MSL=60000
CONFIG_TCP_SND_BUF_DEFAULT=5760
CONFIG_TCP_WND_DEFAULT=5760
CONFIG_TCP_RECVMBOX_SIZE=6
CONFIG_TCP_QUEUE_OOSEQ=y
CONFIG_TCP_OVERSIZE_MSS=y
# CONFIG_TCP_OVERSIZE_QUARTER_MSS is not set
# CONFIG_TCP_OVERSIZE_DISABLE is not set
CONFIG_UDP_RECVMBOX_SIZE=6
CONFIG_TCPIP_TASK_STACK_SIZE=3072
CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY=y
# CONFIG_TCPIP_TASK_AFFINITY_CPU0 is not set
CONFIG_TCPIP_TASK_AFFINITY=0x7FFFFFFF
# CONFIG_PPP_SUPPORT is not set
CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF=y
# CONFIG_NEWLIB_STDOUT_LINE_ENDING_LF is not set
# CONFIG_NEWLIB_STDOUT_LINE_ENDING_CR is not set
# CONFIG_NEWLIB_STDIN_LINE_ENDING_CRLF is not set
# CONFIG_NEWLIB_STDIN_LINE_ENDING_LF is not set
CONFIG_NEWLIB_STDIN_LINE_ENDING_CR=y
# CONFIG_NEWLIB_NANO_FORMAT is not set
CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT=y
# CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC is not set
# CONFIG_NEWLIB_TIME_SYSCALL_USE_HRT is not set
# CONFIG_NEWLIB_TIME_SYSCALL_USE_NONE is not set
CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT=5
CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT=3072
CONFIG_ESP32_PTHREAD_STACK_MIN=768
CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT=-1
CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT="pthread"
CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS=y
# CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_FAILS is not set
# CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ALLOWED is not set
CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT=y
CONFIG_SUPPORT_TERMIOS=y
CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS=1
# End of deprecated options


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\include\bsp_api.h
# =================================================================================================

/*
  Fichero: ./components/diymon_bsp/include/bsp_api.h
  Fecha: 13/08/2025 - 12:06 
  √öltimo cambio: Limpieza de la API del IMU y a√±adido bsp_battery_init.
  Descripci√≥n: Interfaz p√∫blica del BSP. Se eliminan las declaraciones de funciones
               relacionadas con la interrupci√≥n del IMU y se a√±ade la declaraci√≥n
               correcta para bsp_battery_init.
*/
#ifndef BSP_API_H
#define BSP_API_H

#include "esp_err.h"
#include "esp_lcd_panel_ops.h"
#include "esp_lcd_touch.h"
#include "driver/i2c_master.h"
#include "driver/gpio.h"
#include "esp_wifi.h"
#include <stdint.h> // Para uint16_t

// --- INICIALIZADORES DE HARDWARE ---
esp_err_t bsp_init(void);
esp_err_t bsp_init_service_mode(void);
esp_err_t bsp_init_minimal_headless(void);

// --- INICIALIZADORES DE PERIF√âRICOS INDIVIDUALES ---
esp_err_t bsp_i2c_init(void);
esp_err_t bsp_spi_init(void);
esp_err_t bsp_display_init(void);
esp_err_t bsp_touch_init(void);
esp_err_t bsp_sdcard_init(void);
esp_err_t bsp_imu_init(void);
esp_err_t bsp_battery_init(void);

// --- FUNCIONES DE WIFI ---
void bsp_wifi_init_stack(void);
void bsp_wifi_start_ap(void);
void bsp_wifi_init_sta_from_nvs(void);
bool bsp_wifi_wait_for_ip(uint32_t timeout_ms);
void bsp_wifi_get_ip(char *ip);

// --- FUNCIONES DE CONTROL ---
void bsp_display_set_brightness(int percentage);
void bsp_display_turn_on(void);
void bsp_display_turn_off(void);

// --- FUNCIONES DEL IMU (SENSOR DE MOVIMIENTO) ---
void bsp_imu_read(float acc[3], float gyro[3]);

// --- FUNCIONES DE BATER√çA ---
void bsp_battery_get_voltage(float *voltage, uint16_t *adc_value);

// --- GETTERS DE HANDLES Y CONFIGURACI√ìN ---
i2c_master_bus_handle_t bsp_get_i2c_bus_handle(void);
esp_lcd_panel_io_handle_t bsp_get_panel_io_handle(void);
esp_lcd_panel_handle_t bsp_get_display_handle(void);
esp_lcd_touch_handle_t bsp_get_touch_handle(void);
int bsp_get_display_hres(void);
int bsp_get_display_vres(void);
size_t bsp_get_display_buffer_size(void);

#endif // BSP_API_H


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\esp_lcd_touch_cst816s\include\esp_lcd_touch_cst816s.h
# =================================================================================================

/*
 * SPDX-FileCopyrightText: 2023-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @file
 * @brief ESP LCD touch: CST816S
 */

#pragma once

#include "esp_idf_version.h"
#include "esp_lcd_touch.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Create a new CST816S touch driver
 *
 * @note  The I2C communication should be initialized before use this function.
 *
 * @param io LCD panel IO handle, it should be created by `esp_lcd_new_panel_io_i2c()`
 * @param config Touch panel configuration
 * @param tp Touch panel handle
 * @return
 *      - ESP_OK: on success
 */
esp_err_t esp_lcd_touch_new_i2c_cst816s(const esp_lcd_panel_io_handle_t io, const esp_lcd_touch_config_t *config, esp_lcd_touch_handle_t *tp);

/**
 * @brief I2C address of the CST816S controller
 *
 */
#define ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS    (0x15)

/**
 * @brief Touch IO configuration structure
 *
 */
#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(5, 2, 0)
#define ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG()             \
    {                                                     \
        .dev_addr = ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS, \
        .on_color_trans_done = 0,                         \
        .user_ctx = 0,                                    \
        .control_phase_bytes = 1,                         \
        .dc_bit_offset = 0,                               \
        .lcd_cmd_bits = 8,                                \
        .lcd_param_bits = 0,                              \
        .flags =                                          \
        {                                                 \
            .dc_low_on_data = 0,                          \
            .disable_control_phase = 1,                   \
        }                                                 \
    }
#else
#define ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG()             \
    {                                                     \
        .dev_addr = ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS, \
        .on_color_trans_done = 0,                         \
        .user_ctx = 0,                                    \
        .control_phase_bytes = 1,                         \
        .dc_bit_offset = 0,                               \
        .lcd_cmd_bits = 8,                                \
        .lcd_param_bits = 0,                              \
        .flags =                                          \
        {                                                 \
            .dc_low_on_data = 0,                          \
            .disable_control_phase = 1,                   \
        },                                                \
        .scl_speed_hz = 100000                            \
    }
#endif

#ifdef __cplusplus
}
#endif


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\main\CMakeLists.txt
# =================================================================================================

idf_component_register(SRCS "test_esp_lcd_touch_cst816s.c")


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\main\test_esp_lcd_touch_cst816s.c
# =================================================================================================

/*
 * SPDX-FileCopyrightText: 2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: CC0-1.0
 */

#include <inttypes.h>
#include "driver/i2c.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "unity.h"
#include "unity_test_runner.h"

#include "esp_lcd_touch_cst816s.h"

#define TEST_TOUCH_I2C_NUM       (0)
#define TEST_TOUCH_I2C_CLK_HZ    (400000)

#define TEST_LCD_H_RES              (240)
#define TEST_LCD_V_RES              (240)

/* LCD touch pins */
#define TEST_TOUCH_I2C_SCL       (GPIO_NUM_18)
#define TEST_TOUCH_I2C_SDA       (GPIO_NUM_8)
#define TEST_TOUCH_GPIO_INT      (GPIO_NUM_3)

TEST_CASE("test cst816s to initialize touch", "[cst816s][i2c]")
{
    /* Initilize I2C */
    const i2c_config_t i2c_conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = TEST_TOUCH_I2C_SDA,
        .sda_pullup_en = GPIO_PULLUP_DISABLE,
        .scl_io_num = TEST_TOUCH_I2C_SCL,
        .scl_pullup_en = GPIO_PULLUP_DISABLE,
        .master.clk_speed = TEST_TOUCH_I2C_CLK_HZ
    };
    TEST_ESP_OK(i2c_param_config(TEST_TOUCH_I2C_NUM, &i2c_conf));
    TEST_ESP_OK(i2c_driver_install(TEST_TOUCH_I2C_NUM, i2c_conf.mode, 0, 0, 0));

    /* Initialize touch HW */
    const esp_lcd_touch_config_t tp_cfg = {
        .x_max = TEST_LCD_H_RES,
        .y_max = TEST_LCD_V_RES,
        .rst_gpio_num = GPIO_NUM_NC, // Shared with LCD reset
        .int_gpio_num = TEST_TOUCH_GPIO_INT,
        .levels = {
            .reset = 0,
            .interrupt = 0,
        },
        .flags = {
            .swap_xy = 0,
            .mirror_x = 1,
            .mirror_y = 0,
        },
    };

    esp_lcd_touch_handle_t touch_handle;
    esp_lcd_panel_io_handle_t tp_io_handle = NULL;
    const esp_lcd_panel_io_i2c_config_t tp_io_config = ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG();
    TEST_ESP_OK(esp_lcd_new_panel_io_i2c((esp_lcd_i2c_bus_handle_t)TEST_TOUCH_I2C_NUM, &tp_io_config, &tp_io_handle));
    TEST_ESP_OK(esp_lcd_touch_new_i2c_cst816s(tp_io_handle, &tp_cfg, &touch_handle));
}

void app_main(void)
{
    printf("CST816S Test\r\n");
    unity_run_menu();
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\esp_lcd_touch_cst816s\test_apps\CMakeLists.txt
# =================================================================================================

# The following lines of boilerplate have to be in your project's CMakeLists
# in this exact order for cmake to work correctly
cmake_minimum_required(VERSION 3.5)
set(EXTRA_COMPONENT_DIRS "$ENV{IDF_PATH}/tools/unit-test-app/components")
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(test_esp_lcd_touch_cst816s)


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\esp_lcd_touch_cst816s\CMakeLists.txt
# =================================================================================================

idf_component_register(SRCS "esp_lcd_touch_cst816s.c" INCLUDE_DIRS "include" REQUIRES "esp_lcd")


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\esp_lcd_touch_cst816s\esp_lcd_touch_cst816s.c
# =================================================================================================

/*
 * SPDX-FileCopyrightText: 2015-2025 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_system.h"
#include "esp_err.h"
#include "esp_log.h"
#include "esp_check.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_touch.h"

#define POINT_NUM_MAX       (1)

#define DATA_START_REG      (0x02)
#define CHIP_ID_REG         (0xA7)

static const char *TAG = "CST816S";

static esp_err_t read_data(esp_lcd_touch_handle_t tp);
static bool get_xy(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num);
static esp_err_t del(esp_lcd_touch_handle_t tp);

static esp_err_t i2c_read_bytes(esp_lcd_touch_handle_t tp, uint16_t reg, uint8_t *data, uint8_t len);

static esp_err_t reset(esp_lcd_touch_handle_t tp);
static esp_err_t read_id(esp_lcd_touch_handle_t tp);

esp_err_t esp_lcd_touch_new_i2c_cst816s(const esp_lcd_panel_io_handle_t io, const esp_lcd_touch_config_t *config, esp_lcd_touch_handle_t *tp)
{
    ESP_RETURN_ON_FALSE(io, ESP_ERR_INVALID_ARG, TAG, "Invalid io");
    ESP_RETURN_ON_FALSE(config, ESP_ERR_INVALID_ARG, TAG, "Invalid config");
    ESP_RETURN_ON_FALSE(tp, ESP_ERR_INVALID_ARG, TAG, "Invalid touch handle");

    /* Prepare main structure */
    esp_err_t ret = ESP_OK;
    esp_lcd_touch_handle_t cst816s = calloc(1, sizeof(esp_lcd_touch_t));
    ESP_GOTO_ON_FALSE(cst816s, ESP_ERR_NO_MEM, err, TAG, "Touch handle malloc failed");

    /* Communication interface */
    cst816s->io = io;
    /* Only supported callbacks are set */
    cst816s->read_data = read_data;
    cst816s->get_xy = get_xy;
    cst816s->del = del;
    /* Mutex */
    cst816s->data.lock.owner = portMUX_FREE_VAL;
    /* Save config */
    memcpy(&cst816s->config, config, sizeof(esp_lcd_touch_config_t));

    /* Prepare pin for touch interrupt */
    if (cst816s->config.int_gpio_num != GPIO_NUM_NC) {
        const gpio_config_t int_gpio_config = {
            .mode = GPIO_MODE_INPUT,
            .intr_type = (cst816s->config.levels.interrupt ? GPIO_INTR_POSEDGE : GPIO_INTR_NEGEDGE),
            .pin_bit_mask = BIT64(cst816s->config.int_gpio_num)
        };
        ESP_GOTO_ON_ERROR(gpio_config(&int_gpio_config), err, TAG, "GPIO intr config failed");

        /* Register interrupt callback */
        if (cst816s->config.interrupt_callback) {
            esp_lcd_touch_register_interrupt_callback(cst816s, cst816s->config.interrupt_callback);
        }
    }
    /* Prepare pin for touch controller reset */
    if (cst816s->config.rst_gpio_num != GPIO_NUM_NC) {
        const gpio_config_t rst_gpio_config = {
            .mode = GPIO_MODE_OUTPUT,
            .pin_bit_mask = BIT64(cst816s->config.rst_gpio_num)
        };
        ESP_GOTO_ON_ERROR(gpio_config(&rst_gpio_config), err, TAG, "GPIO reset config failed");
    }
    /* Reset controller */
    ESP_GOTO_ON_ERROR(reset(cst816s), err, TAG, "Reset failed");
    /* Read product id */
#ifdef CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID
    ESP_LOGI(TAG, "Read ID disabled");
#else
    ESP_GOTO_ON_ERROR(read_id(cst816s), err, TAG, "Read ID failed");
#endif
    *tp = cst816s;

    return ESP_OK;
err:
    if (cst816s) {
        del(cst816s);
    }
    ESP_LOGE(TAG, "Initialization failed!");
    return ret;
}

static esp_err_t read_data(esp_lcd_touch_handle_t tp)
{
    typedef struct {
        uint8_t num;
        uint8_t x_h : 4;
        uint8_t : 4;
        uint8_t x_l;
        uint8_t y_h : 4;
        uint8_t : 4;
        uint8_t y_l;
    } data_t;

    data_t point;
    ESP_RETURN_ON_ERROR(i2c_read_bytes(tp, DATA_START_REG, (uint8_t *)&point, sizeof(data_t)), TAG, "I2C read failed");

    portENTER_CRITICAL(&tp->data.lock);
    point.num = (point.num > POINT_NUM_MAX ? POINT_NUM_MAX : point.num);
    tp->data.points = point.num;
    /* Fill all coordinates */
    for (int i = 0; i < point.num; i++) {
        tp->data.coords[i].x = point.x_h << 8 | point.x_l;
        tp->data.coords[i].y = point.y_h << 8 | point.y_l;
    }
    portEXIT_CRITICAL(&tp->data.lock);

    return ESP_OK;
}

static bool get_xy(esp_lcd_touch_handle_t tp, uint16_t *x, uint16_t *y, uint16_t *strength, uint8_t *point_num, uint8_t max_point_num)
{
    portENTER_CRITICAL(&tp->data.lock);
    /* Count of points */
    *point_num = (tp->data.points > max_point_num ? max_point_num : tp->data.points);
    for (size_t i = 0; i < *point_num; i++) {
        x[i] = tp->data.coords[i].x;
        y[i] = tp->data.coords[i].y;

        if (strength) {
            strength[i] = tp->data.coords[i].strength;
        }
    }
    /* Invalidate */
    tp->data.points = 0;
    portEXIT_CRITICAL(&tp->data.lock);

    return (*point_num > 0);
}

static esp_err_t del(esp_lcd_touch_handle_t tp)
{
    /* Reset GPIO pin settings */
    if (tp->config.int_gpio_num != GPIO_NUM_NC) {
        gpio_reset_pin(tp->config.int_gpio_num);
        if (tp->config.interrupt_callback) {
            gpio_isr_handler_remove(tp->config.int_gpio_num);
        }
    }
    if (tp->config.rst_gpio_num != GPIO_NUM_NC) {
        gpio_reset_pin(tp->config.rst_gpio_num);
    }
    /* Release memory */
    free(tp);

    return ESP_OK;
}

static esp_err_t reset(esp_lcd_touch_handle_t tp)
{
    if (tp->config.rst_gpio_num != GPIO_NUM_NC) {
        ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, tp->config.levels.reset), TAG, "GPIO set level failed");
        vTaskDelay(pdMS_TO_TICKS(200));
        ESP_RETURN_ON_ERROR(gpio_set_level(tp->config.rst_gpio_num, !tp->config.levels.reset), TAG, "GPIO set level failed");
        vTaskDelay(pdMS_TO_TICKS(200));
    }

    return ESP_OK;
}

#ifndef CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID
static esp_err_t read_id(esp_lcd_touch_handle_t tp)
{
    uint8_t id;
    ESP_RETURN_ON_ERROR(i2c_read_bytes(tp, CHIP_ID_REG, &id, 1), TAG, "I2C read failed");
    ESP_LOGI(TAG, "IC id: %d", id);
    return ESP_OK;
}
#endif

static esp_err_t i2c_read_bytes(esp_lcd_touch_handle_t tp, uint16_t reg, uint8_t *data, uint8_t len)
{
    ESP_RETURN_ON_FALSE(data, ESP_ERR_INVALID_ARG, TAG, "Invalid data");

    return esp_lcd_panel_io_rx_param(tp->io, reg, data, len);
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\esp_lcd_touch_cst816s\README.md
# =================================================================================================

# ESP LCD Touch CST816S Controller

[![Component Registry](https://components.espressif.com/components/espressif/esp_lcd_touch_cst816s/badge.svg)](https://components.espressif.com/components/espressif/esp_lcd_touch_cst816s)

Implementation of the CST816S touch controller with esp_lcd_touch component.

| Touch controller | Communication interface |    Component name     |                             Link to datasheet                              |
| :--------------: | :---------------------: | :-------------------: | :------------------------------------------------------------------------: |
|     CST816S      |           I2C           | esp_lcd_touch_cst816s | [datasheet](https://www.buydisplay.com/download/ic/DS-CST816S_DS_V1.3.pdf) |

> [!NOTE]
> * There are two things about the driver are noteworthy (from [document](https://doc.riot-os.org/group__drivers__cst816s.html)):
>   * It only responds to I2C commands after an event, such as a touch detection. Do not expect it to respond on init. Instead after a touch event, it will assert the IRQ and respond to I2C reads for a short time.
>   * While it should be able to detect multiple finger events, this version of the chip always returns only a single finger event and a gesture. Reading the display data multiple times during a single event will return the last sampled finger position.
> * For some chips, reading ID may cause initialization failure. Disable reading ID by setting `CONFIG_ESP_LCD_TOUCH_CST816S_DISABLE_READ_ID` to `y` in `menuconfig`.

## Add to project

Packages from this repository are uploaded to [Espressif's component service](https://components.espressif.com/).
You can add them to your project via `idf.py add-dependancy`, e.g.
```
    idf.py add-dependency esp_lcd_touch_cst816s==1.0.0
```

Alternatively, you can create `idf_component.yml`. More is in [Espressif's documentation](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/tools/idf-component-manager.html).

## Example use

Define a mutex for the touch and create it before initialize the touch:

```
static SemaphoreHandle_t touch_mux;

touch_mux = xSemaphoreCreateBinary();
```

Define a callback function used by ISR:

```
static void touch_callback(esp_lcd_touch_handle_t tp)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(touch_mux, &xHigherPriorityTaskWoken);

    if (xHigherPriorityTaskWoken) {
        portYIELD_FROM_ISR();
    }
}
```

Initialization of the touch component.

```
    esp_lcd_panel_io_i2c_config_t io_config = ESP_LCD_TOUCH_IO_I2C_CST816S_CONFIG();

    esp_lcd_touch_config_t tp_cfg = {
        .x_max = CONFIG_LCD_HRES,
        .y_max = CONFIG_LCD_VRES,
        .rst_gpio_num = CONFIG_LCD_TOUCH_RST,
        .int_gpio_num = CONFIG_LCD_TOUCH_INT,
        .levels = {
            .reset = 0,
            .interrupt = 0,
        },
        .flags = {
            .swap_xy = 0,
            .mirror_x = 0,
            .mirror_y = 0,
        },
        .interrupt_callback = touch_callback,
    };

    esp_lcd_touch_handle_t tp;
    esp_lcd_touch_new_i2c_cst816s(io_handle, &tp_cfg, &tp);
```

Read data from the touch controller and store it in RAM memory. It should be called regularly in poll.

```
    if (xSemaphoreTake(touch_mux, 0) == pdTRUE) {
        esp_lcd_touch_read_data(tp); // read only when ISR was triggled
    }
```

Get one X and Y coordinates with strength of touch.

```
    uint16_t touch_x[1];
    uint16_t touch_y[1];
    uint16_t touch_strength[1];
    uint8_t touch_cnt = 0;

    bool touchpad_pressed = esp_lcd_touch_get_coordinates(tp, touch_x, touch_y, touch_strength, &touch_cnt, 1);
```


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_battery.c
# =================================================================================================

/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_battery.c
 * Fecha: 13/08/2025 - 12:06 
 * √öltimo cambio: Corregido el tipo de retorno de la funci√≥n de inicializaci√≥n.
 * Descripci√≥n: Se ha corregido la firma de la funci√≥n sp_battery_init de oid a sp_err_t
 *              para que coincida con su declaraci√≥n en la API p√∫blica. Esto resuelve un error
 *              cr√≠tico de compilaci√≥n (ESP_ERROR_CHECK sobre una funci√≥n void) que causaba
 *              un reinicio del dispositivo durante el arranque.
 */
#include "bsp_battery.h"

#include "esp_adc/adc_oneshot.h"
#include "esp_adc/adc_cali.h"
#include "esp_adc/adc_cali_scheme.h"


#include "esp_log.h"

static char *TAG = "bsp_battery";


static adc_oneshot_unit_handle_t adc1_handle;
static adc_cali_handle_t adc1_cali_chan0_handle = NULL;
static bool do_calibration1_chan0;


static bool example_adc_calibration_init(adc_unit_t unit, adc_channel_t channel, adc_atten_t atten, adc_cali_handle_t *out_handle)
{
    adc_cali_handle_t handle = NULL;
    esp_err_t ret = ESP_FAIL;
    bool calibrated = false;

#if ADC_CALI_SCHEME_CURVE_FITTING_SUPPORTED
    if (!calibrated)
    {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Curve Fitting");
        adc_cali_curve_fitting_config_t cali_config = {
            .unit_id = unit,
            .chan = channel,
            .atten = atten,
            .bitwidth = ADC_BITWIDTH_DEFAULT,
        };
        ret = adc_cali_create_scheme_curve_fitting(&cali_config, &handle);
        if (ret == ESP_OK)
        {
            calibrated = true;
        }
    }
#endif

#if ADC_CALI_SCHEME_LINE_FITTING_SUPPORTED
    if (!calibrated)
    {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Line Fitting");
        adc_cali_line_fitting_config_t cali_config = {
            .unit_id = unit,
            .atten = atten,
            .bitwidth = ADC_BITWIDTH_DEFAULT,
        };
        ret = adc_cali_create_scheme_line_fitting(&cali_config, &handle);
        if (ret == ESP_OK)
        {
            calibrated = true;
        }
    }
#endif

    *out_handle = handle;
    if (ret == ESP_OK)
    {
        ESP_LOGI(TAG, "Calibration Success");
    }
    else if (ret == ESP_ERR_NOT_SUPPORTED || !calibrated)
    {
        ESP_LOGW(TAG, "eFuse not burnt, skip software calibration");
    }
    else
    {
        ESP_LOGE(TAG, "Invalid arg or no memory");
    }

    return calibrated;
}


esp_err_t bsp_battery_init(void)
{

    adc_oneshot_unit_init_cfg_t init_config1 = {
        .unit_id = EXAMPLE_ADC_UNIT,
    };
    ESP_ERROR_CHECK(adc_oneshot_new_unit(&init_config1, &adc1_handle));
    //-------------ADC1 Config---------------//
    adc_oneshot_chan_cfg_t config = {
        .bitwidth = ADC_BITWIDTH_DEFAULT,
        .atten = EXAMPLE_ADC_ATTEN,
    };
    ESP_ERROR_CHECK(adc_oneshot_config_channel(adc1_handle, EXAMPLE_BATTERY_ADC_CHANNEL, &config));

    //-------------ADC1 Calibration Init---------------//

    do_calibration1_chan0 = example_adc_calibration_init(EXAMPLE_ADC_UNIT, EXAMPLE_BATTERY_ADC_CHANNEL, EXAMPLE_ADC_ATTEN, &adc1_cali_chan0_handle);
    return ESP_OK;
}


void bsp_battery_get_voltage(float *voltage, uint16_t *adc_value)
{
    int adc_raw;
    int voltage_int;
    
    ESP_ERROR_CHECK(adc_oneshot_read(adc1_handle, EXAMPLE_BATTERY_ADC_CHANNEL, &adc_raw));
    
    // ESP_LOGI(TAG, "ADC%d Channel[%d] Raw Data: %d", ADC_UNIT_1 + 1, EXAMPLE_BATTERY_ADC_CHANNEL, adc_raw);
    if (do_calibration1_chan0)
    {
        ESP_ERROR_CHECK(adc_cali_raw_to_voltage(adc1_cali_chan0_handle, adc_raw, &voltage_int));
        *voltage = (voltage_int / 1000.0f) * 3.0; 

        if (adc_value)
        {
            *adc_value = adc_raw;
        }   
    }
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_battery.h
# =================================================================================================

/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_battery.h
 * Fecha: 13/08/2025 - 12:06 
 * √öltimo cambio: Corregido el tipo de retorno de la funci√≥n de inicializaci√≥n.
 * Descripci√≥n: Cabecera privada para el driver de la bater√≠a. Se ha corregido la firma
 *              de sp_battery_init a sp_err_t para que sea consistente con la
 *              API p√∫blica y evitar un crash en tiempo de ejecuci√≥n.
 */
#ifndef __BSP_BATTERY_H__
#define __BSP_BATTERY_H__
#include <stdio.h>
#include "esp_err.h"
#include <stdint.h>

#define EXAMPLE_ADC_UNIT ADC_UNIT_1
#define EXAMPLE_BATTERY_ADC_CHANNEL ADC_CHANNEL_0
#define EXAMPLE_ADC_ATTEN ADC_ATTEN_DB_12


#ifdef __cplusplus
extern "C" {
#endif

esp_err_t bsp_battery_init(void);
void bsp_battery_get_voltage(float *voltage, uint16_t *adc_value);

#ifdef __cplusplus
}
#endif


#endif


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_display.c
# =================================================================================================

/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_display.c
 * Fecha: 13/08/2025 - 08:03 
 * √öltimo cambio: Eliminado 'swap_color_bytes' obsoleto para compatibilidad con ESP-IDF 5.x.
 * Descripci√≥n: Driver del display. Se elimina la propiedad 'swap_color_bytes' de la configuraci√≥n del panel IO SPI, ya que es obsoleta en la versi√≥n actual de ESP-IDF. La inversi√≥n de bytes se gestionar√° en una capa superior (LVGL port).
 */
#include "bsp_api.h"
#include "esp_log.h"
#include "driver/spi_master.h"
#include "driver/ledc.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_ops.h"
#include "esp_lcd_panel_vendor.h"
#include "nvs_flash.h"
#include "nvs.h"

static const char *TAG = "bsp_display";

#define BSP_SPI_HOST            SPI2_HOST
#define PIN_NUM_LCD_SCLK        5
#define PIN_NUM_LCD_MOSI        4
#define PIN_NUM_LCD_CS          7
#define PIN_NUM_LCD_DC          6
#define PIN_NUM_LCD_RST         14
#define PIN_NUM_LCD_BL          15
#define PIN_NUM_SD_MISO         19
#define BSP_LCD_H_RES           170
#define BSP_LCD_V_RES           320

static esp_lcd_panel_handle_t g_panel_handle = NULL;
static esp_lcd_panel_io_handle_t g_io_handle = NULL;

// Variable est√°tica para guardar el √∫ltimo nivel de brillo
static int s_last_brightness_percentage = 100;

esp_err_t bsp_display_init(void) {
    ESP_LOGI(TAG, "Initializing display...");

    ledc_timer_config_t bl_timer_conf = {
        .speed_mode = LEDC_LOW_SPEED_MODE, .duty_resolution = LEDC_TIMER_8_BIT,
        .timer_num = LEDC_TIMER_0, .freq_hz = 5000, .clk_cfg = LEDC_AUTO_CLK
    };
    ESP_ERROR_CHECK(ledc_timer_config(&bl_timer_conf));
    ledc_channel_config_t bl_channel_conf = {
        .gpio_num = PIN_NUM_LCD_BL, .speed_mode = LEDC_LOW_SPEED_MODE,
        .channel = LEDC_CHANNEL_0, .timer_sel = LEDC_TIMER_0, .duty = 0, .hpoint = 0
    };
    ESP_ERROR_CHECK(ledc_channel_config(&bl_channel_conf));

    // Carga el √∫ltimo nivel de brillo guardado en NVS.
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READONLY, &nvs_handle);
    int32_t saved_brightness = 100; // Valor por defecto si no se encuentra nada.
    if (err == ESP_OK) {
        err = nvs_get_i32(nvs_handle, "brightness", &saved_brightness);
        if (err != ESP_OK) {
            ESP_LOGW(TAG, "No se encontr√≥ brillo en NVS, usando valor por defecto (100).");
            saved_brightness = 100;
        } else {
            ESP_LOGI(TAG, "Brillo cargado desde NVS: %d%%", (int)saved_brightness);
        }
        nvs_close(nvs_handle);
    } else {
        ESP_LOGE(TAG, "Error al abrir NVS para leer brillo: %s", esp_err_to_name(err));
    }
    bsp_display_set_brightness((int)saved_brightness);

    esp_lcd_panel_io_spi_config_t io_config = {
        .cs_gpio_num = PIN_NUM_LCD_CS, .dc_gpio_num = PIN_NUM_LCD_DC,
        .spi_mode = 0, .pclk_hz = 40 * 1000 * 1000, .trans_queue_depth = 10,
        .lcd_cmd_bits = 8, .lcd_param_bits = 8
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi((esp_lcd_spi_bus_handle_t)BSP_SPI_HOST, &io_config, &g_io_handle));

    esp_lcd_panel_dev_config_t panel_config = {
        .reset_gpio_num = PIN_NUM_LCD_RST, .bits_per_pixel = 16,
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_st7789(g_io_handle, &panel_config, &g_panel_handle));
    
    esp_lcd_panel_reset(g_panel_handle);
    esp_lcd_panel_init(g_panel_handle);
    
    esp_lcd_panel_swap_xy(g_panel_handle, true);
    esp_lcd_panel_mirror(g_panel_handle, false, true);
    esp_lcd_panel_set_gap(g_panel_handle, 35, 0); 
    esp_lcd_panel_invert_color(g_panel_handle, true);

    esp_lcd_panel_disp_on_off(g_panel_handle, true);
    
    ESP_LOGI(TAG, "Display initialized and rotated by driver to 170x320.");
    return ESP_OK;
}

void bsp_display_set_brightness(int percentage) {
    if (percentage > 100) percentage = 100;
    if (percentage < 0) percentage = 0;

    // Guarda el √∫ltimo nivel de brillo (si es mayor a 0) para la funci√≥n de re-encendido.
    if (percentage > 0) {
        s_last_brightness_percentage = percentage;
    }

    // Calcula y establece el ciclo de trabajo del PWM para el backlight.
    uint32_t duty = 255 - ((255 * percentage) / 100);
    ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);

    // Guarda el nuevo nivel de brillo en la memoria no vol√°til (NVS).
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err == ESP_OK) {
        err = nvs_set_i32(nvs_handle, "brightness", (int32_t)percentage);
        if (err == ESP_OK) {
            nvs_commit(nvs_handle);
            ESP_LOGD(TAG, "Brillo (%d%%) guardado en NVS.", percentage);
        } else {
            ESP_LOGE(TAG, "Error al guardar brillo en NVS: %s", esp_err_to_name(err));
        }
        nvs_close(nvs_handle);
    } else {
        ESP_LOGE(TAG, "Error al abrir NVS para guardar brillo: %s", esp_err_to_name(err));
    }
}

void bsp_display_turn_on(void) {
    ESP_LOGI(TAG, "Turning display ON and restoring brightness to %d%%", s_last_brightness_percentage);
    // 1. Restaurar el brillo
    bsp_display_set_brightness(s_last_brightness_percentage);
    // 2. Encender el panel
    esp_lcd_panel_disp_on_off(g_panel_handle, true);
}

void bsp_display_turn_off(void) {
    ESP_LOGI(TAG, "Turning display and backlight OFF");
    // 1. Apagar el panel
    esp_lcd_panel_disp_on_off(g_panel_handle, false);
    // 2. Apagar el backlight (sin guardar el 0% como √∫ltimo brillo)
    uint32_t duty = 255; // Duty 255 es 0% de brillo en mi configuraci√≥n invertida
    ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, duty);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);
}

esp_lcd_panel_handle_t bsp_get_display_handle(void) { return g_panel_handle; }
esp_lcd_panel_io_handle_t bsp_get_panel_io_handle(void) { return g_io_handle; }
int bsp_get_display_hres(void) { return BSP_LCD_H_RES; }
int bsp_get_display_vres(void) { return BSP_LCD_V_RES; }
size_t bsp_get_display_buffer_size(void) { return BSP_LCD_H_RES * 20; }


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_display.h
# =================================================================================================

/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_display.h
 * Fecha: 12/08/2025 - 11:46
 * √öltimo cambio: A√±adidas las declaraciones para encendido/apagado del display.
 * Descripci√≥n: Cabecera privada para el driver del display. Se a√±aden las declaraciones de las funciones que controlan el estado de encendido del panel.
 */
#ifndef BSP_DISPLAY_H
#define BSP_DISPLAY_H

#include "esp_err.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_ops.h"

#ifdef __cplusplus
extern "C" {
#endif

// Constantes de la pantalla
#define BSP_LCD_H_RES           170
#define BSP_LCD_V_RES           320

// Funciones exportadas por bsp_display.c
esp_err_t bsp_display_init(void);
void bsp_display_set_brightness(int percentage);
void bsp_display_turn_on(void);
void bsp_display_turn_off(void);
esp_lcd_panel_handle_t bsp_get_display_handle(void);
esp_lcd_panel_io_handle_t bsp_get_panel_io_handle(void);
int bsp_get_display_hres(void);
int bsp_get_display_vres(void);
size_t bsp_get_display_buffer_size(void);

#ifdef __cplusplus
}
#endif

#endif // BSP_DISPLAY_H

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_i2c.c
# =================================================================================================

/*
 * Fichero: ./diymon_bsp/WS1.9TS/bsp_i2c.c
 * Fecha: 12/08/2025 - 05:05 pm
 * √öltimo cambio: Implementada la inicializaci√≥n idempotente.
 * Descripci√≥n: Centraliza la inicializaci√≥n del bus I2C. La funci√≥n sp_i2c_init es ahora idempotente, lo que significa que puede ser llamada m√∫ltiples veces de forma segura, pero solo ejecutar√° la inicializaci√≥n del bus la primera vez, evitando errores de reinicializaci√≥n.
 */
#include "bsp_api.h"
#include "esp_log.h"
#include "driver/i2c_master.h"

static const char *TAG = "bsp_i2c";

// Pines definidos para el bus I2C
#define PIN_I2C_SCL      8
#define PIN_I2C_SDA      18
#define I2C_PORT_NUM     I2C_NUM_0
#define I2C_CLK_SPEED_HZ 400000

// Variable est√°tica para almacenar el manejador del bus I2C
static i2c_master_bus_handle_t g_bus_handle = NULL;
// Bandera para asegurar la inicializaci√≥n √∫nica (idempotencia)
static bool g_i2c_bus_initialized = false;

esp_err_t bsp_i2c_init(void)
{
    if (g_i2c_bus_initialized) {
        ESP_LOGD(TAG, "I2C master bus ya est√° inicializado.");
        return ESP_OK;
    }

    ESP_LOGI(TAG, "Initializing I2C master bus (Modern API)...");

    i2c_master_bus_config_t i2c_bus_config = {
        .i2c_port = I2C_PORT_NUM,
        .sda_io_num = PIN_I2C_SDA,
        .scl_io_num = PIN_I2C_SCL,
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .glitch_ignore_cnt = 7,
        .flags.enable_internal_pullup = true,
    };
    
    ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_config, &g_bus_handle));

    g_i2c_bus_initialized = true;
    ESP_LOGI(TAG, "I2C bus initialized successfully.");
    return ESP_OK;
}

i2c_master_bus_handle_t bsp_get_i2c_bus_handle(void)
{
    return g_bus_handle;
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_i2c.h
# =================================================================================================

/*
 * Archivo: components/diymon_bsp/WS1.9TS/bsp_touch.h
 * Versi√≥n Corregida: Header privado para el m√≥dulo t√°ctil.
 */
#ifndef BSP_TOUCH_H__
#define BSP_TOUCH_H__

#include "driver/i2c_master.h"
#include "esp_lcd_touch_axs5106.h"

// No se declaran funciones aqu√≠ porque todas las funciones p√∫blicas
// est√°n definidas en bsp_api.h.

#endif // BSP_TOUCH_H__

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_qmi8658.c
# =================================================================================================

/*
  Fichero: ./components/diymon_bsp/WS1.9TS/bsp_qmi8658.c
  Fecha: 13/08/2025 - 12:03 
  √öltimo cambio: Eliminadas las funciones de interrupci√≥n no utilizadas.
  Descripci√≥n: Driver del IMU. Se han eliminado las implementaciones de las funciones
               de interrupci√≥n (bsp_imu_interrupt_init, bsp_imu_enable_motion_interrupt,
               bsp_imu_clear_interrupt) para limpiar el c√≥digo, ya que la detecci√≥n
               de 'shake' ahora se realiza por sondeo en la capa de la UI.
*/
#include "bsp_api.h"
#include "bsp_qmi8658.h"
#include "esp_log.h"
#include "driver/i2c_master.h"
#include "driver/gpio.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static const char *TAG = "bsp_qmi8658";

#define IMU_I2C_ADDRESS  0x6B
#define I2C_CLK_SPEED_HZ 400000

static i2c_master_dev_handle_t g_imu_dev_handle = NULL;

// --- Funciones de ayuda est√°ticas ---
static void qmi8658_on_demand_cali(void) {
    ESP_LOGI(TAG, "Performing on-demand calibration...");
    
    uint8_t reset_buf[] = {QMI8658_RESET, 0xb0};
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, reset_buf, sizeof(reset_buf), pdMS_TO_TICKS(100)));
    vTaskDelay(pdMS_TO_TICKS(20));

    uint8_t cali_cmd_buf[] = {QMI8658_CTRL9, QMI8658_CTRL9_CMD_ON_DEMAND_CALI};
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, cali_cmd_buf, sizeof(cali_cmd_buf), pdMS_TO_TICKS(100)));
    
    vTaskDelay(pdMS_TO_TICKS(2200));

    uint8_t nop_cmd_buf[] = {QMI8658_CTRL9, QMI8658_CTRL9_CMD_NOP};
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, nop_cmd_buf, sizeof(nop_cmd_buf), pdMS_TO_TICKS(100)));
    vTaskDelay(pdMS_TO_TICKS(100));

    ESP_LOGI(TAG, "On-demand calibration finished.");
}


// --- Funciones p√∫blicas ---

esp_err_t bsp_imu_init(void)
{
    ESP_LOGI(TAG, "Initializing IMU QMI8658 with Modern I2C API...");
    
    i2c_master_bus_handle_t bus_handle = bsp_get_i2c_bus_handle();
    if (bus_handle == NULL) {
        ESP_LOGE(TAG, "I2C bus handle is not initialized!");
        return ESP_FAIL;
    }

    i2c_device_config_t dev_cfg = {
        .device_address = IMU_I2C_ADDRESS,
        .scl_speed_hz = I2C_CLK_SPEED_HZ,
    };
    
    ESP_ERROR_CHECK(i2c_master_bus_add_device(bus_handle, &dev_cfg, &g_imu_dev_handle));
    ESP_LOGI(TAG, "IMU device added to I2C bus successfully.");

    uint8_t who_am_i = 0;
    ESP_ERROR_CHECK(i2c_master_transmit_receive(g_imu_dev_handle, 
                                                (uint8_t[]){QMI8658_WHO_AM_I}, 1, 
                                                &who_am_i, 1, 
                                                pdMS_TO_TICKS(100)));

    if (who_am_i != 0x05) {
        ESP_LOGE(TAG, "QMI8658 not found! WhoAmI check failed. Read value: 0x%02X", who_am_i);
        return ESP_FAIL;
    }
    ESP_LOGI(TAG, "QMI8658 found successfully! WhoAmI: 0x%02X", who_am_i);

    qmi8658_on_demand_cali();
    
    uint8_t ctrl1_buf[] = {QMI8658_CTRL1, 0x60}; // Habilitar Address Auto-Increment
    ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, ctrl1_buf, sizeof(ctrl1_buf), pdMS_TO_TICKS(100)));

    uint8_t ctrl_regs_data[][2] = {
        {QMI8658_CTRL7, 0x03}, // Habilitar Accel y Gyro
        {QMI8658_CTRL2, 0x23}, // Accel: +-8g, 250Hz ODR
        {QMI8658_CTRL3, 0x53}  // Gyro:  +-1024dps, 250Hz ODR
    };

    for (int i = 0; i < sizeof(ctrl_regs_data) / sizeof(ctrl_regs_data[0]); i++) {
        ESP_ERROR_CHECK(i2c_master_transmit(g_imu_dev_handle, ctrl_regs_data[i], 2, pdMS_TO_TICKS(100)));
    }
    
    ESP_LOGI(TAG, "IMU initialized.");
    return ESP_OK;
}

void bsp_imu_read(float acc[3], float gyro[3])
{
    if (g_imu_dev_handle == NULL) {
        ESP_LOGE(TAG, "IMU device handle not initialized, cannot read.");
        acc[0] = acc[1] = acc[2] = 0;
        gyro[0] = gyro[1] = gyro[2] = 0;
        return;
    }

    uint8_t buf_reg[12];
    short raw_acc_xyz[3];
    short raw_gyro_xyz[3];

    esp_err_t ret = i2c_master_transmit_receive(g_imu_dev_handle,
                                (uint8_t[]){QMI8658_AX_L}, 1,
                                buf_reg, 12,
                                pdMS_TO_TICKS(100));

    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to read IMU data via I2C");
        acc[0] = acc[1] = acc[2] = 0;
        gyro[0] = gyro[1] = gyro[2] = 0;
        return;
    }

    raw_acc_xyz[0] = (int16_t)((buf_reg[1] << 8) | buf_reg[0]);
    raw_acc_xyz[1] = (int16_t)((buf_reg[3] << 8) | buf_reg[2]);
    raw_acc_xyz[2] = (int16_t)((buf_reg[5] << 8) | buf_reg[4]);
    raw_gyro_xyz[0] = (int16_t)((buf_reg[7] << 8) | buf_reg[6]);
    raw_gyro_xyz[1] = (int16_t)((buf_reg[9] << 8) | buf_reg[8]);
    raw_gyro_xyz[2] = (int16_t)((buf_reg[11] << 8) | buf_reg[10]);

    // Conversi√≥n a m/s^2 (+-8g)
    acc[0] = ((float)raw_acc_xyz[0] / 4096.0f) * 9.81f;
    acc[1] = ((float)raw_acc_xyz[1] / 4096.0f) * 9.81f;
    acc[2] = ((float)raw_acc_xyz[2] / 4096.0f) * 9.81f;
    
    // Conversi√≥n a dps (+-1024dps)
    gyro[0] = (float)raw_gyro_xyz[0] / 32.0f;
    gyro[1] = (float)raw_gyro_xyz[1] / 32.0f;
    gyro[2] = (float)raw_gyro_xyz[2] / 32.0f;
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_qmi8658.h
# =================================================================================================

/*
 * Fichero: ./diymon_bsp/WS1.9TS/bsp_qmi8658.h
 * Fecha: 12/08/2025 - 09:25 pm
 * √öltimo cambio: Corregidos los valores de los registros y a√±adidos los de calibraci√≥n.
 * Descripci√≥n: Cabecera privada para el sensor QMI8658. Se han corregido las direcciones
 *              de los registros de datos (temperatura, aceler√≥metro, etc.) para que coincidan
 *              con la hoja de datos oficial y se han a√±adido los registros y comandos
 *              necesarios para la calibraci√≥n y configuraci√≥n avanzada del sensor.
 */
#ifndef BSP_QMI8658_H
#define BSP_QMI8658_H

#include <stdint.h>

// Definici√≥n de los registros del sensor QMI8658 (corregidos seg√∫n datasheet)
typedef enum
{
    QMI8658_WHO_AM_I        = 0x00,
    QMI8658_REVISION_ID     = 0x01,
    QMI8658_CTRL1           = 0x02,
    QMI8658_CTRL2           = 0x03,
    QMI8658_CTRL3           = 0x04,
    QMI8658_CTRL4           = 0x05,
    QMI8658_CTRL5           = 0x06,
    QMI8658_CTRL6           = 0x07,
    QMI8658_CTRL7           = 0x08,
    QMI8658_CTRL9           = 0x0A,
    QMI8658_CAL1_L          = 0x0B,
    QMI8658_STATUS_INT      = 0x2D,
    QMI8658_TEMP_L          = 0x33,
    QMI8658_TEMP_H          = 0x34,
    QMI8658_AX_L            = 0x35,
    QMI8658_AX_H            = 0x36,
    QMI8658_AY_L            = 0x37,
    QMI8658_AY_H            = 0x38,
    QMI8658_AZ_L            = 0x39,
    QMI8658_AZ_H            = 0x3A,
    QMI8658_GX_L            = 0x3B,
    QMI8658_GX_H            = 0x3C,
    QMI8658_GY_L            = 0x3D,
    QMI8658_GY_H            = 0x3E,
    QMI8658_GZ_L            = 0x3F,
    QMI8658_GZ_H            = 0x40,
    QMI8658_RESET           = 0x60
} qmi8658_reg_t;

// Comandos para el registro CTRL9
typedef enum {
    QMI8658_CTRL9_CMD_NOP = 0x00,
    QMI8658_CTRL9_CMD_ON_DEMAND_CALI = 0xA2,
} qmi8658_ctrl9_cmd_t;

#endif // BSP_QMI8658_H


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_sdcard.c
# =================================================================================================

/*
 * Archivo: components/diymon_bsp/WS1.9TS/bsp_sdcard.c
 * Versi√≥n: Final (con max_files aumentado)
 */
#include "bsp_api.h"
#include "esp_log.h"
#include "esp_vfs_fat.h"
#include "sdmmc_cmd.h"
#include "driver/sdspi_host.h"
#include "driver/spi_common.h"
#include "bsp_sdcard.h" 

static const char *TAG = "bsp_sdcard";

// --- CONFIGURACI√ìN PRIVADA ---
#define PIN_NUM_MISO  (GPIO_NUM_19)
#define PIN_NUM_MOSI  (GPIO_NUM_4)
#define PIN_NUM_CLK   (GPIO_NUM_5)
#define PIN_NUM_CS    (GPIO_NUM_20)
#define MOUNT_POINT   "/sdcard"

static sdmmc_card_t *g_card = NULL;
static sdmmc_host_t g_host = SDSPI_HOST_DEFAULT();

// --- IMPLEMENTACI√ìN DE LA FUNCI√ìN P√öBLICA ---
esp_err_t bsp_sdcard_init(void)
{
    ESP_LOGI(TAG, "Initializing SD card...");
    esp_err_t ret;

    // 1. Configurar el sistema de ficheros FAT que se va a montar
    esp_vfs_fat_sdmmc_mount_config_t mount_config = {
        .format_if_mount_failed = false,
        // [CAMBIO CLAVE] Aumentamos el l√≠mite para permitir la navegaci√≥n por subdirectorios.
        .max_files = 10,  // <-- El √∫nico cambio est√° aqu√≠. Antes era 5.
        .allocation_unit_size = 16 * 1024
    };

    g_host.slot = SPI2_HOST;

    sdspi_device_config_t slot_config = SDSPI_DEVICE_CONFIG_DEFAULT();
    slot_config.gpio_cs = PIN_NUM_CS;
    slot_config.host_id = SPI2_HOST;

    ret = esp_vfs_fat_sdspi_mount(MOUNT_POINT, &g_host, &slot_config, &mount_config, &g_card);

    if (ret != ESP_OK) {
        if (ret == ESP_FAIL) {
            ESP_LOGE(TAG, "Failed to mount filesystem.");
        } else {
            ESP_LOGE(TAG, "Failed to initialize the card (%s).", esp_err_to_name(ret));
        }
        return ret;
    }
    
    sdmmc_card_print_info(stdout, g_card);
    ESP_LOGI(TAG, "SD card initialized successfully!");
    
    return ESP_OK;
}

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_sdcard.h
# =================================================================================================

/*
 * Fichero: bsp_sdcard.h
 * Fecha: 08/08/2025
 * √öltimo cambio: A√±adida la declaraci√≥n de bsp_sdcard_init.
 * Descripci√≥n: Interfaz p√∫blica para el controlador de la tarjeta SD.
 */
#ifndef __BSP_SDCARD_H_
#define __BSP_SDCARD_H_

#include "esp_err.h"
#include <stdint.h> // Para uint64_t

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el bus SPI y monta el sistema de ficheros FAT en la tarjeta SD.
 * 
 * @return esp_err_t 
 *         - ESP_OK si la inicializaci√≥n y el montaje son exitosos.
 *         - ESP_FAIL u otros c√≥digos de error si algo falla.
 */
esp_err_t bsp_sdcard_init(void);

/**
 * @brief Obtiene el tama√±o total de la tarjeta SD en bytes.
 * 
 * @note Esta funci√≥n debe ser llamada despu√©s de una inicializaci√≥n exitosa.
 * @return uint64_t Tama√±o de la tarjeta en bytes.
 */
uint64_t bsp_sdcard_get_size(void);


#ifdef __cplusplus
}
#endif

#endif // __BSP_SDCARD_H_

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_spi.c
# =================================================================================================

/*
 * Fichero: ./components/diymon_bsp/WS1.9TS/bsp_spi.c
 * Fecha: 12/08/2025 - 05:05 pm
 * √öltimo cambio: Implementada la inicializaci√≥n idempotente.
 * Descripci√≥n: Driver para la inicializaci√≥n del bus SPI. La funci√≥n sp_spi_init es ahora idempotente, asegurando que el bus SPI solo se inicializa una vez, previniendo crashes por m√∫ltiples llamadas.
 */
#include "bsp_api.h"
#include "esp_log.h"
#include "driver/spi_master.h"
#include "bsp_display.h" 

static const char *TAG = "bsp_spi";

#define BSP_SPI_HOST            SPI2_HOST
#define PIN_NUM_SPI_SCLK        5
#define PIN_NUM_SPI_MOSI        4
#define PIN_NUM_SPI_MISO        19 

// Bandera para asegurar la inicializaci√≥n √∫nica (idempotencia)
static bool g_spi_bus_initialized = false;

esp_err_t bsp_spi_init(void) {
    if (g_spi_bus_initialized) {
        ESP_LOGD(TAG, "SPI bus (Host: %d) ya est√° inicializado.", BSP_SPI_HOST);
        return ESP_OK;
    }

    ESP_LOGI(TAG, "Initializing main SPI bus (Host: %d)...", BSP_SPI_HOST);

    spi_bus_config_t buscfg = {
        .sclk_io_num = PIN_NUM_SPI_SCLK, 
        .mosi_io_num = PIN_NUM_SPI_MOSI,
        .miso_io_num = PIN_NUM_SPI_MISO, 
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = BSP_LCD_H_RES * 100 * sizeof(uint16_t)
    };
    
    esp_err_t ret = spi_bus_initialize(BSP_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize SPI bus!");
    } else {
        g_spi_bus_initialized = true;
        ESP_LOGI(TAG, "SPI bus initialized successfully.");
    }

    return ret;
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_touch.c
# =================================================================================================

/*
  Fichero: ./components/diymon_bsp/WS1.9TS/bsp_touch.c
  Fecha: 12/08/2025 - 09:00
  √öltimo cambio: Corregido para usar el bus I2C global en lugar de pasarlo.
  Descripci√≥n: Driver del panel t√°ctil CST816S. Ahora utiliza la funci√≥n p√∫blica
               `bsp_get_i2c_bus_handle` para obtener el manejador del bus I2C.
*/
#include "bsp_api.h"
#include "esp_log.h"
#include "esp_lcd_touch_cst816s.h"

static const char *TAG = "bsp_touch";
static esp_lcd_touch_handle_t g_touch_handle = NULL;

esp_err_t bsp_touch_init(void)
{
    ESP_LOGI(TAG, "Initializing touch controller CST816S (Modern API)...");

    i2c_master_bus_handle_t bus_handle = bsp_get_i2c_bus_handle();
    if (bus_handle == NULL) {
        ESP_LOGE(TAG, "I2C bus handle is not initialized!");
        return ESP_FAIL;
    }

    esp_lcd_panel_io_handle_t tp_io_handle = NULL;
    const esp_lcd_panel_io_i2c_config_t tp_io_config = {
        .dev_addr = ESP_LCD_TOUCH_IO_I2C_CST816S_ADDRESS,
        .control_phase_bytes = 1,
        .lcd_cmd_bits = 8,
        .lcd_param_bits = 8,
        .scl_speed_hz = 400000,
        .flags = {
            .dc_low_on_data = 0,
            .disable_control_phase = 1,
        }
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_io_i2c(bus_handle, &tp_io_config, &tp_io_handle));

    const esp_lcd_touch_config_t tp_cfg = {
        .x_max = 170,
        .y_max = 320,
        .rst_gpio_num = GPIO_NUM_NC,
        .int_gpio_num = GPIO_NUM_NC,
    };
    ESP_ERROR_CHECK(esp_lcd_touch_new_i2c_cst816s(tp_io_handle, &tp_cfg, &g_touch_handle));
    
    ESP_LOGI(TAG, "Touch driver initialized successfully.");
    return ESP_OK;
}

esp_lcd_touch_handle_t bsp_get_touch_handle(void)
{
    return g_touch_handle;
}

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_touch.h
# =================================================================================================

#ifndef __BSP_TOUCH_H__
#define __BSP_TOUCH_H__

#include "driver/i2c_master.h"
#include "esp_lcd_touch_axs5106.h"


#define EXAMPLE_PIN_TP_INT GPIO_NUM_21
#define EXAMPLE_PIN_TP_RST GPIO_NUM_20


#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif


#endif

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_wifi.c
# =================================================================================================

/*
  Fichero: ./components/diymon_bsp/WS1.9TS/bsp_wifi.c
  Fecha: 12/08/2025 - 04:35 pm
  √öltimo cambio: A√±adido log de depuraci√≥n para mostrar la contrase√±a le√≠da de NVS.
  Descripci√≥n: Gestor de conexi√≥n WiFi. Se a√±ade un log de advertencia para imprimir la contrase√±a real utilizada durante la conexi√≥n, facilitando la depuraci√≥n de caracteres especiales.
*/
#include "bsp_api.h"
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "freertos/semphr.h"
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"
#include "lwip/err.h"
#include "lwip/sys.h"
#include <assert.h>

#define PORTAL_AP_SSID          "DIYTogether"
#define PORTAL_AP_PASS          "MakeItYours"
#define PORTAL_AP_CHANNEL       1
#define PORTAL_AP_MAX_CONN      4

static const char *TAG = "bsp_wifi";
static SemaphoreHandle_t s_ip_acquired_sem = NULL;

static void event_handler(void* arg, esp_event_base_t event_base,
                                int32_t event_id, void* event_data)
{
    if (event_base == WIFI_EVENT) {
        switch(event_id) {
            case WIFI_EVENT_STA_START:
                ESP_LOGI(TAG, "EVENTO: WIFI_EVENT_STA_START - Intentando conectar...");
                esp_wifi_connect();
                break;
            case WIFI_EVENT_STA_CONNECTED:
                ESP_LOGI(TAG, "EVENTO: WIFI_EVENT_STA_CONNECTED - Conectado al AP, esperando IP.");
                break;
            case WIFI_EVENT_STA_DISCONNECTED: {
                wifi_event_sta_disconnected_t* event = (wifi_event_sta_disconnected_t*) event_data;
                ESP_LOGE(TAG, "EVENTO: WIFI_EVENT_STA_DISCONNECTED - Desconexi√≥n de la red.");
                ESP_LOGE(TAG, "Raz√≥n de la desconexi√≥n: %d", event->reason);
                if (event->reason == WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT) {
                    ESP_LOGE(TAG, "DIAGN√ìSTICO: Error '4-Way Handshake Timeout'. ¬°Verifica que la contrase√±a guardada sea correcta para la red!");
                }
                break;
            }
            default:
                ESP_LOGD(TAG, "Recibido evento WiFi no gestionado: %d", (int)event_id);
                break;
        }
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "EVENTO: IP_EVENT_STA_GOT_IP - ¬°IP Obtenida!: " IPSTR, IP2STR(&event->ip_info.ip));
        if (s_ip_acquired_sem) {
            xSemaphoreGive(s_ip_acquired_sem);
        }
    }
}


void bsp_wifi_init_stack(void) {
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
}

esp_err_t bsp_wifi_scan(void) {
    ESP_LOGI(TAG, "Iniciando escaneo de redes WiFi (modo aut√≥nomo)...");
    
    esp_netif_t *sta_netif = esp_netif_create_default_wifi_sta();
    assert(sta_netif);
    
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_start());

    wifi_scan_config_t scan_config = {
        .ssid = 0, .bssid = 0, .channel = 0, .show_hidden = false
    };
    ESP_ERROR_CHECK(esp_wifi_scan_start(&scan_config, true));

    uint16_t ap_count = 0;
    esp_wifi_scan_get_ap_num(&ap_count);
    if (ap_count > 0) {
        wifi_ap_record_t *ap_list = (wifi_ap_record_t *)malloc(sizeof(wifi_ap_record_t) * ap_count);
        if (ap_list) {
            ESP_ERROR_CHECK(esp_wifi_scan_get_ap_records(&ap_count, ap_list));
            ESP_LOGI(TAG, "------------------- REDES WIFI ENCONTRADAS -------------------");
            for (int i = 0; i < ap_count; i++) {
                ESP_LOGI(TAG, "SSID: %-32s | RSSI: %d", (char*)ap_list[i].ssid, ap_list[i].rssi);
            }
            ESP_LOGI(TAG, "------------------------------------------------------------");
            free(ap_list);
        }
    } else {
        ESP_LOGW(TAG, "No se encontraron redes WiFi.");
    }
    
    ESP_ERROR_CHECK(esp_wifi_stop());
    ESP_ERROR_CHECK(esp_wifi_deinit());
    esp_netif_destroy(sta_netif);
    
    ESP_LOGI(TAG, "Escaneo aut√≥nomo finalizado, recursos liberados.");
    return ESP_OK;
}

void bsp_wifi_start_ap(void) {
    esp_netif_create_default_wifi_ap();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    wifi_config_t wifi_config = {
        .ap = {
            .ssid = PORTAL_AP_SSID,
            .ssid_len = strlen(PORTAL_AP_SSID),
            .channel = PORTAL_AP_CHANNEL,
            .password = PORTAL_AP_PASS,
            .max_connection = PORTAL_AP_MAX_CONN,
            .authmode = WIFI_AUTH_WPA_WPA2_PSK
        },
    };
    if (strlen(PORTAL_AP_PASS) == 0) {
        wifi_config.ap.authmode = WIFI_AUTH_OPEN;
    }

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());

    ESP_LOGI(TAG, "Punto de Acceso WiFi iniciado. SSID: %s, Password: %s",
             PORTAL_AP_SSID, PORTAL_AP_PASS);
}

void bsp_wifi_init_sta_from_nvs(void) {
    bsp_wifi_scan();
    
    esp_netif_create_default_wifi_sta();
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &event_handler, NULL, NULL));
    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &event_handler, NULL, NULL));

    s_ip_acquired_sem = xSemaphoreCreateBinary();

    char ssid[32] = {0}, pass[64] = {0};
    int32_t authmode = 0;
    size_t len_ssid = sizeof(ssid), len_pass = sizeof(pass);

    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "No se pudo abrir NVS para leer credenciales WiFi.");
        return;
    }
    nvs_get_str(nvs_handle, "wifi_ssid", ssid, &len_ssid);
    nvs_get_str(nvs_handle, "wifi_pass", pass, &len_pass);
    nvs_get_i32(nvs_handle, "wifi_authmode", &authmode);
    nvs_close(nvs_handle);

    if (len_ssid > 1 && strcmp(ssid, "skipped") != 0) {
        // --- [NUEVO] Log de depuraci√≥n para mostrar la contrase√±a ---
        ESP_LOGW(TAG, "DEPURACI√ìN: Usando SSID:[%s] | Contrase√±a:[%s] | ModoAuth:[%d]", ssid, pass, (int)authmode);

        wifi_config_t wifi_config = {0};
        strcpy((char *)wifi_config.sta.ssid, ssid);
        strcpy((char *)wifi_config.sta.password, pass);
        wifi_config.sta.scan_method = WIFI_ALL_CHANNEL_SCAN;
        
        switch (authmode) {
            case 2: // Forzar WPA3
                ESP_LOGI(TAG, "Configurando conexi√≥n: WPA3-PSK (PMF Requerido).");
                wifi_config.sta.threshold.authmode = WIFI_AUTH_WPA3_PSK;
                wifi_config.sta.pmf_cfg.capable = true;
                wifi_config.sta.pmf_cfg.required = true;
                break;
            case 1: // Forzar WPA2
                ESP_LOGI(TAG, "Configurando conexi√≥n: WPA2-PSK (PMF Desactivado).");
                wifi_config.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;
                wifi_config.sta.pmf_cfg.capable = false;
                wifi_config.sta.pmf_cfg.required = false;
                break;
            case 0: // Autom√°tico (por defecto)
            default:
                ESP_LOGI(TAG, "Configurando conexi√≥n: Modo autom√°tico -> WPA2-PSK (PMF Desactivado para compatibilidad).");
                wifi_config.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;
                wifi_config.sta.pmf_cfg.capable = false;
                wifi_config.sta.pmf_cfg.required = false;
                break;
        }
        
        ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
        ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
        
        ESP_LOGI(TAG, "Protocolos WiFi limitados a 802.11b/g/n para m√°xima compatibilidad.");
        ESP_ERROR_CHECK(esp_wifi_set_protocol(WIFI_IF_STA, WIFI_PROTOCOL_11B | WIFI_PROTOCOL_11G | WIFI_PROTOCOL_11N));
        
        ESP_ERROR_CHECK(esp_wifi_start());
        ESP_ERROR_CHECK(esp_wifi_set_ps(WIFI_PS_NONE));

        ESP_LOGI(TAG, "Iniciando conexi√≥n a la red guardada: %s", ssid);
    } else {
        ESP_LOGW(TAG, "No hay credenciales WiFi v√°lidas para conectar.");
    }
}

bool bsp_wifi_wait_for_ip(uint32_t timeout_ms) {
    if (!s_ip_acquired_sem) return false;
    return (xSemaphoreTake(s_ip_acquired_sem, pdMS_TO_TICKS(timeout_ms)) == pdTRUE);
}

void bsp_wifi_get_ip(char *ip) {
    esp_netif_t* netif = esp_netif_get_handle_from_ifkey("WIFI_STA_DEF");
    if(netif) {
        esp_netif_ip_info_t ip_info;
        esp_netif_get_ip_info(netif, &ip_info);
        sprintf(ip, IPSTR, IP2STR(&ip_info.ip));
    }
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp_wifi.h
# =================================================================================================

/*
  Fichero: ./components/diymon_bsp/WS1.9TS/bsp_wifi.h
  Fecha: 12/08/2025 - 05:05 pm
  √öltimo cambio: Actualizadas las declaraciones de funciones para reflejar la implementaci√≥n.
  Descripci√≥n: Interfaz p√∫blica del gestor WiFi del BSP. Se han corregido las declaraciones para que coincidan con las funciones realmente exportadas por sp_wifi.c, resolviendo posibles errores de 'implicit declaration'.
*/
#ifndef __BSP_WIFI_H__
#define __BSP_WIFI_H__

#include "esp_err.h"
#include "esp_wifi.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Inicializa el stack de red (netif y event loop).
 */
void bsp_wifi_init_stack(void);

/**
 * @brief Escanea redes WiFi disponibles y las muestra en el log.
 * @return ESP_OK si el escaneo fue exitoso.
 */
esp_err_t bsp_wifi_scan(void);

/**
 * @brief Inicia el dispositivo en modo Punto de Acceso (AP).
 */
void bsp_wifi_start_ap(void);

/**
 * @brief Inicia el dispositivo en modo Estaci√≥n (STA) usando credenciales de NVS.
 */
void bsp_wifi_init_sta_from_nvs(void);

/**
 * @brief Espera de forma bloqueante hasta obtener una direcci√≥n IP.
 * @param timeout_ms Tiempo m√°ximo de espera en milisegundos.
 * @return true si se obtuvo IP, false en caso de timeout.
 */
bool bsp_wifi_wait_for_ip(uint32_t timeout_ms);

/**
 * @brief Obtiene la direcci√≥n IP actual del dispositivo en modo STA.
 * @param ip Puntero a un buffer de caracteres donde se escribir√° la IP.
 */
void bsp_wifi_get_ip(char *ip);

#ifdef __cplusplus
}
#endif

#endif // __BSP_WIFI_H__


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\WS1.9TS\bsp.c
# =================================================================================================

/*
  Fichero: ./components/diymon_bsp/WS1.9TS/bsp.c
  Fecha: 13/08/2025 - 12:06 
  √öltimo cambio: A√±adida la inicializaci√≥n del ADC de la bater√≠a.
  Descripci√≥n: Orquestador del BSP. Se a√±ade la llamada a sp_battery_init en la
               secuencia de inicializaci√≥n principal para asegurar que el ADC est√©
               listo antes de que cualquier tarea intente leer el voltaje de la bater√≠a,
               solucionando as√≠ un crash por puntero nulo.
*/
#include "bsp_api.h"
#include "esp_err.h"
#include "esp_log.h" 
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

static const char *TAG = "bsp";

// Inicializaci√≥n completa para la aplicaci√≥n principal
esp_err_t bsp_init(void) {
    ESP_LOGI(TAG, "Inicializando TODO el hardware para la aplicaci√≥n principal...");
    ESP_ERROR_CHECK(bsp_i2c_init());
    ESP_ERROR_CHECK(bsp_spi_init());
    ESP_ERROR_CHECK(bsp_display_init());
    ESP_ERROR_CHECK(bsp_touch_init());
    ESP_ERROR_CHECK(bsp_imu_init());
    ESP_ERROR_CHECK(bsp_sdcard_init());
    ESP_ERROR_CHECK(bsp_battery_init());
    return ESP_OK;
}

// Inicializaci√≥n para modos de servicio que necesitan mostrar una imagen
esp_err_t bsp_init_service_mode(void) {
    ESP_LOGI(TAG, "Inicializando hardware para modo de servicio con pantalla...");
    ESP_ERROR_CHECK(bsp_spi_init());
    ESP_ERROR_CHECK(bsp_sdcard_init());
    ESP_ERROR_CHECK(bsp_display_init());
    bsp_display_set_brightness(100);
    return ESP_OK;
}

// Inicializaci√≥n m√≠nima para modos de servicio que no usan pantalla
esp_err_t bsp_init_minimal_headless(void) {
    ESP_LOGI(TAG, "Inicializando hardware M√çNIMO para modo headless (SPI + SD)...");
    ESP_ERROR_CHECK(bsp_spi_init());
    ESP_ERROR_CHECK(bsp_sdcard_init());
    return ESP_OK;
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_bsp\CMakeLists.txt
# =================================================================================================

# Fichero: ./components/diymon_bsp/CMakeLists.txt
# Fecha: 08/08/2025 - 21:50
# √öltimo cambio: Restaurado a la lista de dependencias correcta.
# Descripci√≥n: Registro del componente BSP. Se mantiene la lista de dependencias
#              alineada con el hardware real del proyecto.

# 1. Definimos la subcarpeta de nuestra placa
set(BOARD_SUBDIR "WS1.9TS")

# 2. Le decimos a CMake que encuentre todos los archivos .c
file(GLOB component_sources "${BOARD_SUBDIR}/*.c")

# 3. Registramos el componente
idf_component_register(
    SRCS ${component_sources}
    
    INCLUDE_DIRS "include"
    PRIV_INCLUDE_DIRS "${BOARD_SUBDIR}"
    
    REQUIRES 
        # Drivers est√°ndar
        driver
        esp_lcd
        sdmmc
        fatfs
        esp_adc
        esp_wifi
        esp_driver_i2c
        nvs_flash

        # Drivers gestionados
        lvgl
        esp_lvgl_port
        esp_lcd_touch_cst816s
        esp_lcd_sh8601
)

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_core\include\diymon_evolution.h
# =================================================================================================

/*
 * Fichero: ./components/diymon_core/include/diymon_evolution.h
 * Fecha: 13/08/2025 - 19:45
 * √öltimo cambio: A√±adida la declaraci√≥n para resetear el estado.
 * Descripci√≥n: Cabecera del motor de evoluci√≥n. Expone las funciones para gestionar el estado y la secuencia de evoluci√≥n del DIYMON, incluyendo la involuci√≥n y el reseteo de estado.
 */
#ifndef DIYMON_EVOLUTION_H
#define DIYMON_EVOLUTION_H

#include <stdint.h> // Para usar tipos como uint8_t

// Estructura para almacenar las estad√≠sticas de una forma can√≥nica
typedef struct {
    uint8_t fue;
    uint8_t res;
    uint8_t vel;
    uint8_t intel;
} diymon_stats_t;

/**
 * @brief Inicializa el motor de evoluci√≥n.
 */
void diymon_evolution_init(void);

/**
 * @brief Obtiene las estad√≠sticas base para un C√≥digo Evolutivo dado.
 * @param evo_code El c√≥digo a buscar (ej: "1.2.3").
 * @return Un puntero a las estad√≠sticas (solo lectura) o NULL si no se encuentra.
 */
const diymon_stats_t* diymon_get_stats_for_code(const char* evo_code);

/**
 * @brief Establece el c√≥digo evolutivo del DIYMON activo.
 * @param new_code El nuevo c√≥digo a establecer.
 */
void diymon_set_current_code(const char* new_code);

/**
 * @brief Obtiene el c√≥digo evolutivo del DIYMON activo.
 * @return Un puntero al c√≥digo actual.
 */
const char* diymon_get_current_code(void);

/**
 * @brief Obtiene el siguiente c√≥digo en la secuencia de evoluci√≥n predefinida.
 * @param current_code El c√≥digo actual.
 * @return El siguiente c√≥digo en la secuencia, o NULL si es la evoluci√≥n final.
 */
const char* diymon_get_next_evolution_in_sequence(const char* current_code);

/**
 * @brief Obtiene el c√≥digo anterior en la secuencia de evoluci√≥n predefinida.
 * @param current_code El c√≥digo actual.
 * @return El c√≥digo anterior en la secuencia, o NULL si es la forma inicial.
 */
const char* diymon_get_previous_evolution_in_sequence(const char* current_code);

/**
 * @brief Construye un c√≥digo de evoluci√≥n ramificado y comprueba si existe.
 * @param current_code El c√≥digo de evoluci√≥n actual.
 * @param branch_id El identificador de la rama elemental (1-4).
 * @return El nuevo c√≥digo de evoluci√≥n si es v√°lido, o NULL si no existe.
 */
const char* diymon_get_branched_evolution(const char* current_code, int branch_id);

/**
 * @brief Borra el estado de evoluci√≥n guardado en la NVS.
 */
void diymon_evolution_reset_state(void);


#endif // DIYMON_EVOLUTION_H


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_core\CMakeLists.txt
# =================================================================================================

idf_component_register(SRCS "diymon_evolution.c"
                    INCLUDE_DIRS "include"
                    # Le damos permiso para usar tanto los logs como la memoria flash
                    REQUIRES "log" "nvs_flash"
                    )

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_core\diymon_evolution.c
# =================================================================================================

/*
 * Fichero: ./components/diymon_core/diymon_evolution.c
 * Fecha: 13/08/2025 - 19:45
 * √öltimo cambio: Implementada la funci√≥n de reseteo de estado.
 * Descripci√≥n: A√±adida la l√≥gica para obtener la evoluci√≥n anterior y para resetear el estado de evoluci√≥n guardado en la NVS.
 */

#include "diymon_evolution.h"
#include <string.h>
#include <stdlib.h>
#include "esp_log.h"
#include "nvs_flash.h"
#include "nvs.h"

static const char* TAG = "DIYMON_CORE";

// --- LA TABLA MAESTRA DE ESTAD√çSTICAS ---
static const struct {
    const char* evo_code;
    const diymon_stats_t stats;
} G_MASTER_TABLE[] = {
    // Base
    {"0",       {5, 5, 5, 5}},
    // Etapa 1
    {"1",       {7, 5, 6, 6}},
    // Etapa 2 (ramas de "1")
    {"1.1",     {10, 5, 7, 7}}, // Fuego
    {"1.2",     {7, 10, 5, 7}}, // Agua
    {"1.3",     {8, 8, 8, 5}}, // Tierra
    {"1.4",     {7, 5, 10, 7}}, // Aire
    // Etapa 3 (ramas de "1.1")
    {"1.1.1",   {12, 5, 8, 8}},
    {"1.1.2",   {10, 8, 7, 8}},
    {"1.1.3",   {11, 7, 9, 6}},
    {"1.1.4",   {10, 5, 9, 9}},
};

static char G_CURRENT_DIYMON_CODE[16] = "0";
// B√∫fer est√°tico para construir c√≥digos de evoluci√≥n candidatos.
static char G_EVO_CODE_BUFFER[16];


// ----- Funciones para interactuar con la memoria FLASH (NVS) -----

static void diymon_core_save_state(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("diymon_storage", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) abriendo NVS para escribir!", esp_err_to_name(err));
        return;
    }
    err = nvs_set_str(nvs_handle, "evo_code", G_CURRENT_DIYMON_CODE);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) guardando 'evo_code' en NVS!", esp_err_to_name(err));
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) haciendo commit en NVS!", esp_err_to_name(err));
    }
    nvs_close(nvs_handle);
    ESP_LOGI(TAG, "Estado guardado en memoria flash: %s", G_CURRENT_DIYMON_CODE);
}

static void diymon_core_load_state(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("diymon_storage", NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGI(TAG, "NVS: No se encontr√≥ partici√≥n, empezando de cero.");
        strcpy(G_CURRENT_DIYMON_CODE, "0"); // Asegurar estado inicial si no hay NVS
        return;
    }
    size_t required_size = sizeof(G_CURRENT_DIYMON_CODE);
    err = nvs_get_str(nvs_handle, "evo_code", G_CURRENT_DIYMON_CODE, &required_size);
    switch (err) {
        case ESP_OK:
            ESP_LOGI(TAG, "Estado cargado de memoria flash: %s", G_CURRENT_DIYMON_CODE);
            break;
        case ESP_ERR_NVS_NOT_FOUND:
            ESP_LOGI(TAG, "NVS: Clave 'evo_code' no encontrada. Es la primera ejecuci√≥n.");
            strcpy(G_CURRENT_DIYMON_CODE, "0"); // Estado inicial
            break;
        default:
            ESP_LOGE(TAG, "Error (%s) cargando 'evo_code' desde NVS!", esp_err_to_name(err));
    }
    nvs_close(nvs_handle);
}

// ----- Funciones p√∫blicas -----

void diymon_evolution_init(void) {
    ESP_LOGI(TAG, "Motor de evoluci√≥n inicializado.");
    diymon_core_load_state();
}

void diymon_set_current_code(const char* new_code) {
    strncpy(G_CURRENT_DIYMON_CODE, new_code, sizeof(G_CURRENT_DIYMON_CODE) - 1);
    diymon_core_save_state();
}

const diymon_stats_t* diymon_get_stats_for_code(const char* evo_code) {
    for (int i = 0; i < sizeof(G_MASTER_TABLE) / sizeof(G_MASTER_TABLE[0]); ++i) {
        if (strcmp(G_MASTER_TABLE[i].evo_code, evo_code) == 0) {
            return &G_MASTER_TABLE[i].stats;
        }
    }
    return NULL;
}

const char* diymon_get_current_code(void) {
    return G_CURRENT_DIYMON_CODE;
}

const char* diymon_get_next_evolution_in_sequence(const char* current_code) {
    if (strcmp(current_code, "0") == 0) return "1";
    if (strcmp(current_code, "1") == 0) return "1.1";
    if (strcmp(current_code, "1.1") == 0) return "1.1.1";
    return NULL;
}

const char* diymon_get_previous_evolution_in_sequence(const char* current_code) {
    if (strcmp(current_code, "0") == 0) {
        return NULL; // Ya est√° en la forma base.
    }

    const char* last_dot = strrchr(current_code, '.');
    
    // Si no hay punto, la involuci√≥n es hacia "0".
    if (!last_dot) {
        return "0";
    }

    // Si hay un punto, se trunca el c√≥digo.
    size_t parent_len = last_dot - current_code;
    strncpy(G_EVO_CODE_BUFFER, current_code, parent_len);
    G_EVO_CODE_BUFFER[parent_len] = '\0';

    // Se busca el c√≥digo padre en la tabla para devolver un puntero v√°lido.
    for (int i = 0; i < sizeof(G_MASTER_TABLE) / sizeof(G_MASTER_TABLE[0]); ++i) {
        if (strcmp(G_MASTER_TABLE[i].evo_code, G_EVO_CODE_BUFFER) == 0) {
            return G_MASTER_TABLE[i].evo_code;
        }
    }

    return NULL; // El padre no existe en la tabla.
}

const char* diymon_get_branched_evolution(const char* current_code, int branch_id) {
    snprintf(G_EVO_CODE_BUFFER, sizeof(G_EVO_CODE_BUFFER), "%s.%d", current_code, branch_id);

    // Buscar si el c√≥digo generado existe en la tabla de evoluciones
    for (int i = 0; i < sizeof(G_MASTER_TABLE) / sizeof(G_MASTER_TABLE[0]); ++i) {
        if (strcmp(G_MASTER_TABLE[i].evo_code, G_EVO_CODE_BUFFER) == 0) {
            return G_MASTER_TABLE[i].evo_code; // Devuelve el puntero de la tabla
        }
    }

    return NULL; // La evoluci√≥n no es v√°lida
}

void diymon_evolution_reset_state(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("diymon_storage", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Error (%s) abriendo NVS para borrar estado de evoluci√≥n.", esp_err_to_name(err));
        return;
    }
    err = nvs_erase_key(nvs_handle, "evo_code");
    if (err == ESP_OK) {
        ESP_LOGI(TAG, "Clave 'evo_code' borrada de NVS.");
    } else {
        ESP_LOGE(TAG, "Error al borrar 'evo_code': %s", esp_err_to_name(err));
    }
    nvs_commit(nvs_handle);
    nvs_close(nvs_handle);
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\actions.c
# =================================================================================================

/*
  Fichero: ./components/diymon_ui/actions.c
  Fecha: 12/08/2025 - 02:15 pm
  √öltimo cambio: Acortada la clave NVS para cumplir el l√≠mite de 15 caracteres.
  Descripci√≥n: Se ha corregido el error ESP_ERR_NVS_KEY_TOO_LONG al cambiar el nombre de
               la clave de "enable_config_mode" (18 caracteres) a "config_mode" (11 caracteres),
               lo que cumple con el l√≠mite m√°ximo de la API de NVS.
*/
#include "actions.h"
#include "ui_action_animations.h" 
#include "esp_log.h"
#include "diymon_evolution.h"
#include "screen_manager.h" 
#include "wifi_portal.h"
#include "esp_system.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "nvs_flash.h"
#include "nvs.h"

static const char *TAG = "DIYMON_ACTIONS";

static int s_brightness_levels[] = {25, 50, 75, 100};
static int s_current_brightness_idx = 3;

static void erase_nvs_key(const char* key) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err == ESP_OK) {
        nvs_erase_key(nvs_handle, key);
        nvs_commit(nvs_handle);
        nvs_close(nvs_handle);
    }
}

void execute_diymon_action(diymon_action_id_t action_id) {
    switch(action_id) {
        case ACTION_ID_COMER:
        case ACTION_ID_EJERCICIO:
        case ACTION_ID_ATACAR:
            ESP_LOGI(TAG, "Accion de jugador. Delegando a reproductor.");
            ui_action_animations_play(action_id);
            break;

        case ACTION_ID_BRIGHTNESS_CYCLE:
            s_current_brightness_idx = (s_current_brightness_idx + 1) % (sizeof(s_brightness_levels) / sizeof(s_brightness_levels[0]));
            int new_brightness = s_brightness_levels[s_current_brightness_idx];
            screen_manager_set_brightness(new_brightness);
            ESP_LOGI(TAG, "Accion: Ciclar Brillo a %d%%", new_brightness);
            break;

        case ACTION_ID_TOGGLE_SCREEN:
            if (screen_manager_is_off()) {
                ESP_LOGI(TAG, "Accion: Encender pantalla.");
                screen_manager_turn_on();
            } else {
                ESP_LOGI(TAG, "Accion: Apagar pantalla.");
                screen_manager_turn_off();
            }
            break;

        case ACTION_ID_RESET_ALL:
            ESP_LOGW(TAG, "ACCI√ìN: Borrado completo de configuraciones.");
            wifi_portal_erase_credentials();
            diymon_evolution_reset_state();
            erase_nvs_key("config_mode");
            ESP_LOGW(TAG, "Todas las configuraciones han sido borradas. Reiniciando en 1 segundo...");
            vTaskDelay(pdMS_TO_TICKS(1000));
            esp_restart();
            break;
            
        case ACTION_ID_ENABLE_CONFIG_MODE: {
            ESP_LOGI(TAG, "Accion: Habilitar modo Servidor Web en el proximo reinicio.");
            nvs_handle_t nvs_handle;
            esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
            if (err == ESP_OK) {
                err = nvs_set_str(nvs_handle, "config_mode", "1");
                if (err != ESP_OK) {
                    ESP_LOGE(TAG, "Error (%s) al establecer la bandera 'config_mode' en NVS.", esp_err_to_name(err));
                }

                err = nvs_commit(nvs_handle);
                if (err != ESP_OK) {
                    ESP_LOGE(TAG, "Error (%s) al hacer commit de la bandera 'config_mode' en NVS.", esp_err_to_name(err));
                } else {
                    ESP_LOGI(TAG, "Marca de modo configuraci√≥n guardada y commit realizado. Reiniciando en 2 segundos...");
                }
                
                nvs_close(nvs_handle);
            } else {
                ESP_LOGE(TAG, "Error (%s) abriendo NVS para habilitar modo config.", esp_err_to_name(err));
            }
            vTaskDelay(pdMS_TO_TICKS(2000));
            esp_restart();
            break;
        }

        case ACTION_ID_EVO_FIRE:
        case ACTION_ID_EVO_WATER:
        case ACTION_ID_EVO_EARTH:
        case ACTION_ID_EVO_WIND: {
            const char* current_code = diymon_get_current_code();
            int branch_id = 0;
            if (action_id == ACTION_ID_EVO_FIRE)  branch_id = 1;
            if (action_id == ACTION_ID_EVO_WATER) branch_id = 2;
            if (action_id == ACTION_ID_EVO_EARTH) branch_id = 3;
            if (action_id == ACTION_ID_EVO_WIND)  branch_id = 4;
            
            const char* next_code = diymon_get_branched_evolution(current_code, branch_id);
            if (next_code) {
                ESP_LOGI(TAG, "Evolucionando de '%s' a '%s'. Reiniciando...", current_code, next_code);
                diymon_set_current_code(next_code);
                vTaskDelay(pdMS_TO_TICKS(500));
                esp_restart();
            } else {
                ESP_LOGW(TAG, "Evoluci√≥n no v√°lida desde '%s' con la rama %d.", current_code, branch_id);
            }
            break;
        }

        case ACTION_ID_EVO_BACK: {
            const char* current_code = diymon_get_current_code();
            const char* prev_code = diymon_get_previous_evolution_in_sequence(current_code);
            if (prev_code) {
                ESP_LOGI(TAG, "Involucionando de '%s' a '%s'. Reiniciando...", current_code, prev_code);
                diymon_set_current_code(prev_code);
                vTaskDelay(pdMS_TO_TICKS(500));
                esp_restart();
            } else {
                ESP_LOGW(TAG, "Ya se encuentra en la forma base '%s'. No se puede involucionar.", current_code);
            }
            break;
        }
        
        case ACTION_ID_ADMIN_PLACEHOLDER:
        case ACTION_ID_CONFIG_PLACEHOLDER:
            ESP_LOGI(TAG, "Accion %d (sin implementaci√≥n actual).", action_id);
            break;

        default:
            ESP_LOGW(TAG, "ID de accion desconocido: %d", action_id);
            break;
    }
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\actions.h
# =================================================================================================

/*
  Fichero: ./components/diymon_ui/actions.h
  Fecha: 12/08/2025 - 13:30
  √öltimo cambio: Corregido el ID de acci√≥n para habilitar el modo de configuraci√≥n.
  Descripci√≥n: Se actualiza el enumerado de acciones para que coincida con la
               implementaci√≥n en `actions.c`, renombrando `ACTION_ID_ENABLE_FTP` a
               `ACTION_ID_ENABLE_CONFIG_MODE`.
*/
#ifndef ACTIONS_H
#define ACTIONS_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif

// --- El Modelo de Datos para las Acciones ---
typedef enum {
    // Acciones del panel de jugador (superior 1)
    ACTION_ID_COMER,
    ACTION_ID_EJERCICIO,
    ACTION_ID_ATACAR,

    // Acciones del panel de administraci√≥n (superior 2)
    ACTION_ID_BRIGHTNESS_CYCLE,
    ACTION_ID_TOGGLE_SCREEN,
    ACTION_ID_ADMIN_PLACEHOLDER,

    // Acciones del panel de evoluci√≥n (lateral)
    ACTION_ID_EVO_FIRE,
    ACTION_ID_EVO_WATER,
    ACTION_ID_EVO_EARTH,
    ACTION_ID_EVO_WIND,
    ACTION_ID_EVO_BACK,
    
    // Acciones del panel de configuraci√≥n (superior 3)
    ACTION_ID_RESET_ALL,
    ACTION_ID_ENABLE_CONFIG_MODE, // Anteriormente ACTION_ID_ENABLE_FTP
    ACTION_ID_CONFIG_PLACEHOLDER,

    ACTION_ID_COUNT 
} diymon_action_id_t;


// --- El Orquestador de Acciones ---
void execute_diymon_action(diymon_action_id_t action_id);


#ifdef __cplusplus
}
#endif

#endif // ACTIONS_H

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\animation_loader.c
# =================================================================================================

/*
 * Fichero: ./components/diymon_ui/animation_loader.c
 * Fecha: 13/08/2025 - 10:01 
 * √öltimo cambio: Corregido el acceso a miembros de un puntero.
 * Descripci√≥n: Se ha corregido un error de sintaxis en nimation_loader_load_frame donde se usaba el operador '.' en lugar de '->' para acceder a los datos de la animaci√≥n a trav√©s de un puntero, lo que causaba un fallo de compilaci√≥n.
 */
#include "animation_loader.h"
#include "esp_log.h"
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static const char *TAG = "ANIM_LOADER";
#define LVGL_BIN_HEADER_SIZE 12

static void swap_bytes_for_rgb565(uint8_t *data, size_t size) {
    for (size_t i = 0; i < size; i += 2) {
        uint8_t temp = data[i];
        data[i] = data[i + 1];
        data[i + 1] = temp;
    }
}

animation_t animation_loader_init(const char *path, uint16_t width, uint16_t height, uint16_t num_frames) {
    animation_t anim = { 0 };
    anim.base_path = path ? strdup(path) : NULL;
    anim.frame_count = num_frames;
    anim.width = width;
    anim.height = height;
    
    uint32_t line_bytes = width * 2;
    uint32_t stride = (line_bytes + 3) & ~3;
    size_t buffer_size = stride * height;

    anim.img_dsc.data = (uint8_t *)malloc(buffer_size);
    if (!anim.img_dsc.data) { 
        ESP_LOGE(TAG, "Fallo al reservar buffer de animaci√≥n!");
        animation_loader_free(&anim); 
        return anim; 
    }
    
    anim.img_dsc.header.w = width;
    anim.img_dsc.header.h = height;
    anim.img_dsc.header.stride = stride;
    anim.img_dsc.header.cf = LV_COLOR_FORMAT_RGB565;
    anim.img_dsc.data_size = buffer_size;
    
    ESP_LOGI(TAG, "Gestor de animaci√≥n inicializado. Buffer de %d bytes.", (int)buffer_size);
    return anim;
}

bool animation_loader_load_frame(animation_t *anim, uint16_t frame_index, const char *prefix) {
    if (!anim || !anim->base_path) return false;
    char full_path[128];
    snprintf(full_path, sizeof(full_path), "%s/%s%d.bin", anim->base_path, prefix, frame_index + 1);

    FILE *f = fopen(full_path, "rb");
    if (!f) { return false; } // No logueamos aqu√≠ para no spamear durante el conteo.
    
    fseek(f, LVGL_BIN_HEADER_SIZE, SEEK_SET);
    // [CORRECCI√ìN] Se usa '->' en lugar de '.' porque 'anim' es un puntero.
    fread((void *)anim->img_dsc.data, 1, anim->img_dsc.data_size, f);
    fclose(f);

    // swap_bytes_for_rgb565((uint8_t *)anim->img_dsc.data, anim->img_dsc.data_size);
    return true;
}

void animation_loader_free(animation_t *anim) {
    if (!anim) return;
    if(anim->base_path) {
        free(anim->base_path);
        anim->base_path = NULL;
    }
    if (anim->img_dsc.data) {
        free((void*)anim->img_dsc.data);
        anim->img_dsc.data = NULL;
    }
    anim->frame_count = 0;
}

/**
 * @brief [IMPLEMENTACI√ìN A√ëADIDA] Cuenta los ficheros de una animaci√≥n en un directorio.
 */
uint16_t animation_loader_count_frames(const char *path, const char *prefix) {
    if (!path || !prefix) {
        return 0;
    }

    uint16_t count = 0;
    DIR *dir = opendir(path);
    if (!dir) {
        ESP_LOGE(TAG, "No se pudo abrir el directorio: %s", path);
        return 0;
    }

    struct dirent *ent;
    size_t prefix_len = strlen(prefix);

    while ((ent = readdir(dir)) != NULL) {
        if (strncmp(ent->d_name, prefix, prefix_len) == 0) {
            count++;
        }
    }

    closedir(dir);
    return count;
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\animation_loader.h
# =================================================================================================

/*
 * Fichero: ./components/diymon_ui/animation_loader.h
 * Fecha: 11/08/2025 - 12:00
 * √öltimo cambio: Sin cambios en esta iteraci√≥n.
 * Descripci√≥n: Define la interfaz para el cargador de animaciones. Se a√±ade una
 *              funci√≥n que permite contar el n√∫mero de fotogramas de una animaci√≥n
 *              en un directorio espec√≠fico, basado en un prefijo de fichero.
 */
#ifndef ANIMATION_LOADER_H
#define ANIMATION_LOADER_H

#include "lvgl.h"

typedef struct {
    char *base_path;
    uint16_t frame_count;
    uint16_t width;
    uint16_t height;
    lv_img_dsc_t img_dsc;
} animation_t;

animation_t animation_loader_init(const char *path, uint16_t width, uint16_t height, uint16_t num_frames);
bool animation_loader_load_frame(animation_t *anim, uint16_t frame_index, const char *prefix);
void animation_loader_free(animation_t *anim);
uint16_t animation_loader_count_frames(const char *path, const char *prefix);

#endif // ANIMATION_LOADER_H

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\CMakeLists.txt
# =================================================================================================

# Fichero: ./components/diymon_ui/CMakeLists.txt
# Fecha: 13/08/2025 - 12:08 
# √öltimo cambio: Corregida la sintaxis de la variable de CMake para las fuentes.
# Descripci√≥n: Se corrige el error de sintaxis en idf_component_register que imped√≠a
#              la correcta expansi√≥n de la lista de ficheros fuente, solucionando el fallo
#              de compilaci√≥n.

file(GLOB component_sources
    "*.c"
    "screens/*.c"
    "actions/*.c"
    "styles/*.c"
    "ui_telemetry.c"
)

idf_component_register(
    SRCS ${component_sources}
    INCLUDE_DIRS "."
    PRIV_INCLUDE_DIRS "."
    
    REQUIRES 
        lvgl
        diymon_bsp
        diymon_core
        screen_manager
        wifi_portal
)


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\diymon_ui_helpers.c
# =================================================================================================

/*
 * Fichero: ./components/diymon_ui/diymon_ui_helpers.c
 * Fecha: 13/08/2025 - 10:20 
 * √öltimo cambio: Restaurada la carga de fondo a trav√©s de un b√∫fer temporal en RAM.
 * Descripci√≥n: Se vuelve a implementar la carga del fondo de pantalla (BG.bin) utilizando un b√∫fer temporal que se libera despu√©s de su uso. Esta estrategia evita el uso de la integraci√≥n de LVGL con FatFS y soluciona el problema de memoria que ocurr√≠a anteriormente.
 */
#include "diymon_ui_helpers.h"
#include "diymon_evolution.h"
#include "esp_log.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define SD_MOUNT_POINT "/sdcard"

static const char *TAG = "UI_HELPERS";

// Funci√≥n interna para obtener el nombre del directorio de evoluci√≥n (ej: "111")
static void get_evolution_dir_name(char* dir_name_buffer, size_t buffer_size) {
    const char* evo_code = diymon_get_current_code();
    memset(dir_name_buffer, 0, buffer_size);
    int j = 0;
    for (int i = 0; evo_code[i] != '\0' && j < buffer_size - 1; i++) {
        if (evo_code[i] != '.') {
            dir_name_buffer[j++] = evo_code[i];
        }
    }
}

void ui_helpers_build_asset_path(char* buffer, size_t buffer_size, const char* asset_filename) {
    char dir_name[9];
    get_evolution_dir_name(dir_name, sizeof(dir_name));

    if (strncmp(asset_filename, "BTN_", 4) == 0 ||
        strncmp(asset_filename, "EVO_", 4) == 0) {
        snprintf(buffer, buffer_size, "%s/buttons/%s", SD_MOUNT_POINT, asset_filename);
    }
    else if (strncmp(asset_filename, "ANIM_IDLE_", 10) == 0) {
         snprintf(buffer, buffer_size, "%s/DIYMON/%s/%s", SD_MOUNT_POINT, dir_name, asset_filename);
    }
    else if (strncmp(asset_filename, "EAT_", 4) == 0 || strncmp(asset_filename, "GYM_", 4) == 0 || strncmp(asset_filename, "ATK_", 4) == 0) {
         snprintf(buffer, buffer_size, "%s/DIYMON/%s/%s", SD_MOUNT_POINT, dir_name, asset_filename);
    }
    else {
        snprintf(buffer, buffer_size, "%s/DIYMON/%s/", SD_MOUNT_POINT, dir_name);
    }
}

void ui_helpers_load_background(lv_obj_t* parent) {
    char dir_name[9];
    get_evolution_dir_name(dir_name, sizeof(dir_name));
    char path[128];
    snprintf(path, sizeof(path), "%s/DIYMON/%s/BG.bin", SD_MOUNT_POINT, dir_name);

    FILE* f = fopen(path, "rb");
    if (!f) {
        ESP_LOGE(TAG, "No se pudo abrir el fichero de fondo: %s", path);
        return;
    }

    fseek(f, 0, SEEK_END);
    long file_size = ftell(f);
    fseek(f, 0, SEEK_SET);

    uint8_t* background_buffer = (uint8_t*)malloc(file_size);
    if (!background_buffer) {
        ESP_LOGE(TAG, "Fallo al reservar memoria temporal (%ld bytes) para el fondo.", file_size);
        fclose(f);
        return;
    }

    fread(background_buffer, 1, file_size, f);
    fclose(f);

    lv_img_dsc_t bg_dsc;
    memcpy(&bg_dsc, background_buffer, sizeof(lv_img_dsc_t));
    bg_dsc.data = background_buffer + sizeof(lv_img_dsc_t);

    lv_obj_set_style_bg_img_src(parent, &bg_dsc, 0);
    lv_obj_set_style_bg_opa(parent, LV_OPA_COVER, 0);

    free(background_buffer);

    ESP_LOGI(TAG, "Fondo de pantalla '%s' cargado, aplicado y b√∫fer liberado.", path);
}

void ui_helpers_free_background_buffer() {
    // La gesti√≥n del b√∫fer ahora es local a ui_helpers_load_background, esta funci√≥n ya no es necesaria.
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\diymon_ui_helpers.h
# =================================================================================================

/*
 * Fichero: ./components/diymon_ui/diymon_ui_helpers.h
 * Fecha: 13/08/2025 - 09:34 
 * √öltimo cambio: A√±adidas declaraciones para la carga del fondo de pantalla.
 * Descripci√≥n: Funciones de ayuda para la interfaz de usuario, como la carga de recursos din√°micos desde la tarjeta SD.
 */
#ifndef DIYMON_UI_HELPERS_H
#define DIYMON_UI_HELPERS_H

#include "lvgl.h"

/**
 * @brief Construye la ruta completa a un recurso (asset) en la SD.
 * 
 * Esta funci√≥n obtiene el c√≥digo de evoluci√≥n actual, lo convierte a un nombre
 * de directorio compatible con 8.3 (ej: "1.1.1" -> "111"), y construye la ruta
 * final a un fichero dentro de ese directorio.
 * 
 * @param buffer Puntero al buffer donde se guardar√° la ruta generada.
 * @param buffer_size Tama√±o del buffer.
 * @param asset_filename Nombre del fichero del recurso (ej: "IDLE.GIF"). Debe ser compatible 8.3.
 */
void ui_helpers_build_asset_path(char* buffer, size_t buffer_size, const char* asset_filename);

/**
 * @brief Carga la imagen de fondo desde el fichero BG.BIN en la SD.
 * 
 * Utiliza la funci√≥n de construcci√≥n de rutas para encontrar el fichero BG.BIN
 * correspondiente a la evoluci√≥n actual y lo establece como fondo del objeto padre.
 * 
 * @param parent Puntero al objeto que recibir√° la imagen de fondo (normalmente, la pantalla principal).
 */
void ui_helpers_load_background(lv_obj_t* parent);

/**
 * @brief Libera la memoria utilizada por el b√∫fer de la imagen de fondo.
 * 
 * Debe llamarse cuando la pantalla se destruye para evitar fugas de memoria.
 */
void ui_helpers_free_background_buffer();

/**
 * @brief Crea y muestra el GIF animado del DIYMON en el centro de la pantalla.
 * 
 * Carga el fichero diymon.gif correspondiente a la evoluci√≥n actual en un b√∫fer
 * de memoria y lo muestra centrado en su objeto padre.
 * 
 * @param parent Puntero al objeto sobre el que se crear√° el GIF (la pantalla principal).
 */
void ui_helpers_create_diymon_gif(lv_obj_t* parent);

/**
 * @brief Libera la memoria utilizada por el b√∫fer del GIF del DIYMON.
 * 
 * Debe llamarse cuando la pantalla se destruye para evitar fugas de memoria.
 */
void ui_helpers_free_gif_buffer();


#endif // DIYMON_UI_HELPERS_H


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\fonts.h
# =================================================================================================

#ifndef EEZ_LVGL_UI_FONTS_H
#define EEZ_LVGL_UI_FONTS_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#endif /*EEZ_LVGL_UI_FONTS_H*/

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\screens.c
# =================================================================================================

/*
  Fichero: ./components/diymon_ui/screens.c
  Fecha: 13/08/2025 - 09:47 
  √öltimo cambio: Reordenada la inicializaci√≥n para priorizar la reserva del b√∫fer de animaci√≥n.
  Descripci√≥n: Se ha cambiado el orden de las llamadas en create_screen_main. Ahora se crea primero el b√∫fer de animaci√≥n compartido y LUEGO se carga el fondo. Esto asegura que la memoria m√°s cr√≠tica (la de animaci√≥n) se reserve primero, solucionando el fallo de malloc.
*/
#include "screens.h"
#include "ui_idle_animation.h"
#include "ui_actions_panel.h"
#include "ui_action_animations.h"
#include "ui_telemetry.h" 
#include "diymon_ui_helpers.h"
#include "esp_log.h"
#include "bsp_api.h"
#include "screen_manager.h"

static const char *TAG = "SCREENS";

// --- Variables para la detecci√≥n manual de doble toque ---
static uint8_t g_click_count = 0;
static lv_timer_t *g_double_click_timer = NULL;

lv_obj_t *g_main_screen_obj = NULL;

static lv_coord_t touch_start_x = -1;
static lv_coord_t touch_start_y = -1;

static void main_screen_event_cb(lv_event_t *e);

static void double_click_timer_cb(lv_timer_t *timer) {
    g_click_count = 0;
    g_double_click_timer = NULL;
}

void create_screen_main(void) {
    g_main_screen_obj = lv_obj_create(NULL);
    lv_obj_clear_flag(g_main_screen_obj, LV_OBJ_FLAG_SCROLLABLE);
    lv_obj_set_size(g_main_screen_obj, 170, 320);
    lv_obj_add_flag(g_main_screen_obj, LV_OBJ_FLAG_CLICKABLE);
    lv_obj_add_event_cb(g_main_screen_obj, main_screen_event_cb, LV_EVENT_ALL, NULL);

    // [CORRECCI√ìN] 1. Reservar el b√∫fer de animaci√≥n persistente PRIMERO.
    ui_action_animations_create(g_main_screen_obj);
    
    // 2. Cargar el fondo (que usa un b√∫fer temporal y lo libera).
    ui_helpers_load_background(g_main_screen_obj);
    
    // 3. Crear el resto de elementos que usar√°n el b√∫fer de animaci√≥n ya reservado.
    ui_idle_animation_start();
    ui_actions_panel_create(g_main_screen_obj);
    ui_telemetry_create(g_main_screen_obj); 

    ESP_LOGI(TAG, "Pantalla principal creada delegando en m√≥dulos.");
}

static void main_screen_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    lv_indev_t *indev = lv_indev_get_act();

    switch(code) {
        case LV_EVENT_PRESSED: {
            lv_point_t p;
            lv_indev_get_point(indev, &p);
            touch_start_x = p.x;
            touch_start_y = p.y;
            if (!screen_manager_is_off()) {
                ESP_LOGD(TAG, "Touch detected, pausing idle animation.");
                ui_idle_animation_pause();
            }
            break;
        }
        case LV_EVENT_RELEASED:
            touch_start_x = -1;
            touch_start_y = -1;
            break;
        case LV_EVENT_GESTURE: {
            if (!screen_manager_is_off()) { 
                lv_dir_t dir = lv_indev_get_gesture_dir(indev);
                ui_actions_panel_handle_gesture(dir, touch_start_x, touch_start_y);
            }
            break;
        }
        case LV_EVENT_CLICKED: {
            if (screen_manager_is_off()) {
                g_click_count++;
                if (g_click_count == 1) {
                    g_double_click_timer = lv_timer_create(double_click_timer_cb, 300, NULL);
                    lv_timer_set_repeat_count(g_double_click_timer, 1);
                } else if (g_click_count == 2) {
                    if (g_double_click_timer) {
                        lv_timer_del(g_double_click_timer);
                        g_double_click_timer = NULL;
                    }
                    ESP_LOGI(TAG, "Doble toque detectado. Encendiendo pantalla...");
                    screen_manager_turn_on();
                    g_click_count = 0;
                }
            } else {
                ESP_LOGD(TAG, "Simple click detected, resuming idle animation.");
                ui_idle_animation_resume();
            }
            break;
        }
        default:
            break;
    }
}

void delete_screen_main(void) {
    if (g_main_screen_obj) {
        lv_obj_del(g_main_screen_obj);
        g_main_screen_obj = NULL;
    }
    ui_idle_animation_stop();
    ui_action_animations_destroy();
    ui_telemetry_destroy(); 
    ui_helpers_free_background_buffer();
}

void create_screens(void) {
    create_screen_main();
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\screens.h
# =================================================================================================

/*
 * Fichero: ./components/diymon_ui/screens.h
 * Fecha: 13/08/2025 - 09:34 
 * √öltimo cambio: Eliminado el puntero g_idle_animation_obj obsoleto.
 * Descripci√≥n: Se ha limpiado la cabecera eliminando la declaraci√≥n del puntero g_idle_animation_obj, ya que la animaci√≥n de reposo ahora utiliza el objeto de imagen compartido.
 */
#ifndef SCREENS_H
#define SCREENS_H

#include "ui.h" 
#include <lvgl.h>

// --- DECLARACIONES DE OBJETOS GLOBALES ---
// Usamos 'extern' para decirle a otros archivos .c (como ui.c)
// que estas variables existen y ser√°n definidas en screens.c.
extern lv_obj_t *g_main_screen_obj;


// --- DECLARACIONES DE FUNCIONES ---
// Estas son las funciones definidas en screens.c que ui.c necesita llamar.
void create_screen_main(void);
void delete_screen_main(void);
void create_screens(void);

#endif // SCREENS_H


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\structs.h
# =================================================================================================

#ifndef EEZ_LVGL_UI_STRUCTS_H
#define EEZ_LVGL_UI_STRUCTS_H



#if defined(EEZ_FOR_LVGL)

#include <eez/flow/flow.h>
#include <stdint.h>
#include <stdbool.h>

#include "vars.h"

using namespace eez;





#endif

#endif /*EEZ_LVGL_UI_STRUCTS_H*/


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\styles.c
# =================================================================================================

/*
 * Archivo: styles.c
 * Versi√≥n: 8.0 (CORREGIDO sin el include de images.h)
 */

#include "styles.h"
// [ELIMINADO] #include "images.h" // Este archivo ya no existe.
#include "lvgl.h"

// Aqu√≠ ir√≠a tu c√≥digo para crear y registrar estilos de LVGL, si lo tuvieras.
// Por ahora, puede estar vac√≠o.

void init_styles(void) {
    // Inicializa aqu√≠ los estilos que necesites
}

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\styles.h
# =================================================================================================

#ifndef EEZ_LVGL_UI_STYLES_H
#define EEZ_LVGL_UI_STYLES_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#endif /*EEZ_LVGL_UI_STYLES_H*/

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_action_animations.c
# =================================================================================================

/*
 * Fichero: ./components/diymon_ui/ui_action_animations.c
 * Fecha: 13/08/2025 - 10:04 
 * √öltimo cambio: Ajustada la resoluci√≥n del b√∫fer de animaci√≥n a 150x230.
 * Descripci√≥n: Gesti√≥n de las animaciones de acci√≥n. Se ha corregido el tama√±o del b√∫fer de animaci√≥n compartido a 150x230 para que coincida con las dimensiones de los assets de animaci√≥n, solucionando problemas de visualizaci√≥n y liberando RAM adicional.
 */
#include "ui_action_animations.h"
#include "animation_loader.h"
#include "diymon_ui_helpers.h"
#include "ui_idle_animation.h"
#include "esp_log.h"
#include <stdio.h>
#include <string.h>

static const char *TAG = "UI_ACTION_ANIM";

// --- Variables Globales y Est√°ticas ---
lv_obj_t *g_animation_img_obj;
animation_t g_animation_player;

static lv_timer_t *s_anim_timer;
static bool s_is_action_in_progress = false;
static int s_current_frame_index;

#define FRAME_INTERVAL_MS 500

// --- Declaraciones de Funciones Internas ---
static void animation_timer_cb(lv_timer_t *timer);
static void animation_finished(void);
static const char* get_anim_prefix(diymon_action_id_t action_id);

// --- Implementaci√≥n de Funciones P√∫blicas ---

void ui_action_animations_create(lv_obj_t *parent) {
    // [SOLUCI√ìN] Ajustar el tama√±o del b√∫fer a la resoluci√≥n real de la animaci√≥n.
    g_animation_player = animation_loader_init(NULL, 150, 230, 0);
    if (g_animation_player.img_dsc.data == NULL) {
        ESP_LOGE(TAG, "FALLO CR√çTICO: No se pudo reservar memoria para el b√∫fer de animaci√≥n compartido.");
        return;
    }
    ESP_LOGI(TAG, "B√∫fer de animaci√≥n compartido (150x230) pre-reservado correctamente.");

    g_animation_img_obj = lv_img_create(parent);
    lv_img_set_src(g_animation_img_obj, &g_animation_player.img_dsc);
    
    lv_obj_set_style_bg_opa(g_animation_img_obj, LV_OPA_TRANSP, 0);
    lv_obj_align(g_animation_img_obj, LV_ALIGN_BOTTOM_MID, 0, 0);
}

void ui_action_animations_play(diymon_action_id_t action_id) {
    if (s_is_action_in_progress || action_id >= ACTION_ID_COUNT) return;
    if (g_animation_player.img_dsc.data == NULL) {
        ESP_LOGE(TAG, "No se puede iniciar la animaci√≥n: el b√∫fer compartido no est√° disponible.");
        return;
    }

    s_is_action_in_progress = true;
    
    ui_idle_animation_pause();

    const char *prefix = get_anim_prefix(action_id);
    char path_buffer[128];
    ui_helpers_build_asset_path(path_buffer, sizeof(path_buffer), "");
    size_t len = strlen(path_buffer);
    if (len > 0 && path_buffer[len - 1] == '/') path_buffer[len - 1] = '\0';
    
    uint16_t frame_count = animation_loader_count_frames(path_buffer, prefix);
    if (frame_count == 0) {
        ESP_LOGE(TAG, "No se encontraron fotogramas para la animaci√≥n '%s' en '%s'.", prefix, path_buffer);
        animation_finished(); 
        return;
    }
    
    ESP_LOGI(TAG, "Reproduciendo animaci√≥n '%s' (%d fotogramas) a %dms/frame.", prefix, frame_count, FRAME_INTERVAL_MS);

    if (g_animation_player.base_path) free(g_animation_player.base_path);
    g_animation_player.base_path = strdup(path_buffer);
    g_animation_player.frame_count = frame_count;

    s_current_frame_index = 0;
    if (animation_loader_load_frame(&g_animation_player, s_current_frame_index, prefix)) {
        lv_obj_invalidate(g_animation_img_obj);
        s_anim_timer = lv_timer_create(animation_timer_cb, FRAME_INTERVAL_MS, (void*)(intptr_t)action_id);
    } else {
        ESP_LOGE(TAG, "Fallo al cargar el primer fotograma (%s).", prefix);
        animation_finished();
    }
}

void ui_action_animations_destroy(void) {
    ESP_LOGI(TAG, "Liberando b√∫fer de animaci√≥n compartido.");
    animation_loader_free(&g_animation_player);
}

animation_t* ui_action_animations_get_player(void) {
    return &g_animation_player;
}

static void animation_timer_cb(lv_timer_t *timer) {
    s_current_frame_index++;
    if (s_current_frame_index >= g_animation_player.frame_count) {
        animation_finished();
        return;
    }

    diymon_action_id_t action_id = (diymon_action_id_t)(intptr_t)timer->user_data;
    const char *prefix = get_anim_prefix(action_id);

    if (animation_loader_load_frame(&g_animation_player, s_current_frame_index, prefix)) {
        lv_obj_invalidate(g_animation_img_obj);
    } else {
        ESP_LOGW(TAG, "No se pudo cargar el fotograma %d para %s. Finalizando animaci√≥n.", s_current_frame_index + 1, prefix);
        animation_finished();
    }
}

static void animation_finished(void) {
    if (s_anim_timer) {
        lv_timer_del(s_anim_timer);
        s_anim_timer = NULL;
    }
    
    if (g_animation_player.base_path) {
        free(g_animation_player.base_path);
        g_animation_player.base_path = NULL;
    }
    g_animation_player.frame_count = 0;
    
    ui_idle_animation_resume();
    
    s_is_action_in_progress = false;
    ESP_LOGI(TAG, "Animaci√≥n de acci√≥n finalizada. Control devuelto a idle.");
}

static const char* get_anim_prefix(diymon_action_id_t action_id) {
    switch(action_id) {
        case ACTION_ID_COMER:     return "EAT_";
        case ACTION_ID_EJERCICIO: return "GYM_";
        case ACTION_ID_ATACAR:    return "ATK_";
        default:                  return "";
    }
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_action_animations.h
# =================================================================================================

/*
 * Fichero: ./components/diymon_ui/ui_action_animations.h
 * Fecha: 14/08/2025 - 10:00 am
 * √öltimo cambio: Refactorizado para arquitectura de animaci√≥n compartida.
 * Descripci√≥n: Interfaz p√∫blica para el m√≥dulo de animaciones de acci√≥n. Expone el objeto de imagen global y adapta las funciones para operar sobre un b√∫fer de animaci√≥n compartido.
 */
#ifndef UI_ACTION_ANIMATIONS_H
#define UI_ACTION_ANIMATIONS_H

#include <lvgl.h>
#include "actions.h"
#include "animation_loader.h"

#ifdef __cplusplus
extern "C" {
#endif

// --- OBJETO GLOBAL COMPARTIDO ---
/**
 * @brief Puntero al objeto de imagen que servir√° como "lienzo" para todas las animaciones.
 *        Se define en ui_action_animations.c y se declara aqu√≠ para ser accesible
 *        por otros m√≥dulos de la UI que necesiten invalidarlo.
 */
extern lv_obj_t *g_animation_img_obj;


// --- FUNCIONES P√öBLICAS ---

/**
 * @brief Crea el objeto de imagen de animaci√≥n y pre-reserva el b√∫fer de memoria compartido.
 * @param parent El objeto padre sobre el que se crear√° la imagen.
 */
void ui_action_animations_create(lv_obj_t *parent);

/**
 * @brief Reproduce una animaci√≥n de acci√≥n, tomando control del b√∫fer compartido.
 * @param action_id El ID de la acci√≥n a reproducir (COMER, EJERCICIO, ATACAR).
 */
void ui_action_animations_play(diymon_action_id_t action_id);

/**
 * @brief Libera el b√∫fer de memoria compartido y otros recursos.
 *        Debe llamarse cuando la pantalla se destruye para evitar fugas de memoria.
 */
void ui_action_animations_destroy(void);

/**
 * @brief Obtiene un puntero al reproductor de animaci√≥n que contiene el b√∫fer compartido.
 *        Necesario para que el m√≥dulo de animaci√≥n de reposo (idle) pueda usar el mismo b√∫fer.
 * @return Puntero a la estructura de animaci√≥n compartida.
 */
animation_t* ui_action_animations_get_player(void);

#ifdef __cplusplus
}
#endif

#endif // UI_ACTION_ANIMATIONS_H

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_actions_panel.c
# =================================================================================================

/*
  Fichero: ./components/diymon_ui/ui_actions_panel.c
  Fecha: 13/08/2025 - 08:30 
  √öltimo cambio: Corregidas las funciones de chroma key a la API de LVGL v9.
  Descripci√≥n: Se ha modificado la creaci√≥n de botones para asegurar que su fondo sea
               completamente transparente. Se habilita la transparencia por chroma key para el asset 
               ASSET_ICON_CONFIG_PLACEHOLDER, usando las funciones correctas de LVGL v9 (lv_obj_set_style_img_chroma_keyed).
*/
#include "ui_actions_panel.h"
#include "ui_asset_loader.h"
#include "actions.h"
#include "ui_idle_animation.h"
#include "esp_log.h"
#include <stdio.h>

static const char *TAG = "UI_PANELS";

// --- Constantes de configuraci√≥n ---
#define PANEL_AUTO_HIDE_DELAY 10000 
#define BUTTON_SIZE 50
#define BUTTON_PADDING 10
#define ANIM_TIME_MS 300
#define NUM_TOP_BUTTONS 3
#define NUM_SIDE_BUTTONS 5
#define EDGE_SWIPE_THRESHOLD 50

typedef enum {
    PANEL_STATE_HIDDEN,
    PANEL_STATE_PLAYER_VISIBLE,
    PANEL_STATE_ADMIN_VISIBLE,
    PANEL_STATE_SIDE_VISIBLE,
    PANEL_STATE_CONFIG_VISIBLE,
} panel_state_t;

static lv_obj_t *s_player_btns[NUM_TOP_BUTTONS];
static lv_obj_t *s_admin_btns[NUM_TOP_BUTTONS];
static lv_obj_t *s_side_btns[NUM_SIDE_BUTTONS];
static lv_obj_t *s_config_btns[NUM_TOP_BUTTONS];
static lv_timer_t *s_hide_timer = NULL;
static panel_state_t s_panel_state = PANEL_STATE_HIDDEN;
static bool s_is_animating = false;

// --- Declaraciones de funciones internas ---
static void animate_panel_in_top(lv_obj_t **buttons);
static void animate_panel_out_top(lv_obj_t **buttons);
static void animate_panel_in_side(lv_obj_t **buttons);
static void animate_panel_out_side(lv_obj_t **buttons);
static void timer_auto_hide_callback(lv_timer_t *timer);
static lv_obj_t* create_top_action_button(lv_obj_t *parent, ui_asset_id_t asset_id, int index);
static lv_obj_t* create_side_action_button(lv_obj_t *parent, ui_asset_id_t asset_id, int index);
static void button_event_cb(lv_event_t *e);
static void anim_ready_hide_cb(lv_anim_t *a);
static void animation_finish_cb(lv_anim_t *a);
static void last_button_out_anim_ready_cb(lv_anim_t *a);


static lv_obj_t* create_top_action_button(lv_obj_t *parent, ui_asset_id_t asset_id, int index) {
    lv_obj_t *btn = lv_btn_create(parent);
    lv_obj_remove_style_all(btn); // Eliminar estilos por defecto
    lv_obj_set_size(btn, BUTTON_SIZE, BUTTON_SIZE);
    
    // Forzar transparencia total para el fondo, borde y sombra en todos los estados.
    lv_obj_set_style_bg_opa(btn, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(btn, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(btn, 0, LV_STATE_ANY);

    lv_obj_t *img = lv_img_create(btn);
    lv_img_set_src(img, ui_assets_get_icon(asset_id));
    lv_obj_center(img);
        
    lv_obj_set_pos(btn, (BUTTON_SIZE + BUTTON_PADDING) * index, -BUTTON_SIZE);
    lv_obj_add_flag(btn, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_event_cb(btn, button_event_cb, LV_EVENT_PRESSED, NULL);
    return btn;
}

static lv_obj_t* create_side_action_button(lv_obj_t *parent, ui_asset_id_t asset_id, int index) {
    lv_obj_t *btn = lv_btn_create(parent);
    lv_obj_remove_style_all(btn); // Eliminar estilos por defecto
    lv_obj_set_size(btn, BUTTON_SIZE, BUTTON_SIZE);

    // Forzar transparencia total para el fondo, borde y sombra en todos los estados.
    lv_obj_set_style_bg_opa(btn, LV_OPA_TRANSP, LV_STATE_ANY);
    lv_obj_set_style_border_width(btn, 0, LV_STATE_ANY);
    lv_obj_set_style_shadow_width(btn, 0, LV_STATE_ANY);
    
    lv_obj_t *img = lv_img_create(btn);
    lv_img_set_src(img, ui_assets_get_icon(asset_id));
    lv_obj_center(img);
    
    lv_obj_set_pos(btn, -BUTTON_SIZE, BUTTON_PADDING + (BUTTON_SIZE + BUTTON_PADDING) * index);
    lv_obj_add_flag(btn, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_event_cb(btn, button_event_cb, LV_EVENT_PRESSED, NULL);
    return btn;
}

void ui_actions_panel_create(lv_obj_t *parent) {
    s_player_btns[0] = create_top_action_button(parent, ASSET_ICON_EAT, 0);
    s_player_btns[1] = create_top_action_button(parent, ASSET_ICON_GYM, 1);
    s_player_btns[2] = create_top_action_button(parent, ASSET_ICON_ATK, 2);

    s_admin_btns[0] = create_top_action_button(parent, ASSET_ICON_BRIGHTNESS, 0);
    s_admin_btns[1] = create_top_action_button(parent, ASSET_ICON_SCREEN_OFF, 1);
    s_admin_btns[2] = create_top_action_button(parent, ASSET_ICON_ADMIN_PLACEHOLDER, 2);

    s_config_btns[0] = create_top_action_button(parent, ASSET_ICON_RESET_ALL, 0);
    s_config_btns[1] = create_top_action_button(parent, ASSET_ICON_ENABLE_FTP, 1);
    s_config_btns[2] = create_top_action_button(parent, ASSET_ICON_CONFIG_PLACEHOLDER, 2);

    s_side_btns[0] = create_side_action_button(parent, ASSET_ICON_EVO_FIRE, 0);
    s_side_btns[1] = create_side_action_button(parent, ASSET_ICON_EVO_WATER, 1);
    s_side_btns[2] = create_side_action_button(parent, ASSET_ICON_EVO_EARTH, 2);
    s_side_btns[3] = create_side_action_button(parent, ASSET_ICON_EVO_WIND, 3);
    s_side_btns[4] = create_side_action_button(parent, ASSET_ICON_EVO_BACK, 4);

    ESP_LOGI(TAG, "Todos los paneles de acci√≥n creados.");
}

lv_obj_t* ui_actions_panel_get_eat_btn(void) { return s_player_btns[0]; }
lv_obj_t* ui_actions_panel_get_gym_btn(void) { return s_player_btns[1]; }
lv_obj_t* ui_actions_panel_get_atk_btn(void) { return s_player_btns[2]; }
lv_obj_t* ui_actions_panel_get_brightness_btn(void) { return s_admin_btns[0]; }
lv_obj_t* ui_actions_panel_get_toggle_screen_btn(void) { return s_admin_btns[1]; }
lv_obj_t* ui_actions_panel_get_admin_placeholder_btn(void) { return s_admin_btns[2]; }
lv_obj_t* ui_actions_panel_get_reset_all_btn(void) { return s_config_btns[0]; }
lv_obj_t* ui_actions_panel_get_enable_config_mode_btn(void) { return s_config_btns[1]; }
lv_obj_t* ui_actions_panel_get_config_placeholder_btn(void) { return s_config_btns[2]; }
lv_obj_t* ui_actions_panel_get_evo_fire_btn(void) { return s_side_btns[0]; }
lv_obj_t* ui_actions_panel_get_evo_water_btn(void) { return s_side_btns[1]; }
lv_obj_t* ui_actions_panel_get_evo_earth_btn(void) { return s_side_btns[2]; }
lv_obj_t* ui_actions_panel_get_evo_wind_btn(void) { return s_side_btns[3]; }
lv_obj_t* ui_actions_panel_get_evo_back_btn(void) { return s_side_btns[4]; }


static void timer_auto_hide_callback(lv_timer_t *timer) {
    if (s_panel_state == PANEL_STATE_PLAYER_VISIBLE) animate_panel_out_top(s_player_btns);
    if (s_panel_state == PANEL_STATE_ADMIN_VISIBLE) animate_panel_out_top(s_admin_btns);
    if (s_panel_state == PANEL_STATE_CONFIG_VISIBLE) animate_panel_out_top(s_config_btns);
    if (s_panel_state == PANEL_STATE_SIDE_VISIBLE) animate_panel_out_side(s_side_btns);
    
    ESP_LOGD(TAG, "Auto-hide timer triggered. Resuming idle animation.");
    ui_idle_animation_resume();

    s_panel_state = PANEL_STATE_HIDDEN;
    s_hide_timer = NULL;
}

static void anim_ready_hide_cb(lv_anim_t *a) {
    lv_obj_add_flag((lv_obj_t *)a->var, LV_OBJ_FLAG_HIDDEN);
}

static void animation_finish_cb(lv_anim_t *a) {
    s_is_animating = false;
    ESP_LOGD(TAG, "Panel IN animation finished. Gesture lock released.");
}

static void last_button_out_anim_ready_cb(lv_anim_t *a) {
    lv_obj_add_flag((lv_obj_t *)a->var, LV_OBJ_FLAG_HIDDEN);
    s_is_animating = false;
    ESP_LOGD(TAG, "Panel OUT animation finished. Gesture lock released.");
}


static void animate_panel_in_top(lv_obj_t **buttons) {
    if (s_hide_timer) lv_timer_del(s_hide_timer);
    
    s_is_animating = true;
    for (int i = 0; i < NUM_TOP_BUTTONS; i++) {
        if (buttons[i]) {
            lv_obj_clear_flag(buttons[i], LV_OBJ_FLAG_HIDDEN);
            lv_anim_t a;
            lv_anim_init(&a);
            lv_anim_set_var(&a, buttons[i]);
            lv_anim_set_values(&a, lv_obj_get_y(buttons[i]), BUTTON_PADDING);
            lv_anim_set_time(&a, ANIM_TIME_MS);
            lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_y);
            lv_anim_set_path_cb(&a, lv_anim_path_ease_out);
            lv_anim_set_delay(&a, i * 50);
            if (i == NUM_TOP_BUTTONS - 1) {
                lv_anim_set_ready_cb(&a, animation_finish_cb);
            }
            lv_anim_start(&a);
        }
    }
    s_hide_timer = lv_timer_create(timer_auto_hide_callback, PANEL_AUTO_HIDE_DELAY, NULL);
    lv_timer_set_repeat_count(s_hide_timer, 1);
}

static void animate_panel_out_top(lv_obj_t **buttons) {
    if (s_hide_timer) {
        lv_timer_del(s_hide_timer);
        s_hide_timer = NULL;
    }
    s_is_animating = true;
    for (int i = 0; i < NUM_TOP_BUTTONS; i++) {
        if (buttons[i]) {
            lv_anim_t a;
            lv_anim_init(&a);
            lv_anim_set_var(&a, buttons[i]);
            lv_anim_set_values(&a, lv_obj_get_y(buttons[i]), -BUTTON_SIZE);
            lv_anim_set_time(&a, ANIM_TIME_MS);
            lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_y);
            lv_anim_set_path_cb(&a, lv_anim_path_ease_in);
            lv_anim_set_delay(&a, i * 50);
            if (i == NUM_TOP_BUTTONS - 1) {
                lv_anim_set_ready_cb(&a, last_button_out_anim_ready_cb);
            } else {
                lv_anim_set_ready_cb(&a, anim_ready_hide_cb);
            }
            lv_anim_start(&a);
        }
    }
}

static void animate_panel_in_side(lv_obj_t **buttons) {
    if (s_hide_timer) lv_timer_del(s_hide_timer);
    
    s_is_animating = true;
    for (int i = 0; i < NUM_SIDE_BUTTONS; i++) {
        if (buttons[i]) {
            lv_obj_clear_flag(buttons[i], LV_OBJ_FLAG_HIDDEN);
            lv_anim_t a;
            lv_anim_init(&a);
            lv_anim_set_var(&a, buttons[i]);
            lv_anim_set_values(&a, lv_obj_get_x(buttons[i]), BUTTON_PADDING);
            lv_anim_set_time(&a, ANIM_TIME_MS);
            lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_x);
            lv_anim_set_path_cb(&a, lv_anim_path_ease_out);
            lv_anim_set_delay(&a, i * 50);
            if (i == NUM_SIDE_BUTTONS - 1) {
                lv_anim_set_ready_cb(&a, animation_finish_cb);
            }
            lv_anim_start(&a);
        }
    }
    s_hide_timer = lv_timer_create(timer_auto_hide_callback, PANEL_AUTO_HIDE_DELAY, NULL);
    lv_timer_set_repeat_count(s_hide_timer, 1);
}

static void animate_panel_out_side(lv_obj_t **buttons) {
    if (s_hide_timer) {
        lv_timer_del(s_hide_timer);
        s_hide_timer = NULL;
    }
    s_is_animating = true;
    for (int i = 0; i < NUM_SIDE_BUTTONS; i++) {
        if (buttons[i]) {
            lv_anim_t a;
            lv_anim_init(&a);
            lv_anim_set_var(&a, buttons[i]);
            lv_anim_set_values(&a, lv_obj_get_x(buttons[i]), -BUTTON_SIZE);
            lv_anim_set_time(&a, ANIM_TIME_MS);
            lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_x);
            lv_anim_set_path_cb(&a, lv_anim_path_ease_in);
            lv_anim_set_delay(&a, i * 50);
            if (i == NUM_SIDE_BUTTONS - 1) {
                lv_anim_set_ready_cb(&a, last_button_out_anim_ready_cb);
            } else {
                lv_anim_set_ready_cb(&a, anim_ready_hide_cb);
            }
            lv_anim_start(&a);
        }
    }
}

void ui_actions_panel_handle_gesture(lv_dir_t dir, lv_coord_t start_x, lv_coord_t start_y) {
    if (s_is_animating) {
        ESP_LOGD(TAG, "Animation in progress, gesture ignored.");
        return;
    }

    ESP_LOGD(TAG, "Gesture: Dir=%d, X=%d, Y=%d, State=%d", dir, start_x, start_y, s_panel_state);

    switch(s_panel_state) {
        case PANEL_STATE_HIDDEN:
            if ((dir == LV_DIR_BOTTOM && start_y < EDGE_SWIPE_THRESHOLD) || (dir == LV_DIR_RIGHT && start_x < EDGE_SWIPE_THRESHOLD)) {
                // El gesto es v√°lido, no hacemos nada m√°s aqu√≠.
            } else {
                ESP_LOGD(TAG, "Invalid gesture. Resuming idle animation.");
                ui_idle_animation_resume();
                return;
            }

            if (dir == LV_DIR_BOTTOM) {
                animate_panel_in_top(s_player_btns);
                s_panel_state = PANEL_STATE_PLAYER_VISIBLE;
            } else if (dir == LV_DIR_RIGHT) {
                animate_panel_in_side(s_side_btns);
                s_panel_state = PANEL_STATE_SIDE_VISIBLE;
            }
            break;

        case PANEL_STATE_PLAYER_VISIBLE:
            if (dir == LV_DIR_BOTTOM) {
                animate_panel_out_top(s_player_btns);
                animate_panel_in_top(s_admin_btns);
                s_panel_state = PANEL_STATE_ADMIN_VISIBLE;
            } else if (dir == LV_DIR_TOP) {
                animate_panel_out_top(s_player_btns);
                s_panel_state = PANEL_STATE_HIDDEN;
                ui_idle_animation_resume();
            }
            break;

        case PANEL_STATE_ADMIN_VISIBLE:
            if (dir == LV_DIR_BOTTOM) {
                animate_panel_out_top(s_admin_btns);
                animate_panel_in_top(s_config_btns);
                s_panel_state = PANEL_STATE_CONFIG_VISIBLE;
            } else if (dir == LV_DIR_TOP) {
                animate_panel_out_top(s_admin_btns);
                s_panel_state = PANEL_STATE_HIDDEN;
                ui_idle_animation_resume();
            }
            break;
            
        case PANEL_STATE_CONFIG_VISIBLE:
            if (dir == LV_DIR_TOP) {
                animate_panel_out_top(s_config_btns);
                s_panel_state = PANEL_STATE_HIDDEN;
                ui_idle_animation_resume();
            }
            break;
        
        case PANEL_STATE_SIDE_VISIBLE:
            if (dir == LV_DIR_LEFT) {
                animate_panel_out_side(s_side_btns);
                s_panel_state = PANEL_STATE_HIDDEN;
                ui_idle_animation_resume();
            }
            break;
    }
}

static void button_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_PRESSED) {
        if (s_hide_timer) {
            lv_timer_reset(s_hide_timer);
        }
    }
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_actions_panel.h
# =================================================================================================

/*
  Fichero: ./components/diymon_ui/ui_actions_panel.h
  Fecha: 12/08/2025 - 14:00
  √öltimo cambio: Renombrada la funci√≥n `get` para el bot√≥n de modo configuraci√≥n.
  Descripci√≥n: Interfaz p√∫blica para el gestor de paneles. Se renombra 
               `ui_actions_panel_get_enable_ftp_btn` a 
               `ui_actions_panel_get_enable_config_mode_btn` para que 
               coincida con la nueva funcionalidad.
*/
#ifndef UI_ACTIONS_PANEL_H
#define UI_ACTIONS_PANEL_H

#include <lvgl.h>

void ui_actions_panel_create(lv_obj_t *parent);
void ui_actions_panel_handle_gesture(lv_dir_t dir, lv_coord_t start_x, lv_coord_t start_y);

// --- Getters para botones del panel SUPERIOR 1 (JUGADOR) ---
lv_obj_t* ui_actions_panel_get_eat_btn(void);
lv_obj_t* ui_actions_panel_get_gym_btn(void);
lv_obj_t* ui_actions_panel_get_atk_btn(void);

// --- Getters para botones del panel SUPERIOR 2 (ADMIN) ---
lv_obj_t* ui_actions_panel_get_brightness_btn(void);
lv_obj_t* ui_actions_panel_get_toggle_screen_btn(void);
lv_obj_t* ui_actions_panel_get_admin_placeholder_btn(void);

// --- Getters para botones del panel LATERAL (EVOLUCI√ìN) ---
lv_obj_t* ui_actions_panel_get_evo_fire_btn(void);
lv_obj_t* ui_actions_panel_get_evo_water_btn(void);
lv_obj_t* ui_actions_panel_get_evo_earth_btn(void);
lv_obj_t* ui_actions_panel_get_evo_wind_btn(void);
lv_obj_t* ui_actions_panel_get_evo_back_btn(void);

// --- Getters para botones del panel SUPERIOR 3 (CONFIG) ---
lv_obj_t* ui_actions_panel_get_reset_all_btn(void);
lv_obj_t* ui_actions_panel_get_enable_config_mode_btn(void); // Renombrado
lv_obj_t* ui_actions_panel_get_config_placeholder_btn(void);

#endif // UI_ACTIONS_PANEL_H

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_asset_loader.c
# =================================================================================================

/*
  Fichero: ./components/diymon_ui/ui_asset_loader.c
  Fecha: 13/08/2025 - 09:37 
  √öltimo cambio: Eliminada la funci√≥n no utilizada swap_bytes_for_rgb565.
  Descripci√≥n: Implementaci√≥n del gestor de assets. Se ha eliminado una funci√≥n est√°tica que no se estaba utilizando para limpiar el c√≥digo y resolver una advertencia del compilador.
*/
#include "ui_asset_loader.h"
#include "diymon_ui_helpers.h"
#include "esp_log.h"
#include <stdio.h>
#include <stdlib.h>

static const char *TAG = "UI_ASSET_LOADER";

// Almacenamiento est√°tico para los descriptores y los datos de los iconos.
static lv_img_dsc_t g_asset_dscs[ASSET_COUNT];
static uint8_t* g_asset_buffers[ASSET_COUNT] = {NULL};

/**
 * @brief Carga un √∫nico asset (icono) desde un fichero a la memoria.
 */
static bool load_asset(ui_asset_id_t id, const char* filename) {
    char path[128];
    ui_helpers_build_asset_path(path, sizeof(path), filename);

    FILE* f = fopen(path, "rb");
    if (!f) {
        ESP_LOGE(TAG, "No se pudo abrir el asset: %s", path);
        return false;
    }

    // Leer la cabecera LVGL directamente.
    fread(&g_asset_dscs[id].header, 1, sizeof(lv_image_header_t), f);

    // Calcular tama√±o, reservar b√∫fer y leer los datos de p√≠xeles.
    fseek(f, 0, SEEK_END);
    long file_size = ftell(f);
    size_t data_size = file_size - sizeof(lv_image_header_t);
    g_asset_dscs[id].data_size = data_size;

    g_asset_buffers[id] = (uint8_t*)malloc(data_size);
    if (!g_asset_buffers[id]) {
        ESP_LOGE(TAG, "Fallo al reservar memoria para el asset %s", filename);
        fclose(f);
        return false;
    }
    
    fseek(f, sizeof(lv_image_header_t), SEEK_SET);
    fread(g_asset_buffers[id], 1, data_size, f);
    fclose(f);
    
    // Apuntar el descriptor al b√∫fer en memoria.
    g_asset_dscs[id].data = g_asset_buffers[id];

    ESP_LOGI(TAG, "Asset '%s' cargado correctamente en memoria.", filename);
    return true;
}

void ui_assets_init(void) {
    ESP_LOGI(TAG, "Precargando todos los assets de la UI con la nueva estructura de nombres...");
    
    // Panel de jugador (iconos 1-3)
    load_asset(ASSET_ICON_EAT, "BTN_1.bin");
    load_asset(ASSET_ICON_GYM, "BTN_2.bin");
    load_asset(ASSET_ICON_ATK, "BTN_3.bin");
    
    // Panel de admin (iconos 4-6)
    load_asset(ASSET_ICON_BRIGHTNESS, "BTN_4.bin");
    load_asset(ASSET_ICON_SCREEN_OFF, "BTN_5.bin");
    load_asset(ASSET_ICON_ADMIN_PLACEHOLDER, "BTN_6.bin");

    // Panel de configuraci√≥n (iconos 7-9)
    load_asset(ASSET_ICON_RESET_ALL, "BTN_7.bin");
    load_asset(ASSET_ICON_ENABLE_FTP, "BTN_8.bin");
    load_asset(ASSET_ICON_CONFIG_PLACEHOLDER, "BTN_9.bin");

    // Panel lateral de evoluci√≥n (iconos EVO 1-5)
    load_asset(ASSET_ICON_EVO_FIRE,  "EVO_1.bin");
    load_asset(ASSET_ICON_EVO_WATER, "EVO_2.bin");
    load_asset(ASSET_ICON_EVO_EARTH, "EVO_3.bin");
    load_asset(ASSET_ICON_EVO_WIND,  "EVO_4.bin");
    load_asset(ASSET_ICON_EVO_BACK,  "EVO_5.bin");
}

void ui_assets_deinit(void) {
    for (int i = 0; i < ASSET_COUNT; i++) {
        if (g_asset_buffers[i]) {
            free(g_asset_buffers[i]);
            g_asset_buffers[i] = NULL;
        }
    }
}

const lv_img_dsc_t* ui_assets_get_icon(ui_asset_id_t asset_id) {
    if (asset_id < ASSET_COUNT && asset_id >= 0) {
        return &g_asset_dscs[asset_id];
    }
    return NULL;
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_asset_loader.h
# =================================================================================================

/*
  Fichero: ./components/diymon_ui/ui_asset_loader.h
  Fecha: 14/08/2025 - 11:00 am
  √öltimo cambio: Reestructurados los identificadores de assets para mayor claridad.
  Descripci√≥n: Interfaz p√∫blica para el gestor de assets. Se han renombrado los identificadores de los iconos para que su nombre sea m√°s descriptivo y coincida con la acci√≥n que representan, eliminando nombres gen√©ricos como 'BTN_7'.
*/
#ifndef UI_ASSET_LOADER_H
#define UI_ASSET_LOADER_H

#include "lvgl.h"

// Identificadores √∫nicos para cada asset precargado.
typedef enum {
    // Iconos del panel de jugador (superior 1)
    ASSET_ICON_EAT,
    ASSET_ICON_GYM,
    ASSET_ICON_ATK,

    // Iconos del panel de administraci√≥n (superior 2)
    ASSET_ICON_BRIGHTNESS,
    ASSET_ICON_SCREEN_OFF,
    ASSET_ICON_ADMIN_PLACEHOLDER,
    
    // Iconos del panel de configuraci√≥n (superior 3)
    ASSET_ICON_RESET_ALL,
    ASSET_ICON_ENABLE_FTP,
    ASSET_ICON_CONFIG_PLACEHOLDER,

    // Iconos del panel de evoluci√≥n (lateral)
    ASSET_ICON_EVO_FIRE,
    ASSET_ICON_EVO_WATER,
    ASSET_ICON_EVO_EARTH,
    ASSET_ICON_EVO_WIND,
    ASSET_ICON_EVO_BACK,

    ASSET_COUNT // Utilidad para contar el n√∫mero de assets
} ui_asset_id_t;

/**
 * @brief Inicializa el gestor y precarga todos los assets en memoria.
 */
void ui_assets_init(void);

/**
 * @brief Libera la memoria utilizada por los assets precargados.
 */
void ui_assets_deinit(void);

/**
 * @brief Obtiene un puntero al descriptor de imagen de un icono ya cargado.
 * @param asset_id El identificador del icono a obtener.
 * @return Un puntero constante al descriptor de imagen LVGL.
 */
const lv_img_dsc_t* ui_assets_get_icon(ui_asset_id_t asset_id);

#endif // UI_ASSET_LOADER_H

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_idle_animation.c
# =================================================================================================

/*
 * Fichero: ./components/diymon_ui/ui_idle_animation.c
 * Fecha: 13/08/2025 - 09:34 
 * √öltimo cambio: Refactorizado para usar el objeto de imagen y b√∫fer compartidos.
 * Descripci√≥n: La animaci√≥n de reposo ya no crea su propio objeto de imagen. En su lugar, utiliza el g_animation_img_obj global creado por el m√≥dulo de animaciones de acci√≥n. Esto soluciona conflictos de renderizado y asegura el uso de un √∫nico b√∫fer de memoria.
 */
#include "ui_idle_animation.h"
#include "ui_action_animations.h" // Necesario para obtener el reproductor y el objeto de imagen compartidos
#include "animation_loader.h"
#include "diymon_ui_helpers.h"
#include "esp_log.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static const char *TAG = "UI_IDLE_ANIM";

#define IDLE_FRAME_INTERVAL 1500

// Variables est√°ticas para la gesti√≥n de la animaci√≥n de reposo
static lv_timer_t *g_anim_timer;
static animation_t g_idle_animation_player; // Player local que usa el b√∫fer compartido
static int g_current_frame_index = -1;

static void idle_animation_timer_cb(lv_timer_t *timer) {
    if (g_idle_animation_player.frame_count == 0) return;
    
    g_current_frame_index = (g_current_frame_index + 1) % g_idle_animation_player.frame_count;
    
    if (animation_loader_load_frame(&g_idle_animation_player, g_current_frame_index, "ANIM_IDLE_")) {
        lv_obj_invalidate(g_animation_img_obj); // Invalida el objeto de imagen compartido
    }
}

void ui_idle_animation_start(void) {
    animation_t* shared_player = ui_action_animations_get_player();
    if (shared_player == NULL || shared_player->img_dsc.data == NULL) {
        ESP_LOGE(TAG, "No se puede iniciar la animaci√≥n idle: el b√∫fer compartido no es v√°lido.");
        return;
    }

    // Apuntar al b√∫fer de datos del descriptor de imagen compartido
    g_idle_animation_player.img_dsc = shared_player->img_dsc;

    char anim_path[128];
    ui_helpers_build_asset_path(anim_path, sizeof(anim_path), "");
    size_t len = strlen(anim_path);
    if (len > 0 && anim_path[len - 1] == '/') anim_path[len - 1] = '\0';
    
    g_idle_animation_player.base_path = strdup(anim_path);
    g_idle_animation_player.frame_count = animation_loader_count_frames(anim_path, "ANIM_IDLE_");
    
    if(g_idle_animation_player.frame_count == 0) {
        ESP_LOGW(TAG, "No se encontraron fotogramas para 'ANIM_IDLE_' en %s.", anim_path);
    }
    
    // El objeto de imagen ya existe, no se crea uno nuevo.
    // Se crea el temporizador que cargar√° los fotogramas y los dibujar√°.
    g_anim_timer = lv_timer_create(idle_animation_timer_cb, IDLE_FRAME_INTERVAL, NULL);
    lv_timer_ready(g_anim_timer); // Ejecuta el primer ciclo inmediatamente para cargar el frame inicial
    
    ESP_LOGI(TAG, "Animaci√≥n de Idle iniciada desde %s con %d fotogramas (usando b√∫fer compartido).", anim_path, g_idle_animation_player.frame_count);
}

void ui_idle_animation_stop(void) {
    ESP_LOGI(TAG, "Deteniendo y limpiando animaci√≥n de idle.");
    if (g_anim_timer) {
        lv_timer_del(g_anim_timer);
        g_anim_timer = NULL;
    }
    if (g_idle_animation_player.base_path) {
        free(g_idle_animation_player.base_path);
        g_idle_animation_player.base_path = NULL;
    }
    g_current_frame_index = -1;
}

void ui_idle_animation_pause(void) {
    if (g_anim_timer) {
        lv_timer_pause(g_anim_timer);
        ESP_LOGI(TAG, "Animaci√≥n de Idle PAUSADA.");
    }
}

void ui_idle_animation_resume(void) {
    if (g_anim_timer) {
        lv_timer_resume(g_anim_timer);
        ESP_LOGI(TAG, "Animaci√≥n de Idle REANUDADA.");
    }
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_idle_animation.h
# =================================================================================================

/*
 * Fichero: ./components/diymon_ui/ui_idle_animation.h
 * Fecha: 13/08/2025 - 09:34 
 * √öltimo cambio: Simplificada la funci√≥n de inicio.
 * Descripci√≥n: Interfaz p√∫blica para la animaci√≥n de reposo. La funci√≥n `ui_idle_animation_start` se ha simplificado para que no necesite par√°metros ni devuelva un valor, ya que opera sobre el objeto de imagen global compartido.
 */
#ifndef UI_IDLE_ANIMATION_H
#define UI_IDLE_ANIMATION_H

#include <lvgl.h>

/**
 * @brief Inicia la animaci√≥n de idle.
 */
void ui_idle_animation_start(void);

/**
 * @brief Detiene y libera todos los recursos de la animaci√≥n de idle.
 */
void ui_idle_animation_stop(void);

/**
 * @brief Pausa el temporizador de la animaci√≥n de idle.
 */
void ui_idle_animation_pause(void);

/**
 * @brief Reanuda el temporizador de la animaci√≥n de idle.
 */
void ui_idle_animation_resume(void);

#endif // UI_IDLE_ANIMATION_H


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_priv.h
# =================================================================================================

/*
 * Fichero: ui_priv.h
 * Fecha: 08/08/2025
 * √öltimo cambio: A√±adido puntero para el panel de acciones desplegable.
 * Descripci√≥n: Cabecera PRIVADA para el componente UI.
 *              Comparte definiciones y variables globales SOLO entre los .c de la UI.
 */
#ifndef UI_PRIV_H
#define UI_PRIV_H

#ifdef __cplusplus
extern "C" {
#endif

#include "lvgl.h"

/**
 * @struct objects_t
 * @brief  Contiene los punteros a todos los objetos LVGL gestionados por la UI.
 * 
 * Esta estructura centraliza el acceso a los elementos visuales. Se agrupan por
 * tipo (objetos principales, panel, botones, animaciones) para una mayor claridad.
 */
typedef struct {
    // --- Objetos Principales ---
    lv_obj_t *main;         // Objeto de la pantalla principal.
    lv_obj_t *idle;         // GIF de la animaci√≥n de reposo.

    // --- Panel de Acciones Desplegable ---
    lv_obj_t *actions_panel; // El contenedor que se desliza desde arriba.

    // --- Botones de Acci√≥n (contenidos en el panel) ---
    lv_obj_t *comer;        // Bot√≥n para la acci√≥n 'Comer'.
    lv_obj_t *pesas;        // Bot√≥n para la acci√≥n 'Ejercicio'.
    lv_obj_t *atacar;       // Bot√≥n para la acci√≥n 'Atacar'.

    // --- Animaciones GIF de Acciones ---
    lv_obj_t *comiendo;     // GIF para la animaci√≥n 'Comiendo'.
    lv_obj_t *ejercicio;    // GIF para la animaci√≥n 'Ejercicio'.
    lv_obj_t *ataque;       // GIF para la animaci√≥n 'Ataque'.

} objects_t;

/**
 * @brief Variable global 'objects'.
 * 
 * Declaraci√≥n 'extern' que permite a todos los ficheros del componente UI
 * acceder a la instancia √∫nica de la estructura 'objects_t', que ser√°
 * definida en 'screens.c'.
 */
extern objects_t objects;

#ifdef __cplusplus
}
#endif

#endif // UI_PRIV_H

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_telemetry.c
# =================================================================================================

/*
  Fichero: ./components/diymon_ui/ui_telemetry.c
  Fecha: 13/08/2025 - 12:19 
  √öltimo cambio: Invertidos los colores y movidos los labels a la esquina inferior.
  Descripci√≥n: Se ha modificado el estilo de los labels de telemetr√≠a para que tengan
               texto negro sobre fondo blanco semitransparente. Adem√°s, se han realineado
               todos los elementos en la esquina inferior izquierda de la pantalla para
               mejorar la visibilidad de la animaci√≥n principal.
*/
#include "ui_telemetry.h"
#include "bsp_api.h"
#include "screen_manager.h"
#include "esp_log.h"
#include "esp_lvgl_port.h"
#include <math.h>

static const char *TAG = "UI_TELEMETRY";

// --- Constantes de configuraci√≥n ---
#define TELEMETRY_UPDATE_INTERVAL_MS 10000
#define SHAKE_THRESHOLD_G            2.5f
#define MIN_BAT_V                    3.0f
#define MAX_BAT_V                    4.2f

// --- Variables est√°ticas del m√≥dulo ---
static lv_obj_t *s_battery_label;
static lv_obj_t *s_orientation_label;
static lv_obj_t *s_accel_label;
static lv_timer_t *s_telemetry_timer;

/**
 * @brief Callback del temporizador que actualiza los datos de telemetr√≠a en la pantalla.
 */
static void telemetry_update_timer_cb(lv_timer_t *timer) {
    float acc[3], gyro[3];
    float voltage;

    // Proteger el acceso I2C con el mutex de LVGL
    if (lvgl_port_lock(0)) {
        bsp_imu_read(acc, gyro);
        bsp_battery_get_voltage(&voltage, NULL);
        lvgl_port_unlock();
    } else {
        return; // No se pudo obtener el mutex, reintentar en el pr√≥ximo ciclo
    }

    // 1. Procesar y mostrar datos de bater√≠a
    float percentage = 100.0f * (voltage - MIN_BAT_V) / (MAX_BAT_V - MIN_BAT_V);
    if (percentage > 100.0f) percentage = 100.0f;
    if (percentage < 0.0f) percentage = 0.0f;
    lv_label_set_text_fmt(s_battery_label, LV_SYMBOL_BATTERY_FULL " %d%%", (int)percentage);

    // 2. Procesar y mostrar datos de aceleraci√≥n
    float magnitude = sqrt(acc[0] * acc[0] + acc[1] * acc[1] + acc[2] * acc[2]);
    lv_label_set_text_fmt(s_accel_label, LV_SYMBOL_CHARGE " %.2f m/s2", magnitude);

    // 3. Procesar y mostrar datos de orientaci√≥n
    float roll = atan2(acc[1], acc[2]) * 180.0 / M_PI;
    float pitch = atan2(-acc[0], sqrt(acc[1] * acc[1] + acc[2] * acc[2])) * 180.0 / M_PI;
    lv_label_set_text_fmt(s_orientation_label, LV_SYMBOL_SETTINGS " R:%.0f P:%.0f", roll, pitch);

    // 4. L√≥gica de 'shake-to-wake'
    if (screen_manager_is_off() && (magnitude > (SHAKE_THRESHOLD_G * 9.81f))) {
        ESP_LOGI(TAG, "Shake detectado por sondeo (magnitud: %.2f > %.2f). Encendiendo pantalla.", magnitude, SHAKE_THRESHOLD_G * 9.81f);
        if (lvgl_port_lock(0)) {
            screen_manager_turn_on();
            lvgl_port_unlock();
        }
    }
}

void ui_telemetry_create(lv_obj_t *parent) {
    // Estilo para los labels de telemetr√≠a (colores invertidos)
    static lv_style_t style_telemetry;
    lv_style_init(&style_telemetry);
    lv_style_set_text_color(&style_telemetry, lv_color_black());
    lv_style_set_text_font(&style_telemetry, &lv_font_montserrat_14);
    lv_style_set_bg_color(&style_telemetry, lv_color_white());
    lv_style_set_bg_opa(&style_telemetry, LV_OPA_70); // Un poco m√°s opaco para legibilidad
    lv_style_set_radius(&style_telemetry, 5);
    lv_style_set_pad_all(&style_telemetry, 5);

    // Crear los tres labels en la esquina inferior
    s_orientation_label = lv_label_create(parent);
    lv_obj_add_style(s_orientation_label, &style_telemetry, 0);
    lv_obj_align(s_orientation_label, LV_ALIGN_BOTTOM_LEFT, 5, -5);
    lv_label_set_text(s_orientation_label, LV_SYMBOL_SETTINGS " R:-- P:--");

    s_battery_label = lv_label_create(parent);
    lv_obj_add_style(s_battery_label, &style_telemetry, 0);
    lv_obj_align_to(s_battery_label, s_orientation_label, LV_ALIGN_OUT_TOP_LEFT, 0, -5);
    lv_label_set_text(s_battery_label, LV_SYMBOL_BATTERY_FULL " --%");

    s_accel_label = lv_label_create(parent);
    lv_obj_add_style(s_accel_label, &style_telemetry, 0);
    lv_obj_align_to(s_accel_label, s_battery_label, LV_ALIGN_OUT_RIGHT_MID, 10, 0);
    lv_label_set_text(s_accel_label, LV_SYMBOL_CHARGE " -- m/s2");
    
    // Crear y lanzar el temporizador
    s_telemetry_timer = lv_timer_create(telemetry_update_timer_cb, TELEMETRY_UPDATE_INTERVAL_MS, NULL);
    ESP_LOGI(TAG, "M√≥dulo de telemetr√≠a de UI creado.");
}

void ui_telemetry_destroy(void) {
    if (s_telemetry_timer) {
        lv_timer_del(s_telemetry_timer);
        s_telemetry_timer = NULL;
        ESP_LOGI(TAG, "Temporizador de telemetr√≠a destruido.");
    }
}


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui_telemetry.h
# =================================================================================================

/*
  Fichero: ./components/diymon_ui/ui_telemetry.h
  Fecha: 13/08/2025 - 12:03 
  √öltimo cambio: Creaci√≥n del fichero.
  Descripci√≥n: Interfaz p√∫blica para el nuevo m√≥dulo de telemetr√≠a de la UI.
               Define las funciones para crear y destruir los elementos de la UI
               que mostrar√°n los datos de los sensores.
*/
#ifndef UI_TELEMETRY_H
#define UI_TELEMETRY_H

#include <lvgl.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Crea los labels y el temporizador para mostrar los datos de los sensores.
 * @param parent El objeto padre sobre el que se crear√°n los labels.
 */
void ui_telemetry_create(lv_obj_t *parent);

/**
 * @brief Destruye el temporizador de telemetr√≠a para liberar recursos.
 */
void ui_telemetry_destroy(void);

#ifdef __cplusplus
}
#endif

#endif // UI_TELEMETRY_H


# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui.c
# =================================================================================================

/*
  Fichero: ./components/diymon_ui/ui.c
  Fecha: 12/08/2025 - 14:00
  √öltimo cambio: Corregida la llamada para registrar el evento del bot√≥n de modo configuraci√≥n.
  Descripci√≥n: Orquestador principal de la UI. Se actualiza la funci√≥n 
               `ui_connect_actions` para usar el nuevo nombre de la funci√≥n `get`
               y el nuevo ID de acci√≥n, completando la refactorizaci√≥n del modo
               FTP a modo de configuraci√≥n web.
*/
#include "ui.h"
#include "screens.h"
#include "actions.h"
#include "ui_actions_panel.h"
#include "ui_asset_loader.h"
#include "esp_log.h"

extern lv_obj_t *g_main_screen_obj; 

static const char *TAG = "DIYMON_UI_MAIN";

static void button_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    diymon_action_id_t action_id = (diymon_action_id_t)(intptr_t)lv_event_get_user_data(e);
    
    if (code == LV_EVENT_CLICKED || code == LV_EVENT_LONG_PRESSED) {
        ESP_LOGI(TAG, "Evento de bot√≥n detectado para la acci√≥n ID: %d", action_id);
        execute_diymon_action(action_id);
    }
}

static void ui_connect_actions(void) {
    // Panel 1: Jugador
    lv_obj_add_event_cb(ui_actions_panel_get_eat_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_COMER);
    lv_obj_add_event_cb(ui_actions_panel_get_gym_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_EJERCICIO);
    lv_obj_add_event_cb(ui_actions_panel_get_atk_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_ATACAR);

    // Panel 2: Admin
    lv_obj_add_event_cb(ui_actions_panel_get_brightness_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_BRIGHTNESS_CYCLE);
    lv_obj_add_event_cb(ui_actions_panel_get_toggle_screen_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_TOGGLE_SCREEN);
    lv_obj_add_event_cb(ui_actions_panel_get_admin_placeholder_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_ADMIN_PLACEHOLDER);
    
    // Panel 3: Configuraci√≥n
    lv_obj_add_event_cb(ui_actions_panel_get_reset_all_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_RESET_ALL);
    lv_obj_add_event_cb(ui_actions_panel_get_enable_config_mode_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_ENABLE_CONFIG_MODE);
    lv_obj_add_event_cb(ui_actions_panel_get_config_placeholder_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_CONFIG_PLACEHOLDER);
    
    // Panel Lateral: Evoluci√≥n
    lv_obj_add_event_cb(ui_actions_panel_get_evo_fire_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_EVO_FIRE);
    lv_obj_add_event_cb(ui_actions_panel_get_evo_water_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_EVO_WATER);
    lv_obj_add_event_cb(ui_actions_panel_get_evo_earth_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_EVO_EARTH);
    lv_obj_add_event_cb(ui_actions_panel_get_evo_wind_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_EVO_WIND);
    lv_obj_add_event_cb(ui_actions_panel_get_evo_back_btn(), button_event_cb, LV_EVENT_ALL, (void*)ACTION_ID_EVO_BACK);

    ESP_LOGI(TAG, "Eventos de todos los botones de acci√≥n conectados.");
}

void ui_init(void) {
    ui_assets_init();
    create_screens();
    
    if (g_main_screen_obj) {
        ui_connect_actions();
        lv_obj_add_event_cb(g_main_screen_obj, (lv_event_cb_t)delete_screen_main, LV_EVENT_DELETE, NULL);
    }
    
    lv_screen_load(g_main_screen_obj);
    ESP_LOGI(TAG, "UI modularizada y lista.");
}

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\ui.h
# =================================================================================================

/*
 * Fichero: ./components/diymon_ui/ui.h
 * Fecha: 09/08/2025 - 06:55
 * √öltimo cambio: Sin cambios en la interfaz p√∫blica.
 * Descripci√≥n: Interfaz P√öBLICA del componente de la UI.
 *              Define las funciones de alto nivel para controlar la UI desde el exterior.
 */
#ifndef UI_H
#define UI_H

#ifdef __cplusplus
extern "C" {
#endif

// --- DEFINICIONES COMPARTIDAS ---

// Enum para identificar las pantallas. Se mantiene aqu√≠ porque es parte de la
// interfaz p√∫blica para, potencialmente, cambiar de pantalla.
enum ScreensEnum {
    SCREEN_ID_MAIN = 1,
};


// --- FUNCIONES P√öBLICAS DE LA UI ---

/**
 * @brief Inicializa y configura toda la interfaz de usuario.
 *
 * Esta es la funci√≥n principal que se debe llamar desde fuera del componente
 * (por ejemplo, desde main.c) para poner en marcha toda la UI.
 */
void ui_init(void);


#ifdef __cplusplus
}
#endif

#endif // UI_H

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\vars.h
# =================================================================================================

#ifndef EEZ_LVGL_UI_VARS_H
#define EEZ_LVGL_UI_VARS_H

#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

// enum declarations



// Flow global variables

enum FlowGlobalVariables {
    FLOW_GLOBAL_VARIABLE_NONE
};

// Native global variables

extern int32_t get_var_brightness();
extern void set_var_brightness(int32_t value);


#ifdef __cplusplus
}
#endif

#endif /*EEZ_LVGL_UI_VARS_H*/

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\welcome_screen.c
# =================================================================================================

#include "welcome_screen.h"
#include "esp_log.h"

static const char *TAG = "WELCOME_SCREEN";

// --- ANOTACI√ìN: Puntero est√°tico para almacenar el callback de inicio. ---
// Guardamos la funci√≥n que nos pasa 'main' para poder llamarla cuando se pulse el bot√≥n.
static void (*g_on_start_callback)(void) = NULL;

/**
 * @brief Callback del evento del bot√≥n "INICIAR".
 *        Llama a la funci√≥n de callback registrada si existe.
 */
static void start_button_event_cb(lv_event_t *e) {
    lv_event_code_t code = lv_event_get_code(e);
    if (code == LV_EVENT_CLICKED) {
        ESP_LOGI(TAG, "Bot√≥n 'INICIAR' presionado.");
        if (g_on_start_callback) {
            g_on_start_callback();
        }
    }
}

/**
 * @brief Implementaci√≥n de la creaci√≥n de la pantalla de bienvenida.
 */
void welcome_screen_show(void (*on_start_cb)(void)) {
    g_on_start_callback = on_start_cb;

    // --- ANOTACI√ìN: Creaci√≥n de la pantalla y sus elementos. ---
    // Se crea un nuevo screen para asegurar que no hay elementos previos.
    lv_obj_t *scr = lv_obj_create(NULL);
    lv_obj_set_style_bg_color(scr, lv_color_hex(0x000000), LV_PART_MAIN);
    lv_obj_set_layout(scr, LV_LAYOUT_FLEX);
    lv_obj_set_flex_flow(scr, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(scr, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_set_style_pad_row(scr, 20, LV_PART_MAIN);

    const char *texts[] = {"SSID: DIYTogether", "PASS: MakeItYours", "192.168.4.1"};
    for (int i = 0; i < 3; i++) {
        lv_obj_t *label = lv_label_create(scr);
        lv_label_set_text(label, texts[i]);
        lv_obj_set_style_text_color(label, lv_color_hex(0xFFFFFF), LV_PART_MAIN);
    }

    lv_obj_t *btn = lv_btn_create(scr);
    lv_obj_add_event_cb(btn, start_button_event_cb, LV_EVENT_CLICKED, NULL);

    lv_obj_t *label_btn = lv_label_create(btn);
    lv_label_set_text(label_btn, "INICIAR");
    lv_obj_center(label_btn);

    // --- ANOTACI√ìN: Se carga la nueva pantalla. ---
    // Esta llamada reemplaza la pantalla activa anterior y evita el crash.
    lv_screen_load(scr);
    ESP_LOGI(TAG, "Pantalla de bienvenida mostrada.");
}

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui\welcome_screen.h
# =================================================================================================

#ifndef WELCOME_SCREEN_H
#define WELCOME_SCREEN_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Muestra la pantalla de bienvenida.
 *
 * @param on_start_cb Puntero a una funci√≥n que se llamar√° cuando se pulse el bot√≥n "INICIAR".
 */
void welcome_screen_show(void (*on_start_cb)(void));

#ifdef __cplusplus
}
#endif

#endif // WELCOME_SCREEN_H

# =================================================================================================
# Fichero: Z:\DIYTOGETHER\DIYtogether\components\diymon_ui_panels\include\diymon_ui_panels.h
# =================================================================================================

/*
  Fichero: ./components/diymon_ui/ui_actions_panel.h
  Fecha: 12/08/2025 - 08:00 pm
  √öltimo cambio: Creado como parte de la unificaci√≥n de la UI.
  Descripci√≥n: Interfaz p√∫blica para el gestor de paneles de acciones, ahora
               integrado dentro del componente `diymon_ui`.
*/
#ifndef UI_ACTIONS_PANEL_H
#define UI_ACTIONS_PANEL_H

#include <lvgl.h>

void ui_actions_panel_create(lv_obj_t *parent);
void ui_actions_panel_handle_gesture(lv_dir_t dir, lv_coord_t start_x, lv_coord_t start_y);

#endif // UI_ACTIONS_PANEL_H
